#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1998-11-30 17:53 PST by <zoid@pak.threewave.com>.
# Source directory was `/home/zoid/3.20src/rogue'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   6193 -rw-rw-r-- Makefile
#  14672 -rw-rw-r-- dm_ball.c
#   7631 -rw-rw-r-- dm_tag.c
#  39451 -rw-rw-r-- g_ai.c
#   3412 -rw-rw-r-- g_chase.c
#  19125 -rw-rw-r-- g_cmds.c
#  25345 -rw-rw-r-- g_combat.c
#  68796 -rw-rw-r-- g_func.c
#  71570 -rw-rw-r-- g_items.c
#  40901 -rw-rw-r-- g_local.h
#   7883 -rw-rw-r-- g_main.c
#  47803 -rw-rw-r-- g_misc.c
#  23122 -rw-rw-r-- g_monster.c
#  48669 -rw-rw-r-- g_newai.c
#   8993 -rw-rw-r-- g_newdm.c
#   8550 -rw-rw-r-- g_newfnc.c
#   8094 -rw-rw-r-- g_newtarg.c
#   4194 -rw-rw-r-- g_newtrig.c
#  60131 -rw-rw-r-- g_newweap.c
#  25071 -rw-rw-r-- g_phys.c
#  19126 -rw-rw-r-- g_save.c
#  44893 -rw-rw-r-- g_spawn.c
#  18537 -rw-rw-r-- g_sphere.c
#   5345 -rw-rw-r-- g_svcmds.c
#  20668 -rw-rw-r-- g_target.c
#  15164 -rw-rw-r-- g_trigger.c
#  15291 -rw-rw-r-- g_turret.c
#  14069 -rw-rw-r-- g_utils.c
#  23501 -rw-rw-r-- g_weapon.c
#   6954 -rw-rw-r-- game.h
#  13233 -rw-rw-r-- m_actor.c
#  16845 -rw-rw-r-- m_actor.h
#  13895 -rw-rw-r-- m_berserk.c
#   8814 -rw-rw-r-- m_berserk.h
#  20057 -rw-rw-r-- m_boss2.c
#   6351 -rw-rw-r-- m_boss2.h
#   1316 -rw-rw-r-- m_boss3.c
#  17065 -rw-rw-r-- m_boss31.c
#   6601 -rw-rw-r-- m_boss31.h
#  20554 -rw-rw-r-- m_boss32.c
#  17207 -rw-rw-r-- m_boss32.h
#  15671 -rw-rw-r-- m_brain.c
#   7786 -rw-rw-r-- m_brain.h
#  35741 -rw-rw-r-- m_carrier.c
#   2766 -rw-rw-r-- m_carrier.h
#  22848 -rw-rw-r-- m_chick.c
#  10093 -rw-rw-r-- m_chick.h
#  11714 -rw-rw-r-- m_flash.c
#   8962 -rw-rw-r-- m_flipper.c
#   5618 -rw-rw-r-- m_flipper.h
#  16513 -rw-rw-r-- m_float.c
#   8696 -rw-rw-r-- m_float.h
#  20893 -rw-rw-r-- m_flyer.c
#   5432 -rw-rw-r-- m_flyer.h
#   9435 -rw-rw-r-- m_gladiator.c
#   3179 -rw-rw-r-- m_gladiator.h
#  25358 -rw-rw-r-- m_gunner.c
#   7593 -rw-rw-r-- m_gunner.h
#  18430 -rw-rw-r-- m_hover.c
#   7191 -rw-rw-r-- m_hover.h
#  19624 -rw-rw-r-- m_infantry.c
#   7547 -rw-rw-r-- m_infantry.h
#  16523 -rw-rw-r-- m_insane.c
#   9887 -rw-rw-r-- m_insane.h
#  46875 -rw-rw-r-- m_medic.c
#   8311 -rw-rw-r-- m_medic.h
#  18787 -rw-rw-r-- m_move.c
#  15467 -rw-rw-r-- m_move2.c
#  15668 -rw-rw-r-- m_mutant.c
#   5368 -rw-rw-r-- m_mutant.h
#  16217 -rw-rw-r-- m_parasite.c
#   4495 -rw-rw-r-- m_parasite.h
#   6945 -rw-rw-r-- m_player.h
#   2162 -rw-rw-r-- m_rider.h
#  41093 -rw-rw-r-- m_soldier.c
#  16643 -rw-rw-r-- m_soldier.h
#  29112 -rw-rw-r-- m_stalker.c
#   3282 -rw-rw-r-- m_stalker.h
#  16071 -rw-rw-r-- m_supertank.c
#   8913 -rw-rw-r-- m_supertank.h
#  24628 -rw-rw-r-- m_tank.c
#  10302 -rw-rw-r-- m_tank.h
#  23725 -rw-rw-r-- m_turret.c
#    657 -rw-rw-r-- m_turret.h
#  45002 -rw-rw-r-- m_widow.c
#   5932 -rw-rw-r-- m_widow.h
#  47155 -rw-rw-r-- m_widow2.c
#   4428 -rw-rw-r-- m_widow2.h
#  50361 -rw-rw-r-- p_client.c
#  14136 -rw-rw-r-- p_hud.c
#   2122 -rw-rw-r-- p_trail.c
#  28402 -rw-rw-r-- p_view.c
#  55810 -rw-rw-r-- p_weapon.c
#  24947 -rw-rw-r-- q_shared.c
#  34104 -rw-rw-r-- q_shared.h
#

more <<EOF
	LIMITED PROGRAM SOURCE CODE LICENSE

     This Limited Program Source Code License (the "Agreement") is between
     Id Software, Inc., a Texas corporation, (hereinafter "Id Software")
     and Licensee (as defined below) and is made effective beginning on
     the date you, the Licensee, download the Code, as defined below,
     (the "Effective Date").  BY DOWNLOADING THE CODE, AS DEFINED
     BELOW, YOU, THE LICENSEE, AGREE TO ALL THE TERMS AND CONDITIONS OF
     THIS AGREEMENT.  YOU SHOULD READ THIS AGREEMENT CAREFULLY BEFORE
     DOWNLOADING THE CODE.  EVERY PERSON IN POSSESSION OF AN AUTHORIZED
     COPY, AS DEFINED BELOW, OF THE CODE SHALL BE SUBJECT TO THE TERMS
     AND CONDITIONS OF THIS AGREEMENT.

	R E C I T A L S

WHEREAS, Id Software is the owner and developer of the computer software
program source code accompanied by this Agreement (the "Code");

WHEREAS, Id Software desires to license certain limited non-exclusive
rights regarding the Code to Licensee; and

WHEREAS, Licensee desires to receive a limited license for such rights.

	T E R M S    A N D    C O N D I T I O N S

     NOW, THEREFORE, for and in consideration of the mutual premises
     contained herein and for other good and valuable consideration,
     the receipt and sufficiency of which is hereby acknowledged, the
     undersigned parties do hereby agree as follows:

1.  Definitions.  The parties hereto agree the following definitions
shall apply to this Agreement:

     a.  "Authorized Copy" shall mean a copy of the Code obtained by
     Authorized Means, as defined below.  A copy of the Code is not
     an "Authorized Copy" unless it is accompanied by a copy of this
     Agreement and obtained by Authorized Means.  A Modified Copy,
     as defined below, is not an Authorized Copy;

     b.  "Authorized Means" shall mean obtaining an Authorized Copy only
     by downloading the Authorized Copy from Id Software's Internet web
     site or from another web site authorized or approved by Id Software
     for such purposes or by obtaining an Authorized Copy by electronic
     means via the Internet;

     c.  "Code" shall mean the computer software program source code
     which accompanies this Agreement and includes Code included within
     any Modified Copy and which is the code that constitutes the
     Authorized Copy;

     d.  "Game" shall mean QUAKE II;

     e.  "Licensee" shall mean you, the person who is in possession of
     an Authorized Copy by Authorized Means; and

     f.  "Modified Copy" shall mean a copy of the Code first obtained
     by Authorized Means which is subsequently modified by Licensee,
     as provided in paragraph 2. below.

2.  Grant of Rights.  Subject to the terms and provisions of this
Agreement, Id Software hereby grants to Licensee and Licensee hereby
accepts, a limited, world-wide (except as otherwise provided herein),
non-exclusive, non-transferable, and non-assignable license to:  (i)
use the Authorized Copy and the Modified Copy, as defined above, for
the development by Licensee of extra levels operable with the Game (the
"Extra Levels"); (ii) incorporate all or a portion of the Authorized Copy
and the Modified Copy within the Extra Levels; (iii) distribute by way
of a sublicense limited by the terms of this Agreement, free of charge
and at no cost, the Authorized Copy and the Modified Copy to the extent
such Modified Copy and such Authorized Copy, or a portion thereof, is
included within the Extra Levels; (iv) distribute by way of a sublicense
limited by the terms of this Agreement, free of charge and at no cost, by
electronic transmission via  the Internet only the Authorized Copy without
any alteration or modification along with a copy of this Agreement which
must always accompany the Authorized Copy; (v) modify the Authorized Copy
in order to create a Modified Copy, as defined above; and (vi) distribute
the Modified Copy by way of a sublicense limited by the terms of this
Agreement, free of charge and at no cost, by electronic transmission via
the Internet only.  Each person or entity who/which receives a copy of
the Code shall be subject to the terms of this Agreement but, no rights
are granted to any person or entity who/which obtains, receives, or is
in possession of any copy of the Code by other than Authorized Means.

3.  Reservation of Rights and Prohibitions.  Id Software expressly
reserves all rights not granted herein.  Licensee shall not make any use
of the trademarks relating to the Game or Id Software (the "Trademarks").
Any use by Licensee of the Authorized Copy or the Modified Copy not
expressly permitted in paragraph 2. above is expressly prohibited and
any such unauthorized use shall constitute a material breach of this
Agreement by Licensee.	Any use of the Code, whether included within
a Modified Copy or otherwise, and/or the Authorized Copy not permitted
in this Agreement shall constitute an infringement or violation of Id
Software's copyright in the Code.  Licensee shall not copy, reproduce,
manufacture or distribute (free of charge or otherwise) the Authorized
Copy or the Modified Copy in any tangible media, including, without
limitation, a CD ROM.  Licensee shall not commercially exploit by sale,
lease, rental or otherwise the Authorized Copy or the Modified Copy
whether included within Extra Levels or otherwise.  Licensee shall not
commercially exploit by sale, lease, rental or otherwise any Extra Levels
developed by the use of the Code, whether in whole or in part.	Licensee
is not receiving any rights hereunder regarding the Game, the Trademarks
or any audio-visual elements, artwork, sound, music, images, characters,
or other element of the Game.  Licensee may modify the Authorized Copy in
order to create a Modified Copy, as noted above, but all sublicensees who
receive the Modified Copy shall not receive any rights to commercially
exploit or to make any other use of the Code included therein except the
right to use such Code for such sublicensee's personal entertainment. By
way of example and not exclusion, a sublicensee for the Modified Copy
shall not further modify the Code within the Modified Copy.  Only the
Licensee who obtains the Code by Authorized Means shall be permitted to
modify such Code on the terms as described in this Agreement.

4.  Additional Obligations.  In addition to the obligations of Licensee
otherwise set forth in this Agreement, during the Term, and thereafter
where specified, Licensee agrees that:

     a.  Licensee will not attack or challenge the ownership by Id
     Software of the Code, the Authorized Copy, the Game, the Trademarks,
     or any copyright, patent or trademark or other intellectual property
     right related thereto and Licensee will not attack or challenge
     the validity of the license granted hereunder during the Term or
     thereafter; and

     b.  Licensee will promptly inform Id Software of any unauthorized
     use of the Code, the Authorized Copy, the Trademarks, or the Game,
     or any portions thereof, and will reasonably assist Id Software
     in the enforcement of all rights Id Software may have against such
     unauthorized users.

5.  Ownership.	Title to and all ownership rights in and to the Code,
whether included within the Modified Copy, the Authorized Copy or
otherwise, the Game, the Authorized Copy, and the Trademarks and the
copyrights, trade secrets, trademarks, patents and all other intellectual
property rights related thereto shall remain with Id Software which shall
have the exclusive right to protect the same by copyright or otherwise.
Licensee shall have no ownership rights in or to the Game, the Code,
the Authorized Copy or the Trademarks.	Licensee acknowledges that
Licensee, by this Agreement, is only receiving a limited license to use
the Authorized Copy, as specified in paragraph 2. of this Agreement.

6.   Compliance with Applicable Laws.  In exercising Licensee's
limited rights hereunder, Licensee shall comply with all applicable
laws, [including, without limitation, 22 U.S.C., section 2778 and 22
U.S.C. C.F.R. Parts 120-130 (1995)] regulations, ordinances and statutes,
including, but not limited to, the import/export laws and regulations
of the United States and its governmental and regulatory agencies
(including, without limitation, the Bureau of Export Administration
and the U.S. Department of Commerce) and all applicable international
treaties and laws.

7.  Term and Termination.

     a.  The term of this Agreement and the license granted herein
     begins on the Effective Date and shall expire, without notice,
     on a date one (1) calendar year from the Effective Date (the "Term").

     b.  Either party may terminate this Agreement, for any reason or
     no reason, on thirty (30) days written notice to the other party.
     Termination will be effective on the thirtieth (30th) day following
     delivery of the notice of termination.  Notwithstanding anything
     to the contrary herein, this Agreement shall immediately terminate,
     without the requirement of any notice from Id Software to Licensee,
     upon the occurrence of any of the following "Terminating Events":
     (i) if Licensee  files a petition in bankruptcy; (ii) if Licensee
     makes an assignment for the benefit of creditors; (iii) if any
     bankruptcy proceeding or assignment for benefit of creditors is
     commenced against Licensee and not dismissed within sixty (60)
     days after the date of its commencement; (iv) the insolvency of
     Licensee; or (v) a breach, whether material or otherwise, of this
     Agreement by Licensee.  Upon the occurrence of a Terminating Event,
     this Agreement and any and all rights hereunder shall terminate
     without prejudice to any rights or claims Id Software may have,
     and all rights granted hereunder shall revert, without notice,
     to and be vested in Id Software.

     c.  Termination or expiration of this Agreement shall not create
     any liability against Id Software and shall not relieve Licensee
     from any liability which arises prior to termination or expiration.
     Upon expiration or earlier termination of this Agreement, Licensee
     shall have no further right to exercise the rights licensed hereunder
     or otherwise acquired in relation to this Agreement.

8.  Licensee's Warranties.  Licensee warrants and represents that:
(i) Licensee has full legal rights and authority to enter into and
become bound by the terms of this Agreement; (ii) Licensee has full
legal rights and authority to perform Licensee?s obligations hereunder;
(iii) Licensee will comply, at all times during the Term, with all
applicable laws, as set forth hereinabove; (iv) all modifications which
Licensee performs on the Code in order to create the Modified Copy and
all non-Id Software property included within Extra Levels shall not
infringe against or misappropriate any third party rights, including,
without limitation, copyrights and trade secrets; and (v) the use or
non-use of all modifications which Licensee performs on the Code in order
to create the Modified Copy and all non-Id Software property included
within Extra Levels shall not infringe against or misappropriate any third
party rights, including, without limitation, copyrights and trade secrets.

9.  Indemnification.  Licensee hereby agrees to indemnify, hold
harmless and defend Id Software and Id Software's predecessors,
successors, assigns, officers, directors, shareholders, employees,
agents, representatives, licensees (but not including Licensee),
sublicensees, distributors, attorneys and accountants (collectively,
the "Id Related Parties") from and against any and all "Claims", which
shall mean all damages, claims, losses, causes of action, liabilities,
lawsuits, judgments and expenses (including, without limitation,
reasonable attorneys' fees and expenses) arising from, relating to or in
connection with (i) a breach of this Agreement by Licensee and/or (ii)
Licensee's use or non-use of the Code, whether the Authorized Copy or
whether a portion of the Code as may be included within the Modified
Copy or within Extra Levels.  Id Software agrees to notify Licensee
of any such Claims within a reasonable time after Id Software learns
of same.  Licensee, at its own expense, shall defend Id Software and the
Id Related Parties from and against any and all Claims.  Id Software and
the Id Related Parties reserve the right to participate in any defense
of the Claims with counsel of their choice, and at their own expense.
In the event Licensee fails to provide a defense, then Licensee shall be
responsible for paying the attorneys' fees and expenses incurred by Id
Software and the Id Related Parties regarding the defense of the Claims.
Id Software and the Id Related Parties, as applicable, agree to reasonably
assist in the defense of the Claims.  No settlement by Licensee of any
Claims shall be valid unless Licensee receives the prior written consent
of Id Software and the Id Related Parties, as applicable, to any such
settlement, with consent may be withheld in Id Software's and the Id
Related Parties' sole discretion.

10.  Limitation of Liability.  UNDER NO CIRCUMSTANCES SHALL ID SOFTWARE
BE LIABLE TO LICENSEE FOR ACTUAL, SPECIAL, INCIDENTAL, CONSEQUENTIAL
OR PUNITIVE DAMAGES OR ANY OTHER DAMAGES, WHETHER OR NOT ID SOFTWARE
RECEIVES NOTICE OF ANY SUCH DAMAGES.

11.  Disclaimer of Warranties.	ID SOFTWARE EXPRESSLY DISCLAIMS ALL
WARRANTIES, WHETHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE, WITH REGARD TO THE CODE, THE AUTHORIZED COPY AND OTHERWISE.

12.  Goodwill.	Licensee recognizes the great value of the goodwill
associated with the Game and the Trademarks, and acknowledges that such
goodwill, now existing and hereafter created, exclusively belongs to Id
Software and that the Trademarks have acquired a secondary meaning in
the mind of the public.

13.  Remedies.	In the event of a breach of this Agreement by Id Software,
Licensee's sole remedy shall be to terminate this Agreement by delivering
written notice of termination to Id Software.  In the event of a breach
by Licensee of this Agreement, Id Software may pursue the remedies to
which Id Software is entitled under applicable law and this Agreement.
Licensee agrees that Licensee's unauthorized use of the Authorized
Copy would immediately and irreparably damage Id Software, and in the
event of such threatened or actual unauthorized use, Id Software shall
be entitled to an injunctive order appropriately restraining and/or
prohibiting such unauthorized use without the necessity of Id Software
posting bond or other security.  Pursuit of any remedy by Id Software
shall not constitute a waiver of any other right or remedy of Id Software
under this Agreement or under applicable law.

14.  Choice of Law, Venue and Service of Process.  This Agreement shall
be construed in accordance with the laws of the State of Texas and
applicable United States federal law and all claims and/or lawsuits
in connection with this Agreement must be brought in Dallas County,
Texas where exclusive venue shall lie.	Licensee hereby agrees that
service of process by certified mail to the address set forth below,
with return receipt requested, shall constitute valid service of process
upon Licensee.	If for any reason Licensee has moved or cannot be validly
served, then Licensee appoints the Secretary of State of the state of
Texas to accept service of process on Licensee's behalf.

15.  Delivery of Notices.  Unless otherwise directed in writing by
the parties, all notices given hereunder shall be sent to the last
known address of addressee.  All notices, requests, consents and other
communications under this Agreement shall be in writing and shall be
deemed to have been delivered on the date personally delivered or on the
date deposited in the United States Postal Service, postage prepaid, by
certified mail, return receipt requested, or telegraphed and confirmed,
or delivered by electronic facsimile and confirmed.  Any notice to Id
Software shall also be sent to its counsel: D. Wade Cloud, Jr., Hiersche,
Martens, Hayward, Drakeley & Urbach, P.C., 15303 Dallas Parkway, Suite
700, LB 17, Dallas, Texas  75248.

16.  No Partnership, Etc.  This Agreement does not constitute and shall
not be construed as constituting a partnership or joint venture between
Id Software and Licensee.  Neither party shall have any right to obligate
or bind the other party in any manner whatsoever, and nothing herein
contained shall give, or is intended to give, any rights of any kind to
any third persons.

17.  Entire agreement.	This Agreement constitutes the entire
understanding between Licensee and Id Software regarding the subject
matter hereof.	Each and every clause of this Agreement is severable from
the whole and shall survive unless the entire Agreement is declared
unenforceable.	No prior or present agreements or representations
between the parties hereto regarding the subject matter hereof shall be
binding upon the parties hereto unless incorporated in this Agreement.
No modification or change in this Agreement shall be valid or binding
upon the parties hereto unless in writing and executed by the parties
to be bound thereby.

18.  Assignment.  This Agreement shall bind and inure to the benefit of
Id Software, its successors and assigns, and Id Software may assign its
rights hereunder, in Id Software's sole discretion.  This Agreement
is personal to Licensee, and Licensee shall not assign, transfer,
convey nor franchise its rights granted hereunder.  As provided above,
Licensee may sublicense Licensee's limited rights herein by transferring
the Authorized Copy by Authorized Means.  As noted, each sublicensee
in possession of a copy of the Authorized Copy shall be subject to the
terms and conditions of this Agreement.

19.  Survival.	The following provisions shall survive the expiration
or earlier termination of this Agreement:  paragraphs 5., 8., 9., 10.,
11., 12., 13., 14., 15., 16., 17., 19., 20.a. and 20.b.

20.  Miscellaneous.

      a.  All captions in this Agreement are intended solely for the
      convenience of the parties, and none shall effect the meaning or
      construction of any provision.

      b.  The terms and conditions of this Agreement have been negotiated
      fully and freely among the parties.  Accordingly, the preparation
      of this Agreement by counsel for a given party will not be material
      to the construction hereof, and the terms of this Agreement shall
      not be strictly construed against such party.

BY DOWNLOADING THE CODE, AS DEFINED ABOVE, YOU, THE LICENSEE, AGREE TO
ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.


February 12, 1998


LIMITED  PROGRAM SOURCE CODE LICENSE	PAGE 1

EOF

echo "Do you agree with the license conditions (answer \"yes\")?"
read ans
if [ "$ans" != "yes" ];then
	exit 1
fi




save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh09367; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
X
BUILD_DEBUG_DIR=debug
BUILD_RELEASE_DIR=release
X
CC=gcc
BASE_CFLAGS=-Dstricmp=strcasecmp
RELEASE_CFLAGS=$(BASE_CFLAGS) -ffast-math -funroll-loops \
X	-fomit-frame-pointer -fexpensive-optimizations
DEBUG_CFLAGS=$(BASE_CFLAGS) -g
LDFLAGS=-ldl -lm
X
SHLIBEXT=so
X
SHLIBCFLAGS=-fPIC
SHLIBLDFLAGS=-shared
X
DO_CC=$(CC) $(CFLAGS) -o $@ -c $<
DO_SHLIB_CC=$(CC) $(CFLAGS) $(SHLIBCFLAGS) -o $@ -c $<
X
TARGETS=$(BUILDDIR)/game$(ARCH).$(SHLIBEXT) \
X
build_debug:
X	@-mkdir $(BUILD_DEBUG_DIR)
X	$(MAKE) targets BUILDDIR=$(BUILD_DEBUG_DIR) CFLAGS="$(DEBUG_CFLAGS)"
X
build_release:
X	@-mkdir $(BUILD_RELEASE_DIR)
X	$(MAKE) targets BUILDDIR=$(BUILD_RELEASE_DIR) CFLAGS="$(RELEASE_CFLAGS)"
X
all: build_debug build_release
X
targets: $(TARGETS)
X
ROGUE_OBJS = \
X	$(BUILDDIR)/dm_ball.o \
X	$(BUILDDIR)/dm_tag.o \
X	$(BUILDDIR)/g_ai.o \
X	$(BUILDDIR)/g_chase.o \
X	$(BUILDDIR)/g_cmds.o \
X	$(BUILDDIR)/g_combat.o \
X	$(BUILDDIR)/g_func.o \
X	$(BUILDDIR)/g_items.o \
X	$(BUILDDIR)/g_main.o \
X	$(BUILDDIR)/g_misc.o \
X	$(BUILDDIR)/g_monster.o \
X	$(BUILDDIR)/g_newai.o \
X	$(BUILDDIR)/g_newdm.o \
X	$(BUILDDIR)/g_newfnc.o \
X	$(BUILDDIR)/g_newtarg.o \
X	$(BUILDDIR)/g_newtrig.o \
X	$(BUILDDIR)/g_newweap.o \
X	$(BUILDDIR)/g_phys.o \
X	$(BUILDDIR)/g_save.o \
X	$(BUILDDIR)/g_spawn.o \
X	$(BUILDDIR)/g_sphere.o \
X	$(BUILDDIR)/g_svcmds.o \
X	$(BUILDDIR)/g_target.o \
X	$(BUILDDIR)/g_trigger.o \
X	$(BUILDDIR)/g_turret.o \
X	$(BUILDDIR)/g_utils.o \
X	$(BUILDDIR)/g_weapon.o \
X	$(BUILDDIR)/m_actor.o \
X	$(BUILDDIR)/m_berserk.o \
X	$(BUILDDIR)/m_boss2.o \
X	$(BUILDDIR)/m_boss3.o \
X	$(BUILDDIR)/m_boss31.o \
X	$(BUILDDIR)/m_boss32.o \
X	$(BUILDDIR)/m_brain.o \
X	$(BUILDDIR)/m_carrier.o \
X	$(BUILDDIR)/m_chick.o \
X	$(BUILDDIR)/m_flash.o \
X	$(BUILDDIR)/m_flipper.o \
X	$(BUILDDIR)/m_float.o \
X	$(BUILDDIR)/m_flyer.o \
X	$(BUILDDIR)/m_gladiator.o \
X	$(BUILDDIR)/m_gunner.o \
X	$(BUILDDIR)/m_hover.o \
X	$(BUILDDIR)/m_infantry.o \
X	$(BUILDDIR)/m_insane.o \
X	$(BUILDDIR)/m_medic.o \
X	$(BUILDDIR)/m_move.o \
X	$(BUILDDIR)/m_mutant.o \
X	$(BUILDDIR)/m_parasite.o \
X	$(BUILDDIR)/m_soldier.o \
X	$(BUILDDIR)/m_stalker.o \
X	$(BUILDDIR)/m_supertank.o \
X	$(BUILDDIR)/m_tank.o \
X	$(BUILDDIR)/m_turret.o \
X	$(BUILDDIR)/m_widow.o \
X	$(BUILDDIR)/m_widow2.o \
X	$(BUILDDIR)/p_client.o \
X	$(BUILDDIR)/p_hud.o \
X	$(BUILDDIR)/p_trail.o \
X	$(BUILDDIR)/p_view.o \
X	$(BUILDDIR)/p_weapon.o \
X	$(BUILDDIR)/q_shared.o
X
$(BUILDDIR)/game$(ARCH).$(SHLIBEXT) : $(ROGUE_OBJS)
X	$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(ROGUE_OBJS)
X
$(BUILDDIR)/dm_ball.o :      dm_ball.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/dm_tag.o :       dm_tag.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_ai.o :         g_ai.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_chase.o :      g_chase.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_cmds.o :       g_cmds.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_combat.o :     g_combat.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_func.o :       g_func.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_items.o :      g_items.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_main.o :       g_main.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_misc.o :       g_misc.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_monster.o :    g_monster.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_newai.o :      g_newai.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_newdm.o :      g_newdm.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_newfnc.o :     g_newfnc.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_newtarg.o :    g_newtarg.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_newtrig.o :    g_newtrig.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_newweap.o :    g_newweap.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_phys.o :       g_phys.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_save.o :       g_save.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_spawn.o :      g_spawn.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_sphere.o :     g_sphere.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_svcmds.o :     g_svcmds.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_target.o :     g_target.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_trigger.o :    g_trigger.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_turret.o :     g_turret.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_utils.o :      g_utils.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/g_weapon.o :     g_weapon.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_actor.o :      m_actor.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_berserk.o :    m_berserk.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_boss2.o :      m_boss2.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_boss3.o :      m_boss3.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_boss31.o :     m_boss31.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_boss32.o :     m_boss32.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_brain.o :      m_brain.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_carrier.o :    m_carrier.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_chick.o :      m_chick.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_flash.o :      m_flash.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_flipper.o :    m_flipper.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_float.o :      m_float.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_flyer.o :      m_flyer.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_gladiator.o :  m_gladiator.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_gunner.o :     m_gunner.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_hover.o :      m_hover.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_infantry.o :   m_infantry.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_insane.o :     m_insane.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_medic.o :      m_medic.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_move.o :       m_move.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_mutant.o :     m_mutant.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_parasite.o :   m_parasite.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_soldier.o :    m_soldier.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_stalker.o :    m_stalker.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_supertank.o :  m_supertank.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_tank.o :       m_tank.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_turret.o :     m_turret.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_widow.o :      m_widow.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/m_widow2.o :     m_widow2.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/p_client.o :     p_client.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/p_hud.o :        p_hud.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/p_trail.o :      p_trail.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/p_view.o :       p_view.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/p_weapon.o :     p_weapon.c
X	$(DO_SHLIB_CC)
X
$(BUILDDIR)/q_shared.o :     q_shared.c
X	$(DO_SHLIB_CC)
X
######################
X
clean: clean-debug clean-release
X
clean-debug:
X	$(MAKE) clean2 BUILDDIR=$(BUILD_DEBUG_DIR) CFLAGS="$(DEBUG_CFLAGS)"
X
clean-release:
X	$(MAKE) clean2 BUILDDIR=$(BUILD_RELEASE_DIR) CFLAGS="$(DEBUG_CFLAGS)"
X
clean2:
X	-rm -f $(ROGUE_OBJS)
SHAR_EOF
  $shar_touch -am 1130175398 'Makefile' &&
  chmod 0664 'Makefile' ||
  $echo 'restore of' 'Makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'Makefile:' 'MD5 check failed'
80faeadcb1937c3b23bcc34bfedf35f8  Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'Makefile'`"
    test 6193 -eq "$shar_count" ||
    $echo 'Makefile:' 'original size' '6193,' 'current size' "$shar_count!"
  fi
fi
# ============= dm_ball.c ==============
if test -f 'dm_ball.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'dm_ball.c' '(file already exists)'
else
  $echo 'x -' extracting 'dm_ball.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'dm_ball.c' &&
// dm_ball.c
// pmack
// june 98
X
#include "g_local.h"
X
// defines
X
#define DBALL_GOAL_TEAM1	0x0001
#define DBALL_GOAL_TEAM2	0x0002
X
// globals
X
edict_t *dball_ball_entity = NULL;
int		dball_ball_startpt_count;
int		dball_team1_goalscore;
int		dball_team2_goalscore;
X
cvar_t	*dball_team1_skin;
cvar_t	*dball_team2_skin;
cvar_t	*goallimit;
X
// prototypes
X
extern void EndDMLevel (void);
extern void ClientUserinfoChanged (edict_t *ent, char *userinfo);
extern void	SelectSpawnPoint (edict_t *ent, vec3_t origin, vec3_t angles);
extern float PlayersRangeFromSpot (edict_t *spot);
X
void DBall_BallDie (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
void DBall_BallRespawn (edict_t *self);
X
// **************************
// Game rules
// **************************
X
int DBall_CheckDMRules (void)
{
X	if(goallimit && goallimit->value)
X	{
X		if(dball_team1_goalscore >= goallimit->value)
X			gi.bprintf (PRINT_HIGH, "Team 1 Wins.\n");
X		else if(dball_team2_goalscore >= goallimit->value)
X			gi.bprintf (PRINT_HIGH, "Team 2 Wins.\n");
X		else
X			return 0;
X
X		EndDMLevel ();
X		return 1;
X	}
X
X	return 0;
}
X
//==================
//==================
void DBall_ClientBegin (edict_t *ent)
{
X	int			team1, team2, unassigned;
X	edict_t		*other;
X	char		*p;
X	static char	value[512];
X	int			j;
X
X	team1 = 0;
X	team2 = 0;
X	unassigned = 0;
X
X	for (j = 1; j <= game.maxclients; j++)
X	{
X		other = &g_edicts[j];
X		if (!other->inuse)
X			continue;
X		if (!other->client)
X			continue;
X		if (other == ent)	// don't count the new player
X			continue;
X		
X		strcpy(value, Info_ValueForKey (other->client->pers.userinfo, "skin"));
X		p = strchr(value, '/');
X		if (p)
X		{
X			if(!strcmp(dball_team1_skin->string, value))
X				team1++;
X			else if(!strcmp(dball_team2_skin->string, value))
X				team2++;
X			else
X				unassigned++;
X		}
X		else
X			unassigned++;
X	}
X
X	if(team1 > team2)
X	{
X		gi.dprintf("assigned to team 2\n");
X		Info_SetValueForKey(ent->client->pers.userinfo, "skin", dball_team2_skin->string);
X	}
X	else
X	{
X		gi.dprintf("assigned to team 1\n");
X		Info_SetValueForKey(ent->client->pers.userinfo, "skin", dball_team1_skin->string);
X	}
X	
X	ClientUserinfoChanged(ent, ent->client->pers.userinfo);
X
X	if(unassigned)
X		gi.dprintf("%d unassigned players present!\n", unassigned);
}
X
//==================
//==================
void DBall_SelectSpawnPoint (edict_t *ent, vec3_t origin, vec3_t angles)
{
X	edict_t	*bestspot;
X	float	bestdistance, bestplayerdistance;
X	edict_t	*spot;
X	char	*spottype;
X	char	skin[512];
X
X	strcpy(skin, Info_ValueForKey (ent->client->pers.userinfo, "skin"));
X	if(!strcmp(dball_team1_skin->string, skin))
X		spottype = "dm_dball_team1_start";
X	else if(!strcmp(dball_team2_skin->string, skin))
X		spottype = "dm_dball_team2_start";
X	else
X		spottype = "info_player_deathmatch";
X
X	spot = NULL;
X	bestspot = NULL;
X	bestdistance = 0;
X	while ((spot = G_Find (spot, FOFS(classname), spottype)) != NULL)
X	{
X		bestplayerdistance = PlayersRangeFromSpot (spot);
X
X		if (bestplayerdistance > bestdistance)
X		{
X			bestspot = spot;
X			bestdistance = bestplayerdistance;
X		}
X	}
X
X	if (bestspot)
X	{
X		VectorCopy (bestspot->s.origin, origin);
X		origin[2] += 9;
X		VectorCopy (bestspot->s.angles, angles);
X		return;
X	}
X
X	// if we didn't find an appropriate spawnpoint, just
X	// call the standard one.
X	SelectSpawnPoint(ent, origin, angles);
}
X
//==================
//==================
void DBall_GameInit (void)
{
X	// we don't want a minimum speed for friction to take effect.
X	// this will allow any knockback to move stuff.
X	sv_stopspeed->value = 0;
X	dball_team1_goalscore = 0;
X	dball_team2_goalscore = 0;
X
X	dmflags->value = (int)dmflags->value | DF_NO_MINES | DF_NO_NUKES | DF_NO_STACK_DOUBLE | 
X						DF_NO_FRIENDLY_FIRE | DF_SKINTEAMS;
X	
X	dball_team1_skin = gi.cvar ("dball_team1_skin", "male/ctf_r", 0);
X	dball_team2_skin = gi.cvar ("dball_team2_skin", "male/ctf_b", 0);
X	goallimit = gi.cvar ("goallimit", "0", 0);
}
X
//==================
//==================
void DBall_PostInitSetup (void)
{
X	edict_t		*e;
X
X	e=NULL;
X	// turn teleporter destinations nonsolid.
X	while(e = G_Find (e, FOFS(classname), "misc_teleporter_dest"))
X	{
X		e->solid = SOLID_NOT;
X		gi.linkentity (e);
X	}
X
X	// count the ball start points
X	dball_ball_startpt_count = 0;
X	e=NULL;
X	while(e = G_Find (e, FOFS(classname), "dm_dball_ball_start"))
X	{
X		dball_ball_startpt_count++;
X	}
X
X	if(dball_ball_startpt_count == 0)
X		gi.dprintf("No Deathball start points!\n");
}
X
//==================
// DBall_ChangeDamage - half damage between players. full if it involves
//		the ball entity
//==================
int DBall_ChangeDamage (edict_t *targ, edict_t *attacker, int damage, int mod)
{
X	// cut player -> ball damage to 1
X	if (targ == dball_ball_entity)
X		return 1;
X
X	// damage player -> player is halved
X	if (attacker != dball_ball_entity)
X		return damage / 2;
X
X	return damage;
}
X
//==================
//==================
int DBall_ChangeKnockback (edict_t *targ, edict_t *attacker, int knockback, int mod)
{
X	if(targ != dball_ball_entity)
X		return knockback;
X	
X	if(knockback < 1)
X	{
X		// FIXME - these don't account for quad/double
X		if(mod == MOD_ROCKET)		// rocket
X			knockback = 70;
X		else if(mod == MOD_BFG_EFFECT)	// bfg
X			knockback = 90;
X		else
X	 		gi.dprintf ("zero knockback, mod %d\n", mod);
X	}
X	else
X	{
X		// FIXME - change this to an array?
X		switch(mod)
X		{
X			case MOD_BLASTER:
X				knockback *= 3;
X				break;
X			case MOD_SHOTGUN:
X				knockback = (knockback * 3) / 8;
X				break;
X			case MOD_SSHOTGUN:
X				knockback = knockback / 3;
X				break;
X			case MOD_MACHINEGUN:
X				knockback = (knockback * 3) / 2;
X				break;
X			case MOD_HYPERBLASTER:
X				knockback *= 4;
X				break;
X			case MOD_GRENADE:
X			case MOD_HANDGRENADE:
X			case MOD_PROX:
X			case MOD_G_SPLASH:
X			case MOD_HG_SPLASH:
X			case MOD_HELD_GRENADE:
X			case MOD_TRACKER:
X			case MOD_DISINTEGRATOR:
X				knockback /= 2;
X				break;
X			case MOD_R_SPLASH:
X				knockback = (knockback * 3) / 2;
X				break;
X			case MOD_RAILGUN:
X			case MOD_HEATBEAM:
X				knockback /= 3;
X				break;
X		}
X	}
X
//	gi.dprintf("mod: %d    knockback: %d\n", mod, knockback);
X	return knockback;
}
X
// **************************
// Goals
// **************************
X
void DBall_GoalTouch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	int		team_score;
X	int		scorechange;
X	int		j;
X	char	value[512];
X	char	*p;
X	edict_t	*ent;
X
X	if(other != dball_ball_entity)
X		return;
X
X	self->health = self->max_health;
X
X	// determine which team scored, and bump the team score
X	if(self->spawnflags & DBALL_GOAL_TEAM1)
X	{
X		dball_team1_goalscore += self->wait;		
X		team_score = 1;
X	}
X	else
X	{
X		dball_team2_goalscore += self->wait;		
X		team_score = 2;
X	}
X
X	// bump the score for everyone on the correct team.
X	for (j = 1; j <= game.maxclients; j++)
X	{
X		ent = &g_edicts[j];
X		if (!ent->inuse)
X			continue;
X		if (!ent->client)
X			continue;
X		
X		if (ent == other->enemy)
X			scorechange = self->wait + 5;
X		else
X			scorechange = self->wait;
X
X		strcpy(value, Info_ValueForKey (ent->client->pers.userinfo, "skin"));
X		p = strchr(value, '/');
X		if (p)
X		{
X			if(!strcmp(dball_team1_skin->string, value))
X			{
X				if(team_score == 1)
X					ent->client->resp.score += scorechange;
X				else if(other->enemy == ent)
X					ent->client->resp.score -= scorechange;
X			}
X			else if(!strcmp(dball_team2_skin->string, value))
X			{
X				if(team_score == 2)
X					ent->client->resp.score += scorechange;
X				else if(other->enemy == ent)
X					ent->client->resp.score -= scorechange;
X			}
X			else
X				gi.dprintf("unassigned player!!!!\n");
X		}
X	}
X
X	if(other->enemy)
X		gi.dprintf("score for team %d by %s\n", team_score, other->enemy->client->pers.netname);
X	else
X		gi.dprintf("score for team %d by someone\n", team_score);
X
X	DBall_BallDie (other, other->enemy, other->enemy, 0, vec3_origin);
X
X	G_UseTargets (self, other);
}
X
// **************************
// Ball
// **************************
X
edict_t *PickBallStart (edict_t *ent)
{
X	int		which, current;
X	edict_t	*e;
X
X	which = ceil(random() * dball_ball_startpt_count);
X	e = NULL;
X	current = 0;
X
X	while(e = G_Find (e, FOFS(classname), "dm_dball_ball_start"))
X	{
X		current++;
X		if(current == which)
X			return e;
X	}
X
X	if(current == 0)
X		gi.dprintf("No ball start points found!\n");
X
X	return G_Find(NULL, FOFS(classname), "dm_dball_ball_start");
}
X
//==================
// DBall_BallTouch - if the ball hit another player, hurt them
//==================
void DBall_BallTouch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	vec3_t	dir;
X	float	dot;
X	float	speed;
X
X	if(other->takedamage == DAMAGE_NO)
X		return;
X
X	// hit a player
X	if(other->client) 
X	{
X		if(ent->velocity[0] || ent->velocity[1] || ent->velocity[2])
X		{
X			speed = VectorLength(ent->velocity);
X
X			VectorSubtract(ent->s.origin, other->s.origin, dir);
X			dot = DotProduct(dir, ent->velocity);
X
X			if(dot > 0.7)
X			{
X				T_Damage (other, ent, ent, vec3_origin, ent->s.origin, vec3_origin, 
X						speed/10, speed/10, 0, MOD_DBALL_CRUSH);
X			}
X		}
X	}
}
X
//==================
// DBall_BallPain
//==================
void DBall_BallPain (edict_t *self, edict_t *other, float kick, int damage)
{
X	self->enemy = other;
X	self->health = self->max_health;
//	if(other->classname)
//		gi.dprintf("hurt by %s -- %d\n", other->classname, self->health);
}
X
void DBall_BallDie (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	// do the splash effect
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_DBALL_GOAL);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	VectorClear(self->s.angles);
X	VectorClear(self->velocity);
X	VectorClear(self->avelocity);
X
X	// make it invisible and desolid until respawn time
X	self->solid = SOLID_NOT;
//	self->s.modelindex = 0;
X	self->think = DBall_BallRespawn;
X	self->nextthink = level.time + 2;
X	gi.linkentity(self);
X
}
X
void DBall_BallRespawn (edict_t *self)
{
X	edict_t		*start;
X
X	// do the splash effect
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_DBALL_GOAL);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	// move the ball and stop it
X	start = PickBallStart(self);
X	if(start)
X	{
X		VectorCopy(start->s.origin, self->s.origin);
X		VectorCopy(start->s.origin, self->s.old_origin);
X	}
X
X	VectorClear(self->s.angles);
X	VectorClear(self->velocity);
X	VectorClear(self->avelocity);
X	
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/objects/dball/tris.md2");
X	self->s.event = EV_PLAYER_TELEPORT;
X	self->groundentity = NULL;
X
X	// kill anything at the destination
X	KillBox (self);
X
X	gi.linkentity (self);
}
X
// ************************
// SPEED CHANGES
// ************************
X
#define DBALL_SPEED_ONEWAY		1
X
void DBall_SpeedTouch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	float	dot;
X	vec3_t	vel;
X
X	if(other != dball_ball_entity)
X		return;
X
X	if(self->timestamp >= level.time)
X		return;
X
X	if(VectorLength(other->velocity) < 1)
X		return;
X
X	if(self->spawnflags & DBALL_SPEED_ONEWAY)
X	{
X		VectorCopy (other->velocity, vel);
X		VectorNormalize (vel);
X		dot = DotProduct (vel, self->movedir);
X		if(dot < 0.8)
X			return;
X	}
X
X	self->timestamp = level.time + self->delay;
X	VectorScale (other->velocity, self->speed, other->velocity);
}
X
// ************************
// SPAWN FUNCTIONS
// ************************
X
/*QUAKED dm_dball_ball (1 .5 .5) (-48 -48 -48) (48 48 48)
Deathball Ball
*/
void SP_dm_dball_ball (edict_t *self)
{
X	if(!(deathmatch->value))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
X
X	if(gamerules && (gamerules->value != RDM_DEATHBALL))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
X
X	dball_ball_entity = self;
//	VectorCopy (self->s.origin, dball_ball_startpt);
X
X	self->s.modelindex = gi.modelindex ("models/objects/dball/tris.md2");
X	VectorSet (self->mins, -32, -32, -32);
X	VectorSet (self->maxs, 32, 32, 32);
X	self->solid = SOLID_BBOX;
X	self->movetype = MOVETYPE_NEWTOSS;
X	self->clipmask = MASK_MONSTERSOLID;
X
X	self->takedamage = DAMAGE_YES;
X	self->mass = 50;
X	self->health = 50000;
X	self->max_health = 50000;
X	self->pain = DBall_BallPain;
X	self->die = DBall_BallDie;
X	self->touch = DBall_BallTouch;
X
X	gi.linkentity (self);
}
X
/*QUAKED dm_dball_team1_start (1 .5 .5) (-16 -16 -24) (16 16 32)
Deathball team 1 start point
*/
void SP_dm_dball_team1_start (edict_t *self)
{
X	if (!deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X	if(gamerules && (gamerules->value != RDM_DEATHBALL))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
}
X
/*QUAKED dm_dball_team2_start (1 .5 .5) (-16 -16 -24) (16 16 32)
Deathball team 2 start point
*/
void SP_dm_dball_team2_start (edict_t *self)
{
X	if (!deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X	if(gamerules && (gamerules->value != RDM_DEATHBALL))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
}
X
/*QUAKED dm_dball_ball_start (1 .5 .5) (-48 -48 -48) (48 48 48)
Deathball ball start point
*/
void SP_dm_dball_ball_start (edict_t *self)
{
X	if (!deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X	if(gamerules && (gamerules->value != RDM_DEATHBALL))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
}
X
/*QUAKED dm_dball_speed_change (1 .5 .5) ? ONEWAY
Deathball ball speed changing field.
X
speed: multiplier for speed (.5 = half, 2 = double, etc) (default = double)
angle: used with ONEWAY so speed change is only one way.
delay: time between speed changes (default: 0.2 sec)
*/
void SP_dm_dball_speed_change (edict_t *self)
{
X	if (!deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X	if(gamerules && (gamerules->value != RDM_DEATHBALL))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
X
X	if(!self->speed)
X		self->speed = 2;
X
X	if(!self->delay)
X		self->delay = 0.2;
X
X	self->touch = DBall_SpeedTouch;
X	self->solid = SOLID_TRIGGER;
X	self->movetype = MOVETYPE_NONE;
X	self->svflags |= SVF_NOCLIENT;
X
X	if (!VectorCompare(self->s.angles, vec3_origin))
X		G_SetMovedir (self->s.angles, self->movedir);
X	else
X		VectorSet (self->movedir, 1, 0, 0);
X
X	gi.setmodel (self, self->model);
X	gi.linkentity (self);
}
X
/*QUAKED dm_dball_goal (1 .5 .5) ? TEAM1 TEAM2
Deathball goal
X
Team1/Team2 - beneficiary of this goal. when the ball enters this goal, the beneficiary team will score.
X
"wait": score to be given for this goal (default 10) player gets score+5.
*/
void SP_dm_dball_goal (edict_t *self)
{
X	if(!(deathmatch->value))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
X
X	if(gamerules && (gamerules->value != RDM_DEATHBALL))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
X
X	if(!self->wait)
X		self->wait = 10;
X
X	self->touch = DBall_GoalTouch;
X	self->solid = SOLID_TRIGGER;
X	self->movetype = MOVETYPE_NONE;
X	self->svflags |= SVF_NOCLIENT;
X
X	if (!VectorCompare(self->s.angles, vec3_origin))
X		G_SetMovedir (self->s.angles, self->movedir);
X
X	gi.setmodel (self, self->model);
X	gi.linkentity (self);
X
}
SHAR_EOF
  $shar_touch -am 1130175398 'dm_ball.c' &&
  chmod 0664 'dm_ball.c' ||
  $echo 'restore of' 'dm_ball.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'dm_ball.c:' 'MD5 check failed'
ae80d03b0f13843f6489a1578c2f9a8d  dm_ball.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'dm_ball.c'`"
    test 14672 -eq "$shar_count" ||
    $echo 'dm_ball.c:' 'original size' '14672,' 'current size' "$shar_count!"
  fi
fi
# ============= dm_tag.c ==============
if test -f 'dm_tag.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'dm_tag.c' '(file already exists)'
else
  $echo 'x -' extracting 'dm_tag.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'dm_tag.c' &&
// dm_tag
// pmack
// june 1998
X
#include "g_local.h"
X
extern edict_t *SelectFarthestDeathmatchSpawnPoint (void);
extern void	SelectSpawnPoint (edict_t *ent, vec3_t origin, vec3_t angles);
X
void SP_dm_tag_token (edict_t *self);
X
// ***********************
// Tag Specific Stuff
// ***********************
X
edict_t		*tag_token;
edict_t		*tag_owner;
int			tag_count;
X
//=================
//=================
void Tag_PlayerDeath(edict_t *targ, edict_t *inflictor, edict_t *attacker)
{
//	gi.dprintf("%s killed %s\n", attacker->classname, targ->classname);
//	gi.dprintf("%x killed %x\n", attacker, targ);
X
X	if(tag_token && targ && (targ == tag_owner))
X	{
//		gi.dprintf("owner died/suicided. dropping\n");
X		Tag_DropToken(targ, FindItem( "Tag Token" ));
X		tag_owner = NULL;
X		tag_count = 0;
X	}
//	else
//		gi.dprintf("unrelated slaying\n");
}
X
//=================
//=================
void Tag_KillItBonus (edict_t *self)
{
X	edict_t			*armor;
X
X	// if the player is hurt, boost them up to max.
X	if(self->health < self->max_health)
X	{
X		self->health += 200;
X		if(self->health > self->max_health)
X			self->health = self->max_health;
X	}
X
X	// give the player a body armor
X	armor = G_Spawn();
X	armor->spawnflags |= DROPPED_ITEM;
X	armor->item = FindItem("Body Armor");
X	Touch_Item(armor, self, NULL, NULL);
X	if(armor->inuse)
X		G_FreeEdict(armor);
}
X
//=================
//=================
void Tag_PlayerDisconnect (edict_t *self)
{
X	if(tag_token && self && (self == tag_owner))
X	{
//		gi.dprintf("owner died/suicided. dropping\n");
X		Tag_DropToken(self, FindItem( "Tag Token" ));
X		tag_owner = NULL;
X		tag_count = 0;
X	}
}
X
//=================
//=================
void Tag_Score (edict_t *attacker, edict_t *victim, int scoreChange)
{
X	gitem_t		*quad;
X	int			mod;
X
X	mod = meansOfDeath & ~MOD_FRIENDLY_FIRE;
X
//	gi.dprintf("%s killed %s\n", attacker->classname, victim->classname);
//	gi.dprintf("%x killed %x\n", attacker, victim);
X	if(tag_token && tag_owner)
X	{
X		// owner killed somone else
X		if((scoreChange > 0) && tag_owner == attacker)
X		{
X			scoreChange = 3;
X			tag_count++;
//			gi.dprintf("tag total: %d\n", tag_count);
X			if(tag_count == 5)
X			{
//				gi.dprintf("going to quad\n");
X				quad = FindItem ("Quad Damage");
X				attacker->client->pers.inventory[ITEM_INDEX(quad)]++;
X				quad->use (attacker, quad);
X				tag_count = 0;
X			}
X		}
X		// owner got killed. 5 points and switch owners
X		else if(tag_owner == victim && tag_owner != attacker)
X		{
//			gi.dprintf("owner killed by another player.\n");
X			scoreChange = 5;
X			if ((mod == MOD_HUNTER_SPHERE) || (mod == MOD_DOPPLE_EXPLODE) ||
X				(mod == MOD_DOPPLE_VENGEANCE) || (mod == MOD_DOPPLE_HUNTER) ||
X				(attacker->health <= 0))
X			{
X				Tag_DropToken(tag_owner, FindItem( "Tag Token" ));
X				tag_owner = NULL;
X				tag_count = 0;
X			}
X			else
X			{
X				Tag_KillItBonus(attacker);
X				tag_owner = attacker;
X				tag_count = 0;
X			}
X		}
//		else
//			gi.dprintf("unaffected slaying\n");
X	}
//	else
//		gi.dprintf("no tag token?\n");
X
X	attacker->client->resp.score += scoreChange;
}
X
//=================
//=================
qboolean Tag_PickupToken (edict_t *ent, edict_t *other)
{
X	if(gamerules && (gamerules->value != 2))
X	{
X		return false;
X	}
X
//	gi.dprintf("tag token picked up by %x\n", other);
X	// sanity checking is good.
X	if(tag_token != ent)
X		tag_token = ent;
X
X	other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X	
X	tag_owner = other;
X	tag_count = 0;
X
X	Tag_KillItBonus (other);
X
X	return true;
}
X
//=================
//=================
void Tag_Respawn (edict_t *ent)
{
X	edict_t	*spot;
X
X	spot = SelectFarthestDeathmatchSpawnPoint();
X	if(spot == NULL)
X	{
//		gi.dprintf("No open spawn point, waiting...\n");
X		ent->nextthink = level.time + 1;
X		return;
X	}
X
//	gi.dprintf("Relocating\n");
X
X	VectorCopy(spot->s.origin, ent->s.origin);
X	gi.linkentity(ent);
}
X
//=================
//=================
void Tag_MakeTouchable (edict_t *ent)
{
X	ent->touch = Touch_Item;
X
X	tag_token->think = Tag_Respawn;
X
X	// check here to see if it's in lava or slime. if so, do a respawn sooner
X	if(gi.pointcontents(ent->s.origin) & (CONTENTS_LAVA|CONTENTS_SLIME))
X	{
//		gi.dprintf("spawned in slime or lava. quick relocate\n");
X		tag_token->nextthink = level.time + 3;
X	}
X	else
X	{
//		gi.dprintf("spawned in the clear. regular relocate\n");
X		tag_token->nextthink = level.time + 30;
X	}
}
X
//=================
//=================
void Tag_DropToken (edict_t *ent, gitem_t *item)
{
X	trace_t	trace;
X	vec3_t	forward, right;
X	vec3_t	offset;
X
//	if(ent->client)
//		gi.dprintf("%s dropped the tag token\n", ent->client->pers.netname);
//	else
//		gi.dprintf("non-client dropped the tag token  (%s)\n", ent->classname);
X
X	// reset the score count for next player
X	tag_count = 0;
X	tag_owner = NULL;
X
X	tag_token = G_Spawn();
X
X	tag_token->classname = item->classname;
X	tag_token->item = item;
X	tag_token->spawnflags = DROPPED_ITEM;
X	tag_token->s.effects = EF_ROTATE | EF_TAGTRAIL;
X	tag_token->s.renderfx = RF_GLOW;
X	VectorSet (tag_token->mins, -15, -15, -15);
X	VectorSet (tag_token->maxs, 15, 15, 15);
X	gi.setmodel (tag_token, tag_token->item->world_model);
X	tag_token->solid = SOLID_TRIGGER;
X	tag_token->movetype = MOVETYPE_TOSS;  
X	tag_token->touch = NULL;
X	tag_token->owner = ent;
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X	VectorSet(offset, 24, 0, -16);
X	G_ProjectSource (ent->s.origin, offset, forward, right, tag_token->s.origin);
X	trace = gi.trace (ent->s.origin, tag_token->mins, tag_token->maxs,
X		tag_token->s.origin, ent, CONTENTS_SOLID);
X	VectorCopy (trace.endpos, tag_token->s.origin);
X
X	VectorScale (forward, 100, tag_token->velocity);
X	tag_token->velocity[2] = 300;
X
X	tag_token->think = Tag_MakeTouchable;
X	tag_token->nextthink = level.time + 1;
X
X	gi.linkentity (tag_token);
X
//	tag_token = Drop_Item (ent, item);
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
}
X
//=================
//=================
void Tag_PlayerEffects (edict_t *ent)
{
X	if(ent == tag_owner)
X		ent->s.effects |= EF_TAGTRAIL;
}
X
//=================
//=================
void Tag_DogTag (edict_t *ent, edict_t *killer, char **pic)
{
X	if(ent == tag_owner)
X			(*pic)="tag3";
}
X
//=================
// Tag_ChangeDamage - damage done that does not involve the tag owner
//		is at 75% original to encourage folks to go after the tag owner.
//=================
int	Tag_ChangeDamage (edict_t *targ, edict_t *attacker, int damage, int mod)
{
X	if((targ != tag_owner) && (attacker != tag_owner))
X		return (damage * 3 / 4);
X
X	return damage;
}
X
//=================
//=================
void Tag_GameInit (void)
{
X	tag_token = NULL;
X	tag_owner = NULL;
X	tag_count = 0;
}
X
//=================
//=================
void Tag_PostInitSetup (void)
{
X	edict_t		*e;
X	vec3_t		origin, angles;
X
X	// automatic spawning of tag token if one is not present on map.
X	e = G_Find (NULL, FOFS(classname), "dm_tag_token");
X	if(e == NULL)
X	{
X		e = G_Spawn();
X		e->classname = "dm_tag_token";
X
X		SelectSpawnPoint (e, origin, angles);
X		VectorCopy(origin, e->s.origin);
X		VectorCopy(origin, e->s.old_origin);
X		VectorCopy(angles, e->s.angles);
X		SP_dm_tag_token (e);
X	}
}
X
/*QUAKED dm_tag_token (.3 .3 1) (-16 -16 -16) (16 16 16)
The tag token for deathmatch tag games.
*/
void SP_dm_tag_token (edict_t *self)
{
X	if(!(deathmatch->value))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
X
X	if(gamerules && (gamerules->value != 2))
X	{
X		G_FreeEdict(self);	
X		return;
X	}
X
X	// store the tag token edict pointer for later use.
X	tag_token = self;
X	tag_count = 0;
X
X	self->classname = "dm_tag_token";
X	self->model = "models/items/tagtoken/tris.md2";
X	self->count = 1;
X	SpawnItem (self, FindItem ("Tag Token"));
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'dm_tag.c' &&
  chmod 0664 'dm_tag.c' ||
  $echo 'restore of' 'dm_tag.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'dm_tag.c:' 'MD5 check failed'
fe6bb24a974f3f22970f133e19107bef  dm_tag.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'dm_tag.c'`"
    test 7631 -eq "$shar_count" ||
    $echo 'dm_tag.c:' 'original size' '7631,' 'current size' "$shar_count!"
  fi
fi
# ============= g_ai.c ==============
if test -f 'g_ai.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_ai.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_ai.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_ai.c' &&
// g_ai.c
X
#include "g_local.h"
X
qboolean FindTarget (edict_t *self);
extern cvar_t	*maxclients;
X
qboolean ai_checkattack (edict_t *self, float dist);
X
qboolean	enemy_vis;
qboolean	enemy_infront;
int			enemy_range;
float		enemy_yaw;
X
// ROGUE STUFF
#define SLIDING_TROOPS	1
#define	MAX_SIDESTEP	8.0
//
X
//============================================================================
X
X
/*
=================
AI_SetSightClient
X
Called once each frame to set level.sight_client to the
player to be checked for in findtarget.
X
If all clients are either dead or in notarget, sight_client
will be null.
X
In coop games, sight_client will cycle between the clients.
=================
*/
void AI_SetSightClient (void)
{
X	edict_t	*ent;
X	int		start, check;
X
X	if (level.sight_client == NULL)
X		start = 1;
X	else
X		start = level.sight_client - g_edicts;
X
X	check = start;
X	while (1)
X	{
X		check++;
X		if (check > game.maxclients)
X			check = 1;
X		ent = &g_edicts[check];
X		if (ent->inuse
X			&& ent->health > 0
X			&& !(ent->flags & (FL_NOTARGET|FL_DISGUISED)) )
X		{
X			level.sight_client = ent;
X			return;		// got one
X		}
X		if (check == start)
X		{
X			level.sight_client = NULL;
X			return;		// nobody to see
X		}
X	}
}
X
//============================================================================
X
/*
=============
ai_move
X
Move the specified distance at current facing.
This replaces the QC functions: ai_forward, ai_back, ai_pain, and ai_painforward
==============
*/
void ai_move (edict_t *self, float dist)
{
X	M_walkmove (self, self->s.angles[YAW], dist);
}
X
X
/*
=============
ai_stand
X
Used for standing around and looking for players
Distance is for slight position adjustments needed by the animations
==============
*/
void ai_stand (edict_t *self, float dist)
{
X	vec3_t	v;
X	// PMM
X	qboolean retval;
X
X	if (dist)
X		M_walkmove (self, self->s.angles[YAW], dist);
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		if (self->enemy)
X		{
X			VectorSubtract (self->enemy->s.origin, self->s.origin, v);
X			self->ideal_yaw = vectoyaw(v);
X			if (self->s.angles[YAW] != self->ideal_yaw && self->monsterinfo.aiflags & AI_TEMP_STAND_GROUND)
X			{
X				self->monsterinfo.aiflags &= ~(AI_STAND_GROUND | AI_TEMP_STAND_GROUND);
X				self->monsterinfo.run (self);
X			}
X			if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X				M_ChangeYaw (self);
X			// PMM
X			// find out if we're going to be shooting
X			retval = ai_checkattack (self, 0);
X			// record sightings of player
X			if ((self->enemy) && (self->enemy->inuse) && (visible(self, self->enemy)))
X			{
X				self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X				VectorCopy (self->enemy->s.origin, self->monsterinfo.last_sighting);
X				VectorCopy (self->enemy->s.origin, self->monsterinfo.blind_fire_target);
X				self->monsterinfo.trail_time = level.time;
X				self->monsterinfo.blind_fire_delay = 0;
X			}
X			// check retval to make sure we're not blindfiring
X			else if (!retval)
X			{
X				FindTarget (self);
X				return;
X			}
//			ai_checkattack (self, 0);
X			// pmm
X		}
X		else
X			FindTarget (self);
X		return;
X	}
X
X	if (FindTarget (self))
X		return;
X	
X	if (level.time > self->monsterinfo.pausetime)
X	{
X		self->monsterinfo.walk (self);
X		return;
X	}
X
X	if (!(self->spawnflags & 1) && (self->monsterinfo.idle) && (level.time > self->monsterinfo.idle_time))
X	{
X		if (self->monsterinfo.idle_time)
X		{
X			self->monsterinfo.idle (self);
X			self->monsterinfo.idle_time = level.time + 15 + random() * 15;
X		}
X		else
X		{
X			self->monsterinfo.idle_time = level.time + random() * 15;
X		}
X	}
}
X
X
/*
=============
ai_walk
X
The monster is walking it's beat
=============
*/
void ai_walk (edict_t *self, float dist)
{
X	M_MoveToGoal (self, dist);
X
X	// check for noticing a player
X	if (FindTarget (self))
X		return;
X
X	if ((self->monsterinfo.search) && (level.time > self->monsterinfo.idle_time))
X	{
X		if (self->monsterinfo.idle_time)
X		{
X			self->monsterinfo.search (self);
X			self->monsterinfo.idle_time = level.time + 15 + random() * 15;
X		}
X		else
X		{
X			self->monsterinfo.idle_time = level.time + random() * 15;
X		}
X	}
}
X
X
/*
=============
ai_charge
X
Turns towards target and advances
Use this call with a distance of 0 to replace ai_face
==============
*/
void ai_charge (edict_t *self, float dist)
{
X	vec3_t	v;
X	// PMM
X	float	ofs;
X	// PMM
X
X	// PMM - made AI_MANUAL_STEERING affect things differently here .. they turn, but
X	// don't set the ideal_yaw
X
X	// This is put in there so monsters won't move towards the origin after killing
X	// a tesla. This could be problematic, so keep an eye on it.
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	// PMM - save blindfire target
X	if (visible(self, self->enemy))
X		VectorCopy (self->enemy->s.origin, self->monsterinfo.blind_fire_target);
X	// pmm 
X
X	if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X	{
X		VectorSubtract (self->enemy->s.origin, self->s.origin, v);
X		self->ideal_yaw = vectoyaw(v);
//		gi.dprintf ("enemy = %s\n", vtos (self->enemy->s.origin));
//		gi.dprintf ("enemy: ideal yaw is %f\n", self->ideal_yaw);
X	}
//	if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X	M_ChangeYaw (self);
// PMM
//	if (dist)
//		M_walkmove (self, self->s.angles[YAW], dist);
X
X	if (dist)
X	{
X		if (self->monsterinfo.aiflags & AI_CHARGING)
X		{
X			M_MoveToGoal (self, dist);
X			return;
X		}
X		// circle strafe support
X		if (self->monsterinfo.attack_state == AS_SLIDING)
X		{
X			// if we're fighting a tesla, NEVER circle strafe
X			if ((self->enemy) && (self->enemy->classname) && (!strcmp(self->enemy->classname, "tesla")))
X				ofs = 0;
X			else if (self->monsterinfo.lefty)
X				ofs = 90;
X			else
X				ofs = -90;
X			
X			if (M_walkmove (self, self->ideal_yaw + ofs, dist))
X				return;
X				
X			self->monsterinfo.lefty = 1 - self->monsterinfo.lefty;
X			M_walkmove (self, self->ideal_yaw - ofs, dist);
X		}
X		else
X			M_walkmove (self, self->s.angles[YAW], dist);
X	}
// PMM
}
X
X
/*
=============
ai_turn
X
don't move, but turn towards ideal_yaw
Distance is for slight position adjustments needed by the animations
=============
*/
void ai_turn (edict_t *self, float dist)
{
X	if (dist)
X		M_walkmove (self, self->s.angles[YAW], dist);
X
X	if (FindTarget (self))
X		return;
X	
X	if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X		M_ChangeYaw (self);
}
X
X
/*
X
X.enemy
Will be world if not currently angry at anyone.
X
X.movetarget
The next path spot to walk toward.  If .enemy, ignore .movetarget.
When an enemy is killed, the monster will try to return to it's path.
X
X.hunt_time
Set to time + something when the player is in sight, but movement straight for
him is blocked.  This causes the monster to use wall following code for
movement direction instead of sighting on the player.
X
X.ideal_yaw
A yaw angle of the intended direction, which will be turned towards at up
to 45 deg / state.  If the enemy is in view and hunt_time is not active,
this will be the exact line towards the enemy.
X
X.pausetime
A monster will leave it's stand state and head towards it's .movetarget when
time > .pausetime.
X
walkmove(angle, speed) primitive is all or nothing
*/
X
/*
=============
range
X
returns the range catagorization of an entity reletive to self
0	melee range, will become hostile even if back is turned
1	visibility and infront, or visibility and show hostile
2	infront and show hostile
3	only triggered by damage
=============
*/
int range (edict_t *self, edict_t *other)
{
X	vec3_t	v;
X	float	len;
X
X	VectorSubtract (self->s.origin, other->s.origin, v);
X	len = VectorLength (v);
X	if (len < MELEE_DISTANCE)
X		return RANGE_MELEE;
X	if (len < 500)
X		return RANGE_NEAR;
X	if (len < 1000)
X		return RANGE_MID;
X	return RANGE_FAR;
}
X
/*
=============
visible
X
returns 1 if the entity is visible to self, even if not infront ()
=============
*/
qboolean visible (edict_t *self, edict_t *other)
{
X	vec3_t	spot1;
X	vec3_t	spot2;
X	trace_t	trace;
X
X	VectorCopy (self->s.origin, spot1);
X	spot1[2] += self->viewheight;
X	VectorCopy (other->s.origin, spot2);
X	spot2[2] += other->viewheight;
X	trace = gi.trace (spot1, vec3_origin, vec3_origin, spot2, self, MASK_OPAQUE);
X	
X	if (trace.fraction == 1.0 || trace.ent == other)		// PGM
X		return true;
X	return false;
}
X
X
/*
=============
infront
X
returns 1 if the entity is in front (in sight) of self
=============
*/
qboolean infront (edict_t *self, edict_t *other)
{
X	vec3_t	vec;
X	float	dot;
X	vec3_t	forward;
X	
X	AngleVectors (self->s.angles, forward, NULL, NULL);
X	VectorSubtract (other->s.origin, self->s.origin, vec);
X	VectorNormalize (vec);
X	dot = DotProduct (vec, forward);
X	
X	if (dot > 0.3)
X		return true;
X	return false;
}
X
X
//============================================================================
X
void HuntTarget (edict_t *self)
{
X	vec3_t	vec;
X
X	self->goalentity = self->enemy;
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.stand (self);
X	else
X		self->monsterinfo.run (self);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, vec);
X	self->ideal_yaw = vectoyaw(vec);
X	// wait a while before first attack
X	if (!(self->monsterinfo.aiflags & AI_STAND_GROUND))
X		AttackFinished (self, 1);
}
X
void FoundTarget (edict_t *self)
{
X	// let other monsters see this monster for a while
X	if (self->enemy->client)
X	{
X		if(self->enemy->flags & FL_DISGUISED)
X		{
//			level.disguise_violator = self->enemy;
//			level.disguise_violation_framenum = level.framenum + 5;
X			self->enemy->flags &= ~FL_DISGUISED;
X		}
X		
X		level.sight_entity = self;
X		level.sight_entity_framenum = level.framenum;
X		level.sight_entity->light_level = 128;
X	}
X
X	self->show_hostile = level.time + 1;		// wake up other monsters
X
X	VectorCopy(self->enemy->s.origin, self->monsterinfo.last_sighting);
X	self->monsterinfo.trail_time = level.time;
X	// PMM
X	VectorCopy (self->enemy->s.origin, self->monsterinfo.blind_fire_target);
X	self->monsterinfo.blind_fire_delay = 0;
X	// PMM
X
X	if (!self->combattarget)
X	{
X		HuntTarget (self);
X		return;
X	}
X
X	self->goalentity = self->movetarget = G_PickTarget(self->combattarget);
X	if (!self->movetarget)
X	{
X		self->goalentity = self->movetarget = self->enemy;
X		HuntTarget (self);
X		gi.dprintf("%s at %s, combattarget %s not found\n", self->classname, vtos(self->s.origin), self->combattarget);
X		return;
X	}
X
X	// clear out our combattarget, these are a one shot deal
X	self->combattarget = NULL;
X	self->monsterinfo.aiflags |= AI_COMBAT_POINT;
X
X	// clear the targetname, that point is ours!
X	self->movetarget->targetname = NULL;
X	self->monsterinfo.pausetime = 0;
X
X	// run for it
X	self->monsterinfo.run (self);
}
X
X
/*
===========
FindTarget
X
Self is currently not attacking anything, so try to find a target
X
Returns TRUE if an enemy was sighted
X
When a player fires a missile, the point of impact becomes a fakeplayer so
that monsters that see the impact will respond as if they had seen the
player.
X
To avoid spending too much time, only a single client (or fakeclient) is
checked each frame.  This means multi player games will have slightly
slower noticing monsters.
============
*/
qboolean FindTarget (edict_t *self)
{
X	edict_t		*client;
X	qboolean	heardit;
X	int			r;
X
X	if (self->monsterinfo.aiflags & AI_GOOD_GUY)
X	{
X		if (self->goalentity && self->goalentity->inuse && self->goalentity->classname)
X		{
X			if (strcmp(self->goalentity->classname, "target_actor") == 0)
X				return false;
X		}
X
X		//FIXME look for monsters?
X		return false;
X	}
X
X	// if we're going to a combat point, just proceed
X	if (self->monsterinfo.aiflags & AI_COMBAT_POINT)
X		return false;
X
// if the first spawnflag bit is set, the monster will only wake up on
// really seeing the player, not another monster getting angry or hearing
// something
X
// revised behavior so they will wake up if they "see" a player make a noise
// but not weapon impact/explosion noises
X
X	heardit = false;
X	if ((level.sight_entity_framenum >= (level.framenum - 1)) && !(self->spawnflags & 1) )
X	{
X		client = level.sight_entity;
X		if (client->enemy == self->enemy)
X		{
X			return false;
X		}
X	}
X	else if (level.disguise_violation_framenum > level.framenum)
X	{
X		client = level.disguise_violator;
X	}
X	else if (level.sound_entity_framenum >= (level.framenum - 1))
X	{
X		client = level.sound_entity;
X		heardit = true;
X	}
X	else if (!(self->enemy) && (level.sound2_entity_framenum >= (level.framenum - 1)) && !(self->spawnflags & 1) )
X	{
X		client = level.sound2_entity;
X		heardit = true;
X	}
X	else
X	{
X		client = level.sight_client;
X		if (!client)
X			return false;	// no clients to get mad at
X	}
X
X	// if the entity went away, forget it
X	if (!client->inuse)
X		return false;
X
X	if (client == self->enemy)
X		return true;	// JDC false;
X
X	//PMM - hintpath coop fix
X	if ((self->monsterinfo.aiflags & AI_HINT_PATH) && (coop) && (coop->value))
X	{
//		if ((heardit) && (g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("ignoring coop sound target\n");
X		heardit = false;
X	}
X	// pmm
X
X	if (client->client)
X	{
X		if (client->flags & FL_NOTARGET)
X			return false;
X	}
X	else if (client->svflags & SVF_MONSTER)
X	{
X		if (!client->enemy)
X			return false;
X		if (client->enemy->flags & FL_NOTARGET)
X			return false;
X	}
X	else if (heardit)
X	{
X		// pgm - a little more paranoia won't hurt....
X		if ((client->owner) && (client->owner->flags & FL_NOTARGET))
X			return false;
X	}
X	else
X		return false;
X
X	if (!heardit)
X	{
X		r = range (self, client);
X
X		if (r == RANGE_FAR)
X			return false;
X
// this is where we would check invisibility
X
X		// is client in an spot too dark to be seen?
X		if (client->light_level <= 5)
X			return false;
X
X		if (!visible (self, client))
X		{
X			return false;
X		}
X
X		if (r == RANGE_NEAR)
X		{
X			if (client->show_hostile < level.time && !infront (self, client))
X			{
X				return false;
X			}
X		}
X		else if (r == RANGE_MID)
X		{
X			if (!infront (self, client))
X			{
X				return false;
X			}
X		}
X
X		self->enemy = client;
X
X		if (strcmp(self->enemy->classname, "player_noise") != 0)
X		{
X			self->monsterinfo.aiflags &= ~AI_SOUND_TARGET;
X
X			if (!self->enemy->client)
X			{
X				self->enemy = self->enemy->enemy;
X				if (!self->enemy->client)
X				{
X					self->enemy = NULL;
X					return false;
X				}
X			}
X		}
X	}
X	else	// heardit
X	{
X		vec3_t	temp;
X
X		if (self->spawnflags & 1)
X		{
X			if (!visible (self, client))
X				return false;
X		}
X		else
X		{
X			if (!gi.inPHS(self->s.origin, client->s.origin))
X				return false;
X		}
X
X		VectorSubtract (client->s.origin, self->s.origin, temp);
X
X		if (VectorLength(temp) > 1000)	// too far to hear
X		{
X			return false;
X		}
X
X		// check area portals - if they are different and not connected then we can't hear it
X		if (client->areanum != self->areanum)
X			if (!gi.AreasConnected(self->areanum, client->areanum))
X				return false;
X	
X		self->ideal_yaw = vectoyaw(temp);
X		if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X			M_ChangeYaw (self);
X
X		// hunt the sound for a bit; hopefully find the real player
X		self->monsterinfo.aiflags |= AI_SOUND_TARGET;
X		self->enemy = client;
X	}
X
//
// got one
//
X	// PMM - if we got an enemy, we need to bail out of hint paths, so take over here
X	if (self->monsterinfo.aiflags & AI_HINT_PATH)
X	{
//		if(g_showlogic && g_showlogic->value)
//			gi.dprintf("stopped following hint paths in FindTarget\n");
X
X		// this calls foundtarget for us
X		hintpath_stop (self);
X	}
X	else
X	{
X		FoundTarget (self);
X	}
X	// pmm
X	if (!(self->monsterinfo.aiflags & AI_SOUND_TARGET) && (self->monsterinfo.sight))
X		self->monsterinfo.sight (self, self->enemy);
X
X	return true;
}
X
X
//=============================================================================
X
/*
============
FacingIdeal
X
============
*/
qboolean FacingIdeal(edict_t *self)
{
X	float	delta;
X
X	delta = anglemod(self->s.angles[YAW] - self->ideal_yaw);
X	if (delta > 45 && delta < 315)
X		return false;
X	return true;
}
X
X
//=============================================================================
X
qboolean M_CheckAttack (edict_t *self)
{
X	vec3_t	spot1, spot2;
X	float	chance;
X	trace_t	tr;
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA|CONTENTS_WINDOW);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X		{	
X			// PGM - we want them to go ahead and shoot at info_notnulls if they can.
X			if(self->enemy->solid != SOLID_NOT || tr.fraction < 1.0)		//PGM
X			{
X				// PMM - if we can't see our target, and we're not blocked by a monster, go into blind fire if available
X				if ((!(tr.ent->svflags & SVF_MONSTER)) && (!visible(self, self->enemy)))
X				{
X					if ((self->monsterinfo.blindfire) && (self->monsterinfo.blind_fire_delay <= 20.0))
X					{
X						if (level.time < self->monsterinfo.attack_finished)
X						{
X							return false;
X						}
X						if (level.time < (self->monsterinfo.trail_time + self->monsterinfo.blind_fire_delay))
X						{
X							// wait for our time
X							return false;
X						}
X						else
X						{
//	gi.WriteByte (svc_temp_entity);
//	gi.WriteByte (TE_DEBUGTRAIL);
//	gi.WritePosition (spot1);
//	gi.WritePosition (self->monsterinfo.blind_fire_target);
//	gi.multicast (self->s.origin, MULTICAST_ALL);
X							// make sure we're not going to shoot a monster
X							tr = gi.trace (spot1, NULL, NULL, self->monsterinfo.blind_fire_target, self, CONTENTS_MONSTER);
X							if (tr.allsolid || tr.startsolid || ((tr.fraction < 1.0) && (tr.ent != self->enemy)))
X							{
//								if ((g_showlogic) && (g_showlogic->value))
//									gi.dprintf ("blindfire blocked\n");
X								return false;
X							}
X
X							self->monsterinfo.attack_state = AS_BLIND;
X							return true;
X						}
X					}
X				}
X				// pmm
X				return false;
X			}
X		}
X	}
X	
X	// melee attack
X	if (enemy_range == RANGE_MELEE)
X	{
X		// don't always melee in easy mode
X		if (skill->value == 0 && (rand()&3) )
X		{
X			// PMM - fix for melee only monsters & strafing
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X			return false;
X		}
X		if (self->monsterinfo.melee)
X			self->monsterinfo.attack_state = AS_MELEE;
X		else
X			self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X	
// missile attack
X	if (!self->monsterinfo.attack)
X	{
X		// PMM - fix for melee only monsters & strafing
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X		return false;
X	}
X	
X	if (level.time < self->monsterinfo.attack_finished)
X		return false;
X		
X	if (enemy_range == RANGE_FAR)
X		return false;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MELEE)
X	{
X		chance = 0.2;
X	}
X	else if (enemy_range == RANGE_NEAR)
X	{
X		chance = 0.1;
X	}
X	else if (enemy_range == RANGE_MID)
X	{
X		chance = 0.02;
X	}
X	else
X	{
X		return false;
X	}
X
X	if (skill->value == 0)
X		chance *= 0.5;
X	else if (skill->value >= 2)
X		chance *= 2;
X
X	// PGM - go ahead and shoot every time if it's a info_notnull
X	if ((random () < chance) || (self->enemy->solid == SOLID_NOT))
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
X		self->monsterinfo.attack_finished = level.time + 2*random();
X		return true;
X	}
X
X	// PMM -daedalus should strafe more .. this can be done here or in a customized
X	// check_attack code for the hover.
X	if (self->flags & FL_FLY)
X	{
X		// originally, just 0.3
X		float strafe_chance;
X		if (!(strcmp(self->classname, "monster_daedalus")))
X			strafe_chance = 0.8;
X		else
X			strafe_chance = 0.6;
X
X		// if enemy is tesla, never strafe
X		if ((self->enemy) && (self->enemy->classname) && (!strcmp(self->enemy->classname, "tesla")))
X			strafe_chance = 0;
X
X		if (random() < strafe_chance)
X			self->monsterinfo.attack_state = AS_SLIDING;
X		else
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
// do we want the monsters strafing?
#ifdef SLIDING_TROOPS
X	else
X	{
X		if (random() < 0.4)
X			self->monsterinfo.attack_state = AS_SLIDING;
X		else
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
#endif
//-PMM
X
X	return false;
}
X
X
/*
=============
ai_run_melee
X
Turn and close until within an angle to launch a melee attack
=============
*/
void ai_run_melee(edict_t *self)
{
X	self->ideal_yaw = enemy_yaw;
X	if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X		M_ChangeYaw (self);
X
X	if (FacingIdeal(self))
X	{
X		self->monsterinfo.melee (self);
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
}
X
X
/*
=============
ai_run_missile
X
Turn in place until within an angle to launch a missile attack
=============
*/
void ai_run_missile(edict_t *self)
{
X	self->ideal_yaw = enemy_yaw;
X	if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X		M_ChangeYaw (self);
X
X	if (FacingIdeal(self))
X	{
X		self->monsterinfo.attack (self);
//		if (self->monsterinfo.attack_state == AS_MISSILE)
X		if ((self->monsterinfo.attack_state == AS_MISSILE) || (self->monsterinfo.attack_state == AS_BLIND))
X			self->monsterinfo.attack_state = AS_STRAIGHT;
//		else if (self->monsterinfo.attack_state != AS_SLIDING)
//			gi.dprintf ("ai_run_missile: Unexpected attack state %d !\n", self->monsterinfo.attack_state);
X	}
};
X
X
/*
=============
ai_run_slide
X
Strafe sideways, but stay at aproximately the same range
=============
*/
void ai_run_slide(edict_t *self, float distance)
{
X	float	ofs;
X	float	angle;
X
X	self->ideal_yaw = enemy_yaw;
X
//	if (self->flags & FL_FLY)
//		angle = 90;
//	else
//		angle = 45;
X	
X	angle = 90;
X	
X	if (self->monsterinfo.lefty)
X		ofs = angle;
X	else
X		ofs = -angle;
//	
//	if (!(self->flags & FL_FLY))
//	{
//		// non fliers should actually turn towards the direction their trying to run
//		self->ideal_yaw += ofs;
//	}
//
X	if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X		M_ChangeYaw (self);
X
X	/*
X	if (!(self->flags & FL_FLY))
X	{
X		if (M_walkmove (self, self->ideal_yaw + ofs, distance))
X			return;
X	}
X	else
X	{
X		if (M_walkmove (self, self->ideal_yaw, distance))
X			return;
X	}
X	*/
X	// PMM - clamp maximum sideways move for non flyers to make them look less jerky
X	if (!self->flags & FL_FLY)
X		distance = min (distance, MAX_SIDESTEP);
X	if (M_walkmove (self, self->ideal_yaw + ofs, distance))
X		return;
X	// PMM - if we're dodging, give up on it and go straight
X	if (self->monsterinfo.aiflags & AI_DODGING)
X	{
X		monster_done_dodge (self);
X		// by setting as_straight, caller will know to try straight move
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X		return;
X	}
X
X	self->monsterinfo.lefty = 1 - self->monsterinfo.lefty;
X	if (M_walkmove (self, self->ideal_yaw - ofs, distance))
X		return;
X	// PMM - if we're dodging, give up on it and go straight
X	if (self->monsterinfo.aiflags & AI_DODGING)
X		monster_done_dodge (self);
X
X	// PMM - the move failed, so signal the caller (ai_run) to try going straight
X	self->monsterinfo.attack_state = AS_STRAIGHT;
X	/*
X	if (!(self->flags & FL_FLY))
X	{
X		M_walkmove (self, self->ideal_yaw + ofs, distance);
X	}
X	else
X	{
X		M_walkmove (self, self->ideal_yaw, distance);
X	}*/
}
X
X
/*
=============
ai_checkattack
X
Decides if we're going to attack or do something else
used by ai_run and ai_stand
=============
*/
qboolean ai_checkattack (edict_t *self, float dist)
{
X	vec3_t		temp;
X	qboolean	hesDeadJim;
X	// PMM
X	qboolean	retval;
X
// this causes monsters to run blindly to the combat point w/o firing
X	if (self->goalentity)
X	{
X		if (self->monsterinfo.aiflags & AI_COMBAT_POINT)
X			return false;
X
X		if (self->monsterinfo.aiflags & AI_SOUND_TARGET)
X		{
X			if ((level.time - self->enemy->teleport_time) > 5.0)
X			{
X				if (self->goalentity == self->enemy)
X					if (self->movetarget)
X						self->goalentity = self->movetarget;
X					else
X						self->goalentity = NULL;
X				self->monsterinfo.aiflags &= ~AI_SOUND_TARGET;
X				if (self->monsterinfo.aiflags & AI_TEMP_STAND_GROUND)
X					self->monsterinfo.aiflags &= ~(AI_STAND_GROUND | AI_TEMP_STAND_GROUND);
X			}
X			else
X			{
X				self->show_hostile = level.time + 1;
X				return false;
X			}
X		}
X	}
X
X	enemy_vis = false;
X
// see if the enemy is dead
X	hesDeadJim = false;
X	if ((!self->enemy) || (!self->enemy->inuse))
X	{
X		hesDeadJim = true;
X	}
X	else if (self->monsterinfo.aiflags & AI_MEDIC)
X	{
X		if (!(self->enemy->inuse) || (self->enemy->health > 0))
X		{
X			hesDeadJim = true;
//			self->monsterinfo.aiflags &= ~AI_MEDIC;
X		}
X	}
X	else
X	{
X		if (self->monsterinfo.aiflags & AI_BRUTAL)
X		{
X			if (self->enemy->health <= -80)
X				hesDeadJim = true;
X		}
X		else
X		{
X			if (self->enemy->health <= 0)
X				hesDeadJim = true;
X		}
X	}
X
X	if (hesDeadJim)
X	{
X		self->monsterinfo.aiflags &= ~AI_MEDIC;
X		self->enemy = NULL;
X	// FIXME: look all around for other targets
X		if (self->oldenemy && self->oldenemy->health > 0)
X		{
X			self->enemy = self->oldenemy;
X			self->oldenemy = NULL;
X			HuntTarget (self);
X		}
//ROGUE - multiple teslas make monsters lose track of the player.
X		else if(self->monsterinfo.last_player_enemy && self->monsterinfo.last_player_enemy->health > 0)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf("resorting to last_player_enemy...\n");
X			self->enemy = self->monsterinfo.last_player_enemy;
X			self->oldenemy = NULL;
X			self->monsterinfo.last_player_enemy = NULL;
X			HuntTarget (self);
X		}
//ROGUE
X		else
X		{
X			if (self->movetarget)
X			{
X				self->goalentity = self->movetarget;
X				self->monsterinfo.walk (self);
X			}
X			else
X			{
X				// we need the pausetime otherwise the stand code
X				// will just revert to walking with no target and
X				// the monsters will wonder around aimlessly trying
X				// to hunt the world entity
X				self->monsterinfo.pausetime = level.time + 100000000;
X				self->monsterinfo.stand (self);
X			}
X			return true;
X		}
X	}
X
X	self->show_hostile = level.time + 1;		// wake up other monsters
X
// check knowledge of enemy
X	enemy_vis = visible(self, self->enemy);
X	if (enemy_vis)
X	{
X		self->monsterinfo.search_time = level.time + 5;
X		VectorCopy (self->enemy->s.origin, self->monsterinfo.last_sighting);
X		// PMM
X		self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X		self->monsterinfo.trail_time = level.time;
X		VectorCopy (self->enemy->s.origin, self->monsterinfo.blind_fire_target);
X		self->monsterinfo.blind_fire_delay = 0;
X		// pmm
X	}
X
// look for other coop players here
//	if (coop && self->monsterinfo.search_time < level.time)
//	{
//		if (FindTarget (self))
//			return true;
//	}
X
X	enemy_infront = infront(self, self->enemy);
X	enemy_range = range(self, self->enemy);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw(temp);
X
X
X	// JDC self->ideal_yaw = enemy_yaw;
X
X	// PMM -- reordered so the monster specific checkattack is called before the run_missle/melee/checkvis
X	// stuff .. this allows for, among other things, circle strafing and attacking while in ai_run
X	retval = self->monsterinfo.checkattack (self);
X	if (retval)
X	{
X		// PMM
X		if (self->monsterinfo.attack_state == AS_MISSILE)
X		{
X			ai_run_missile (self);
X			return true;
X		}
X		if (self->monsterinfo.attack_state == AS_MELEE)
X		{
X			ai_run_melee (self);
X			return true;
X		}
X		// PMM -- added so monsters can shoot blind
X		if (self->monsterinfo.attack_state == AS_BLIND)
X		{
X			ai_run_missile (self);
X			return true;
X		}
X		// pmm
X
X		// if enemy is not currently visible, we will never attack
X		if (!enemy_vis)
X			return false;
X		// PMM
X	}
X	return retval;
X	// PMM
//	return self->monsterinfo.checkattack (self);
}
X
X
/*
=============
ai_run
X
The monster has an enemy it is trying to kill
=============
*/
void ai_run (edict_t *self, float dist)
{
X	vec3_t		v;
X	edict_t		*tempgoal;
X	edict_t		*save;
X	qboolean	new;
X	edict_t		*marker;
X	float		d1, d2;
X	trace_t		tr;
X	vec3_t		v_forward, v_right;
X	float		left, center, right;
X	vec3_t		left_target, right_target;
X	//PMM
X	qboolean	retval;
X	qboolean	alreadyMoved = false;
X	qboolean	gotcha = false;
X	edict_t		*realEnemy;
X 
X	// if we're going to a combat point, just proceed
X	if (self->monsterinfo.aiflags & AI_COMBAT_POINT)
X	{
X		M_MoveToGoal (self, dist);
X		return;
X	}
X
X	// PMM
X	if (self->monsterinfo.aiflags & AI_DUCKED)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("%s - duck flag cleaned up!\n", self->classname);
X		self->monsterinfo.aiflags &= ~AI_DUCKED;
X	}
X	if (self->maxs[2] != self->monsterinfo.base_height)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("%s - ducked height corrected!\n", self->classname);
X		monster_duck_up (self);
X	}
//	if ((self->monsterinfo.aiflags & AI_MANUAL_STEERING) && (strcmp(self->classname, "monster_turret")))
//	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("%s - manual steering in ai_run!\n", self->classname);
//	}
X	// pmm
X
//==========
//PGM
X	// if we're currently looking for a hint path
X	if (self->monsterinfo.aiflags & AI_HINT_PATH)
X	{
X		// determine direction to our destination hintpath.
X		// FIXME - is this needed EVERY time? I was having trouble with them
X		// sometimes not going after it, and this fixed it.
//		VectorSubtract(self->movetarget->s.origin, self->s.origin, v);
//		vectoangles(v, v_forward);
//		self->ideal_yaw = v_forward[YAW];
//		gi.dprintf("seeking hintpath. origin: %s %0.1f\n", vtos(v), self->ideal_yaw);
X		M_MoveToGoal (self, dist);
X		if(!self->inuse)
X			return;			// PGM - g_touchtrigger free problem
//		return;
X
X		// if we've already seen the player, and can't see him now, return
//		if(self->enemy && !visible(self, self->enemy))
//			return;
X
X		// if not and can't find the player, return
//		if(!FindTarget(self))
//			return;
X
X		// first off, make sure we're looking for the player, not a noise he made
X		if (self->enemy)
X		{
X			if (self->enemy->inuse)
X			{
X				if (strcmp(self->enemy->classname, "player_noise") != 0)
X					realEnemy = self->enemy;
X				else if (self->enemy->owner)
X					realEnemy = self->enemy->owner;
X				else // uh oh, can't figure out enemy, bail
X				{
X					self->enemy = NULL;
X					hintpath_stop (self);
X					return;
X				}
X			}
X			else
X			{
X				self->enemy = NULL;
X				hintpath_stop (self);
X				return;
X			}
X		}
X		else
X		{
X			hintpath_stop (self);
X			return;
X		}
X
X		if (coop && coop->value)
X		{
X			// if we're in coop, check my real enemy first .. if I SEE him, set gotcha to true
X			if (self->enemy && visible(self, realEnemy))
X				gotcha = true;
X			else // otherwise, let FindTarget bump us out of hint paths, if appropriate
X				FindTarget(self);
X		}
X		else
X		{
X			if(self->enemy && visible(self, realEnemy))
X				gotcha = true;
X		}
X		
X		// if we see the player, stop following hintpaths.
X		if (gotcha)
X		{
//			if(g_showlogic && g_showlogic->value)
//				gi.dprintf("stopped following hint paths in ai_run\n");
X
X			// disconnect from hintpaths and start looking normally for players.
X			hintpath_stop (self);
X			// pmm - no longer needed, since hintpath_stop does it
//			HuntTarget(self);
X		}
X		return;
X	}
//PGM
//==========
X
X	if (self->monsterinfo.aiflags & AI_SOUND_TARGET)
X	{
X		// PMM - paranoia checking
X		if (self->enemy)
X			VectorSubtract (self->s.origin, self->enemy->s.origin, v);
X
X		if ((!self->enemy) || (VectorLength(v) < 64))
X		// pmm
X		{
X			self->monsterinfo.aiflags |= (AI_STAND_GROUND | AI_TEMP_STAND_GROUND);
X			self->monsterinfo.stand (self);
X			return;
X		}
X
X		M_MoveToGoal (self, dist);
X		// PMM - prevent double moves for sound_targets
X		alreadyMoved = true;
X		// pmm
X		if(!self->inuse)
X			return;			// PGM - g_touchtrigger free problem
X
X		if (!FindTarget (self))
X			return;
X	}
X
X	// PMM -- moved ai_checkattack up here so the monsters can attack while strafing or charging
X
X	// PMM -- if we're dodging, make sure to keep the attack_state AS_SLIDING
X
X	retval = ai_checkattack (self, dist);
X
X	// PMM - don't strafe if we can't see our enemy
X	if ((!enemy_vis) && (self->monsterinfo.attack_state == AS_SLIDING))
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X	// unless we're dodging (dodging out of view looks smart)
X	if (self->monsterinfo.aiflags & AI_DODGING)
X		self->monsterinfo.attack_state = AS_SLIDING;
X	// pmm
X
X	if (self->monsterinfo.attack_state == AS_SLIDING)
X	{
X		// PMM - protect against double moves
X		if (!alreadyMoved)
X			ai_run_slide (self, dist);
X		// PMM
X		// we're using attack_state as the return value out of ai_run_slide to indicate whether or not the
X		// move succeeded.  If the move succeeded, and we're still sliding, we're done in here (since we've
X		// had our chance to shoot in ai_checkattack, and have moved).
X		// if the move failed, our state is as_straight, and it will be taken care of below
X		if ((!retval) && (self->monsterinfo.attack_state == AS_SLIDING))
X			return;
X	}
X	else if (self->monsterinfo.aiflags & AI_CHARGING)
X	{
X		self->ideal_yaw = enemy_yaw;
X		if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
X			M_ChangeYaw (self);
X	}
X	if (retval)
X	{
X		// PMM - is this useful?  Monsters attacking usually call the ai_charge routine..
X		// the only monster this affects should be the soldier
X		if ((dist != 0) && (!alreadyMoved) && (self->monsterinfo.attack_state == AS_STRAIGHT) && (!(self->monsterinfo.aiflags & AI_STAND_GROUND)))
X		{
X			M_MoveToGoal (self, dist);
X		}
X		if ((self->enemy) && (self->enemy->inuse) && (enemy_vis))
X		{
X			self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X			VectorCopy (self->enemy->s.origin, self->monsterinfo.last_sighting);
X			self->monsterinfo.trail_time = level.time;
X			//PMM
X			VectorCopy (self->enemy->s.origin, self->monsterinfo.blind_fire_target);
X			self->monsterinfo.blind_fire_delay = 0;
X			//pmm
X		}
X		return;
X	}
X	//PMM
//	if (ai_checkattack (self, dist))
//		return;
X
//	if (self->monsterinfo.attack_state == AS_SLIDING)
//	{
//		ai_run_slide (self, dist);
//		return;
//	}
X
X	// PGM - added a little paranoia checking here... 9/22/98
X	if ((self->enemy) && (self->enemy->inuse) && (enemy_vis))
X	{
//		if (self->monsterinfo.aiflags & AI_LOST_SIGHT)
//			gi.dprintf("regained sight\n");
X		// PMM - check for alreadyMoved
X		if (!alreadyMoved)
X			M_MoveToGoal (self, dist);
X		if(!self->inuse)
X			return;			// PGM - g_touchtrigger free problem
X
X		self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X		VectorCopy (self->enemy->s.origin, self->monsterinfo.last_sighting);
X		self->monsterinfo.trail_time = level.time;
X		// PMM
X		VectorCopy (self->enemy->s.origin, self->monsterinfo.blind_fire_target);
X		self->monsterinfo.blind_fire_delay = 0;
X		// pmm
X		return;
X	}
X
//=======
//PGM
X	// if we've been looking (unsuccessfully) for the player for 10 seconds
X	// PMM - reduced to 5, makes them much nastier
X	if((self->monsterinfo.trail_time + 5) <= level.time)
X	{
X		// and we haven't checked for valid hint paths in the last 10 seconds
X		if((self->monsterinfo.last_hint_time + 10) <= level.time)
X		{
X			// check for hint_paths.
X			self->monsterinfo.last_hint_time = level.time;
X			if(monsterlost_checkhint(self))
X				return;
X		}
X	}
//PGM
//=======
X
// PMM - moved down here to allow monsters to get on hint paths
X	// coop will change to another enemy if visible
X	if (coop->value)
X	{	// FIXME: insane guys get mad with this, which causes crashes!
X		if (FindTarget (self))
X			return;
X	}
// pmm
X
X	if ((self->monsterinfo.search_time) && (level.time > (self->monsterinfo.search_time + 20)))
X	{
X		// PMM - double move protection
X		if (!alreadyMoved)
X			M_MoveToGoal (self, dist);
X		self->monsterinfo.search_time = 0;
//		gi.dprintf("search timeout\n");
X		return;
X	}
X
X	save = self->goalentity;
X	tempgoal = G_Spawn();
X	self->goalentity = tempgoal;
X
X	new = false;
X
X	if (!(self->monsterinfo.aiflags & AI_LOST_SIGHT))
X	{
X		// just lost sight of the player, decide where to go first
//		gi.dprintf("lost sight of player, last seen at %s\n", vtos(self->monsterinfo.last_sighting));
X		self->monsterinfo.aiflags |= (AI_LOST_SIGHT | AI_PURSUIT_LAST_SEEN);
X		self->monsterinfo.aiflags &= ~(AI_PURSUE_NEXT | AI_PURSUE_TEMP);
X		new = true;
X	}
X
X	if (self->monsterinfo.aiflags & AI_PURSUE_NEXT)
X	{
//		vec3_t	debug_vec;
X
X		self->monsterinfo.aiflags &= ~AI_PURSUE_NEXT;
//		VectorSubtract(self->monsterinfo.last_sighting, self->s.origin, debug_vec); 
//		gi.dprintf("reached current goal: %s %s %f", vtos(self->s.origin), vtos(self->monsterinfo.last_sighting), VectorLength(debug_vec));
X
X		// give ourself more time since we got this far
X		self->monsterinfo.search_time = level.time + 5;
X
X		if (self->monsterinfo.aiflags & AI_PURSUE_TEMP)
X		{
//			gi.dprintf("was temp goal; retrying original\n");
X			self->monsterinfo.aiflags &= ~AI_PURSUE_TEMP;
X			marker = NULL;
X			VectorCopy (self->monsterinfo.saved_goal, self->monsterinfo.last_sighting);
X			new = true;
X		}
X		else if (self->monsterinfo.aiflags & AI_PURSUIT_LAST_SEEN)
X		{
X			self->monsterinfo.aiflags &= ~AI_PURSUIT_LAST_SEEN;
X			marker = PlayerTrail_PickFirst (self);
X		}
X		else
X		{
X			marker = PlayerTrail_PickNext (self);
X		}
X
X		if (marker)
X		{
X			VectorCopy (marker->s.origin, self->monsterinfo.last_sighting);
X			self->monsterinfo.trail_time = marker->timestamp;
X			self->s.angles[YAW] = self->ideal_yaw = marker->s.angles[YAW];
//			gi.dprintf("heading is %0.1f\n", self->ideal_yaw);
X
//			debug_drawline(self.origin, self.last_sighting, 52);
X			new = true;
X		}
X	}
X
X	VectorSubtract (self->s.origin, self->monsterinfo.last_sighting, v);
X	d1 = VectorLength(v);
X	if (d1 <= dist)
X	{
X		self->monsterinfo.aiflags |= AI_PURSUE_NEXT;
X		dist = d1;
X	}
X
X	VectorCopy (self->monsterinfo.last_sighting, self->goalentity->s.origin);
X
X	if (new)
X	{
//		gi.dprintf("checking for course correction\n");
X
X		tr = gi.trace(self->s.origin, self->mins, self->maxs, self->monsterinfo.last_sighting, self, MASK_PLAYERSOLID);
X		if (tr.fraction < 1)
X		{
X			VectorSubtract (self->goalentity->s.origin, self->s.origin, v);
X			d1 = VectorLength(v);
X			center = tr.fraction;
X			d2 = d1 * ((center+1)/2);
X			self->s.angles[YAW] = self->ideal_yaw = vectoyaw(v);
X			AngleVectors(self->s.angles, v_forward, v_right, NULL);
X
X			VectorSet(v, d2, -16, 0);
X			G_ProjectSource (self->s.origin, v, v_forward, v_right, left_target);
X			tr = gi.trace(self->s.origin, self->mins, self->maxs, left_target, self, MASK_PLAYERSOLID);
X			left = tr.fraction;
X
X			VectorSet(v, d2, 16, 0);
X			G_ProjectSource (self->s.origin, v, v_forward, v_right, right_target);
X			tr = gi.trace(self->s.origin, self->mins, self->maxs, right_target, self, MASK_PLAYERSOLID);
X			right = tr.fraction;
X
X			center = (d1*center)/d2;
X			if (left >= center && left > right)
X			{
X				if (left < 1)
X				{
X					VectorSet(v, d2 * left * 0.5, -16, 0);
X					G_ProjectSource (self->s.origin, v, v_forward, v_right, left_target);
//					gi.dprintf("incomplete path, go part way and adjust again\n");
X				}
X				VectorCopy (self->monsterinfo.last_sighting, self->monsterinfo.saved_goal);
X				self->monsterinfo.aiflags |= AI_PURSUE_TEMP;
X				VectorCopy (left_target, self->goalentity->s.origin);
X				VectorCopy (left_target, self->monsterinfo.last_sighting);
X				VectorSubtract (self->goalentity->s.origin, self->s.origin, v);
X				self->s.angles[YAW] = self->ideal_yaw = vectoyaw(v);
//				gi.dprintf("adjusted left\n");
//				debug_drawline(self.origin, self.last_sighting, 152);
X			}
X			else if (right >= center && right > left)
X			{
X				if (right < 1)
X				{
X					VectorSet(v, d2 * right * 0.5, 16, 0);
X					G_ProjectSource (self->s.origin, v, v_forward, v_right, right_target);
//					gi.dprintf("incomplete path, go part way and adjust again\n");
X				}
X				VectorCopy (self->monsterinfo.last_sighting, self->monsterinfo.saved_goal);
X				self->monsterinfo.aiflags |= AI_PURSUE_TEMP;
X				VectorCopy (right_target, self->goalentity->s.origin);
X				VectorCopy (right_target, self->monsterinfo.last_sighting);
X				VectorSubtract (self->goalentity->s.origin, self->s.origin, v);
X				self->s.angles[YAW] = self->ideal_yaw = vectoyaw(v);
//				gi.dprintf("adjusted right\n");
//				debug_drawline(self.origin, self.last_sighting, 152);
X			}
X		}
//		else gi.dprintf("course was fine\n");
X	}
X
X	M_MoveToGoal (self, dist);
X	if(!self->inuse)
X		return;			// PGM - g_touchtrigger free problem
X
X	G_FreeEdict(tempgoal);
X
X	if (self)
X		self->goalentity = save;
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_ai.c' &&
  chmod 0664 'g_ai.c' ||
  $echo 'restore of' 'g_ai.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_ai.c:' 'MD5 check failed'
50eecdd2368f26cc24d8fa5de8b97079  g_ai.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_ai.c'`"
    test 39451 -eq "$shar_count" ||
    $echo 'g_ai.c:' 'original size' '39451,' 'current size' "$shar_count!"
  fi
fi
# ============= g_chase.c ==============
if test -f 'g_chase.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_chase.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_chase.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_chase.c' &&
#include "g_local.h"
X
void UpdateChaseCam(edict_t *ent)
{
X	vec3_t o, ownerv, goal;
X	edict_t *targ;
X	vec3_t forward, right;
X	trace_t trace;
X	int i;
X	vec3_t oldgoal;
X	vec3_t angles;
X
X	// is our chase target gone?
X	if (!ent->client->chase_target->inuse
X		|| ent->client->chase_target->client->resp.spectator) {
X		edict_t *old = ent->client->chase_target;
X		ChaseNext(ent);
X		if (ent->client->chase_target == old) {
X			ent->client->chase_target = NULL;
X			ent->client->ps.pmove.pm_flags &= ~PMF_NO_PREDICTION;
X			return;
X		}
X	}
X
X	targ = ent->client->chase_target;
X
X	VectorCopy(targ->s.origin, ownerv);
X	VectorCopy(ent->s.origin, oldgoal);
X
X	ownerv[2] += targ->viewheight;
X
X	VectorCopy(targ->client->v_angle, angles);
X	if (angles[PITCH] > 56)
X		angles[PITCH] = 56;
X	AngleVectors (angles, forward, right, NULL);
X	VectorNormalize(forward);
X	VectorMA(ownerv, -30, forward, o);
X
X	if (o[2] < targ->s.origin[2] + 20)
X		o[2] = targ->s.origin[2] + 20;
X
X	// jump animation lifts
X	if (!targ->groundentity)
X		o[2] += 16;
X
X	trace = gi.trace(ownerv, vec3_origin, vec3_origin, o, targ, MASK_SOLID);
X
X	VectorCopy(trace.endpos, goal);
X
X	VectorMA(goal, 2, forward, goal);
X
X	// pad for floors and ceilings
X	VectorCopy(goal, o);
X	o[2] += 6;
X	trace = gi.trace(goal, vec3_origin, vec3_origin, o, targ, MASK_SOLID);
X	if (trace.fraction < 1) {
X		VectorCopy(trace.endpos, goal);
X		goal[2] -= 6;
X	}
X
X	VectorCopy(goal, o);
X	o[2] -= 6;
X	trace = gi.trace(goal, vec3_origin, vec3_origin, o, targ, MASK_SOLID);
X	if (trace.fraction < 1) {
X		VectorCopy(trace.endpos, goal);
X		goal[2] += 6;
X	}
X
X	if (targ->deadflag)
X		ent->client->ps.pmove.pm_type = PM_DEAD;
X	else
X		ent->client->ps.pmove.pm_type = PM_FREEZE;
X
X	VectorCopy(goal, ent->s.origin);
X	for (i=0 ; i<3 ; i++)
X		ent->client->ps.pmove.delta_angles[i] = ANGLE2SHORT(targ->client->v_angle[i] - ent->client->resp.cmd_angles[i]);
X
X	if (targ->deadflag) {
X		ent->client->ps.viewangles[ROLL] = 40;
X		ent->client->ps.viewangles[PITCH] = -15;
X		ent->client->ps.viewangles[YAW] = targ->client->killer_yaw;
X	} else {
X		VectorCopy(targ->client->v_angle, ent->client->ps.viewangles);
X		VectorCopy(targ->client->v_angle, ent->client->v_angle);
X	}
X
X	ent->viewheight = 0;
X	ent->client->ps.pmove.pm_flags |= PMF_NO_PREDICTION;
X	gi.linkentity(ent);
}
X
void ChaseNext(edict_t *ent)
{
X	int i;
X	edict_t *e;
X
X	if (!ent->client->chase_target)
X		return;
X
X	i = ent->client->chase_target - g_edicts;
X	do {
X		i++;
X		if (i > maxclients->value)
X			i = 1;
X		e = g_edicts + i;
X		if (!e->inuse)
X			continue;
X		if (!e->client->resp.spectator)
X			break;
X	} while (e != ent->client->chase_target);
X
X	ent->client->chase_target = e;
X	ent->client->update_chase = true;
}
X
void ChasePrev(edict_t *ent)
{
X	int i;
X	edict_t *e;
X
X	if (!ent->client->chase_target)
X		return;
X
X	i = ent->client->chase_target - g_edicts;
X	do {
X		i--;
X		if (i < 1)
X			i = maxclients->value;
X		e = g_edicts + i;
X		if (!e->inuse)
X			continue;
X		if (!e->client->resp.spectator)
X			break;
X	} while (e != ent->client->chase_target);
X
X	ent->client->chase_target = e;
X	ent->client->update_chase = true;
}
X
void GetChaseTarget(edict_t *ent)
{
X	int i;
X	edict_t *other;
X
X	for (i = 1; i <= maxclients->value; i++) {
X		other = g_edicts + i;
X		if (other->inuse && !other->client->resp.spectator) {
X			ent->client->chase_target = other;
X			ent->client->update_chase = true;
X			UpdateChaseCam(ent);
X			return;
X		}
X	}
X	gi.centerprintf(ent, "No other players to chase.");
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_chase.c' &&
  chmod 0664 'g_chase.c' ||
  $echo 'restore of' 'g_chase.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_chase.c:' 'MD5 check failed'
952a2fa08d217e545b75a45fd5a7f383  g_chase.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_chase.c'`"
    test 3412 -eq "$shar_count" ||
    $echo 'g_chase.c:' 'original size' '3412,' 'current size' "$shar_count!"
  fi
fi
# ============= g_cmds.c ==============
if test -f 'g_cmds.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_cmds.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_cmds.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_cmds.c' &&
#include "g_local.h"
#include "m_player.h"
X
X
char *ClientTeam (edict_t *ent)
{
X	char		*p;
X	static char	value[512];
X
X	value[0] = 0;
X
X	if (!ent->client)
X		return value;
X
X	strcpy(value, Info_ValueForKey (ent->client->pers.userinfo, "skin"));
X	p = strchr(value, '/');
X	if (!p)
X		return value;
X
X	if ((int)(dmflags->value) & DF_MODELTEAMS)
X	{
X		*p = 0;
X		return value;
X	}
X
X	// if ((int)(dmflags->value) & DF_SKINTEAMS)
X	return ++p;
}
X
qboolean OnSameTeam (edict_t *ent1, edict_t *ent2)
{
X	char	ent1Team [512];
X	char	ent2Team [512];
X
X	if (!((int)(dmflags->value) & (DF_MODELTEAMS | DF_SKINTEAMS)))
X		return false;
X
X	strcpy (ent1Team, ClientTeam (ent1));
X	strcpy (ent2Team, ClientTeam (ent2));
X
X	if (strcmp(ent1Team, ent2Team) == 0)
X		return true;
X	return false;
}
X
X
void SelectNextItem (edict_t *ent, int itflags)
{
X	gclient_t	*cl;
X	int			i, index;
X	gitem_t		*it;
X
X	cl = ent->client;
X
X	if (cl->chase_target) {
X		ChaseNext(ent);
X		return;
X	}
X
X	// scan  for the next valid one
X	for (i=1 ; i<=MAX_ITEMS ; i++)
X	{
X		index = (cl->pers.selected_item + i)%MAX_ITEMS;
X		if (!cl->pers.inventory[index])
X			continue;
X		it = &itemlist[index];
X		if (!it->use)
X			continue;
X		if (!(it->flags & itflags))
X			continue;
X
X		cl->pers.selected_item = index;
X		return;
X	}
X
X	cl->pers.selected_item = -1;
}
X
void SelectPrevItem (edict_t *ent, int itflags)
{
X	gclient_t	*cl;
X	int			i, index;
X	gitem_t		*it;
X
X	cl = ent->client;
X
X	if (cl->chase_target) {
X		ChasePrev(ent);
X		return;
X	}
X
X	// scan  for the next valid one
X	for (i=1 ; i<=MAX_ITEMS ; i++)
X	{
X		index = (cl->pers.selected_item + MAX_ITEMS - i)%MAX_ITEMS;
X		if (!cl->pers.inventory[index])
X			continue;
X		it = &itemlist[index];
X		if (!it->use)
X			continue;
X		if (!(it->flags & itflags))
X			continue;
X
X		cl->pers.selected_item = index;
X		return;
X	}
X
X	cl->pers.selected_item = -1;
}
X
void ValidateSelectedItem (edict_t *ent)
{
X	gclient_t	*cl;
X
X	cl = ent->client;
X
X	if (cl->pers.inventory[cl->pers.selected_item])
X		return;		// valid
X
X	SelectNextItem (ent, -1);
}
X
X
//=================================================================================
X
/*
==================
Cmd_Give_f
X
Give items to a client
==================
*/
void Cmd_Give_f (edict_t *ent)
{
X	char		*name;
X	gitem_t		*it;
X	int			index;
X	int			i;
X	qboolean	give_all;
X	edict_t		*it_ent;
X
X	if (deathmatch->value && !sv_cheats->value)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "You must run the server with '+set cheats 1' to enable this command.\n");
X		return;
X	}
X
X	name = gi.args();
X
X	if (Q_stricmp(name, "all") == 0)
X		give_all = true;
X	else
X		give_all = false;
X
X	if (give_all || Q_stricmp(gi.argv(1), "health") == 0)
X	{
X		if (gi.argc() == 3)
X			ent->health = atoi(gi.argv(2));
X		else
X			ent->health = ent->max_health;
X		if (!give_all)
X			return;
X	}
X
X	if (give_all || Q_stricmp(name, "weapons") == 0)
X	{
X		for (i=0 ; i<game.num_items ; i++)
X		{
X			it = itemlist + i;
X			if (!it->pickup)
X				continue;
X			if (!(it->flags & IT_WEAPON))
X				continue;
X			ent->client->pers.inventory[i] += 1;
X		}
X		if (!give_all)
X			return;
X	}
X
X	if (give_all || Q_stricmp(name, "ammo") == 0)
X	{
X		for (i=0 ; i<game.num_items ; i++)
X		{
X			it = itemlist + i;
X			if (!it->pickup)
X				continue;
X			if (!(it->flags & IT_AMMO))
X				continue;
X			Add_Ammo (ent, it, 1000);
X		}
X		if (!give_all)
X			return;
X	}
X
X	if (give_all || Q_stricmp(name, "armor") == 0)
X	{
X		gitem_armor_t	*info;
X
X		it = FindItem("Jacket Armor");
X		ent->client->pers.inventory[ITEM_INDEX(it)] = 0;
X
X		it = FindItem("Combat Armor");
X		ent->client->pers.inventory[ITEM_INDEX(it)] = 0;
X
X		it = FindItem("Body Armor");
X		info = (gitem_armor_t *)it->info;
X		ent->client->pers.inventory[ITEM_INDEX(it)] = info->max_count;
X
X		if (!give_all)
X			return;
X	}
X
X	if (give_all || Q_stricmp(name, "Power Shield") == 0)
X	{
X		it = FindItem("Power Shield");
X		it_ent = G_Spawn();
X		it_ent->classname = it->classname;
X		SpawnItem (it_ent, it);
X		Touch_Item (it_ent, ent, NULL, NULL);
X		if (it_ent->inuse)
X			G_FreeEdict(it_ent);
X
X		if (!give_all)
X			return;
X	}
X
X	if (give_all)
X	{
X		for (i=0 ; i<game.num_items ; i++)
X		{
X			it = itemlist + i;
X			if (!it->pickup)
X				continue;
X			if (it->flags & IT_NOT_GIVEABLE)					// ROGUE
X				continue;										// ROGUE
X			if (it->flags & (IT_ARMOR|IT_WEAPON|IT_AMMO))
X				continue;
X			ent->client->pers.inventory[i] = 1;
X		}
X		return;
X	}
X
X	it = FindItem (name);
X	if (!it)
X	{
X		name = gi.argv(1);
X		it = FindItem (name);
X		if (!it)
X		{
X			gi.cprintf (ent, PRINT_HIGH, "unknown item\n");
X			return;
X		}
X	}
X
X	if (!it->pickup)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "non-pickup item\n");
X		return;
X	}
X
//ROGUE
X	if (it->flags & IT_NOT_GIVEABLE)		
X	{
X		gi.dprintf ("item cannot be given\n");
X		return;							
X	}
//ROGUE
X
X	index = ITEM_INDEX(it);
X
X	if (it->flags & IT_AMMO)
X	{
X		if (gi.argc() == 3)
X			ent->client->pers.inventory[index] = atoi(gi.argv(2));
X		else
X			ent->client->pers.inventory[index] += it->quantity;
X	}
X	else
X	{
X		it_ent = G_Spawn();
X		it_ent->classname = it->classname;
X		SpawnItem (it_ent, it);
X		// PMM - since some items don't actually spawn when you say to ..
X		if (!it_ent->inuse)
X			return;
X		// pmm
X		Touch_Item (it_ent, ent, NULL, NULL);
X		if (it_ent->inuse)
X			G_FreeEdict(it_ent);
X	}
}
X
X
/*
==================
Cmd_God_f
X
Sets client to godmode
X
argv(0) god
==================
*/
void Cmd_God_f (edict_t *ent)
{
X	char	*msg;
X
X	if (deathmatch->value && !sv_cheats->value)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "You must run the server with '+set cheats 1' to enable this command.\n");
X		return;
X	}
X
X	ent->flags ^= FL_GODMODE;
X	if (!(ent->flags & FL_GODMODE) )
X		msg = "godmode OFF\n";
X	else
X		msg = "godmode ON\n";
X
X	gi.cprintf (ent, PRINT_HIGH, msg);
}
X
X
/*
==================
Cmd_Notarget_f
X
Sets client to notarget
X
argv(0) notarget
==================
*/
void Cmd_Notarget_f (edict_t *ent)
{
X	char	*msg;
X
X	if (deathmatch->value && !sv_cheats->value)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "You must run the server with '+set cheats 1' to enable this command.\n");
X		return;
X	}
X
X	ent->flags ^= FL_NOTARGET;
X	if (!(ent->flags & FL_NOTARGET) )
X		msg = "notarget OFF\n";
X	else
X		msg = "notarget ON\n";
X
X	gi.cprintf (ent, PRINT_HIGH, msg);
}
X
X
/*
==================
Cmd_Noclip_f
X
argv(0) noclip
==================
*/
void Cmd_Noclip_f (edict_t *ent)
{
X	char	*msg;
X
X	if (deathmatch->value && !sv_cheats->value)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "You must run the server with '+set cheats 1' to enable this command.\n");
X		return;
X	}
X
X	if (ent->movetype == MOVETYPE_NOCLIP)
X	{
X		ent->movetype = MOVETYPE_WALK;
X		msg = "noclip OFF\n";
X	}
X	else
X	{
X		ent->movetype = MOVETYPE_NOCLIP;
X		msg = "noclip ON\n";
X	}
X
X	gi.cprintf (ent, PRINT_HIGH, msg);
}
X
X
/*
==================
Cmd_Use_f
X
Use an inventory item
==================
*/
void Cmd_Use_f (edict_t *ent)
{
X	int			index;
X	gitem_t		*it;
X	char		*s;
X
X	s = gi.args();
X	it = FindItem (s);
X	if (!it)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "unknown item: %s\n", s);
X		return;
X	}
X	if (!it->use)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "Item is not usable.\n");
X		return;
X	}
X	index = ITEM_INDEX(it);
X	if (!ent->client->pers.inventory[index])
X	{
X		gi.cprintf (ent, PRINT_HIGH, "Out of item: %s\n", s);
X		return;
X	}
X
X	it->use (ent, it);
}
X
X
/*
==================
Cmd_Drop_f
X
Drop an inventory item
==================
*/
void Cmd_Drop_f (edict_t *ent)
{
X	int			index;
X	gitem_t		*it;
X	char		*s;
X
X	s = gi.args();
X	it = FindItem (s);
X	if (!it)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "unknown item: %s\n", s);
X		return;
X	}
X	if (!it->drop)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "Item is not dropable.\n");
X		return;
X	}
X	index = ITEM_INDEX(it);
X	if (!ent->client->pers.inventory[index])
X	{
X		gi.cprintf (ent, PRINT_HIGH, "Out of item: %s\n", s);
X		return;
X	}
X
X	it->drop (ent, it);
}
X
X
/*
=================
Cmd_Inven_f
=================
*/
void Cmd_Inven_f (edict_t *ent)
{
X	int			i;
X	gclient_t	*cl;
X
X	cl = ent->client;
X
X	cl->showscores = false;
X	cl->showhelp = false;
X
X	if (cl->showinventory)
X	{
X		cl->showinventory = false;
X		return;
X	}
X
X	cl->showinventory = true;
X
X	gi.WriteByte (svc_inventory);
X	for (i=0 ; i<MAX_ITEMS ; i++)
X	{
X		gi.WriteShort (cl->pers.inventory[i]);
X	}
X	gi.unicast (ent, true);
}
X
/*
=================
Cmd_InvUse_f
=================
*/
void Cmd_InvUse_f (edict_t *ent)
{
X	gitem_t		*it;
X
X	ValidateSelectedItem (ent);
X
X	if (ent->client->pers.selected_item == -1)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "No item to use.\n");
X		return;
X	}
X
X	it = &itemlist[ent->client->pers.selected_item];
X	if (!it->use)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "Item is not usable.\n");
X		return;
X	}
X	it->use (ent, it);
}
X
/*
=================
Cmd_WeapPrev_f
=================
*/
void Cmd_WeapPrev_f (edict_t *ent)
{
X	gclient_t	*cl;
X	int			i, index;
X	gitem_t		*it;
X	int			selected_weapon;
X
X	cl = ent->client;
X
X	if (!cl->pers.weapon)
X		return;
X
X	selected_weapon = ITEM_INDEX(cl->pers.weapon);
X
X	// scan  for the next valid one
X	for (i=1 ; i<=MAX_ITEMS ; i++)
X	{
X		// PMM - prevent scrolling through ALL weapons
//		index = (selected_weapon + i)%MAX_ITEMS;
X		index = (selected_weapon + MAX_ITEMS - i)%MAX_ITEMS;
X		if (!cl->pers.inventory[index])
X			continue;
X		it = &itemlist[index];
X		if (!it->use)
X			continue;
X		if (! (it->flags & IT_WEAPON) )
X			continue;
X		it->use (ent, it);
X		// PMM - prevent scrolling through ALL weapons
//		if (cl->pers.weapon == it)
//			return;	// successful
X		if (cl->newweapon == it)
X			return;
X	}
}
X
/*
=================
Cmd_WeapNext_f
=================
*/
void Cmd_WeapNext_f (edict_t *ent)
{
X	gclient_t	*cl;
X	int			i, index;
X	gitem_t		*it;
X	int			selected_weapon;
X
X	cl = ent->client;
X
X	if (!cl->pers.weapon)
X		return;
X
X	selected_weapon = ITEM_INDEX(cl->pers.weapon);
X
X	// scan  for the next valid one
X	for (i=1 ; i<=MAX_ITEMS ; i++)
X	{
X		// PMM - prevent scrolling through ALL weapons
//		index = (selected_weapon + MAX_ITEMS - i)%MAX_ITEMS;
X		index = (selected_weapon + i)%MAX_ITEMS;
X		if (!cl->pers.inventory[index])
X			continue;
X		it = &itemlist[index];
X		if (!it->use)
X			continue;
X		if (! (it->flags & IT_WEAPON) )
X			continue;
X		it->use (ent, it);
X		// PMM - prevent scrolling through ALL weapons
//		if (cl->pers.weapon == it)
//			return;	// successful
X		if (cl->newweapon == it)
X			return;
X	}
}
X
/*
=================
Cmd_WeapLast_f
=================
*/
void Cmd_WeapLast_f (edict_t *ent)
{
X	gclient_t	*cl;
X	int			index;
X	gitem_t		*it;
X
X	cl = ent->client;
X
X	if (!cl->pers.weapon || !cl->pers.lastweapon)
X		return;
X
X	index = ITEM_INDEX(cl->pers.lastweapon);
X	if (!cl->pers.inventory[index])
X		return;
X	it = &itemlist[index];
X	if (!it->use)
X		return;
X	if (! (it->flags & IT_WEAPON) )
X		return;
X	it->use (ent, it);
}
X
/*
=================
Cmd_InvDrop_f
=================
*/
void Cmd_InvDrop_f (edict_t *ent)
{
X	gitem_t		*it;
X
X	ValidateSelectedItem (ent);
X
X	if (ent->client->pers.selected_item == -1)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "No item to drop.\n");
X		return;
X	}
X
X	it = &itemlist[ent->client->pers.selected_item];
X	if (!it->drop)
X	{
X		gi.cprintf (ent, PRINT_HIGH, "Item is not dropable.\n");
X		return;
X	}
X	it->drop (ent, it);
}
X
/*
=================
Cmd_Kill_f
=================
*/
void Cmd_Kill_f (edict_t *ent)
{
X	if((level.time - ent->client->respawn_time) < 5)
X		return;
X	ent->flags &= ~FL_GODMODE;
X	ent->health = 0;
X	meansOfDeath = MOD_SUICIDE;
X
//ROGUE
X	// make sure no trackers are still hurting us.
X	if(ent->client->tracker_pain_framenum)
X		RemoveAttackingPainDaemons (ent);
X
X	if (ent->client->owned_sphere)
X	{
X		G_FreeEdict(ent->client->owned_sphere);
X		ent->client->owned_sphere = NULL;
X	}
//ROGUE
X
X	player_die (ent, ent, ent, 100000, vec3_origin);
}
X
/*
=================
Cmd_PutAway_f
=================
*/
void Cmd_PutAway_f (edict_t *ent)
{
X	ent->client->showscores = false;
X	ent->client->showhelp = false;
X	ent->client->showinventory = false;
}
X
X
int PlayerSort (void const *a, void const *b)
{
X	int		anum, bnum;
X
X	anum = *(int *)a;
X	bnum = *(int *)b;
X
X	anum = game.clients[anum].ps.stats[STAT_FRAGS];
X	bnum = game.clients[bnum].ps.stats[STAT_FRAGS];
X
X	if (anum < bnum)
X		return -1;
X	if (anum > bnum)
X		return 1;
X	return 0;
}
X
/*
=================
Cmd_Players_f
=================
*/
void Cmd_Players_f (edict_t *ent)
{
X	int		i;
X	int		count;
X	char	small[64];
X	char	large[1280];
X	int		index[256];
X
X	count = 0;
X	for (i = 0 ; i < maxclients->value ; i++)
X		if (game.clients[i].pers.connected)
X		{
X			index[count] = i;
X			count++;
X		}
X
X	// sort by frags
X	qsort (index, count, sizeof(index[0]), PlayerSort);
X
X	// print information
X	large[0] = 0;
X
X	for (i = 0 ; i < count ; i++)
X	{
X		Com_sprintf (small, sizeof(small), "%3i %s\n",
X			game.clients[index[i]].ps.stats[STAT_FRAGS],
X			game.clients[index[i]].pers.netname);
X		if (strlen (small) + strlen(large) > sizeof(large) - 100 )
X		{	// can't print all of them in one packet
X			strcat (large, "...\n");
X			break;
X		}
X		strcat (large, small);
X	}
X
X	gi.cprintf (ent, PRINT_HIGH, "%s\n%i players\n", large, count);
}
X
/*
=================
Cmd_Wave_f
=================
*/
void Cmd_Wave_f (edict_t *ent)
{
X	int		i;
X
X	i = atoi (gi.argv(1));
X
X	// can't wave when ducked
X	if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X		return;
X
X	if (ent->client->anim_priority > ANIM_WAVE)
X		return;
X
X	ent->client->anim_priority = ANIM_WAVE;
X
X	switch (i)
X	{
X	case 0:
X		gi.cprintf (ent, PRINT_HIGH, "flipoff\n");
X		ent->s.frame = FRAME_flip01-1;
X		ent->client->anim_end = FRAME_flip12;
X		break;
X	case 1:
X		gi.cprintf (ent, PRINT_HIGH, "salute\n");
X		ent->s.frame = FRAME_salute01-1;
X		ent->client->anim_end = FRAME_salute11;
X		break;
X	case 2:
X		gi.cprintf (ent, PRINT_HIGH, "taunt\n");
X		ent->s.frame = FRAME_taunt01-1;
X		ent->client->anim_end = FRAME_taunt17;
X		break;
X	case 3:
X		gi.cprintf (ent, PRINT_HIGH, "wave\n");
X		ent->s.frame = FRAME_wave01-1;
X		ent->client->anim_end = FRAME_wave11;
X		break;
X	case 4:
X	default:
X		gi.cprintf (ent, PRINT_HIGH, "point\n");
X		ent->s.frame = FRAME_point01-1;
X		ent->client->anim_end = FRAME_point12;
X		break;
X	}
}
X
/*
==================
Cmd_Say_f
==================
*/
void Cmd_Say_f (edict_t *ent, qboolean team, qboolean arg0)
{
X	int		i, j;
X	edict_t	*other;
X	char	*p;
X	char	text[2048];
X	gclient_t *cl;
X
X	if (gi.argc () < 2 && !arg0)
X		return;
X
X	if (!((int)(dmflags->value) & (DF_MODELTEAMS | DF_SKINTEAMS)))
X		team = false;
X
X	if (team)
X		Com_sprintf (text, sizeof(text), "(%s): ", ent->client->pers.netname);
X	else
X		Com_sprintf (text, sizeof(text), "%s: ", ent->client->pers.netname);
X
X	if (arg0)
X	{
X		strcat (text, gi.argv(0));
X		strcat (text, " ");
X		strcat (text, gi.args());
X	}
X	else
X	{
X		p = gi.args();
X
X		if (*p == '"')
X		{
X			p++;
X			p[strlen(p)-1] = 0;
X		}
X		strcat(text, p);
X	}
X
X	// don't let text be too long for malicious reasons
X	if (strlen(text) > 150)
X		text[150] = 0;
X
X	strcat(text, "\n");
X
X	if (flood_msgs->value) {
X		cl = ent->client;
X
X        if (level.time < cl->flood_locktill) {
X			gi.cprintf(ent, PRINT_HIGH, "You can't talk for %d more seconds\n",
X				(int)(cl->flood_locktill - level.time));
X            return;
X        }
X        i = cl->flood_whenhead - flood_msgs->value + 1;
X        if (i < 0)
X            i = (sizeof(cl->flood_when)/sizeof(cl->flood_when[0])) + i;
X		if (cl->flood_when[i] && 
X			level.time - cl->flood_when[i] < flood_persecond->value) {
X			cl->flood_locktill = level.time + flood_waitdelay->value;
X			gi.cprintf(ent, PRINT_CHAT, "Flood protection:  You can't talk for %d seconds.\n",
X				(int)flood_waitdelay->value);
X            return;
X        }
X		cl->flood_whenhead = (cl->flood_whenhead + 1) %
X			(sizeof(cl->flood_when)/sizeof(cl->flood_when[0]));
X		cl->flood_when[cl->flood_whenhead] = level.time;
X	}
X
X	if (dedicated->value)
X		gi.cprintf(NULL, PRINT_CHAT, "%s", text);
X
X	for (j = 1; j <= game.maxclients; j++)
X	{
X		other = &g_edicts[j];
X		if (!other->inuse)
X			continue;
X		if (!other->client)
X			continue;
X		if (team)
X		{
X			if (!OnSameTeam(ent, other))
X				continue;
X		}
X		gi.cprintf(other, PRINT_CHAT, "%s", text);
X	}
}
X
//======
//ROGUE
void Cmd_Ent_Count_f (edict_t *ent)
{
X	int		x;
X	edict_t	*e;
X
X	x=0;
X
X	for (e=g_edicts;e < &g_edicts[globals.num_edicts] ; e++)
X	{
X		if(e->inuse)
X			x++;
X	}
X
X	gi.dprintf("%d entites active\n", x);
}
//ROGUE
//======
X
void Cmd_PlayerList_f(edict_t *ent)
{
X	int i;
X	char st[80];
X	char text[1400];
X	edict_t *e2;
X
X	// connect time, ping, score, name
X	*text = 0;
X	for (i = 0, e2 = g_edicts + 1; i < maxclients->value; i++, e2++) {
X		if (!e2->inuse)
X			continue;
X
X		Com_sprintf(st, sizeof(st), "%02d:%02d %4d %3d %s%s\n",
X			(level.framenum - e2->client->resp.enterframe) / 600,
X			((level.framenum - e2->client->resp.enterframe) % 600)/10,
X			e2->client->ping,
X			e2->client->resp.score,
X			e2->client->pers.netname,
X			e2->client->resp.spectator ? " (spectator)" : "");
X		if (strlen(text) + strlen(st) > sizeof(text) - 50) {
X			sprintf(text+strlen(text), "And more...\n");
X			gi.cprintf(ent, PRINT_HIGH, "%s", text);
X			return;
X		}
X		strcat(text, st);
X	}
X	gi.cprintf(ent, PRINT_HIGH, "%s", text);
}
X
X
/*
=================
ClientCommand
=================
*/
void ClientCommand (edict_t *ent)
{
X	char	*cmd;
X
X	if (!ent->client)
X		return;		// not fully in game yet
X
X	cmd = gi.argv(0);
X
X	if (Q_stricmp (cmd, "players") == 0)
X	{
X		Cmd_Players_f (ent);
X		return;
X	}
X	if (Q_stricmp (cmd, "say") == 0)
X	{
X		Cmd_Say_f (ent, false, false);
X		return;
X	}
X	if (Q_stricmp (cmd, "say_team") == 0)
X	{
X		Cmd_Say_f (ent, true, false);
X		return;
X	}
X	if (Q_stricmp (cmd, "score") == 0)
X	{
X		Cmd_Score_f (ent);
X		return;
X	}
X	if (Q_stricmp (cmd, "help") == 0)
X	{
X		Cmd_Help_f (ent);
X		return;
X	}
X
X	if (level.intermissiontime)
X		return;
X
X	if (Q_stricmp (cmd, "use") == 0)
X		Cmd_Use_f (ent);
X	else if (Q_stricmp (cmd, "drop") == 0)
X		Cmd_Drop_f (ent);
X	else if (Q_stricmp (cmd, "give") == 0)
X		Cmd_Give_f (ent);
X	else if (Q_stricmp (cmd, "god") == 0)
X		Cmd_God_f (ent);
X	else if (Q_stricmp (cmd, "notarget") == 0)
X		Cmd_Notarget_f (ent);
X	else if (Q_stricmp (cmd, "noclip") == 0)
X		Cmd_Noclip_f (ent);
X	else if (Q_stricmp (cmd, "inven") == 0)
X		Cmd_Inven_f (ent);
X	else if (Q_stricmp (cmd, "invnext") == 0)
X		SelectNextItem (ent, -1);
X	else if (Q_stricmp (cmd, "invprev") == 0)
X		SelectPrevItem (ent, -1);
X	else if (Q_stricmp (cmd, "invnextw") == 0)
X		SelectNextItem (ent, IT_WEAPON);
X	else if (Q_stricmp (cmd, "invprevw") == 0)
X		SelectPrevItem (ent, IT_WEAPON);
X	else if (Q_stricmp (cmd, "invnextp") == 0)
X		SelectNextItem (ent, IT_POWERUP);
X	else if (Q_stricmp (cmd, "invprevp") == 0)
X		SelectPrevItem (ent, IT_POWERUP);
X	else if (Q_stricmp (cmd, "invuse") == 0)
X		Cmd_InvUse_f (ent);
X	else if (Q_stricmp (cmd, "invdrop") == 0)
X		Cmd_InvDrop_f (ent);
X	else if (Q_stricmp (cmd, "weapprev") == 0)
X		Cmd_WeapPrev_f (ent);
X	else if (Q_stricmp (cmd, "weapnext") == 0)
X		Cmd_WeapNext_f (ent);
X	else if (Q_stricmp (cmd, "weaplast") == 0)
X		Cmd_WeapLast_f (ent);
X	else if (Q_stricmp (cmd, "kill") == 0)
X		Cmd_Kill_f (ent);
X	else if (Q_stricmp (cmd, "putaway") == 0)
X		Cmd_PutAway_f (ent);
X	else if (Q_stricmp (cmd, "wave") == 0)
X		Cmd_Wave_f (ent);
X	else if (Q_stricmp(cmd, "playerlist") == 0)
X		Cmd_PlayerList_f(ent);
X	else if (Q_stricmp (cmd, "entcount") == 0)		// PGM
X		Cmd_Ent_Count_f (ent);						// PGM
X	else if (Q_stricmp (cmd, "disguise") == 0)		// PGM
X	{
X		ent->flags |= FL_DISGUISED;
X	}
X	else	// anything that doesn't match a command will be a chat
X		Cmd_Say_f (ent, false, true);
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_cmds.c' &&
  chmod 0664 'g_cmds.c' ||
  $echo 'restore of' 'g_cmds.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_cmds.c:' 'MD5 check failed'
636cb26b4e6c13107712819967fab3f9  g_cmds.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_cmds.c'`"
    test 19125 -eq "$shar_count" ||
    $echo 'g_cmds.c:' 'original size' '19125,' 'current size' "$shar_count!"
  fi
fi
# ============= g_combat.c ==============
if test -f 'g_combat.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_combat.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_combat.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_combat.c' &&
// g_combat.c
X
#include "g_local.h"
X
void M_SetEffects (edict_t *self);
X
/*
ROGUE
clean up heal targets for medic
*/
void cleanupHealTarget (edict_t *ent)
{
X	ent->monsterinfo.healer = NULL;
X	ent->takedamage = DAMAGE_YES;
X	ent->monsterinfo.aiflags &= ~AI_RESURRECTING;
X	M_SetEffects (ent);
}
/*
============
CanDamage
X
Returns true if the inflictor can directly damage the target.  Used for
explosions and melee attacks.
============
*/
qboolean CanDamage (edict_t *targ, edict_t *inflictor)
{
X	vec3_t	dest;
X	trace_t	trace;
X
// bmodels need special checking because their origin is 0,0,0
X	if (targ->movetype == MOVETYPE_PUSH)
X	{
X		VectorAdd (targ->absmin, targ->absmax, dest);
X		VectorScale (dest, 0.5, dest);
X		trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
X		if (trace.fraction == 1.0)
X			return true;
X		if (trace.ent == targ)
X			return true;
X		return false;
X	}
X	
X	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, targ->s.origin, inflictor, MASK_SOLID);
X	if (trace.fraction == 1.0)
X		return true;
X
X	VectorCopy (targ->s.origin, dest);
X	dest[0] += 15.0;
X	dest[1] += 15.0;
X	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
X	if (trace.fraction == 1.0)
X		return true;
X
X	VectorCopy (targ->s.origin, dest);
X	dest[0] += 15.0;
X	dest[1] -= 15.0;
X	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
X	if (trace.fraction == 1.0)
X		return true;
X
X	VectorCopy (targ->s.origin, dest);
X	dest[0] -= 15.0;
X	dest[1] += 15.0;
X	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
X	if (trace.fraction == 1.0)
X		return true;
X
X	VectorCopy (targ->s.origin, dest);
X	dest[0] -= 15.0;
X	dest[1] -= 15.0;
X	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
X	if (trace.fraction == 1.0)
X		return true;
X
X
X	return false;
}
X
X
/*
============
Killed
============
*/
void Killed (edict_t *targ, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	if (targ->health < -999)
X		targ->health = -999;
X
X	if (targ->monsterinfo.aiflags & AI_MEDIC)
X	{
X		if (targ->enemy)  // god, I hope so
X		{
X			cleanupHealTarget (targ->enemy);
X		}
X
X		// clean up self
X		targ->monsterinfo.aiflags &= ~AI_MEDIC;
X		targ->enemy = attacker;
X	}
X	else
X	{
X		targ->enemy = attacker;
X	}
X
X	if ((targ->svflags & SVF_MONSTER) && (targ->deadflag != DEAD_DEAD))
X	{
//		targ->svflags |= SVF_DEADMONSTER;	// now treat as a different content type
X		//ROGUE - free up slot for spawned monster if it's spawned
X		if (targ->monsterinfo.aiflags & AI_SPAWNED_CARRIER)
X		{
X			if (targ->monsterinfo.commander && targ->monsterinfo.commander->inuse && 
X				!strcmp(targ->monsterinfo.commander->classname, "monster_carrier"))
X			{
X				targ->monsterinfo.commander->monsterinfo.monster_slots++;
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("g_combat: freeing up carrier slot - %d left\n", targ->monsterinfo.commander->monsterinfo.monster_slots);
X			}
X		}
X		if (targ->monsterinfo.aiflags & AI_SPAWNED_MEDIC_C)
X		{
X			if (targ->monsterinfo.commander)
X			{
X				if (targ->monsterinfo.commander->inuse && !strcmp(targ->monsterinfo.commander->classname, "monster_medic_commander"))
X				{
X					targ->monsterinfo.commander->monsterinfo.monster_slots++;
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("g_combat: freeing up medic slot - %d left\n", targ->monsterinfo.commander->monsterinfo.monster_slots);
X				}
//				else
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("my commander is dead!  he's a %s\n", targ->monsterinfo.commander->classname);
X			}
//			else if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("My commander is GONE\n");
X
X		}
X		if (targ->monsterinfo.aiflags & AI_SPAWNED_WIDOW)
X		{
X			// need to check this because we can have variable numbers of coop players
X			if (targ->monsterinfo.commander && targ->monsterinfo.commander->inuse && 
X				!strncmp(targ->monsterinfo.commander->classname, "monster_widow", 13))
X			{
X				if (targ->monsterinfo.commander->monsterinfo.monster_used > 0)
X					targ->monsterinfo.commander->monsterinfo.monster_used--;
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("g_combat: freeing up black widow slot - %d used\n", targ->monsterinfo.commander->monsterinfo.monster_used);
X			}
X		}
X		//rogue
X		if ((!(targ->monsterinfo.aiflags & AI_GOOD_GUY)) && (!(targ->monsterinfo.aiflags & AI_DO_NOT_COUNT)))
X		{
X			level.killed_monsters++;
X			if (coop->value && attacker->client)
X				attacker->client->resp.score++;
X			// medics won't heal monsters that they kill themselves
X			// PMM - now they will
//			if (strcmp(attacker->classname, "monster_medic") == 0)
//				targ->owner = attacker;
X		}
X	}
X
X	if (targ->movetype == MOVETYPE_PUSH || targ->movetype == MOVETYPE_STOP || targ->movetype == MOVETYPE_NONE)
X	{	// doors, triggers, etc
X		targ->die (targ, inflictor, attacker, damage, point);
X		return;
X	}
X
X	if ((targ->svflags & SVF_MONSTER) && (targ->deadflag != DEAD_DEAD))
X	{
X		targ->touch = NULL;
X		monster_death_use (targ);
X	}
X
X	targ->die (targ, inflictor, attacker, damage, point);
}
X
X
/*
================
SpawnDamage
================
*/
void SpawnDamage (int type, vec3_t origin, vec3_t normal, int damage)
{
X	if (damage > 255)
X		damage = 255;
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (type);
//	gi.WriteByte (damage);
X	gi.WritePosition (origin);
X	gi.WriteDir (normal);
X	gi.multicast (origin, MULTICAST_PVS);
}
X
X
/*
============
T_Damage
X
targ		entity that is being damaged
inflictor	entity that is causing the damage
attacker	entity that caused the inflictor to damage targ
X	example: targ=monster, inflictor=rocket, attacker=player
X
dir			direction of the attack
point		point at which the damage is being inflicted
normal		normal vector from that point
damage		amount of damage being inflicted
knockback	force to be applied against targ as a result of the damage
X
dflags		these flags are used to control how T_Damage works
X	DAMAGE_RADIUS			damage was indirect (from a nearby explosion)
X	DAMAGE_NO_ARMOR			armor does not protect from this damage
X	DAMAGE_ENERGY			damage is from an energy based weapon
X	DAMAGE_NO_KNOCKBACK		do not affect velocity, just view angles
X	DAMAGE_BULLET			damage is from a bullet (used for ricochets)
X	DAMAGE_NO_PROTECTION	kills godmode, armor, everything
============
*/
static int CheckPowerArmor (edict_t *ent, vec3_t point, vec3_t normal, int damage, int dflags)
{
X	gclient_t	*client;
X	int			save;
X	int			power_armor_type;
X	int			index;
X	int			damagePerCell;
X	int			pa_te_type;
X	int			power;
X	int			power_used;
X
X	if (!damage)
X		return 0;
X
X	client = ent->client;
X
X	if (dflags & (DAMAGE_NO_ARMOR | DAMAGE_NO_POWER_ARMOR))		// PGM
X		return 0;					
X
X	if (client)
X	{
X		power_armor_type = PowerArmorType (ent);
X		if (power_armor_type != POWER_ARMOR_NONE)
X		{
X			index = ITEM_INDEX(FindItem("Cells"));
X			power = client->pers.inventory[index];
X		}
X	}
X	else if (ent->svflags & SVF_MONSTER)
X	{
X		power_armor_type = ent->monsterinfo.power_armor_type;
X		power = ent->monsterinfo.power_armor_power;
X	}
X	else
X		return 0;
X
X	if (power_armor_type == POWER_ARMOR_NONE)
X		return 0;
X	if (!power)
X		return 0;
X
X	if (power_armor_type == POWER_ARMOR_SCREEN)
X	{
X		vec3_t		vec;
X		float		dot;
X		vec3_t		forward;
X
X		// only works if damage point is in front
X		AngleVectors (ent->s.angles, forward, NULL, NULL);
X		VectorSubtract (point, ent->s.origin, vec);
X		VectorNormalize (vec);
X		dot = DotProduct (vec, forward);
X		if (dot <= 0.3)
X			return 0;
X
X		damagePerCell = 1;
X		pa_te_type = TE_SCREEN_SPARKS;
X		damage = damage / 3;
X	}
X	else
X	{
X		damagePerCell = 2;
X		pa_te_type = TE_SHIELD_SPARKS;
X		damage = (2 * damage) / 3;
X	}
X
X	// etf rifle
X	if (dflags & DAMAGE_NO_REG_ARMOR)
X		save = (power * damagePerCell) / 2;
X	else
X		save = power * damagePerCell;
X
X	if (!save)
X		return 0;
X	if (save > damage)
X		save = damage;
X
X	SpawnDamage (pa_te_type, point, normal, save);
X	ent->powerarmor_time = level.time + 0.2;
X
X	if (dflags & DAMAGE_NO_REG_ARMOR)
X		power_used = (save / damagePerCell) * 2;
X	else
X		power_used = save / damagePerCell;
X
X	if (client)
X		client->pers.inventory[index] -= power_used;
X	else
X		ent->monsterinfo.power_armor_power -= power_used;
X	return save;
}
X
static int CheckArmor (edict_t *ent, vec3_t point, vec3_t normal, int damage, int te_sparks, int dflags)
{
X	gclient_t	*client;
X	int			save;
X	int			index;
X	gitem_t		*armor;
X
X	if (!damage)
X		return 0;
X
X	client = ent->client;
X
X	if (!client)
X		return 0;
X
X	// ROGUE - added DAMAGE_NO_REG_ARMOR for atf rifle
X	if (dflags & (DAMAGE_NO_ARMOR | DAMAGE_NO_REG_ARMOR))
X		return 0;
X
X	index = ArmorIndex (ent);
X	if (!index)
X		return 0;
X
X	armor = GetItemByIndex (index);
X
X	if (dflags & DAMAGE_ENERGY)
X		save = ceil(((gitem_armor_t *)armor->info)->energy_protection*damage);
X	else
X		save = ceil(((gitem_armor_t *)armor->info)->normal_protection*damage);
X	if (save >= client->pers.inventory[index])
X		save = client->pers.inventory[index];
X
X	if (!save)
X		return 0;
X
X	client->pers.inventory[index] -= save;
X	SpawnDamage (te_sparks, point, normal, save);
X
X	return save;
}
X
void M_ReactToDamage (edict_t *targ, edict_t *attacker, edict_t *inflictor)
{
X	// pmm
X	qboolean new_tesla;
X
X	if (!(attacker->client) && !(attacker->svflags & SVF_MONSTER))
X		return;
X
//=======
//ROGUE
X	// logic for tesla - if you are hit by a tesla, and can't see who you should be mad at (attacker)
X	// attack the tesla
X	// also, target the tesla if it's a "new" tesla
X	if ((inflictor) && (!strcmp(inflictor->classname, "tesla")))
X	{
X		new_tesla = MarkTeslaArea(targ, inflictor);
X		if (new_tesla)
X			TargetTesla (targ, inflictor);
X		return;
X		// FIXME - just ignore teslas when you're TARGET_ANGER or MEDIC
/*		if (!(targ->enemy && (targ->monsterinfo.aiflags & (AI_TARGET_ANGER|AI_MEDIC))))
X		{
X			// FIXME - coop issues?
X			if ((!targ->enemy) || (!visible(targ, targ->enemy)))
X			{
X				gi.dprintf ("can't see player, switching to tesla\n");
X				TargetTesla (targ, inflictor);
X				return;
X			}
X			gi.dprintf ("can see player, ignoring tesla\n");
X		}
X		else if ((g_showlogic) && (g_showlogic->value))
X			gi.dprintf ("no enemy, or I'm doing other, more important things, than worrying about a damned tesla!\n");
*/
X	}
//ROGUE
//=======
X
X	if (attacker == targ || attacker == targ->enemy)
X		return;
X
X	// if we are a good guy monster and our attacker is a player
X	// or another good guy, do not get mad at them
X	if (targ->monsterinfo.aiflags & AI_GOOD_GUY)
X	{
X		if (attacker->client || (attacker->monsterinfo.aiflags & AI_GOOD_GUY))
X			return;
X	}
X
//PGM
X	// if we're currently mad at something a target_anger made us mad at, ignore
X	// damage
X	if (targ->enemy && targ->monsterinfo.aiflags & AI_TARGET_ANGER)
X	{
X		float	percentHealth;
X
X		// make sure whatever we were pissed at is still around.
X		if(targ->enemy->inuse)
X		{
X			percentHealth = (float)(targ->health) / (float)(targ->max_health);
X			if( targ->enemy->inuse && percentHealth > 0.33)
X				return;
X		}
X
X		// remove the target anger flag
X		targ->monsterinfo.aiflags &= ~AI_TARGET_ANGER;
X	}
//PGM
X
// PMM
// if we're healing someone, do like above and try to stay with them
X	if ((targ->enemy) && (targ->monsterinfo.aiflags & AI_MEDIC))
X	{
X		float	percentHealth;
X
X		percentHealth = (float)(targ->health) / (float)(targ->max_health);
X		// ignore it some of the time
X		if( targ->enemy->inuse && percentHealth > 0.25)
X			return;
X
X		// remove the medic flag
X		targ->monsterinfo.aiflags &= ~AI_MEDIC;
X		cleanupHealTarget (targ->enemy);
X	}
// PMM
X
X	// we now know that we are not both good guys
X
X	// if attacker is a client, get mad at them because he's good and we're not
X	if (attacker->client)
X	{
X		targ->monsterinfo.aiflags &= ~AI_SOUND_TARGET;
X
X		// this can only happen in coop (both new and old enemies are clients)
X		// only switch if can't see the current enemy
X		if (targ->enemy && targ->enemy->client)
X		{
X			if (visible(targ, targ->enemy))
X			{
X				targ->oldenemy = attacker;
X				return;
X			}
X			targ->oldenemy = targ->enemy;
X		}
X		targ->enemy = attacker;
X		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
X			FoundTarget (targ); 
X		return;
X	}
X
X	// it's the same base (walk/swim/fly) type and a different classname and it's not a tank
X	// (they spray too much), get mad at them
X	// PMM
X	// added medics to this 
X	// FIXME -
X	// this really should be turned into an AI flag marking appropriate monsters as "don't shoot me"
X	//   this also leads to the problem of tanks and medics being able to, at will, kill monsters with
X	//   no chance of retaliation.  My vote is to make those monsters who are designed as "don't shoot me"
X	//   such that they also ignore being shot by monsters as well
X	/*
X	if (((targ->flags & (FL_FLY|FL_SWIM)) == (attacker->flags & (FL_FLY|FL_SWIM))) &&
X		 (strcmp (targ->classname, attacker->classname) != 0) &&
X		 (strcmp(attacker->classname, "monster_tank") != 0) &&
X		 (strcmp(attacker->classname, "monster_supertank") != 0) &&
X		 (strcmp(attacker->classname, "monster_makron") != 0) &&
X		 (strcmp(attacker->classname, "monster_jorg") != 0) &&
X		 (strcmp(attacker->classname, "monster_carrier") != 0) && 
X 		 (strncmp(attacker->classname, "monster_medic", 12) != 0) ) // this should get medics & medic_commanders
X	*/
X	if (((targ->flags & (FL_FLY|FL_SWIM)) == (attacker->flags & (FL_FLY|FL_SWIM))) &&
X		(strcmp (targ->classname, attacker->classname) != 0) &&
X		!(attacker->monsterinfo.aiflags & AI_IGNORE_SHOTS) &&
X		!(targ->monsterinfo.aiflags & AI_IGNORE_SHOTS) )
X	{
X		if (targ->enemy && targ->enemy->client)
X			targ->oldenemy = targ->enemy;
X		targ->enemy = attacker;
X		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
X			FoundTarget (targ);
X	}
X	// if they *meant* to shoot us, then shoot back
X	else if (attacker->enemy == targ)
X	{
X		if (targ->enemy && targ->enemy->client)
X			targ->oldenemy = targ->enemy;
X		targ->enemy = attacker;
X		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
X			FoundTarget (targ);
X	}
X	// otherwise get mad at whoever they are mad at (help our buddy) unless it is us!
X	else if (attacker->enemy && attacker->enemy != targ)
X	{
X		if (targ->enemy && targ->enemy->client)
X			targ->oldenemy = targ->enemy;
X		targ->enemy = attacker->enemy;
X		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
X			FoundTarget (targ);
X	}
}
X
qboolean CheckTeamDamage (edict_t *targ, edict_t *attacker)
{
X		//FIXME make the next line real and uncomment this block
X		// if ((ability to damage a teammate == OFF) && (targ's team == attacker's team))
X	return false;
}
X
void T_Damage (edict_t *targ, edict_t *inflictor, edict_t *attacker, vec3_t dir, vec3_t point, vec3_t normal, int damage, int knockback, int dflags, int mod)
{
X	gclient_t	*client;
X	int			take;
X	int			save;
X	int			asave;
X	int			psave;
X	int			te_sparks;
X	int			sphere_notified;	// PGM
X
X	if (!targ->takedamage)
X		return;
X
X	sphere_notified = false;		// PGM
X
X	// friendly fire avoidance
X	// if enabled you can't hurt teammates (but you can hurt yourself)
X	// knockback still occurs
X	if ((targ != attacker) && ((deathmatch->value && ((int)(dmflags->value) & (DF_MODELTEAMS | DF_SKINTEAMS))) || coop->value))
X	{
X		if (OnSameTeam (targ, attacker))
X		{
X			// PMM - nukes kill everyone
X			if (((int)(dmflags->value) & DF_NO_FRIENDLY_FIRE) && (mod != MOD_NUKE))
X				damage = 0;
X			else
X				mod |= MOD_FRIENDLY_FIRE;
X		}
X	}
X	meansOfDeath = mod;
X
//ROGUE
X	// allow the deathmatch game to change values
X	if (deathmatch->value && gamerules && gamerules->value)
X	{
X		if(DMGame.ChangeDamage)
X			damage = DMGame.ChangeDamage(targ, attacker, damage, mod);
X		if(DMGame.ChangeKnockback)
X			knockback = DMGame.ChangeKnockback(targ, attacker, knockback, mod);
X
X		if(!damage)
X			return;
X	}
//ROGUE
X
X	// easy mode takes half damage
X	if (skill->value == 0 && deathmatch->value == 0 && targ->client)
X	{
X		damage *= 0.5;
X		if (!damage)
X			damage = 1;
X	}
X
X	client = targ->client;
X
X	// PMM - defender sphere takes half damage
X	if ((client) && (client->owned_sphere) && (client->owned_sphere->spawnflags == 1))
X	{
X		damage *= 0.5;
X		if (!damage)
X			damage = 1;
X	}
X
X	if (dflags & DAMAGE_BULLET)
X		te_sparks = TE_BULLET_SPARKS;
X	else
X		te_sparks = TE_SPARKS;
X
X	VectorNormalize(dir);
X
// bonus damage for suprising a monster
X	if (!(dflags & DAMAGE_RADIUS) && (targ->svflags & SVF_MONSTER) && (attacker->client) && (!targ->enemy) && (targ->health > 0))
X		damage *= 2;
X
X	if (targ->flags & FL_NO_KNOCKBACK)
X		knockback = 0;
X
// figure momentum add
X	if (!(dflags & DAMAGE_NO_KNOCKBACK))
X	{
X		if ((knockback) && (targ->movetype != MOVETYPE_NONE) && (targ->movetype != MOVETYPE_BOUNCE) && (targ->movetype != MOVETYPE_PUSH) && (targ->movetype != MOVETYPE_STOP))
X		{
X			vec3_t	kvel;
X			float	mass;
X
X			if (targ->mass < 50)
X				mass = 50;
X			else
X				mass = targ->mass;
X
X			if (targ->client  && attacker == targ)
X				VectorScale (dir, 1600.0 * (float)knockback / mass, kvel);	// the rocket jump hack...
X			else
X				VectorScale (dir, 500.0 * (float)knockback / mass, kvel);
X
X			VectorAdd (targ->velocity, kvel, targ->velocity);
X		}
X	}
X
X	take = damage;
X	save = 0;
X
X	// check for godmode
X	if ( (targ->flags & FL_GODMODE) && !(dflags & DAMAGE_NO_PROTECTION) )
X	{
X		take = 0;
X		save = damage;
X		SpawnDamage (te_sparks, point, normal, save);
X	}
X
X	// check for invincibility
X	if ((client && client->invincible_framenum > level.framenum ) && !(dflags & DAMAGE_NO_PROTECTION))
X	{
X		if (targ->pain_debounce_time < level.time)
X		{
X			gi.sound(targ, CHAN_ITEM, gi.soundindex("items/protect4.wav"), 1, ATTN_NORM, 0);
X			targ->pain_debounce_time = level.time + 2;
X		}
X		take = 0;
X		save = damage;
X	}
X	// ROGUE
X	// check for monster invincibility	
X	if (((targ->svflags & SVF_MONSTER) && targ->monsterinfo.invincible_framenum > level.framenum ) && !(dflags & DAMAGE_NO_PROTECTION))
X	{
X		if (targ->pain_debounce_time < level.time)
X		{
X			gi.sound(targ, CHAN_ITEM, gi.soundindex("items/protect4.wav"), 1, ATTN_NORM, 0);
X			targ->pain_debounce_time = level.time + 2;
X		}
X		take = 0;
X		save = damage;
X	}
X	// ROGUE
X
X	psave = CheckPowerArmor (targ, point, normal, take, dflags);
X	take -= psave;
X
X	asave = CheckArmor (targ, point, normal, take, te_sparks, dflags);
X	take -= asave;
X
X	//treat cheat/powerup savings the same as armor
X	asave += save;
X
X	// team damage avoidance
X	if (!(dflags & DAMAGE_NO_PROTECTION) && CheckTeamDamage (targ, attacker))
X		return;
X
// ROGUE - this option will do damage both to the armor and person. originally for DPU rounds
X	if (dflags & DAMAGE_DESTROY_ARMOR)
X	{
X		if(!(targ->flags & FL_GODMODE) && !(dflags & DAMAGE_NO_PROTECTION) &&
X		   !(client && client->invincible_framenum > level.framenum))
X		{
X			take = damage;
X		}
X	}
// ROGUE
X
// do the damage
X	if (take)
X	{
//PGM		need more blood for chainfist.
X		if(targ->flags & FL_MECHANICAL)
X		{
X			SpawnDamage ( TE_ELECTRIC_SPARKS, point, normal, take);
X		}
X		else if ((targ->svflags & SVF_MONSTER) || (client))
X		{
X			if(mod == MOD_CHAINFIST)
X				SpawnDamage (TE_MOREBLOOD, point, normal, 255);
X			else
X				SpawnDamage (TE_BLOOD, point, normal, take);
X		}
X		else
X			SpawnDamage (te_sparks, point, normal, take);
//PGM
X
X		targ->health = targ->health - take;
X			
//PGM - spheres need to know who to shoot at
X		if(client && client->owned_sphere)
X		{
X			sphere_notified = true;
X			if(client->owned_sphere->pain)
X				client->owned_sphere->pain (client->owned_sphere, attacker, 0, 0);
X		}
//PGM
X
X		if (targ->health <= 0)
X		{
X			if ((targ->svflags & SVF_MONSTER) || (client))
X				targ->flags |= FL_NO_KNOCKBACK;
X			Killed (targ, inflictor, attacker, take, point);
X			return;
X		}
X	}
X
//PGM - spheres need to know who to shoot at
X	if (!sphere_notified)
X	{
X		if(client && client->owned_sphere)
X		{
X			sphere_notified = true;
X			if(client->owned_sphere->pain)
X				client->owned_sphere->pain (client->owned_sphere, attacker, 0, 0);
X		}
X	}
//PGM
X
X	if (targ->svflags & SVF_MONSTER)
X	{
X		M_ReactToDamage (targ, attacker, inflictor);
X		// PMM - fixme - if anyone else but the medic ever uses AI_MEDIC, check for it here instead
X		// of in the medic's pain function
X		if (!(targ->monsterinfo.aiflags & AI_DUCKED) && (take))
X		{
X			targ->pain (targ, attacker, knockback, take);
X			// nightmare mode monsters don't go into pain frames often
X			if (skill->value == 3)
X				targ->pain_debounce_time = level.time + 5;
X		}
X	}
X	else if (client)
X	{
X		if (!(targ->flags & FL_GODMODE) && (take))
X			targ->pain (targ, attacker, knockback, take);
X	}
X	else if (take)
X	{
X		if (targ->pain)
X			targ->pain (targ, attacker, knockback, take);
X	}
X
X	// add to the damage inflicted on a player this frame
X	// the total will be turned into screen blends and view angle kicks
X	// at the end of the frame
X	if (client)
X	{
X		client->damage_parmor += psave;
X		client->damage_armor += asave;
X		client->damage_blood += take;
X		client->damage_knockback += knockback;
X		VectorCopy (point, client->damage_from);
X	}
}
X
X
/*
============
T_RadiusDamage
============
*/
void T_RadiusDamage (edict_t *inflictor, edict_t *attacker, float damage, edict_t *ignore, float radius, int mod)
{
X	float	points;
X	edict_t	*ent = NULL;
X	vec3_t	v;
X	vec3_t	dir;
X
X	while ((ent = findradius(ent, inflictor->s.origin, radius)) != NULL)
X	{
X		if (ent == ignore)
X			continue;
X		if (!ent->takedamage)
X			continue;
X
X		VectorAdd (ent->mins, ent->maxs, v);
X		VectorMA (ent->s.origin, 0.5, v, v);
X		VectorSubtract (inflictor->s.origin, v, v);
X		points = damage - 0.5 * VectorLength (v);
X		if (ent == attacker)
X			points = points * 0.5;
X		if (points > 0)
X		{
X			if (CanDamage (ent, inflictor))
X			{
X				VectorSubtract (ent->s.origin, inflictor->s.origin, dir);
X				T_Damage (ent, inflictor, attacker, dir, inflictor->s.origin, vec3_origin, (int)points, (int)points, DAMAGE_RADIUS, mod);
X			}
X		}
X	}
}
X
// **********************
// ROGUE
X
/*
============
T_RadiusNukeDamage
X
Like T_RadiusDamage, but ignores walls (skips CanDamage check, among others)
// up to KILLZONE radius, do 10,000 points
// after that, do damage linearly out to KILLZONE2 radius
============
*/
X
void T_RadiusNukeDamage (edict_t *inflictor, edict_t *attacker, float damage, edict_t *ignore, float radius, int mod)
{
X	float	points;
X	edict_t	*ent = NULL;
X	vec3_t	v;
X	vec3_t	dir;
X	float	len;
X	float	killzone, killzone2;
X	trace_t	tr;
X	float	dist;
X
X	killzone = radius;
X	killzone2 = radius*2.0;
X
X	while ((ent = findradius(ent, inflictor->s.origin, killzone2)) != NULL)
X	{
// ignore nobody
X		if (ent == ignore)
X			continue;
X		if (!ent->takedamage)
X			continue;
X		if (!ent->inuse)
X			continue;
X		if (!(ent->client || (ent->svflags & SVF_MONSTER) || (ent->svflags & SVF_DAMAGEABLE)))
X			continue;
X
X		VectorAdd (ent->mins, ent->maxs, v);
X		VectorMA (ent->s.origin, 0.5, v, v);
X		VectorSubtract (inflictor->s.origin, v, v);
X		len = VectorLength(v);
X		if (len <= killzone)
X		{
X			if (ent->client)
X				ent->flags |= FL_NOGIB;
X			points = 10000;
X		}
X		else if (len <= killzone2)
X			points = (damage/killzone)*(killzone2 - len);
X		else
X			points = 0;
//		points = damage - 0.005 * len*len;
//		if (ent == attacker)
//			points = points * 0.5;
//		if ((g_showlogic) && (g_showlogic->value))
//		{
//			if (!(strcmp(ent->classname, "player")))
//				gi.dprintf ("dist = %2.2f doing %6.0f damage to %s\n", len, points, inflictor->teammaster->client->pers.netname);
//			else
//				gi.dprintf ("dist = %2.2f doing %6.0f damage to %s\n", len, points, ent->classname);
//		}
X		if (points > 0)
X		{
//			if (CanDamage (ent, inflictor))
//			{
X				if (ent->client)
X					ent->client->nuke_framenum = level.framenum + 20;
X				VectorSubtract (ent->s.origin, inflictor->s.origin, dir);
X				T_Damage (ent, inflictor, attacker, dir, inflictor->s.origin, vec3_origin, (int)points, (int)points, DAMAGE_RADIUS, mod);
//			}
X		}
X	}
X	ent = g_edicts+1; // skip the worldspawn
X	// cycle through players
X	while (ent)
X	{
X		if ((ent->client) && (ent->client->nuke_framenum != level.framenum+20) && (ent->inuse))
X		{
X			tr = gi.trace (inflictor->s.origin, NULL, NULL, ent->s.origin, inflictor, MASK_SOLID);
X			if (tr.fraction == 1.0)
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("Undamaged player in LOS with nuke, flashing!\n");
X				ent->client->nuke_framenum = level.framenum + 20;
X			}
X			else
X			{
X				dist = realrange (ent, inflictor);
X				if (dist < 2048)
X					ent->client->nuke_framenum = max(ent->client->nuke_framenum,level.framenum + 15);
X				else
X					ent->client->nuke_framenum = max(ent->client->nuke_framenum,level.framenum + 10);
X			}
X			ent++;
X		}
X		else
X			ent = NULL;
X	}
}
X
/*
============
T_RadiusClassDamage
X
Like T_RadiusDamage, but ignores anything with classname=ignoreClass
============
*/
void T_RadiusClassDamage (edict_t *inflictor, edict_t *attacker, float damage, char *ignoreClass, float radius, int mod)
{
X	float	points;
X	edict_t	*ent = NULL;
X	vec3_t	v;
X	vec3_t	dir;
X
X	while ((ent = findradius(ent, inflictor->s.origin, radius)) != NULL)
X	{
X		if (ent->classname && !strcmp(ent->classname, ignoreClass))
X			continue;
X		if (!ent->takedamage)
X			continue;
X
X		VectorAdd (ent->mins, ent->maxs, v);
X		VectorMA (ent->s.origin, 0.5, v, v);
X		VectorSubtract (inflictor->s.origin, v, v);
X		points = damage - 0.5 * VectorLength (v);
X		if (ent == attacker)
X			points = points * 0.5;
X		if (points > 0)
X		{
X			if (CanDamage (ent, inflictor))
X			{
X				VectorSubtract (ent->s.origin, inflictor->s.origin, dir);
X				T_Damage (ent, inflictor, attacker, dir, inflictor->s.origin, vec3_origin, (int)points, (int)points, DAMAGE_RADIUS, mod);
X			}
X		}
X	}
}
X
// ROGUE
// ********************
SHAR_EOF
  $shar_touch -am 1130175398 'g_combat.c' &&
  chmod 0664 'g_combat.c' ||
  $echo 'restore of' 'g_combat.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_combat.c:' 'MD5 check failed'
27ad12b4169430150fe102c3543c7910  g_combat.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_combat.c'`"
    test 25345 -eq "$shar_count" ||
    $echo 'g_combat.c:' 'original size' '25345,' 'current size' "$shar_count!"
  fi
fi
# ============= g_func.c ==============
if test -f 'g_func.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_func.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_func.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_func.c' &&
#include "g_local.h"
X
/*
=========================================================
X
X  PLATS
X
X  movement options:
X
X  linear
X  smooth start, hard stop
X  smooth start, smooth stop
X
X  start
X  end
X  acceleration
X  speed
X  deceleration
X  begin sound
X  end sound
X  target fired when reaching end
X  wait at end
X
X  object characteristics that use move segments
X  ---------------------------------------------
X  movetype_push, or movetype_stop
X  action when touched
X  action when blocked
X  action when used
X	disabled?
X  auto trigger spawning
X
X
=========================================================
*/
X
#define PLAT_LOW_TRIGGER	1
X
//====
//PGM
#define PLAT2_TOGGLE			2
#define PLAT2_TOP				4
#define PLAT2_TRIGGER_TOP		8
#define PLAT2_TRIGGER_BOTTOM	16
#define PLAT2_BOX_LIFT			32
X
void plat2_spawn_danger_area (edict_t *ent);
void plat2_kill_danger_area (edict_t *ent);
X
//PGM
//====
X
#define	STATE_TOP			0
#define	STATE_BOTTOM		1
#define STATE_UP			2
#define STATE_DOWN			3
X
#define DOOR_START_OPEN		1
#define DOOR_REVERSE		2
#define DOOR_CRUSHER		4
#define DOOR_NOMONSTER		8
#define DOOR_TOGGLE			32
#define DOOR_X_AXIS			64
#define DOOR_Y_AXIS			128
// !easy					256
// !med						512
// !hard					1024
// !dm						2048
// !coop					4096
#define DOOR_INACTIVE		8192
X
//
// Support routines for movement (changes in origin using velocity)
//
X
void Move_Done (edict_t *ent)
{
X	VectorClear (ent->velocity);
X	ent->moveinfo.endfunc (ent);
}
X
void Move_Final (edict_t *ent)
{
X	if (ent->moveinfo.remaining_distance == 0)
X	{
X		Move_Done (ent);
X		return;
X	}
X
X	VectorScale (ent->moveinfo.dir, ent->moveinfo.remaining_distance / FRAMETIME, ent->velocity);
X
X	ent->think = Move_Done;
X	ent->nextthink = level.time + FRAMETIME;
}
X
void Move_Begin (edict_t *ent)
{
X	float	frames;
X
X	if ((ent->moveinfo.speed * FRAMETIME) >= ent->moveinfo.remaining_distance)
X	{
X		Move_Final (ent);
X		return;
X	}
X	VectorScale (ent->moveinfo.dir, ent->moveinfo.speed, ent->velocity);
X	frames = floor((ent->moveinfo.remaining_distance / ent->moveinfo.speed) / FRAMETIME);
X	ent->moveinfo.remaining_distance -= frames * ent->moveinfo.speed * FRAMETIME;
X	ent->nextthink = level.time + (frames * FRAMETIME);
X	ent->think = Move_Final;
}
X
void Think_AccelMove (edict_t *ent);
X
void Move_Calc (edict_t *ent, vec3_t dest, void(*func)(edict_t*))
{
X	VectorClear (ent->velocity);
X	VectorSubtract (dest, ent->s.origin, ent->moveinfo.dir);
X	ent->moveinfo.remaining_distance = VectorNormalize (ent->moveinfo.dir);
X	ent->moveinfo.endfunc = func;
X
X	if (ent->moveinfo.speed == ent->moveinfo.accel && ent->moveinfo.speed == ent->moveinfo.decel)
X	{
X		if (level.current_entity == ((ent->flags & FL_TEAMSLAVE) ? ent->teammaster : ent))
X		{
X			Move_Begin (ent);
X		}
X		else
X		{
X			ent->nextthink = level.time + FRAMETIME;
X			ent->think = Move_Begin;
X		}
X	}
X	else
X	{
X		// accelerative
X		ent->moveinfo.current_speed = 0;
X		ent->think = Think_AccelMove;
X		ent->nextthink = level.time + FRAMETIME;
X	}
}
X
X
//
// Support routines for angular movement (changes in angle using avelocity)
//
X
void AngleMove_Done (edict_t *ent)
{
X	VectorClear (ent->avelocity);
X	ent->moveinfo.endfunc (ent);
}
X
void AngleMove_Final (edict_t *ent)
{
X	vec3_t	move;
X
X	if (ent->moveinfo.state == STATE_UP)
X		VectorSubtract (ent->moveinfo.end_angles, ent->s.angles, move);
X	else
X		VectorSubtract (ent->moveinfo.start_angles, ent->s.angles, move);
X
X	if (VectorCompare (move, vec3_origin))
X	{
X		AngleMove_Done (ent);
X		return;
X	}
X
X	VectorScale (move, 1.0/FRAMETIME, ent->avelocity);
X
X	ent->think = AngleMove_Done;
X	ent->nextthink = level.time + FRAMETIME;
}
X
void AngleMove_Begin (edict_t *ent)
{
X	vec3_t	destdelta;
X	float	len;
X	float	traveltime;
X	float	frames;
X
//PGM		accelerate as needed
X	if(ent->moveinfo.speed < ent->speed)
X	{
X		ent->moveinfo.speed += ent->accel;
X		if(ent->moveinfo.speed > ent->speed)
X			ent->moveinfo.speed = ent->speed;
X	}
//PGM
X
X	// set destdelta to the vector needed to move
X	if (ent->moveinfo.state == STATE_UP)
X		VectorSubtract (ent->moveinfo.end_angles, ent->s.angles, destdelta);
X	else
X		VectorSubtract (ent->moveinfo.start_angles, ent->s.angles, destdelta);
X	
X	// calculate length of vector
X	len = VectorLength (destdelta);
X	
X	// divide by speed to get time to reach dest
X	traveltime = len / ent->moveinfo.speed;
X
X	if (traveltime < FRAMETIME)
X	{
X		AngleMove_Final (ent);
X		return;
X	}
X
X	frames = floor(traveltime / FRAMETIME);
X
X	// scale the destdelta vector by the time spent traveling to get velocity
X	VectorScale (destdelta, 1.0 / traveltime, ent->avelocity);
X
//PGM
X	// if we're done accelerating, act as a normal rotation
X	if(ent->moveinfo.speed >= ent->speed)
X	{
X		// set nextthink to trigger a think when dest is reached
X		ent->nextthink = level.time + frames * FRAMETIME;
X		ent->think = AngleMove_Final;
X	}
X	else
X	{
X		ent->nextthink = level.time + FRAMETIME;
X		ent->think = AngleMove_Begin;
X	}
//PGM
}
X
void AngleMove_Calc (edict_t *ent, void(*func)(edict_t*))
{
X	VectorClear (ent->avelocity);
X	ent->moveinfo.endfunc = func;
X
//PGM
X	// if we're supposed to accelerate, this will tell anglemove_begin to do so
X	if(ent->accel != ent->speed)
X		ent->moveinfo.speed = 0;
//PGM
X
X	if (level.current_entity == ((ent->flags & FL_TEAMSLAVE) ? ent->teammaster : ent))
X	{
X		AngleMove_Begin (ent);
X	}
X	else
X	{
X		ent->nextthink = level.time + FRAMETIME;
X		ent->think = AngleMove_Begin;
X	}
}
X
X
/*
==============
Think_AccelMove
X
The team has completed a frame of movement, so
change the speed for the next frame
==============
*/
#define AccelerationDistance(target, rate)	(target * ((target / rate) + 1) / 2)
X
void plat_CalcAcceleratedMove(moveinfo_t *moveinfo)
{
X	float	accel_dist;
X	float	decel_dist;
X
X	moveinfo->move_speed = moveinfo->speed;
X
X	if (moveinfo->remaining_distance < moveinfo->accel)
X	{
X		moveinfo->current_speed = moveinfo->remaining_distance;
X		return;
X	}
X
X	accel_dist = AccelerationDistance (moveinfo->speed, moveinfo->accel);
X	decel_dist = AccelerationDistance (moveinfo->speed, moveinfo->decel);
X
X	if ((moveinfo->remaining_distance - accel_dist - decel_dist) < 0)
X	{
X		float	f;
X
X		f = (moveinfo->accel + moveinfo->decel) / (moveinfo->accel * moveinfo->decel);
X		moveinfo->move_speed = (-2 + sqrt(4 - 4 * f * (-2 * moveinfo->remaining_distance))) / (2 * f);
X		decel_dist = AccelerationDistance (moveinfo->move_speed, moveinfo->decel);
X	}
X
X	moveinfo->decel_distance = decel_dist;
};
X
void plat_Accelerate (moveinfo_t *moveinfo)
{
X	// are we decelerating?
X	if (moveinfo->remaining_distance <= moveinfo->decel_distance)
X	{
X		if (moveinfo->remaining_distance < moveinfo->decel_distance)
X		{
X			if (moveinfo->next_speed)
X			{
X				moveinfo->current_speed = moveinfo->next_speed;
X				moveinfo->next_speed = 0;
X				return;
X			}
X			if (moveinfo->current_speed > moveinfo->decel)
X				moveinfo->current_speed -= moveinfo->decel;
X		}
X		return;
X	}
X
X	// are we at full speed and need to start decelerating during this move?
X	if (moveinfo->current_speed == moveinfo->move_speed)
X		if ((moveinfo->remaining_distance - moveinfo->current_speed) < moveinfo->decel_distance)
X		{
X			float	p1_distance;
X			float	p2_distance;
X			float	distance;
X
X			p1_distance = moveinfo->remaining_distance - moveinfo->decel_distance;
X			p2_distance = moveinfo->move_speed * (1.0 - (p1_distance / moveinfo->move_speed));
X			distance = p1_distance + p2_distance;
X			moveinfo->current_speed = moveinfo->move_speed;
X			moveinfo->next_speed = moveinfo->move_speed - moveinfo->decel * (p2_distance / distance);
X			return;
X		}
X
X	// are we accelerating?
X	if (moveinfo->current_speed < moveinfo->speed)
X	{
X		float	old_speed;
X		float	p1_distance;
X		float	p1_speed;
X		float	p2_distance;
X		float	distance;
X
X		old_speed = moveinfo->current_speed;
X
X		// figure simple acceleration up to move_speed
X		moveinfo->current_speed += moveinfo->accel;
X		if (moveinfo->current_speed > moveinfo->speed)
X			moveinfo->current_speed = moveinfo->speed;
X
X		// are we accelerating throughout this entire move?
X		if ((moveinfo->remaining_distance - moveinfo->current_speed) >= moveinfo->decel_distance)
X			return;
X
X		// during this move we will accelrate from current_speed to move_speed
X		// and cross over the decel_distance; figure the average speed for the
X		// entire move
X		p1_distance = moveinfo->remaining_distance - moveinfo->decel_distance;
X		p1_speed = (old_speed + moveinfo->move_speed) / 2.0;
X		p2_distance = moveinfo->move_speed * (1.0 - (p1_distance / p1_speed));
X		distance = p1_distance + p2_distance;
X		moveinfo->current_speed = (p1_speed * (p1_distance / distance)) + (moveinfo->move_speed * (p2_distance / distance));
X		moveinfo->next_speed = moveinfo->move_speed - moveinfo->decel * (p2_distance / distance);
X		return;
X	}
X
X	// we are at constant velocity (move_speed)
X	return;
};
X
void Think_AccelMove (edict_t *ent)
{
X	ent->moveinfo.remaining_distance -= ent->moveinfo.current_speed;
X
X	// PGM 04/21/98  - this should fix sthoms' sinking drop pod. Hopefully it wont break stuff.
//	if (ent->moveinfo.current_speed == 0)		// starting or blocked
X		plat_CalcAcceleratedMove(&ent->moveinfo);
X
X	plat_Accelerate (&ent->moveinfo);
X
X	// will the entire move complete on next frame?
X	if (ent->moveinfo.remaining_distance <= ent->moveinfo.current_speed)
X	{
X		Move_Final (ent);
X		return;
X	}
X
X	VectorScale (ent->moveinfo.dir, ent->moveinfo.current_speed*10, ent->velocity);
X	ent->nextthink = level.time + FRAMETIME;
X	ent->think = Think_AccelMove;
}
X
X
void plat_go_down (edict_t *ent);
X
void plat_hit_top (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_end)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_end, 1, ATTN_STATIC, 0);
X		ent->s.sound = 0;
X	}
X	ent->moveinfo.state = STATE_TOP;
X
X	ent->think = plat_go_down;
X	ent->nextthink = level.time + 3;
}
X
void plat_hit_bottom (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_end)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_end, 1, ATTN_STATIC, 0);
X		ent->s.sound = 0;
X	}
X	ent->moveinfo.state = STATE_BOTTOM;
X	
X	plat2_kill_danger_area (ent);		// PGM
}
X
void plat_go_down (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_start)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		ent->s.sound = ent->moveinfo.sound_middle;
X	}
X	ent->moveinfo.state = STATE_DOWN;
X	Move_Calc (ent, ent->moveinfo.end_origin, plat_hit_bottom);
}
X
void plat_go_up (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_start)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		ent->s.sound = ent->moveinfo.sound_middle;
X	}
X	ent->moveinfo.state = STATE_UP;
X	Move_Calc (ent, ent->moveinfo.start_origin, plat_hit_top);
X	
X	plat2_spawn_danger_area(ent);	// PGM
}
X
void plat_blocked (edict_t *self, edict_t *other)
{
X	if (!(other->svflags & SVF_MONSTER) && (!other->client) )
X	{
X		// give it a chance to go away on it's own terms (like gibs)
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 100000, 1, 0, MOD_CRUSH);
X		// if it's still there, nuke it
X		if (other && other->inuse)		// PGM
X			BecomeExplosion1 (other);
X		return;
X	}
X
//PGM
X	// gib dead things
X	if(other->health < 1)
X	{
X		T_Damage(other, self, self, vec3_origin, other->s.origin, vec3_origin, 100, 1, 0, MOD_CRUSH);
X	}
//PGM
X
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
X
X	if (self->moveinfo.state == STATE_UP)
X		plat_go_down (self);
X	else if (self->moveinfo.state == STATE_DOWN)
X		plat_go_up (self);
}
X
X
void Use_Plat (edict_t *ent, edict_t *other, edict_t *activator)
{ 
//======
//ROGUE
X	// if a monster is using us, then allow the activity when stopped.
X	if (other->svflags & SVF_MONSTER)
X	{
X		if (ent->moveinfo.state == STATE_TOP)
X			plat_go_down (ent);
X		else if (ent->moveinfo.state == STATE_BOTTOM)
X			plat_go_up (ent);
X
X		return;
X	}
//ROGUE
//======
X
X	if (ent->think)
X		return;		// already down
X	plat_go_down (ent);
}
X
X
void Touch_Plat_Center (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (!other->client)
X		return;
X		
X	if (other->health <= 0)
X		return;
X
X	ent = ent->enemy;	// now point at the plat, not the trigger
X	if (ent->moveinfo.state == STATE_BOTTOM)
X		plat_go_up (ent);
X	else if (ent->moveinfo.state == STATE_TOP)
X		ent->nextthink = level.time + 1;	// the player is still on the plat, so delay going down
}
X
// PGM - plat2's change the trigger field
//void plat_spawn_inside_trigger (edict_t *ent)
edict_t *plat_spawn_inside_trigger (edict_t *ent)
{
X	edict_t	*trigger;
X	vec3_t	tmin, tmax;
X
//
// middle trigger
//	
X	trigger = G_Spawn();
X	trigger->touch = Touch_Plat_Center;
X	trigger->movetype = MOVETYPE_NONE;
X	trigger->solid = SOLID_TRIGGER;
X	trigger->enemy = ent;
X	
X	tmin[0] = ent->mins[0] + 25;
X	tmin[1] = ent->mins[1] + 25;
X	tmin[2] = ent->mins[2];
X
X	tmax[0] = ent->maxs[0] - 25;
X	tmax[1] = ent->maxs[1] - 25;
X	tmax[2] = ent->maxs[2] + 8;
X
X	tmin[2] = tmax[2] - (ent->pos1[2] - ent->pos2[2] + st.lip);
X
X	if (ent->spawnflags & PLAT_LOW_TRIGGER)
X		tmax[2] = tmin[2] + 8;
X	
X	if (tmax[0] - tmin[0] <= 0)
X	{
X		tmin[0] = (ent->mins[0] + ent->maxs[0]) *0.5;
X		tmax[0] = tmin[0] + 1;
X	}
X	if (tmax[1] - tmin[1] <= 0)
X	{
X		tmin[1] = (ent->mins[1] + ent->maxs[1]) *0.5;
X		tmax[1] = tmin[1] + 1;
X	}
X	
X	VectorCopy (tmin, trigger->mins);
X	VectorCopy (tmax, trigger->maxs);
X
X	gi.linkentity (trigger);
X
X	return trigger;			// PGM 11/17/97
}
X
X
/*QUAKED func_plat (0 .5 .8) ? PLAT_LOW_TRIGGER
speed	default 150
X
Plats are always drawn in the extended position, so they will light correctly.
X
If the plat is the target of another trigger or button, it will start out disabled in the extended position until it is trigger, when it will lower and become a normal plat.
X
"speed"	overrides default 200.
"accel" overrides default 500
"lip"	overrides default 8 pixel lip
X
If the "height" key is set, that will determine the amount the plat moves, instead of being implicitly determoveinfoned by the model's height.
X
Set "sounds" to one of the following:
1) base fast
2) chain slow
*/
void SP_func_plat (edict_t *ent)
{
X	VectorClear (ent->s.angles);
X	ent->solid = SOLID_BSP;
X	ent->movetype = MOVETYPE_PUSH;
X
X	gi.setmodel (ent, ent->model);
X
X	ent->blocked = plat_blocked;
X
X	if (!ent->speed)
X		ent->speed = 20;
X	else
X		ent->speed *= 0.1;
X
X	if (!ent->accel)
X		ent->accel = 5;
X	else
X		ent->accel *= 0.1;
X
X	if (!ent->decel)
X		ent->decel = 5;
X	else
X		ent->decel *= 0.1;
X
X	if (!ent->dmg)
X		ent->dmg = 2;
X
X	if (!st.lip)
X		st.lip = 8;
X
X	// pos1 is the top position, pos2 is the bottom
X	VectorCopy (ent->s.origin, ent->pos1);
X	VectorCopy (ent->s.origin, ent->pos2);
X	if (st.height)
X		ent->pos2[2] -= st.height;
X	else
X		ent->pos2[2] -= (ent->maxs[2] - ent->mins[2]) - st.lip;
X
X	ent->use = Use_Plat;
X
X	plat_spawn_inside_trigger (ent);	// the "start moving" trigger	
X
X	if (ent->targetname)
X	{
X		ent->moveinfo.state = STATE_UP;
X	}
X	else
X	{
X		VectorCopy (ent->pos2, ent->s.origin);
X		gi.linkentity (ent);
X		ent->moveinfo.state = STATE_BOTTOM;
X	}
X
X	ent->moveinfo.speed = ent->speed;
X	ent->moveinfo.accel = ent->accel;
X	ent->moveinfo.decel = ent->decel;
X	ent->moveinfo.wait = ent->wait;
X	VectorCopy (ent->pos1, ent->moveinfo.start_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.start_angles);
X	VectorCopy (ent->pos2, ent->moveinfo.end_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.end_angles);
X
X	ent->moveinfo.sound_start = gi.soundindex ("plats/pt1_strt.wav");
X	ent->moveinfo.sound_middle = gi.soundindex ("plats/pt1_mid.wav");
X	ent->moveinfo.sound_end = gi.soundindex ("plats/pt1_end.wav");
}
X
// ==========================================
// PLAT 2
// ==========================================
#define PLAT2_CALLED		1
#define PLAT2_MOVING		2
#define PLAT2_WAITING		4
X
void plat2_go_down (edict_t *ent);
void plat2_go_up (edict_t *ent);
X
void plat2_spawn_danger_area (edict_t *ent)
{
X	vec3_t	mins, maxs;
X
X	VectorCopy(ent->mins, mins);
X	VectorCopy(ent->maxs, maxs);
X	maxs[2] = ent->mins[2] + 64;
X
X	SpawnBadArea(mins, maxs, 0, ent);
}
X
void plat2_kill_danger_area (edict_t *ent)
{
X	edict_t *t;
X
X	t = NULL;
X	while ((t = G_Find (t, FOFS(classname), "bad_area")))
X	{
X		if(t->owner == ent)
X			G_FreeEdict(t);
X	}
}
X
void plat2_hit_top (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_end)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_end, 1, ATTN_STATIC, 0);
X		ent->s.sound = 0;
X	}
X	ent->moveinfo.state = STATE_TOP;
X
X	if(ent->plat2flags & PLAT2_CALLED)
X	{
X		ent->plat2flags = PLAT2_WAITING;
X		if(!(ent->spawnflags & PLAT2_TOGGLE))
X		{
X			ent->think = plat2_go_down;
X			ent->nextthink = level.time + 5.0;
X		}
X		if(deathmatch->value)
X			ent->last_move_time = level.time - 1.0;
X		else
X			ent->last_move_time = level.time - 2.0;
X	}
X	else if(!(ent->spawnflags & PLAT2_TOP) && !(ent->spawnflags & PLAT2_TOGGLE))
X	{
X		ent->plat2flags = 0;
X		ent->think = plat2_go_down;
X		ent->nextthink = level.time + 2.0;
X		ent->last_move_time = level.time;
X	}
X	else
X	{
X		ent->plat2flags = 0;
X		ent->last_move_time = level.time;
X	}
X
X	G_UseTargets (ent, ent);
}
X
void plat2_hit_bottom (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_end)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_end, 1, ATTN_STATIC, 0);
X		ent->s.sound = 0;
X	}
X	ent->moveinfo.state = STATE_BOTTOM;
X	
X	if(ent->plat2flags & PLAT2_CALLED)
X	{
X		ent->plat2flags = PLAT2_WAITING;
X		if(!(ent->spawnflags & PLAT2_TOGGLE))
X		{
X			ent->think = plat2_go_up;
X			ent->nextthink = level.time + 5.0;
X		}
X		if(deathmatch->value)
X			ent->last_move_time = level.time - 1.0;
X		else
X			ent->last_move_time = level.time - 2.0;
X	}
X	else if ((ent->spawnflags & PLAT2_TOP) && !(ent->spawnflags & PLAT2_TOGGLE))
X	{
X		ent->plat2flags = 0;
X		ent->think = plat2_go_up;
X		ent->nextthink = level.time + 2.0;
X		ent->last_move_time = level.time;
X	}
X	else
X	{
X		ent->plat2flags = 0;
X		ent->last_move_time = level.time;
X	}
X
X	plat2_kill_danger_area (ent);
X	G_UseTargets (ent, ent);
}
X
void plat2_go_down (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_start)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		ent->s.sound = ent->moveinfo.sound_middle;
X	}
X	ent->moveinfo.state = STATE_DOWN;
X	ent->plat2flags |= PLAT2_MOVING;
X
X	Move_Calc (ent, ent->moveinfo.end_origin, plat2_hit_bottom);
}
X
void plat2_go_up (edict_t *ent)
{
X	if (!(ent->flags & FL_TEAMSLAVE))
X	{
X		if (ent->moveinfo.sound_start)
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, ent->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		ent->s.sound = ent->moveinfo.sound_middle;
X	}
X	ent->moveinfo.state = STATE_UP;
X	ent->plat2flags |= PLAT2_MOVING;
X
X	plat2_spawn_danger_area(ent);
X
X	Move_Calc (ent, ent->moveinfo.start_origin, plat2_hit_top);
}
X
void plat2_operate (edict_t *ent, edict_t *other)
{
X	int		otherState;
X	float	pauseTime;
X	float	platCenter;
X	edict_t *trigger;
X
X	trigger = ent;
X	ent = ent->enemy;	// now point at the plat, not the trigger
X
X	if (ent->plat2flags & PLAT2_MOVING)
X		return;
X
X	if ((ent->last_move_time + 2) > level.time)
X		return;
X
X	platCenter = (trigger->absmin[2] + trigger->absmax[2]) / 2;
X
X	if(ent->moveinfo.state == STATE_TOP)
X	{
X		otherState = STATE_TOP;
X		if(ent->spawnflags & PLAT2_BOX_LIFT)
X		{
X			if(platCenter > other->s.origin[2])
X				otherState = STATE_BOTTOM;
X		}
X		else
X		{
X			if(trigger->absmax[2] > other->s.origin[2])
X				otherState = STATE_BOTTOM;
X		}
X	}
X	else
X	{
X		otherState = STATE_BOTTOM;
X		if(other->s.origin[2] > platCenter)
X			otherState = STATE_TOP;
X	}
X
X	ent->plat2flags = PLAT2_MOVING;
X
X	if(deathmatch->value)
X		pauseTime = 0.3;
X	else
X		pauseTime = 0.5;
X
X	if(ent->moveinfo.state != otherState)
X	{
X		ent->plat2flags |= PLAT2_CALLED;
X		pauseTime = 0.1;
X	}
X
X	ent->last_move_time = level.time;
X	
X	if(ent->moveinfo.state == STATE_BOTTOM)
X	{
X		ent->think = plat2_go_up;
X		ent->nextthink = level.time + pauseTime;
X	}
X	else
X	{
X		ent->think = plat2_go_down;
X		ent->nextthink = level.time + pauseTime;
X	}
}
X
void Touch_Plat_Center2 (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	// this requires monsters to actively trigger plats, not just step on them.
X
X	//FIXME - commented out for E3
X	//if (!other->client)
X	//	return;
X		
X	if (other->health <= 0)
X		return;
X
X	// PMM - don't let non-monsters activate plat2s
X	if ((!(other->svflags & SVF_MONSTER)) && (!other->client))
X		return;
X	
X	plat2_operate(ent, other);
}
X
void plat2_blocked (edict_t *self, edict_t *other)
{
X	if (!(other->svflags & SVF_MONSTER) && (!other->client))
X	{
X		// give it a chance to go away on it's own terms (like gibs)
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 100000, 1, 0, MOD_CRUSH);
X		// if it's still there, nuke it
X		if(other && other->inuse)
X			BecomeExplosion1 (other);
X		return;
X	}
X
X	// gib dead things
X	if(other->health < 1)
X	{
X		T_Damage(other, self, self, vec3_origin, other->s.origin, vec3_origin, 100, 1, 0, MOD_CRUSH);
X	}
X
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
X
X	if (self->moveinfo.state == STATE_UP)
X		plat2_go_down (self);
X	else if (self->moveinfo.state == STATE_DOWN)
X		plat2_go_up (self);
}
X
void Use_Plat2 (edict_t *ent, edict_t *other, edict_t *activator)
{ 
X	edict_t		*trigger;
X	int			i;
X
X	if(ent->moveinfo.state > STATE_BOTTOM)
X		return;
X	if((ent->last_move_time + 2) > level.time)
X		return;
X
X	for (i = 1, trigger = g_edicts + 1; i < globals.num_edicts; i++, trigger++)
X	{
X		if (!trigger->inuse)
X			continue;
X		if (trigger->touch == Touch_Plat_Center2)
X		{
X			if (trigger->enemy == ent)
X			{
//				Touch_Plat_Center2 (trigger, activator, NULL, NULL);
X				plat2_operate (trigger, activator);
X				return;
X			}
X		} 
X	}
}
X
void plat2_activate (edict_t *ent, edict_t *other, edict_t *activator)
{
X	edict_t *trigger;
X
//	if(ent->targetname)
//		ent->targetname[0] = 0;
X
X	ent->use = Use_Plat2;
X
X	trigger = plat_spawn_inside_trigger (ent);	// the "start moving" trigger	
X
X	trigger->maxs[0]+=10;
X	trigger->maxs[1]+=10;
X	trigger->mins[0]-=10;
X	trigger->mins[1]-=10;
X
X	gi.linkentity (trigger);
X	
X	trigger->touch = Touch_Plat_Center2;		// Override trigger touch function
X
X	plat2_go_down(ent);
}
X
/*QUAKED func_plat2 (0 .5 .8) ? PLAT_LOW_TRIGGER PLAT2_TOGGLE PLAT2_TOP PLAT2_TRIGGER_TOP PLAT2_TRIGGER_BOTTOM BOX_LIFT
speed	default 150
X
PLAT_LOW_TRIGGER - creates a short trigger field at the bottom
PLAT2_TOGGLE - plat will not return to default position.
PLAT2_TOP - plat's default position will the the top.
PLAT2_TRIGGER_TOP - plat will trigger it's targets each time it hits top
PLAT2_TRIGGER_BOTTOM - plat will trigger it's targets each time it hits bottom
BOX_LIFT - this indicates that the lift is a box, rather than just a platform
X
Plats are always drawn in the extended position, so they will light correctly.
X
If the plat is the target of another trigger or button, it will start out disabled in the extended position until it is trigger, when it will lower and become a normal plat.
X
"speed"	overrides default 200.
"accel" overrides default 500
"lip"	no default
X
If the "height" key is set, that will determine the amount the plat moves, instead of being implicitly determoveinfoned by the model's height.
X
*/
void SP_func_plat2 (edict_t *ent)
{
X	edict_t *trigger;
X
X	VectorClear (ent->s.angles);
X	ent->solid = SOLID_BSP;
X	ent->movetype = MOVETYPE_PUSH;
X
X	gi.setmodel (ent, ent->model);
X
X	ent->blocked = plat2_blocked;
X
X	if (!ent->speed)
X		ent->speed = 20;
X	else
X		ent->speed *= 0.1;
X
X	if (!ent->accel)
X		ent->accel = 5;
X	else
X		ent->accel *= 0.1;
X
X	if (!ent->decel)
X		ent->decel = 5;
X	else
X		ent->decel *= 0.1;
X
X	if (deathmatch->value)
X	{
X		ent->speed *= 2;
X		ent->accel *= 2;
X		ent->decel *= 2;
X	}
X
X
X	//PMM Added to kill things it's being blocked by 
X	if (!ent->dmg)
X		ent->dmg = 2;
X
//	if (!st.lip)
//		st.lip = 8;
X
X	// pos1 is the top position, pos2 is the bottom
X	VectorCopy (ent->s.origin, ent->pos1);
X	VectorCopy (ent->s.origin, ent->pos2);
X
X	if (st.height)
X		ent->pos2[2] -= (st.height - st.lip);
X	else
X		ent->pos2[2] -= (ent->maxs[2] - ent->mins[2]) - st.lip;
X
X	ent->moveinfo.state = STATE_TOP;
X
X	if(ent->targetname)
X	{
X		ent->use = plat2_activate;
X	}
X	else
X	{
X		ent->use = Use_Plat2;
X
X		trigger = plat_spawn_inside_trigger (ent);	// the "start moving" trigger	
X
X		// PGM - debugging??
X		trigger->maxs[0]+=10;
X		trigger->maxs[1]+=10;
X		trigger->mins[0]-=10;
X		trigger->mins[1]-=10;
X
X		gi.linkentity (trigger);
X
X		trigger->touch = Touch_Plat_Center2;		// Override trigger touch function
X
X		if(!(ent->spawnflags & PLAT2_TOP))
X		{
X			VectorCopy (ent->pos2, ent->s.origin);
X			ent->moveinfo.state = STATE_BOTTOM;
X		}	
X	}
X
X	gi.linkentity (ent);
X
X	ent->moveinfo.speed = ent->speed;
X	ent->moveinfo.accel = ent->accel;
X	ent->moveinfo.decel = ent->decel;
X	ent->moveinfo.wait = ent->wait;
X	VectorCopy (ent->pos1, ent->moveinfo.start_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.start_angles);
X	VectorCopy (ent->pos2, ent->moveinfo.end_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.end_angles);
X
X	ent->moveinfo.sound_start = gi.soundindex ("plats/pt1_strt.wav");
X	ent->moveinfo.sound_middle = gi.soundindex ("plats/pt1_mid.wav");
X	ent->moveinfo.sound_end = gi.soundindex ("plats/pt1_end.wav");
}
X
X
//====================================================================
X
/*QUAKED func_rotating (0 .5 .8) ? START_ON REVERSE X_AXIS Y_AXIS TOUCH_PAIN STOP ANIMATED ANIMATED_FAST EAST MED HARD DM COOP ACCEL
You need to have an origin brush as part of this entity.  The center of that brush will be
the point around which it is rotated. It will rotate around the Z axis by default.  You can
check either the X_AXIS or Y_AXIS box to change that.
X
func_rotating will use it's targets when it stops and starts.
X
"speed" determines how fast it moves; default value is 100.
"dmg"	damage to inflict when blocked (2 default)
"accel" if specified, is how much the rotation speed will increase per .1sec.
X
REVERSE will cause the it to rotate in the opposite direction.
STOP mean it will stop moving instead of pushing entities
ACCEL means it will accelerate to it's final speed and decelerate when shutting down.
*/
X
//============
//PGM
void rotating_accel (edict_t *self)
{
X	float	current_speed;
X
X	current_speed = VectorLength (self->avelocity);
X	if(current_speed >= (self->speed - self->accel))		// done
X	{
X		VectorScale (self->movedir, self->speed, self->avelocity);
X		G_UseTargets (self, self);
X	}
X	else
X	{
X		current_speed += self->accel;
X		VectorScale (self->movedir, current_speed, self->avelocity);
X		self->think = rotating_accel;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
void rotating_decel (edict_t *self)
{
X	float	current_speed;
X
X	current_speed = VectorLength (self->avelocity);
X	if(current_speed <= self->decel)		// done
X	{
X		VectorClear (self->avelocity);
X		G_UseTargets (self, self);
X		self->touch = NULL;
X	}
X	else
X	{
X		current_speed -= self->decel;
X		VectorScale (self->movedir, current_speed, self->avelocity);
X		self->think = rotating_decel;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
//PGM
//============
X
X
void rotating_blocked (edict_t *self, edict_t *other)
{
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
}
X
void rotating_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (self->avelocity[0] || self->avelocity[1] || self->avelocity[2])
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
}
X
void rotating_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (!VectorCompare (self->avelocity, vec3_origin))
X	{
X		self->s.sound = 0;
//PGM
X		if(self->spawnflags & 8192)	// Decelerate
X			rotating_decel (self);
X		else
X		{
X			VectorClear (self->avelocity);
X			G_UseTargets (self, self);
X			self->touch = NULL;
X		}
//PGM
X	}
X	else
X	{
X		self->s.sound = self->moveinfo.sound_middle;
//PGM
X		if(self->spawnflags & 8192)	// accelerate
X			rotating_accel (self);
X		else
X		{
X			VectorScale (self->movedir, self->speed, self->avelocity);
X			G_UseTargets (self, self);
X		}
X		if (self->spawnflags & 16)
X			self->touch = rotating_touch;
//PGM
X	}
}
X
void SP_func_rotating (edict_t *ent)
{
X	ent->solid = SOLID_BSP;
X	if (ent->spawnflags & 32)
X		ent->movetype = MOVETYPE_STOP;
X	else
X		ent->movetype = MOVETYPE_PUSH;
X
X	// set the axis of rotation
X	VectorClear(ent->movedir);
X	if (ent->spawnflags & 4)
X		ent->movedir[2] = 1.0;
X	else if (ent->spawnflags & 8)
X		ent->movedir[0] = 1.0;
X	else // Z_AXIS
X		ent->movedir[1] = 1.0;
X
X	// check for reverse rotation
X	if (ent->spawnflags & 2)
X		VectorNegate (ent->movedir, ent->movedir);
X
X	if (!ent->speed)
X		ent->speed = 100;
X	if (!ent->dmg)
X		ent->dmg = 2;
X
//	ent->moveinfo.sound_middle = "doors/hydro1.wav";
X
X	ent->use = rotating_use;
X	if (ent->dmg)
X		ent->blocked = rotating_blocked;
X
X	if (ent->spawnflags & 1)
X		ent->use (ent, NULL, NULL);
X
X	if (ent->spawnflags & 64)
X		ent->s.effects |= EF_ANIM_ALL;
X	if (ent->spawnflags & 128)
X		ent->s.effects |= EF_ANIM_ALLFAST;
X
//PGM
X	if(ent->spawnflags & 8192)	// Accelerate / Decelerate
X	{
X		if(!ent->accel)
X			ent->accel = 1;
X		else if (ent->accel > ent->speed)
X			ent->accel = ent->speed;
X
X		if(!ent->decel)
X			ent->decel = 1;
X		else if (ent->decel > ent->speed)
X			ent->decel = ent->speed;
X	}
//PGM
X
X	gi.setmodel (ent, ent->model);
X	gi.linkentity (ent);
}
X
/*
======================================================================
X
BUTTONS
X
======================================================================
*/
X
/*QUAKED func_button (0 .5 .8) ?
When a button is touched, it moves some distance in the direction of it's angle, triggers all of it's targets, waits some time, then returns to it's original position where it can be triggered again.
X
"angle"		determines the opening direction
"target"	all entities with a matching targetname will be used
"speed"		override the default 40 speed
"wait"		override the default 1 second wait (-1 = never return)
"lip"		override the default 4 pixel lip remaining at end of move
"health"	if set, the button must be killed instead of touched
"sounds"
1) silent
2) steam metal
3) wooden clunk
4) metallic click
5) in-out
*/
X
void button_done (edict_t *self)
{
X	self->moveinfo.state = STATE_BOTTOM;
X	self->s.effects &= ~EF_ANIM23;
X	self->s.effects |= EF_ANIM01;
}
X
void button_return (edict_t *self)
{
X	self->moveinfo.state = STATE_DOWN;
X
X	Move_Calc (self, self->moveinfo.start_origin, button_done);
X
X	self->s.frame = 0;
X
X	if (self->health)
X		self->takedamage = DAMAGE_YES;
}
X
void button_wait (edict_t *self)
{
X	self->moveinfo.state = STATE_TOP;
X	self->s.effects &= ~EF_ANIM01;
X	self->s.effects |= EF_ANIM23;
X
X	G_UseTargets (self, self->activator);
X	self->s.frame = 1;
X	if (self->moveinfo.wait >= 0)
X	{
X		self->nextthink = level.time + self->moveinfo.wait;
X		self->think = button_return;
X	}
}
X
void button_fire (edict_t *self)
{
X	if (self->moveinfo.state == STATE_UP || self->moveinfo.state == STATE_TOP)
X		return;
X
X	self->moveinfo.state = STATE_UP;
X	if (self->moveinfo.sound_start && !(self->flags & FL_TEAMSLAVE))
X		gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X	Move_Calc (self, self->moveinfo.end_origin, button_wait);
}
X
void button_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->activator = activator;
X	button_fire (self);
}
X
void button_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (!other->client)
X		return;
X
X	if (other->health <= 0)
X		return;
X
X	self->activator = other;
X	button_fire (self);
}
X
void button_killed (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	self->activator = attacker;
X	self->health = self->max_health;
X	self->takedamage = DAMAGE_NO;
X	button_fire (self);
}
X
void SP_func_button (edict_t *ent)
{
X	vec3_t	abs_movedir;
X	float	dist;
X
X	G_SetMovedir (ent->s.angles, ent->movedir);
X	ent->movetype = MOVETYPE_STOP;
X	ent->solid = SOLID_BSP;
X	gi.setmodel (ent, ent->model);
X
X	if (ent->sounds != 1)
X		ent->moveinfo.sound_start = gi.soundindex ("switches/butn2.wav");
X	
X	if (!ent->speed)
X		ent->speed = 40;
X	if (!ent->accel)
X		ent->accel = ent->speed;
X	if (!ent->decel)
X		ent->decel = ent->speed;
X
X	if (!ent->wait)
X		ent->wait = 3;
X	if (!st.lip)
X		st.lip = 4;
X
X	VectorCopy (ent->s.origin, ent->pos1);
X	abs_movedir[0] = fabs(ent->movedir[0]);
X	abs_movedir[1] = fabs(ent->movedir[1]);
X	abs_movedir[2] = fabs(ent->movedir[2]);
X	dist = abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - st.lip;
X	VectorMA (ent->pos1, dist, ent->movedir, ent->pos2);
X
X	ent->use = button_use;
X	ent->s.effects |= EF_ANIM01;
X
X	if (ent->health)
X	{
X		ent->max_health = ent->health;
X		ent->die = button_killed;
X		ent->takedamage = DAMAGE_YES;
X	}
X	else if (! ent->targetname)
X		ent->touch = button_touch;
X
X	ent->moveinfo.state = STATE_BOTTOM;
X
X	ent->moveinfo.speed = ent->speed;
X	ent->moveinfo.accel = ent->accel;
X	ent->moveinfo.decel = ent->decel;
X	ent->moveinfo.wait = ent->wait;
X	VectorCopy (ent->pos1, ent->moveinfo.start_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.start_angles);
X	VectorCopy (ent->pos2, ent->moveinfo.end_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.end_angles);
X
X	gi.linkentity (ent);
}
X
/*
======================================================================
X
DOORS
X
X  spawn a trigger surrounding the entire team unless it is
X  already targeted by another
X
======================================================================
*/
X
/*QUAKED func_door (0 .5 .8) ? START_OPEN x CRUSHER NOMONSTER ANIMATED TOGGLE ANIMATED_FAST
TOGGLE		wait in both the start and end states for a trigger event.
START_OPEN	the door to moves to its destination when spawned, and operate in reverse.  It is used to temporarily or permanently close off an area when triggered (not useful for touch or takedamage doors).
NOMONSTER	monsters will not trigger this door
X
"message"	is printed when the door is touched if it is a trigger door and it hasn't been fired yet
"angle"		determines the opening direction
"targetname" if set, no touch field will be spawned and a remote button or trigger field activates the door.
"health"	if set, door must be shot open
"speed"		movement speed (100 default)
"wait"		wait before returning (3 default, -1 = never return)
"lip"		lip remaining at end of move (8 default)
"dmg"		damage to inflict when blocked (2 default)
"sounds"
1)	silent
2)	light
3)	medium
4)	heavy
*/
X
void door_use_areaportals (edict_t *self, qboolean open)
{
X	edict_t	*t = NULL;
X
X	if (!self->target)
X		return;
X
X	while ((t = G_Find (t, FOFS(targetname), self->target)))
X	{
X		if (Q_stricmp(t->classname, "func_areaportal") == 0)
X		{
X			gi.SetAreaPortalState (t->style, open);
X		}
X	}
}
X
void door_go_down (edict_t *self);
X
void door_hit_top (edict_t *self)
{
X	if (!(self->flags & FL_TEAMSLAVE))
X	{
X		if (self->moveinfo.sound_end)
X			gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_end, 1, ATTN_STATIC, 0);
X		self->s.sound = 0;
X	}
X	self->moveinfo.state = STATE_TOP;
X	if (self->spawnflags & DOOR_TOGGLE)
X		return;
X	if (self->moveinfo.wait >= 0)
X	{
X		self->think = door_go_down;
X		self->nextthink = level.time + self->moveinfo.wait;
X	}
}
X
void door_hit_bottom (edict_t *self)
{
X	if (!(self->flags & FL_TEAMSLAVE))
X	{
X		if (self->moveinfo.sound_end)
X			gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_end, 1, ATTN_STATIC, 0);
X		self->s.sound = 0;
X	}
X	self->moveinfo.state = STATE_BOTTOM;
X	door_use_areaportals (self, false);
}
X
void door_go_down (edict_t *self)
{
X	if (!(self->flags & FL_TEAMSLAVE))
X	{
X		if (self->moveinfo.sound_start)
X			gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		self->s.sound = self->moveinfo.sound_middle;
X	}
X	if (self->max_health)
X	{
X		self->takedamage = DAMAGE_YES;
X		self->health = self->max_health;
X	}
X	
X	self->moveinfo.state = STATE_DOWN;
X	if (strcmp(self->classname, "func_door") == 0)
X		Move_Calc (self, self->moveinfo.start_origin, door_hit_bottom);
X	else if (strcmp(self->classname, "func_door_rotating") == 0)
X		AngleMove_Calc (self, door_hit_bottom);
}
X
void door_go_up (edict_t *self, edict_t *activator)
{
X	if (self->moveinfo.state == STATE_UP)
X		return;		// already going up
X
X	if (self->moveinfo.state == STATE_TOP)
X	{	// reset top wait time
X		if (self->moveinfo.wait >= 0)
X			self->nextthink = level.time + self->moveinfo.wait;
X		return;
X	}
X	
X	if (!(self->flags & FL_TEAMSLAVE))
X	{
X		if (self->moveinfo.sound_start)
X			gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		self->s.sound = self->moveinfo.sound_middle;
X	}
X	self->moveinfo.state = STATE_UP;
X	if (strcmp(self->classname, "func_door") == 0)
X		Move_Calc (self, self->moveinfo.end_origin, door_hit_top);
X	else if (strcmp(self->classname, "func_door_rotating") == 0)
X		AngleMove_Calc (self, door_hit_top);
X
X	G_UseTargets (self, activator);
X	door_use_areaportals (self, true);
}
X
//======
//PGM
void smart_water_go_up (edict_t *self)
{
X	float		distance;
X	edict_t		*lowestPlayer;
X	edict_t		*ent;
X	float		lowestPlayerPt;
X	int			i;
X
X	if (self->moveinfo.state == STATE_TOP)
X	{	// reset top wait time
X		if (self->moveinfo.wait >= 0)
X			self->nextthink = level.time + self->moveinfo.wait;
X		return;
X	}
X
X	if (self->health)
X	{
X		if(self->absmax[2] >= self->health)
X		{
X			VectorClear (self->velocity);
X			self->nextthink = 0;
X			self->moveinfo.state = STATE_TOP;
X			return;
X		}
X	}
X
X	if (!(self->flags & FL_TEAMSLAVE))
X	{
X		if (self->moveinfo.sound_start)
X			gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		self->s.sound = self->moveinfo.sound_middle;
X	}
X
X	// find the lowest player point.
X	lowestPlayerPt = 999999;
X	lowestPlayer = NULL;
X	for (i=0 ; i<game.maxclients ; i++)
X	{
X		ent = &g_edicts[1+i];
X
X		// don't count dead or unused player slots
X		if((ent->inuse) && (ent->health > 0))
X		{
X			if (ent->absmin[2] < lowestPlayerPt)
X			{
X				lowestPlayerPt = ent->absmin[2];
X				lowestPlayer = ent;
X			}
X		}
X	}
X
X	if(!lowestPlayer)
X	{
X		return;
X	}
X
X	distance = lowestPlayerPt - self->absmax[2];
X
X	// for the calculations, make sure we intend to go up at least a little.
X	if(distance < self->accel)
X	{
X		distance = 100;
X		self->moveinfo.speed = 5;
X	}
X	else
X		self->moveinfo.speed = distance / self->accel;
X
X	if(self->moveinfo.speed < 5)
X		self->moveinfo.speed = 5;
X	else if(self->moveinfo.speed > self->speed)
X		self->moveinfo.speed = self->speed;
X
X	// FIXME - should this allow any movement other than straight up?
X	VectorSet(self->moveinfo.dir, 0, 0, 1);	
X	VectorScale (self->moveinfo.dir, self->moveinfo.speed, self->velocity);
X	self->moveinfo.remaining_distance = distance;
X
X	if(self->moveinfo.state != STATE_UP)
X	{
X		G_UseTargets (self, lowestPlayer);
X		door_use_areaportals (self, true);
X		self->moveinfo.state = STATE_UP;
X	}
X
X	self->think = smart_water_go_up;
X	self->nextthink = level.time + FRAMETIME;
}
//PGM
//======
X
void door_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t	*ent;
X	vec3_t	center;			//PGM
X
X	if (self->flags & FL_TEAMSLAVE)
X		return;
X
X	if (self->spawnflags & DOOR_TOGGLE)
X	{
X		if (self->moveinfo.state == STATE_UP || self->moveinfo.state == STATE_TOP)
X		{
X			// trigger all paired doors
X			for (ent = self ; ent ; ent = ent->teamchain)
X			{
X				ent->message = NULL;
X				ent->touch = NULL;
X				door_go_down (ent);
X			}
X			return;
X		}
X	}
X
//PGM
X	// smart water is different
X	VectorAdd(self->mins, self->maxs, center);
X	VectorScale(center, 0.5, center);
X	if ((gi.pointcontents (center) & MASK_WATER) && self->spawnflags & 2)
X	{
X		self->message = NULL;
X		self->touch = NULL;
X		self->enemy = activator;
X		smart_water_go_up (self);
X		return;
X	}
//PGM
X
X	// trigger all paired doors
X	for (ent = self ; ent ; ent = ent->teamchain)
X	{
X		ent->message = NULL;
X		ent->touch = NULL;
X		door_go_up (ent, activator);
X	}
};
X
void Touch_DoorTrigger (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other->health <= 0)
X		return;
X
X	if (!(other->svflags & SVF_MONSTER) && (!other->client))
X		return;
X
X	if ((self->owner->spawnflags & DOOR_NOMONSTER) && (other->svflags & SVF_MONSTER))
X		return;
X
X	if (level.time < self->touch_debounce_time)
X		return;
X	self->touch_debounce_time = level.time + 1.0;
X
X	door_use (self->owner, other, other);
}
X
void Think_CalcMoveSpeed (edict_t *self)
{
X	edict_t	*ent;
X	float	min;
X	float	time;
X	float	newspeed;
X	float	ratio;
X	float	dist;
X
X	if (self->flags & FL_TEAMSLAVE)
X		return;		// only the team master does this
X
X	// find the smallest distance any member of the team will be moving
X	min = fabs(self->moveinfo.distance);
X	for (ent = self->teamchain; ent; ent = ent->teamchain)
X	{
X		dist = fabs(ent->moveinfo.distance);
X		if (dist < min)
X			min = dist;
X	}
X
X	time = min / self->moveinfo.speed;
X
X	// adjust speeds so they will all complete at the same time
X	for (ent = self; ent; ent = ent->teamchain)
X	{
X		newspeed = fabs(ent->moveinfo.distance) / time;
X		ratio = newspeed / ent->moveinfo.speed;
X		if (ent->moveinfo.accel == ent->moveinfo.speed)
X			ent->moveinfo.accel = newspeed;
X		else
X			ent->moveinfo.accel *= ratio;
X		if (ent->moveinfo.decel == ent->moveinfo.speed)
X			ent->moveinfo.decel = newspeed;
X		else
X			ent->moveinfo.decel *= ratio;
X		ent->moveinfo.speed = newspeed;
X	}
}
X
void Think_SpawnDoorTrigger (edict_t *ent)
{
X	edict_t		*other;
X	vec3_t		mins, maxs;
X
X	if (ent->flags & FL_TEAMSLAVE)
X		return;		// only the team leader spawns a trigger
X
X	VectorCopy (ent->absmin, mins);
X	VectorCopy (ent->absmax, maxs);
X
X	for (other = ent->teamchain ; other ; other=other->teamchain)
X	{
X		AddPointToBounds (other->absmin, mins, maxs);
X		AddPointToBounds (other->absmax, mins, maxs);
X	}
X
X	// expand 
X	mins[0] -= 60;
X	mins[1] -= 60;
X	maxs[0] += 60;
X	maxs[1] += 60;
X
X	other = G_Spawn ();
X	VectorCopy (mins, other->mins);
X	VectorCopy (maxs, other->maxs);
X	other->owner = ent;
X	other->solid = SOLID_TRIGGER;
X	other->movetype = MOVETYPE_NONE;
X	other->touch = Touch_DoorTrigger;
X	gi.linkentity (other);
X
X	if (ent->spawnflags & DOOR_START_OPEN)
X		door_use_areaportals (ent, true);
X
X	Think_CalcMoveSpeed (ent);
}
X
void door_blocked  (edict_t *self, edict_t *other)
{
X	edict_t	*ent;
X
X	if (!(other->svflags & SVF_MONSTER) && (!other->client) )
X	{
X		// give it a chance to go away on it's own terms (like gibs)
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 100000, 1, 0, MOD_CRUSH);
X		// if it's still there, nuke it
X		if (other && other->inuse)
X			BecomeExplosion1 (other);
X		return;
X	}
X
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
X
X	if (self->spawnflags & DOOR_CRUSHER)
X		return;
X
X
// if a door has a negative wait, it would never come back if blocked,
// so let it just squash the object to death real fast
X	if (self->moveinfo.wait >= 0)
X	{
X		if (self->moveinfo.state == STATE_DOWN)
X		{
X			for (ent = self->teammaster ; ent ; ent = ent->teamchain)
X				door_go_up (ent, ent->activator);
X		}
X		else
X		{
X			for (ent = self->teammaster ; ent ; ent = ent->teamchain)
X				door_go_down (ent);
X		}
X	}
}
X
void door_killed (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	edict_t	*ent;
X
X	for (ent = self->teammaster ; ent ; ent = ent->teamchain)
X	{
X		ent->health = ent->max_health;
X		ent->takedamage = DAMAGE_NO;
X	}
X	door_use (self->teammaster, attacker, attacker);
}
X
void door_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (!other->client)
X		return;
X
X	if (level.time < self->touch_debounce_time)
X		return;
X	self->touch_debounce_time = level.time + 5.0;
X
X	gi.centerprintf (other, "%s", self->message);
X	gi.sound (other, CHAN_AUTO, gi.soundindex ("misc/talk1.wav"), 1, ATTN_NORM, 0);
}
X
void SP_func_door (edict_t *ent)
{
X	vec3_t	abs_movedir;
X
X	if (ent->sounds != 1)
X	{
X		ent->moveinfo.sound_start = gi.soundindex  ("doors/dr1_strt.wav");
X		ent->moveinfo.sound_middle = gi.soundindex  ("doors/dr1_mid.wav");
X		ent->moveinfo.sound_end = gi.soundindex  ("doors/dr1_end.wav");
X	}
X
X	G_SetMovedir (ent->s.angles, ent->movedir);
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_BSP;
X	gi.setmodel (ent, ent->model);
X
X	ent->blocked = door_blocked;
X	ent->use = door_use;
X	
X	if (!ent->speed)
X		ent->speed = 100;
X	if (deathmatch->value)
X		ent->speed *= 2;
X
X	if (!ent->accel)
X		ent->accel = ent->speed;
X	if (!ent->decel)
X		ent->decel = ent->speed;
X
X	if (!ent->wait)
X		ent->wait = 3;
X	if (!st.lip)
X		st.lip = 8;
X	if (!ent->dmg)
X		ent->dmg = 2;
X
X	// calculate second position
X	VectorCopy (ent->s.origin, ent->pos1);
X	abs_movedir[0] = fabs(ent->movedir[0]);
X	abs_movedir[1] = fabs(ent->movedir[1]);
X	abs_movedir[2] = fabs(ent->movedir[2]);
X	ent->moveinfo.distance = abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - st.lip;
X	VectorMA (ent->pos1, ent->moveinfo.distance, ent->movedir, ent->pos2);
X
X	// if it starts open, switch the positions
X	if (ent->spawnflags & DOOR_START_OPEN)
X	{
X		VectorCopy (ent->pos2, ent->s.origin);
X		VectorCopy (ent->pos1, ent->pos2);
X		VectorCopy (ent->s.origin, ent->pos1);
X	}
X
X	ent->moveinfo.state = STATE_BOTTOM;
X
X	if (ent->health)
X	{
X		ent->takedamage = DAMAGE_YES;
X		ent->die = door_killed;
X		ent->max_health = ent->health;
X	}
X	else if (ent->targetname && ent->message)
X	{
X		gi.soundindex ("misc/talk.wav");
X		ent->touch = door_touch;
X	}
X	
X	ent->moveinfo.speed = ent->speed;
X	ent->moveinfo.accel = ent->accel;
X	ent->moveinfo.decel = ent->decel;
X	ent->moveinfo.wait = ent->wait;
X	VectorCopy (ent->pos1, ent->moveinfo.start_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.start_angles);
X	VectorCopy (ent->pos2, ent->moveinfo.end_origin);
X	VectorCopy (ent->s.angles, ent->moveinfo.end_angles);
X
X	if (ent->spawnflags & 16)
X		ent->s.effects |= EF_ANIM_ALL;
X	if (ent->spawnflags & 64)
X		ent->s.effects |= EF_ANIM_ALLFAST;
X
X	// to simplify logic elsewhere, make non-teamed doors into a team of one
X	if (!ent->team)
X		ent->teammaster = ent;
X
X	gi.linkentity (ent);
X
X	ent->nextthink = level.time + FRAMETIME;
X	if (ent->health || ent->targetname)
X		ent->think = Think_CalcMoveSpeed;
X	else
X		ent->think = Think_SpawnDoorTrigger;
}
X
//PGM
void Door_Activate (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->use = NULL;
X	
X	if (self->health)
X	{
X		self->takedamage = DAMAGE_YES;
X		self->die = door_killed;
X		self->max_health = self->health;
X	}
X
X	if (self->health)
X		self->think = Think_CalcMoveSpeed;
X	else
X		self->think = Think_SpawnDoorTrigger;
X	self->nextthink = level.time + FRAMETIME;
X
}
//PGM
X
/*QUAKED func_door_rotating (0 .5 .8) ? START_OPEN REVERSE CRUSHER NOMONSTER ANIMATED TOGGLE X_AXIS Y_AXIS EASY MED HARD DM COOP INACTIVE
TOGGLE causes the door to wait in both the start and end states for a trigger event.
X
START_OPEN	the door to moves to its destination when spawned, and operate in reverse.  It is used to temporarily or permanently close off an area when triggered (not useful for touch or takedamage doors).
NOMONSTER	monsters will not trigger this door
X
You need to have an origin brush as part of this entity.  The center of that brush will be
the point around which it is rotated. It will rotate around the Z axis by default.  You can
check either the X_AXIS or Y_AXIS box to change that.
X
"distance" is how many degrees the door will be rotated.
"speed" determines how fast the door moves; default value is 100.
"accel" if specified,is how much the rotation speed will increase each .1 sec. (default: no accel)
X
REVERSE will cause the door to rotate in the opposite direction.
INACTIVE will cause the door to be inactive until triggered.
X
"message"	is printed when the door is touched if it is a trigger door and it hasn't been fired yet
"angle"		determines the opening direction
"targetname" if set, no touch field will be spawned and a remote button or trigger field activates the door.
"health"	if set, door must be shot open
"speed"		movement speed (100 default)
"wait"		wait before returning (3 default, -1 = never return)
"dmg"		damage to inflict when blocked (2 default)
"sounds"
1)	silent
2)	light
3)	medium
4)	heavy
*/
X
void SP_func_door_rotating (edict_t *ent)
{
X	VectorClear (ent->s.angles);
X
X	// set the axis of rotation
X	VectorClear(ent->movedir);
X	if (ent->spawnflags & DOOR_X_AXIS)
X		ent->movedir[2] = 1.0;
X	else if (ent->spawnflags & DOOR_Y_AXIS)
X		ent->movedir[0] = 1.0;
X	else // Z_AXIS
X		ent->movedir[1] = 1.0;
X
X	// check for reverse rotation
X	if (ent->spawnflags & DOOR_REVERSE)
X		VectorNegate (ent->movedir, ent->movedir);
X
X	if (!st.distance)
X	{
X		gi.dprintf("%s at %s with no distance set\n", ent->classname, vtos(ent->s.origin));
X		st.distance = 90;
X	}
X
X	VectorCopy (ent->s.angles, ent->pos1);
X	VectorMA (ent->s.angles, st.distance, ent->movedir, ent->pos2);
X	ent->moveinfo.distance = st.distance;
X
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_BSP;
X	gi.setmodel (ent, ent->model);
X
X	ent->blocked = door_blocked;
X	ent->use = door_use;
X
X	if (!ent->speed)
X		ent->speed = 100;
X	if (!ent->accel)
X		ent->accel = ent->speed;
X	if (!ent->decel)
X		ent->decel = ent->speed;
X
X	if (!ent->wait)
X		ent->wait = 3;
X	if (!ent->dmg)
X		ent->dmg = 2;
X
X	if (ent->sounds != 1)
X	{
X		ent->moveinfo.sound_start = gi.soundindex  ("doors/dr1_strt.wav");
X		ent->moveinfo.sound_middle = gi.soundindex  ("doors/dr1_mid.wav");
X		ent->moveinfo.sound_end = gi.soundindex  ("doors/dr1_end.wav");
X	}
X
X	// if it starts open, switch the positions
X	if (ent->spawnflags & DOOR_START_OPEN)
X	{
X		VectorCopy (ent->pos2, ent->s.angles);
X		VectorCopy (ent->pos1, ent->pos2);
X		VectorCopy (ent->s.angles, ent->pos1);
X		VectorNegate (ent->movedir, ent->movedir);
X	}
X
X	if (ent->health)
X	{
X		ent->takedamage = DAMAGE_YES;
X		ent->die = door_killed;
X		ent->max_health = ent->health;
X	}
X	
X	if (ent->targetname && ent->message)
X	{
X		gi.soundindex ("misc/talk.wav");
X		ent->touch = door_touch;
X	}
X
X	ent->moveinfo.state = STATE_BOTTOM;
X	ent->moveinfo.speed = ent->speed;
X	ent->moveinfo.accel = ent->accel;
X	ent->moveinfo.decel = ent->decel;
X	ent->moveinfo.wait = ent->wait;
X	VectorCopy (ent->s.origin, ent->moveinfo.start_origin);
X	VectorCopy (ent->pos1, ent->moveinfo.start_angles);
X	VectorCopy (ent->s.origin, ent->moveinfo.end_origin);
X	VectorCopy (ent->pos2, ent->moveinfo.end_angles);
X
X	if (ent->spawnflags & 16)
X		ent->s.effects |= EF_ANIM_ALL;
X
X	// to simplify logic elsewhere, make non-teamed doors into a team of one
X	if (!ent->team)
X		ent->teammaster = ent;
X
X	gi.linkentity (ent);
X
X	ent->nextthink = level.time + FRAMETIME;
X	if (ent->health || ent->targetname)
X		ent->think = Think_CalcMoveSpeed;
X	else
X		ent->think = Think_SpawnDoorTrigger;
X
//PGM
X	if (ent->spawnflags & DOOR_INACTIVE)
X	{
X		ent->takedamage = DAMAGE_NO;
X		ent->die = NULL;
X		ent->think = NULL;
X		ent->nextthink = 0;
X		ent->use = Door_Activate;
X	}
//PGM
}
X
void smart_water_blocked (edict_t *self, edict_t *other)
{
X	if (!(other->svflags & SVF_MONSTER) && (!other->client) )
X	{
X		// give it a chance to go away on it's own terms (like gibs)
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 100000, 1, 0, MOD_LAVA);
X		// if it's still there, nuke it
X		if (other && other->inuse)		// PGM
X			BecomeExplosion1 (other);
X		return;
X	}
X
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 100, 1, 0, MOD_LAVA);
}
X
/*QUAKED func_water (0 .5 .8) ? START_OPEN SMART
func_water is a moveable water brush.  It must be targeted to operate.  Use a non-water texture at your own risk.
X
START_OPEN causes the water to move to its destination when spawned and operate in reverse.
X
SMART causes the water to adjust its speed depending on distance to player. 
(speed = distance/accel, min 5, max self->speed)
"accel"		for smart water, the divisor to determine water speed. default 20 (smaller = faster)
X
"health"	maximum height of this water brush
"angle"		determines the opening direction (up or down only)
"speed"		movement speed (25 default)
"wait"		wait before returning (-1 default, -1 = TOGGLE)
"lip"		lip remaining at end of move (0 default)
"sounds"	(yes, these need to be changed)
0)	no sound
1)	water
2)	lava
*/
X
void SP_func_water (edict_t *self)
{
X	vec3_t	abs_movedir;
X
X  	G_SetMovedir (self->s.angles, self->movedir);
X	self->movetype = MOVETYPE_PUSH;
X	self->solid = SOLID_BSP;
X	gi.setmodel (self, self->model);
X
X	switch (self->sounds)
X	{
X		default:
X			break;
X
X		case 1: // water
X			self->moveinfo.sound_start = gi.soundindex  ("world/mov_watr.wav");
X			self->moveinfo.sound_end = gi.soundindex  ("world/stp_watr.wav");
X			break;
X
X		case 2: // lava
X			self->moveinfo.sound_start = gi.soundindex  ("world/mov_watr.wav");
X			self->moveinfo.sound_end = gi.soundindex  ("world/stp_watr.wav");
X			break;
X	}
X
X	// calculate second position
X	VectorCopy (self->s.origin, self->pos1);
X	abs_movedir[0] = fabs(self->movedir[0]);
X	abs_movedir[1] = fabs(self->movedir[1]);
X	abs_movedir[2] = fabs(self->movedir[2]);
X	self->moveinfo.distance = abs_movedir[0] * self->size[0] + abs_movedir[1] * self->size[1] + abs_movedir[2] * self->size[2] - st.lip;
X	VectorMA (self->pos1, self->moveinfo.distance, self->movedir, self->pos2);
X
X	// if it starts open, switch the positions
X	if (self->spawnflags & DOOR_START_OPEN)
X	{
X		VectorCopy (self->pos2, self->s.origin);
X		VectorCopy (self->pos1, self->pos2);
X		VectorCopy (self->s.origin, self->pos1);
X	}
X
X	VectorCopy (self->pos1, self->moveinfo.start_origin);
X	VectorCopy (self->s.angles, self->moveinfo.start_angles);
X	VectorCopy (self->pos2, self->moveinfo.end_origin);
X	VectorCopy (self->s.angles, self->moveinfo.end_angles);
X
X	self->moveinfo.state = STATE_BOTTOM;
X
X	if (!self->speed)
X		self->speed = 25;
X	self->moveinfo.accel = self->moveinfo.decel = self->moveinfo.speed = self->speed;
X
X	if ( self->spawnflags & 2)	// smart water
X	{
X		// this is actually the divisor of the lowest player's distance to determine speed.
X		// self->speed then becomes the cap of the speed.
X		if(!self->accel)
X			self->accel = 20;
X		self->blocked = smart_water_blocked;
X	}
X
X	if (!self->wait)
X		self->wait = -1;
X	self->moveinfo.wait = self->wait;
X
X	self->use = door_use;
X
X	if (self->wait == -1)
X		self->spawnflags |= DOOR_TOGGLE;
X
X	self->classname = "func_door";
X
X	gi.linkentity (self);
}
X
X
#define TRAIN_START_ON		1
#define TRAIN_TOGGLE		2
#define TRAIN_BLOCK_STOPS	4
X
/*QUAKED func_train (0 .5 .8) ? START_ON TOGGLE BLOCK_STOPS
Trains are moving platforms that players can ride.
The targets origin specifies the min point of the train at each corner.
The train spawns at the first target it is pointing at.
If the train is the target of a button or trigger, it will not begin moving until activated.
speed	default 100
dmg		default	2
noise	looping sound to play when the train is in motion
X
To have other entities move with the train, set all the piece's team value to the same thing. They will move in unison.
*/
void train_next (edict_t *self);
X
void train_blocked (edict_t *self, edict_t *other)
{
X	if (!(other->svflags & SVF_MONSTER) && (!other->client) )
X	{
X		// give it a chance to go away on it's own terms (like gibs)
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 100000, 1, 0, MOD_CRUSH);
X		// if it's still there, nuke it
X		if (other && other->inuse)
X			BecomeExplosion1 (other);
X		return;
X	}
X
X	if (level.time < self->touch_debounce_time)
X		return;
X
X	if (!self->dmg)
X		return;
X	self->touch_debounce_time = level.time + 0.5;
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
}
X
void train_wait (edict_t *self)
{
X	if (self->target_ent->pathtarget)
X	{
X		char	*savetarget;
X		edict_t	*ent;
X
X		ent = self->target_ent;
X		savetarget = ent->target;
X		ent->target = ent->pathtarget;
X		G_UseTargets (ent, self->activator);
X		ent->target = savetarget;
X
X		// make sure we didn't get killed by a killtarget
X		if (!self->inuse)
X			return;
X	}
X
X	if (self->moveinfo.wait)
X	{
X		if (self->moveinfo.wait > 0)
X		{
X			self->nextthink = level.time + self->moveinfo.wait;
X			self->think = train_next;
X		}
X		else if (self->spawnflags & TRAIN_TOGGLE)  // && wait < 0
X		{
X			// PMM - clear target_ent, let train_next get called when we get used
//			train_next (self);
X			self->target_ent = NULL;
X			// pmm
X			self->spawnflags &= ~TRAIN_START_ON;
X			VectorClear (self->velocity);
X			self->nextthink = 0;
X		}
X
X		if (!(self->flags & FL_TEAMSLAVE))
X		{
X			if (self->moveinfo.sound_end)
X				gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_end, 1, ATTN_STATIC, 0);
X			self->s.sound = 0;
X		}
X	}
X	else
X	{
X		train_next (self);
X	}
X	
}
X
//PGM
void train_piece_wait (edict_t *self)
{
}
//PGM
X
void train_next (edict_t *self)
{
X	edict_t		*ent;
X	vec3_t		dest;
X	qboolean	first;
X
X	first = true;
again:
X	if (!self->target)
X	{
//		gi.dprintf ("train_next: no next target\n");
X		return;
X	}
X
X	ent = G_PickTarget (self->target);
X	if (!ent)
X	{
X		gi.dprintf ("train_next: bad target %s\n", self->target);
X		return;
X	}
X
X	self->target = ent->target;
X
X	// check for a teleport path_corner
X	if (ent->spawnflags & 1)
X	{
X		if (!first)
X		{
X			gi.dprintf ("connected teleport path_corners, see %s at %s\n", ent->classname, vtos(ent->s.origin));
X			return;
X		}
X		first = false;
X		VectorSubtract (ent->s.origin, self->mins, self->s.origin);
X		VectorCopy (self->s.origin, self->s.old_origin);
X		self->s.event = EV_OTHER_TELEPORT;
X		gi.linkentity (self);
X		goto again;
X	}
X
//PGM
X	if (ent->speed)
X	{
X		self->speed = ent->speed;
X		self->moveinfo.speed = ent->speed;
X		if(ent->accel)
X			self->moveinfo.accel = ent->accel;
X		else
X			self->moveinfo.accel = ent->speed;
X		if(ent->decel)
X			self->moveinfo.decel = ent->decel;
X		else
X			self->moveinfo.decel = ent->speed;
X		self->moveinfo.current_speed = 0;
X	}
//PGM
X
X	self->moveinfo.wait = ent->wait;
X	self->target_ent = ent;
X
X	if (!(self->flags & FL_TEAMSLAVE))
X	{
X		if (self->moveinfo.sound_start)
X			gi.sound (self, CHAN_NO_PHS_ADD+CHAN_VOICE, self->moveinfo.sound_start, 1, ATTN_STATIC, 0);
X		self->s.sound = self->moveinfo.sound_middle;
X	}
X
X	VectorSubtract (ent->s.origin, self->mins, dest);
X	self->moveinfo.state = STATE_TOP;
X	VectorCopy (self->s.origin, self->moveinfo.start_origin);
X	VectorCopy (dest, self->moveinfo.end_origin);
X	Move_Calc (self, dest, train_wait);
X	self->spawnflags |= TRAIN_START_ON;
X	
//PGM
X	if(self->team)
X	{
X		edict_t *e;
X		vec3_t	dir, dst;
X
X		VectorSubtract (dest, self->s.origin, dir);
X		for (e=self->teamchain; e ; e = e->teamchain)
X		{
X			VectorAdd(dir, e->s.origin, dst);
X			VectorCopy(e->s.origin, e->moveinfo.start_origin);
X			VectorCopy(dst, e->moveinfo.end_origin);
X
X			e->moveinfo.state = STATE_TOP;
X			e->speed = self->speed;
X			e->moveinfo.speed = self->moveinfo.speed;
X			e->moveinfo.accel = self->moveinfo.accel;
X			e->moveinfo.decel = self->moveinfo.decel;
X			e->movetype = MOVETYPE_PUSH;
X			Move_Calc (e, dst, train_piece_wait);
X		}
X	
X	}
//PGM
}
X
void train_resume (edict_t *self)
{
X	edict_t	*ent;
X	vec3_t	dest;
X
X	ent = self->target_ent;
X
X	VectorSubtract (ent->s.origin, self->mins, dest);
X	self->moveinfo.state = STATE_TOP;
X	VectorCopy (self->s.origin, self->moveinfo.start_origin);
X	VectorCopy (dest, self->moveinfo.end_origin);
X	Move_Calc (self, dest, train_wait);
X	self->spawnflags |= TRAIN_START_ON;
}
X
void func_train_find (edict_t *self)
{
X	edict_t *ent;
X
X	if (!self->target)
X	{
X		gi.dprintf ("train_find: no target\n");
X		return;
X	}
X	ent = G_PickTarget (self->target);
X	if (!ent)
X	{
X		gi.dprintf ("train_find: target %s not found\n", self->target);
X		return;
X	}
X	self->target = ent->target;
X
X	VectorSubtract (ent->s.origin, self->mins, self->s.origin);
X	gi.linkentity (self);
X
X	// if not triggered, start immediately
X	if (!self->targetname)
X		self->spawnflags |= TRAIN_START_ON;
X
X	if (self->spawnflags & TRAIN_START_ON)
X	{
X		self->nextthink = level.time + FRAMETIME;
X		self->think = train_next;
X		self->activator = self;
X	}
}
X
void train_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->activator = activator;
X
X	if (self->spawnflags & TRAIN_START_ON)
X	{
X		if (!(self->spawnflags & TRAIN_TOGGLE))
X			return;
X		self->spawnflags &= ~TRAIN_START_ON;
X		VectorClear (self->velocity);
X		self->nextthink = 0;
X	}
X	else
X	{
X		if (self->target_ent)
X			train_resume(self);
X		else
X			train_next(self);
X	}
}
X
void SP_func_train (edict_t *self)
{
X	self->movetype = MOVETYPE_PUSH;
X
X	VectorClear (self->s.angles);
X	self->blocked = train_blocked;
X	if (self->spawnflags & TRAIN_BLOCK_STOPS)
X		self->dmg = 0;
X	else
X	{
X		if (!self->dmg)
X			self->dmg = 100;
X	}
X	self->solid = SOLID_BSP;
X	gi.setmodel (self, self->model);
X
X	if (st.noise)
X		self->moveinfo.sound_middle = gi.soundindex  (st.noise);
X
X	if (!self->speed)
X		self->speed = 100;
X
X	self->moveinfo.speed = self->speed;
X	self->moveinfo.accel = self->moveinfo.decel = self->moveinfo.speed;
X
X	self->use = train_use;
X
X	gi.linkentity (self);
X
X	if (self->target)
X	{
X		// start trains on the second frame, to make sure their targets have had
X		// a chance to spawn
X		self->nextthink = level.time + FRAMETIME;
X		self->think = func_train_find;
X	}
X	else
X	{
X		gi.dprintf ("func_train without a target at %s\n", vtos(self->absmin));
X	}
}
X
X
/*QUAKED trigger_elevator (0.3 0.1 0.6) (-8 -8 -8) (8 8 8)
*/
void trigger_elevator_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t *target;
X
X	if (self->movetarget->nextthink)
X	{
//		gi.dprintf("elevator busy\n");
X		return;
X	}
X
X	if (!other->pathtarget)
X	{
X		gi.dprintf("elevator used with no pathtarget\n");
X		return;
X	}
X
X	target = G_PickTarget (other->pathtarget);
X	if (!target)
X	{
X		gi.dprintf("elevator used with bad pathtarget: %s\n", other->pathtarget);
X		return;
X	}
X
X	self->movetarget->target_ent = target;
X	train_resume (self->movetarget);
}
X
void trigger_elevator_init (edict_t *self)
{
X	if (!self->target)
X	{
X		gi.dprintf("trigger_elevator has no target\n");
X		return;
X	}
X	self->movetarget = G_PickTarget (self->target);
X	if (!self->movetarget)
X	{
X		gi.dprintf("trigger_elevator unable to find target %s\n", self->target);
X		return;
X	}
X	if (strcmp(self->movetarget->classname, "func_train") != 0)
X	{
X		gi.dprintf("trigger_elevator target %s is not a train\n", self->target);
X		return;
X	}
X
X	self->use = trigger_elevator_use;
X	self->svflags = SVF_NOCLIENT;
X
}
X
void SP_trigger_elevator (edict_t *self)
{
X	self->think = trigger_elevator_init;
X	self->nextthink = level.time + FRAMETIME;
}
X
X
/*QUAKED func_timer (0.3 0.1 0.6) (-8 -8 -8) (8 8 8) START_ON
"wait"			base time between triggering all targets, default is 1
"random"		wait variance, default is 0
X
so, the basic time between firing is a random time between
(wait - random) and (wait + random)
X
"delay"			delay before first firing when turned on, default is 0
X
"pausetime"		additional delay used only the very first time
X				and only if spawned with START_ON
X
These can used but not touched.
*/
void func_timer_think (edict_t *self)
{
X	G_UseTargets (self, self->activator);
X	self->nextthink = level.time + self->wait + crandom() * self->random;
}
X
void func_timer_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->activator = activator;
X
X	// if on, turn it off
X	if (self->nextthink)
X	{
X		self->nextthink = 0;
X		return;
X	}
X
X	// turn it on
X	if (self->delay)
X		self->nextthink = level.time + self->delay;
X	else
X		func_timer_think (self);
}
X
void SP_func_timer (edict_t *self)
{
X	if (!self->wait)
X		self->wait = 1.0;
X
X	self->use = func_timer_use;
X	self->think = func_timer_think;
X
X	if (self->random >= self->wait)
X	{
X		self->random = self->wait - FRAMETIME;
X		gi.dprintf("func_timer at %s has random >= wait\n", vtos(self->s.origin));
X	}
X
X	if (self->spawnflags & 1)
X	{
X		self->nextthink = level.time + 1.0 + st.pausetime + self->delay + self->wait + crandom() * self->random;
X		self->activator = self;
X	}
X
X	self->svflags = SVF_NOCLIENT;
}
X
X
/*QUAKED func_conveyor (0 .5 .8) ? START_ON TOGGLE
Conveyors are stationary brushes that move what's on them.
The brush should be have a surface with at least one current content enabled.
speed	default 100
*/
X
void func_conveyor_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->spawnflags & 1)
X	{
X		self->speed = 0;
X		self->spawnflags &= ~1;
X	}
X	else
X	{
X		self->speed = self->count;
X		self->spawnflags |= 1;
X	}
X
X	if (!(self->spawnflags & 2))
X		self->count = 0;
}
X
void SP_func_conveyor (edict_t *self)
{
X	if (!self->speed)
X		self->speed = 100;
X
X	if (!(self->spawnflags & 1))
X	{
X		self->count = self->speed;
X		self->speed = 0;
X	}
X
X	self->use = func_conveyor_use;
X
X	gi.setmodel (self, self->model);
X	self->solid = SOLID_BSP;
X	gi.linkentity (self);
}
X
X
/*QUAKED func_door_secret (0 .5 .8) ? always_shoot 1st_left 1st_down
A secret door.  Slide back and then to the side.
X
open_once		doors never closes
1st_left		1st move is left of arrow
1st_down		1st move is down from arrow
always_shoot	door is shootebale even if targeted
X
"angle"		determines the direction
"dmg"		damage to inflic when blocked (default 2)
"wait"		how long to hold in the open position (default 5, -1 means hold)
*/
X
#define SECRET_ALWAYS_SHOOT	1
#define SECRET_1ST_LEFT		2
#define SECRET_1ST_DOWN		4
X
void door_secret_move1 (edict_t *self);
void door_secret_move2 (edict_t *self);
void door_secret_move3 (edict_t *self);
void door_secret_move4 (edict_t *self);
void door_secret_move5 (edict_t *self);
void door_secret_move6 (edict_t *self);
void door_secret_done (edict_t *self);
X
void door_secret_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	// make sure we're not already moving
X	if (!VectorCompare(self->s.origin, vec3_origin))
X		return;
X
X	Move_Calc (self, self->pos1, door_secret_move1);
X	door_use_areaportals (self, true);
}
X
void door_secret_move1 (edict_t *self)
{
X	self->nextthink = level.time + 1.0;
X	self->think = door_secret_move2;
}
X
void door_secret_move2 (edict_t *self)
{
X	Move_Calc (self, self->pos2, door_secret_move3);
}
X
void door_secret_move3 (edict_t *self)
{
X	if (self->wait == -1)
X		return;
X	self->nextthink = level.time + self->wait;
X	self->think = door_secret_move4;
}
X
void door_secret_move4 (edict_t *self)
{
X	Move_Calc (self, self->pos1, door_secret_move5);
}
X
void door_secret_move5 (edict_t *self)
{
X	self->nextthink = level.time + 1.0;
X	self->think = door_secret_move6;
}
X
void door_secret_move6 (edict_t *self)
{
X	Move_Calc (self, vec3_origin, door_secret_done);
}
X
void door_secret_done (edict_t *self)
{
X	if (!(self->targetname) || (self->spawnflags & SECRET_ALWAYS_SHOOT))
X	{
X		self->health = 0;
X		self->takedamage = DAMAGE_YES;
X	}
X	door_use_areaportals (self, false);
}
X
void door_secret_blocked  (edict_t *self, edict_t *other)
{
X	if (!(other->svflags & SVF_MONSTER) && (!other->client) )
X	{
X		// give it a chance to go away on it's own terms (like gibs)
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 100000, 1, 0, MOD_CRUSH);
X		// if it's still there, nuke it
X		if (other && other->inuse)
X			BecomeExplosion1 (other);
X		return;
X	}
X
X	if (level.time < self->touch_debounce_time)
X		return;
X	self->touch_debounce_time = level.time + 0.5;
X
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
}
X
void door_secret_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	self->takedamage = DAMAGE_NO;
X	door_secret_use (self, attacker, attacker);
}
X
void SP_func_door_secret (edict_t *ent)
{
X	vec3_t	forward, right, up;
X	float	side;
X	float	width;
X	float	length;
X
X	ent->moveinfo.sound_start = gi.soundindex  ("doors/dr1_strt.wav");
X	ent->moveinfo.sound_middle = gi.soundindex  ("doors/dr1_mid.wav");
X	ent->moveinfo.sound_end = gi.soundindex  ("doors/dr1_end.wav");
X
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_BSP;
X	gi.setmodel (ent, ent->model);
X
X	ent->blocked = door_secret_blocked;
X	ent->use = door_secret_use;
X
X	if (!(ent->targetname) || (ent->spawnflags & SECRET_ALWAYS_SHOOT))
X	{
X		ent->health = 0;
X		ent->takedamage = DAMAGE_YES;
X		ent->die = door_secret_die;
X	}
X
X	if (!ent->dmg)
X		ent->dmg = 2;
X
X	if (!ent->wait)
X		ent->wait = 5;
X
X	ent->moveinfo.accel =
X	ent->moveinfo.decel =
X	ent->moveinfo.speed = 50;
X
X	// calculate positions
X	AngleVectors (ent->s.angles, forward, right, up);
X	VectorClear (ent->s.angles);
X	side = 1.0 - (ent->spawnflags & SECRET_1ST_LEFT);
X	if (ent->spawnflags & SECRET_1ST_DOWN)
X		width = fabs(DotProduct(up, ent->size));
X	else
X		width = fabs(DotProduct(right, ent->size));
X	length = fabs(DotProduct(forward, ent->size));
X	if (ent->spawnflags & SECRET_1ST_DOWN)
X		VectorMA (ent->s.origin, -1 * width, up, ent->pos1);
X	else
X		VectorMA (ent->s.origin, side * width, right, ent->pos1);
X	VectorMA (ent->pos1, length, forward, ent->pos2);
X
X	if (ent->health)
X	{
X		ent->takedamage = DAMAGE_YES;
X		ent->die = door_killed;
X		ent->max_health = ent->health;
X	}
X	else if (ent->targetname && ent->message)
X	{
X		gi.soundindex ("misc/talk.wav");
X		ent->touch = door_touch;
X	}
X	
X	ent->classname = "func_door";
X
X	gi.linkentity (ent);
}
X
X
/*QUAKED func_killbox (1 0 0) ?
Kills everything inside when fired, irrespective of protection.
*/
void use_killbox (edict_t *self, edict_t *other, edict_t *activator)
{
X	KillBox (self);
}
X
void SP_func_killbox (edict_t *ent)
{
X	gi.setmodel (ent, ent->model);
X	ent->use = use_killbox;
X	ent->svflags = SVF_NOCLIENT;
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_func.c' &&
  chmod 0664 'g_func.c' ||
  $echo 'restore of' 'g_func.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_func.c:' 'MD5 check failed'
34f3964e46bf874165c1b20d37056caf  g_func.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_func.c'`"
    test 68796 -eq "$shar_count" ||
    $echo 'g_func.c:' 'original size' '68796,' 'current size' "$shar_count!"
  fi
fi
# ============= g_items.c ==============
if test -f 'g_items.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_items.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_items.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_items.c' &&
#include "g_local.h"
X
X
qboolean	Pickup_Weapon (edict_t *ent, edict_t *other);
void		Use_Weapon (edict_t *ent, gitem_t *inv);
void		Drop_Weapon (edict_t *ent, gitem_t *inv);
X
void Weapon_Blaster (edict_t *ent);
void Weapon_Shotgun (edict_t *ent);
void Weapon_SuperShotgun (edict_t *ent);
void Weapon_Machinegun (edict_t *ent);
void Weapon_Chaingun (edict_t *ent);
void Weapon_HyperBlaster (edict_t *ent);
void Weapon_RocketLauncher (edict_t *ent);
void Weapon_Grenade (edict_t *ent);
void Weapon_GrenadeLauncher (edict_t *ent);
void Weapon_Railgun (edict_t *ent);
void Weapon_BFG (edict_t *ent);
X
//=========
//Rogue Weapons
void Weapon_ChainFist (edict_t *ent);
void Weapon_Disintegrator (edict_t *ent);
void Weapon_ETF_Rifle (edict_t *ent);
void Weapon_Heatbeam (edict_t *ent);
void Weapon_Prox (edict_t *ent);
void Weapon_Tesla (edict_t *ent);
void Weapon_ProxLauncher (edict_t *ent);
//void Weapon_Nuke (edict_t *ent);
//Rogue Weapons
//=========
X
gitem_armor_t jacketarmor_info	= { 25,  50, .30, .00, ARMOR_JACKET};
gitem_armor_t combatarmor_info	= { 50, 100, .60, .30, ARMOR_COMBAT};
gitem_armor_t bodyarmor_info	= {100, 200, .80, .60, ARMOR_BODY};
X
static int	jacket_armor_index;
static int	combat_armor_index;
static int	body_armor_index;
static int	power_screen_index;
static int	power_shield_index;
X
#define HEALTH_IGNORE_MAX	1
#define HEALTH_TIMED		2
X
void Use_Quad (edict_t *ent, gitem_t *item);
static int	quad_drop_timeout_hack;
X
//======================================================================
X
/*
===============
GetItemByIndex
===============
*/
gitem_t	*GetItemByIndex (int index)
{
X	if (index == 0 || index >= game.num_items)
X		return NULL;
X
X	return &itemlist[index];
}
X
X
/*
===============
FindItemByClassname
X
===============
*/
gitem_t	*FindItemByClassname (char *classname)
{
X	int		i;
X	gitem_t	*it;
X
X	it = itemlist;
X	for (i=0 ; i<game.num_items ; i++, it++)
X	{
X		if (!it->classname)
X			continue;
X		if (!Q_stricmp(it->classname, classname))
X			return it;
X	}
X
X	return NULL;
}
X
/*
===============
FindItem
X
===============
*/
gitem_t	*FindItem (char *pickup_name)
{
X	int		i;
X	gitem_t	*it;
X
X	it = itemlist;
X	for (i=0 ; i<game.num_items ; i++, it++)
X	{
X		if (!it->pickup_name)
X			continue;
X		if (!Q_stricmp(it->pickup_name, pickup_name))
X			return it;
X	}
X
X	return NULL;
}
X
//======================================================================
X
void DoRespawn (edict_t *ent)
{
X	if (ent->team)
X	{
X		edict_t	*master;
X		int	count;
X		int choice;
X
X		master = ent->teammaster;
X
X		for (count = 0, ent = master; ent; ent = ent->chain, count++)
X			;
X
X		choice = rand() % count;
X
X		for (count = 0, ent = master; count < choice; ent = ent->chain, count++)
X			;
X	}
X
//=====
//ROGUE
X	if(randomrespawn && randomrespawn->value)
X	{
X		edict_t *newEnt;
X
X		newEnt = DoRandomRespawn (ent);
X		
X		// if we've changed entities, then do some sleight of hand.
X		// otherwise, the old entity will respawn
X		if(newEnt)
X		{
X			G_FreeEdict (ent);
X			ent = newEnt;
X		}
X	}
//ROGUE
//=====
X
X	ent->svflags &= ~SVF_NOCLIENT;
X	ent->solid = SOLID_TRIGGER;
X	gi.linkentity (ent);
X
X	// send an effect
X	ent->s.event = EV_ITEM_RESPAWN;
}
X
void SetRespawn (edict_t *ent, float delay)
{
X	ent->flags |= FL_RESPAWN;
X	ent->svflags |= SVF_NOCLIENT;
X	ent->solid = SOLID_NOT;
X	ent->nextthink = level.time + delay;
X	ent->think = DoRespawn;
X	gi.linkentity (ent);
}
X
X
//======================================================================
X
qboolean Pickup_Powerup (edict_t *ent, edict_t *other)
{
X	int		quantity;
X
X	quantity = other->client->pers.inventory[ITEM_INDEX(ent->item)];
X	if ((skill->value == 1 && quantity >= 2) || (skill->value >= 2 && quantity >= 1))
X		return false;
X
X	if ((coop->value) && (ent->item->flags & IT_STAY_COOP) && (quantity > 0))
X		return false;
X
X	other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X
X	if (deathmatch->value)
X	{
X		if (!(ent->spawnflags & DROPPED_ITEM) )
X			SetRespawn (ent, ent->item->quantity);
X		if (((int)dmflags->value & DF_INSTANT_ITEMS) || ((ent->item->use == Use_Quad) && (ent->spawnflags & DROPPED_PLAYER_ITEM)))
X		{
X			if ((ent->item->use == Use_Quad) && (ent->spawnflags & DROPPED_PLAYER_ITEM))
X				quad_drop_timeout_hack = (ent->nextthink - level.time) / FRAMETIME;
//PGM
X			if(ent->item->use)
X				ent->item->use (other, ent->item);
X			else
X				gi.dprintf("Powerup has no use function!\n");
//PGM
X		}
X	}
X
X	return true;
}
X
void Drop_General (edict_t *ent, gitem_t *item)
{
X	Drop_Item (ent, item);
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
}
X
X
//======================================================================
X
qboolean Pickup_Adrenaline (edict_t *ent, edict_t *other)
{
X	if (!deathmatch->value)
X		other->max_health += 1;
X
X	if (other->health < other->max_health)
X		other->health = other->max_health;
X
X	if (!(ent->spawnflags & DROPPED_ITEM) && (deathmatch->value))
X		SetRespawn (ent, ent->item->quantity);
X
X	return true;
}
X
qboolean Pickup_AncientHead (edict_t *ent, edict_t *other)
{
X	other->max_health += 2;
X
X	if (!(ent->spawnflags & DROPPED_ITEM) && (deathmatch->value))
X		SetRespawn (ent, ent->item->quantity);
X
X	return true;
}
X
qboolean Pickup_Bandolier (edict_t *ent, edict_t *other)
{
X	gitem_t	*item;
X	int		index;
X
X	if (other->client->pers.max_bullets < 250)
X		other->client->pers.max_bullets = 250;
X	if (other->client->pers.max_shells < 150)
X		other->client->pers.max_shells = 150;
X	if (other->client->pers.max_cells < 250)
X		other->client->pers.max_cells = 250;
X	if (other->client->pers.max_slugs < 75)
X		other->client->pers.max_slugs = 75;
X	//PMM
X	if (other->client->pers.max_flechettes < 250)
X		other->client->pers.max_flechettes = 250;
#ifndef KILL_DISRUPTOR
X	if (other->client->pers.max_rounds < 150)
X		other->client->pers.max_rounds = 150;
#endif
X	//pmm
X
X	item = FindItem("Bullets");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_bullets)
X			other->client->pers.inventory[index] = other->client->pers.max_bullets;
X	}
X
X	item = FindItem("Shells");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_shells)
X			other->client->pers.inventory[index] = other->client->pers.max_shells;
X	}
X
X	if (!(ent->spawnflags & DROPPED_ITEM) && (deathmatch->value))
X		SetRespawn (ent, ent->item->quantity);
X
X	return true;
}
X
qboolean Pickup_Pack (edict_t *ent, edict_t *other)
{
X	gitem_t	*item;
X	int		index;
X
X	if (other->client->pers.max_bullets < 300)
X		other->client->pers.max_bullets = 300;
X	if (other->client->pers.max_shells < 200)
X		other->client->pers.max_shells = 200;
X	if (other->client->pers.max_rockets < 100)
X		other->client->pers.max_rockets = 100;
X	if (other->client->pers.max_grenades < 100)
X		other->client->pers.max_grenades = 100;
X	if (other->client->pers.max_cells < 300)
X		other->client->pers.max_cells = 300;
X	if (other->client->pers.max_slugs < 100)
X		other->client->pers.max_slugs = 100;
X	//PMM
X	if (other->client->pers.max_flechettes < 200)
X		other->client->pers.max_flechettes = 200;
#ifndef KILL_DISRUPTOR
X	if (other->client->pers.max_rounds < 200)
X		other->client->pers.max_rounds = 200;
#endif
X	//pmm
X
X	item = FindItem("Bullets");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_bullets)
X			other->client->pers.inventory[index] = other->client->pers.max_bullets;
X	}
X
X	item = FindItem("Shells");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_shells)
X			other->client->pers.inventory[index] = other->client->pers.max_shells;
X	}
X
X	item = FindItem("Cells");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_cells)
X			other->client->pers.inventory[index] = other->client->pers.max_cells;
X	}
X
X	item = FindItem("Grenades");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_grenades)
X			other->client->pers.inventory[index] = other->client->pers.max_grenades;
X	}
X
X	item = FindItem("Rockets");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_rockets)
X			other->client->pers.inventory[index] = other->client->pers.max_rockets;
X	}
X
X	item = FindItem("Slugs");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_slugs)
X			other->client->pers.inventory[index] = other->client->pers.max_slugs;
X	}
//PMM
X	item = FindItem("Flechettes");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_flechettes)
X			other->client->pers.inventory[index] = other->client->pers.max_flechettes;
X	}
#ifndef KILL_DISRUPTOR
X	item = FindItem("Rounds");
X	if (item)
X	{
X		index = ITEM_INDEX(item);
X		other->client->pers.inventory[index] += item->quantity;
X		if (other->client->pers.inventory[index] > other->client->pers.max_rounds)
X			other->client->pers.inventory[index] = other->client->pers.max_rounds;
X	}
#endif
//pmm
X	if (!(ent->spawnflags & DROPPED_ITEM) && (deathmatch->value))
X		SetRespawn (ent, ent->item->quantity);
X
X	return true;
}
// ================
// PMM
qboolean Pickup_Nuke (edict_t *ent, edict_t *other)
{
X	int		quantity;
X
//	if (!deathmatch->value)
//		return;
X	quantity = other->client->pers.inventory[ITEM_INDEX(ent->item)];
//	if ((skill->value == 1 && quantity >= 2) || (skill->value >= 2 && quantity >= 1))
//		return false;
X
X	if (quantity >= 1)
X		return false;
X
X	if ((coop->value) && (ent->item->flags & IT_STAY_COOP) && (quantity > 0))
X		return false;
X
X	other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X
X	if (deathmatch->value)
X	{
X		if (!(ent->spawnflags & DROPPED_ITEM) )
X			SetRespawn (ent, ent->item->quantity);
X	}
X
X	return true;
}
X
// ================
// PGM
void Use_IR (edict_t *ent, gitem_t *item)
{
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	if (ent->client->ir_framenum > level.framenum)
X		ent->client->ir_framenum += 600;
X	else
X		ent->client->ir_framenum = level.framenum + 600;
X
X	gi.sound(ent, CHAN_ITEM, gi.soundindex("misc/ir_start.wav"), 1, ATTN_NORM, 0);
}
X
void Use_Double (edict_t *ent, gitem_t *item)
{
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	if (ent->client->double_framenum > level.framenum)
X		ent->client->double_framenum += 300;
X	else
X		ent->client->double_framenum = level.framenum + 300;
X
X	gi.sound(ent, CHAN_ITEM, gi.soundindex("misc/ddamage1.wav"), 1, ATTN_NORM, 0);
}
X
/*
void Use_Torch (edict_t *ent, gitem_t *item)
{
X	ent->client->torch_framenum = level.framenum + 600;
}
*/
X
void Use_Compass (edict_t *ent, gitem_t *item)
{
X	int ang;
X
X	ang = (int)(ent->client->v_angle[1]);
X	if(ang<0)
X		ang += 360;
X
X	gi.cprintf(ent, PRINT_HIGH, "Origin: %0.0f,%0.0f,%0.0f    Dir: %d\n", ent->s.origin[0], ent->s.origin[1],
X				ent->s.origin[2], ang);
}
X
void Use_Nuke (edict_t *ent, gitem_t *item)
{
X	vec3_t	forward, right, start;
X	float	speed;
X
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X
X	VectorCopy (ent->s.origin, start);
X	speed = 100;
X	fire_nuke (ent, start, forward, speed);
}
X
void Use_Doppleganger (edict_t *ent, gitem_t *item)
{
X	vec3_t		forward, right;
X	vec3_t		createPt, spawnPt;
X	vec3_t		ang;
X
X	VectorClear(ang);
X	ang[YAW] = ent->client->v_angle[YAW];
X	AngleVectors (ang, forward, right, NULL);
X
X	VectorMA(ent->s.origin, 48, forward, createPt);
X
X	if(!FindSpawnPoint(createPt, ent->mins, ent->maxs, spawnPt, 32))
X		return;
X
X	if(!CheckGroundSpawnPoint(spawnPt, ent->mins, ent->maxs, 64, -1))
X		return;
X
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	SpawnGrow_Spawn (spawnPt, 0);
X	fire_doppleganger (ent, spawnPt, forward);
}
X
qboolean Pickup_Doppleganger (edict_t *ent, edict_t *other)
{
X	int		quantity;
X
X	if(!(deathmatch->value))		// item is DM only
X		return false;
X
X	quantity = other->client->pers.inventory[ITEM_INDEX(ent->item)];
X	if (quantity >= 1)		// FIXME - apply max to dopplegangers
X		return false;
X
X	other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X
X	if (!(ent->spawnflags & DROPPED_ITEM) )
X		SetRespawn (ent, ent->item->quantity);
X
X	return true;
}
X
X
qboolean Pickup_Sphere (edict_t *ent, edict_t *other)
{
X	int		quantity;
X
X	if(other->client && other->client->owned_sphere)
X	{
//		gi.cprintf(other, PRINT_HIGH, "Only one sphere to a customer!\n");
X		return false;
X	}
X
X	quantity = other->client->pers.inventory[ITEM_INDEX(ent->item)];
X	if ((skill->value == 1 && quantity >= 2) || (skill->value >= 2 && quantity >= 1))
X		return false;
X
X	if ((coop->value) && (ent->item->flags & IT_STAY_COOP) && (quantity > 0))
X		return false;
X
X	other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X
X	if (deathmatch->value)
X	{
X		if (!(ent->spawnflags & DROPPED_ITEM) )
X			SetRespawn (ent, ent->item->quantity);
X		if (((int)dmflags->value & DF_INSTANT_ITEMS))
X		{
//PGM
X			if(ent->item->use)
X				ent->item->use (other, ent->item);
X			else
X				gi.dprintf("Powerup has no use function!\n");
//PGM
X		}
X	}
X
X	return true;
}
X
void Use_Defender (edict_t *ent, gitem_t *item)
{
X	if(ent->client && ent->client->owned_sphere)
X	{
X		gi.cprintf(ent, PRINT_HIGH, "Only one sphere at a time!\n");
X		return;
X	}
X
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	Defender_Launch (ent);
}
X
void Use_Hunter (edict_t *ent, gitem_t *item)
{
X	if(ent->client && ent->client->owned_sphere)
X	{
X		gi.cprintf(ent, PRINT_HIGH, "Only one sphere at a time!\n");
X		return;
X	}
X
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	Hunter_Launch (ent);
}
X
void Use_Vengeance (edict_t *ent, gitem_t *item)
{
X	if(ent->client && ent->client->owned_sphere)
X	{
X		gi.cprintf(ent, PRINT_HIGH, "Only one sphere at a time!\n");
X		return;
X	}
X
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	Vengeance_Launch (ent);
}
X
// PGM
// ================
X
X
//======================================================================
X
void Use_Quad (edict_t *ent, gitem_t *item)
{
X	int		timeout;
X
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	if (quad_drop_timeout_hack)
X	{
X		timeout = quad_drop_timeout_hack;
X		quad_drop_timeout_hack = 0;
X	}
X	else
X	{
X		timeout = 300;
X	}
X
X	if (ent->client->quad_framenum > level.framenum)
X		ent->client->quad_framenum += timeout;
X	else
X		ent->client->quad_framenum = level.framenum + timeout;
X
X	gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage.wav"), 1, ATTN_NORM, 0);
}
X
//======================================================================
X
void Use_Breather (edict_t *ent, gitem_t *item)
{
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	if (ent->client->breather_framenum > level.framenum)
X		ent->client->breather_framenum += 300;
X	else
X		ent->client->breather_framenum = level.framenum + 300;
X
//	gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage.wav"), 1, ATTN_NORM, 0);
}
X
//======================================================================
X
void Use_Envirosuit (edict_t *ent, gitem_t *item)
{
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	if (ent->client->enviro_framenum > level.framenum)
X		ent->client->enviro_framenum += 300;
X	else
X		ent->client->enviro_framenum = level.framenum + 300;
X
//	gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage.wav"), 1, ATTN_NORM, 0);
}
X
//======================================================================
X
void	Use_Invulnerability (edict_t *ent, gitem_t *item)
{
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X
X	if (ent->client->invincible_framenum > level.framenum)
X		ent->client->invincible_framenum += 300;
X	else
X		ent->client->invincible_framenum = level.framenum + 300;
X
X	gi.sound(ent, CHAN_ITEM, gi.soundindex("items/protect.wav"), 1, ATTN_NORM, 0);
}
X
//======================================================================
X
void	Use_Silencer (edict_t *ent, gitem_t *item)
{
X	ent->client->pers.inventory[ITEM_INDEX(item)]--;
X	ValidateSelectedItem (ent);
X	ent->client->silencer_shots += 30;
X
//	gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage.wav"), 1, ATTN_NORM, 0);
}
X
//======================================================================
X
qboolean Pickup_Key (edict_t *ent, edict_t *other)
{
X	if (coop->value)
X	{
X		if (strcmp(ent->classname, "key_power_cube") == 0)
X		{
X			if (other->client->pers.power_cubes & ((ent->spawnflags & 0x0000ff00)>> 8))
X				return false;
X			other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X			other->client->pers.power_cubes |= ((ent->spawnflags & 0x0000ff00) >> 8);
X		}
X		else
X		{
X			if (other->client->pers.inventory[ITEM_INDEX(ent->item)])
X				return false;
X			other->client->pers.inventory[ITEM_INDEX(ent->item)] = 1;
X		}
X		return true;
X	}
X	other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X	return true;
}
X
//======================================================================
X
qboolean Add_Ammo (edict_t *ent, gitem_t *item, int count)
{
X	int			index;
X	int			max;
X
X	if (!ent->client)
X		return false;
X
X	if (item->tag == AMMO_BULLETS)
X		max = ent->client->pers.max_bullets;
X	else if (item->tag == AMMO_SHELLS)
X		max = ent->client->pers.max_shells;
X	else if (item->tag == AMMO_ROCKETS)
X		max = ent->client->pers.max_rockets;
X	else if (item->tag == AMMO_GRENADES)
X		max = ent->client->pers.max_grenades;
X	else if (item->tag == AMMO_CELLS)
X		max = ent->client->pers.max_cells;
X	else if (item->tag == AMMO_SLUGS)
X		max = ent->client->pers.max_slugs;
// ROGUE
//	else if (item->tag == AMMO_MINES)
//		max = ent->client->pers.max_mines;
X	else if (item->tag == AMMO_FLECHETTES)
X		max = ent->client->pers.max_flechettes;
X	else if (item->tag == AMMO_PROX)
X		max = ent->client->pers.max_prox;
X	else if (item->tag == AMMO_TESLA)
X		max = ent->client->pers.max_tesla;
#ifndef KILL_DISRUPTOR
X	else if (item->tag == AMMO_DISRUPTOR)
X		max = ent->client->pers.max_rounds;
#endif
// ROGUE
X	else
X	{
X		gi.dprintf("undefined ammo type\n");
X		return false;
X	}
X
X	index = ITEM_INDEX(item);
X
X	if (ent->client->pers.inventory[index] == max)
X		return false;
X
X	ent->client->pers.inventory[index] += count;
X
X	if (ent->client->pers.inventory[index] > max)
X		ent->client->pers.inventory[index] = max;
X
X	return true;
}
X
qboolean Pickup_Ammo (edict_t *ent, edict_t *other)
{
X	int			oldcount;
X	int			count;
X	qboolean	weapon;
X
X	weapon = (ent->item->flags & IT_WEAPON);
X	if ( (weapon) && ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		count = 1000;
X	else if (ent->count)
X		count = ent->count;
X	else
X		count = ent->item->quantity;
X
X	oldcount = other->client->pers.inventory[ITEM_INDEX(ent->item)];
X
X	if (!Add_Ammo (other, ent->item, count))
X		return false;
X
X	if (weapon && !oldcount)
X	{
X		// don't switch to tesla
X		if (other->client->pers.weapon != ent->item
X				&& ( !deathmatch->value || other->client->pers.weapon == FindItem("blaster"))
X				&& (strcmp(ent->classname, "ammo_tesla")) )
X
X			other->client->newweapon = ent->item;
X	}
X
X	if (!(ent->spawnflags & (DROPPED_ITEM | DROPPED_PLAYER_ITEM)) && (deathmatch->value))
X		SetRespawn (ent, 30);
X	return true;
}
X
void Drop_Ammo (edict_t *ent, gitem_t *item)
{
X	edict_t	*dropped;
X	int		index;
X
X	index = ITEM_INDEX(item);
X	dropped = Drop_Item (ent, item);
X	if (ent->client->pers.inventory[index] >= item->quantity)
X		dropped->count = item->quantity;
X	else
X		dropped->count = ent->client->pers.inventory[index];
X
X	if (ent->client->pers.weapon && 
X		ent->client->pers.weapon->tag == AMMO_GRENADES &&
X		item->tag == AMMO_GRENADES &&
X		ent->client->pers.inventory[index] - dropped->count <= 0) {
X		gi.cprintf (ent, PRINT_HIGH, "Can't drop current weapon\n");
X		G_FreeEdict(dropped);
X		return;
X	}
X
X	ent->client->pers.inventory[index] -= dropped->count;
X	ValidateSelectedItem (ent);
}
X
X
//======================================================================
X
void MegaHealth_think (edict_t *self)
{
X	if (self->owner->health > self->owner->max_health)
X	{
X		self->nextthink = level.time + 1;
X		self->owner->health -= 1;
X		return;
X	}
X
X	if (!(self->spawnflags & DROPPED_ITEM) && (deathmatch->value))
X		SetRespawn (self, 20);
X	else
X		G_FreeEdict (self);
}
X
qboolean Pickup_Health (edict_t *ent, edict_t *other)
{
X	if (!(ent->style & HEALTH_IGNORE_MAX))
X		if (other->health >= other->max_health)
X			return false;
X
X	other->health += ent->count;
X
X	// PMM - health sound fix
X	/*
X	if (ent->count == 2)
X		ent->item->pickup_sound = "items/s_health.wav";
X	else if (ent->count == 10)
X		ent->item->pickup_sound = "items/n_health.wav";
X	else if (ent->count == 25)
X		ent->item->pickup_sound = "items/l_health.wav";
X	else // (ent->count == 100)
X		ent->item->pickup_sound = "items/m_health.wav";
X	*/
X
X	if (!(ent->style & HEALTH_IGNORE_MAX))
X	{
X		if (other->health > other->max_health)
X			other->health = other->max_health;
X	}
X
X	if (ent->style & HEALTH_TIMED)
X	{
X		ent->think = MegaHealth_think;
X		ent->nextthink = level.time + 5;
X		ent->owner = other;
X		ent->flags |= FL_RESPAWN;
X		ent->svflags |= SVF_NOCLIENT;
X		ent->solid = SOLID_NOT;
X	}
X	else
X	{
X		if (!(ent->spawnflags & DROPPED_ITEM) && (deathmatch->value))
X			SetRespawn (ent, 30);
X	}
X
X	return true;
}
X
//======================================================================
X
int ArmorIndex (edict_t *ent)
{
X	if (!ent->client)
X		return 0;
X
X	if (ent->client->pers.inventory[jacket_armor_index] > 0)
X		return jacket_armor_index;
X
X	if (ent->client->pers.inventory[combat_armor_index] > 0)
X		return combat_armor_index;
X
X	if (ent->client->pers.inventory[body_armor_index] > 0)
X		return body_armor_index;
X
X	return 0;
}
X
qboolean Pickup_Armor (edict_t *ent, edict_t *other)
{
X	int				old_armor_index;
X	gitem_armor_t	*oldinfo;
X	gitem_armor_t	*newinfo;
X	int				newcount;
X	float			salvage;
X	int				salvagecount;
X
X	// get info on new armor
X	newinfo = (gitem_armor_t *)ent->item->info;
X
X	old_armor_index = ArmorIndex (other);
X
X	// handle armor shards specially
X	if (ent->item->tag == ARMOR_SHARD)
X	{
X		if (!old_armor_index)
X			other->client->pers.inventory[jacket_armor_index] = 2;
X		else
X			other->client->pers.inventory[old_armor_index] += 2;
X	}
X
X	// if player has no armor, just use it
X	else if (!old_armor_index)
X	{
X		other->client->pers.inventory[ITEM_INDEX(ent->item)] = newinfo->base_count;
X	}
X
X	// use the better armor
X	else
X	{
X		// get info on old armor
X		if (old_armor_index == jacket_armor_index)
X			oldinfo = &jacketarmor_info;
X		else if (old_armor_index == combat_armor_index)
X			oldinfo = &combatarmor_info;
X		else // (old_armor_index == body_armor_index)
X			oldinfo = &bodyarmor_info;
X
X		if (newinfo->normal_protection > oldinfo->normal_protection)
X		{
X			// calc new armor values
X			salvage = oldinfo->normal_protection / newinfo->normal_protection;
X			salvagecount = salvage * other->client->pers.inventory[old_armor_index];
X			newcount = newinfo->base_count + salvagecount;
X			if (newcount > newinfo->max_count)
X				newcount = newinfo->max_count;
X
X			// zero count of old armor so it goes away
X			other->client->pers.inventory[old_armor_index] = 0;
X
X			// change armor to new item with computed value
X			other->client->pers.inventory[ITEM_INDEX(ent->item)] = newcount;
X		}
X		else
X		{
X			// calc new armor values
X			salvage = newinfo->normal_protection / oldinfo->normal_protection;
X			salvagecount = salvage * newinfo->base_count;
X			newcount = other->client->pers.inventory[old_armor_index] + salvagecount;
X			if (newcount > oldinfo->max_count)
X				newcount = oldinfo->max_count;
X
X			// if we're already maxed out then we don't need the new armor
X			if (other->client->pers.inventory[old_armor_index] >= newcount)
X				return false;
X
X			// update current armor value
X			other->client->pers.inventory[old_armor_index] = newcount;
X		}
X	}
X
X	if (!(ent->spawnflags & DROPPED_ITEM) && (deathmatch->value))
X		SetRespawn (ent, 20);
X
X	return true;
}
X
//======================================================================
X
int PowerArmorType (edict_t *ent)
{
X	if (!ent->client)
X		return POWER_ARMOR_NONE;
X
X	if (!(ent->flags & FL_POWER_ARMOR))
X		return POWER_ARMOR_NONE;
X
X	if (ent->client->pers.inventory[power_shield_index] > 0)
X		return POWER_ARMOR_SHIELD;
X
X	if (ent->client->pers.inventory[power_screen_index] > 0)
X		return POWER_ARMOR_SCREEN;
X
X	return POWER_ARMOR_NONE;
}
X
void Use_PowerArmor (edict_t *ent, gitem_t *item)
{
X	int		index;
X
X	if (ent->flags & FL_POWER_ARMOR)
X	{
X		ent->flags &= ~FL_POWER_ARMOR;
X		gi.sound(ent, CHAN_AUTO, gi.soundindex("misc/power2.wav"), 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		index = ITEM_INDEX(FindItem("cells"));
X		if (!ent->client->pers.inventory[index])
X		{
X			gi.cprintf (ent, PRINT_HIGH, "No cells for power armor.\n");
X			return;
X		}
X		ent->flags |= FL_POWER_ARMOR;
X		gi.sound(ent, CHAN_AUTO, gi.soundindex("misc/power1.wav"), 1, ATTN_NORM, 0);
X	}
}
X
qboolean Pickup_PowerArmor (edict_t *ent, edict_t *other)
{
X	int		quantity;
X
X	quantity = other->client->pers.inventory[ITEM_INDEX(ent->item)];
X
X	other->client->pers.inventory[ITEM_INDEX(ent->item)]++;
X
X	if (deathmatch->value)
X	{
X		if (!(ent->spawnflags & DROPPED_ITEM) )
X			SetRespawn (ent, ent->item->quantity);
X		// auto-use for DM only if we didn't already have one
X		if (!quantity)
X			ent->item->use (other, ent->item);
X	}
X
X	return true;
}
X
void Drop_PowerArmor (edict_t *ent, gitem_t *item)
{
X	if ((ent->flags & FL_POWER_ARMOR) && (ent->client->pers.inventory[ITEM_INDEX(item)] == 1))
X		Use_PowerArmor (ent, item);
X	Drop_General (ent, item);
}
X
//======================================================================
X
/*
===============
Touch_Item
===============
*/
void Touch_Item (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	qboolean	taken;
X
X	if (!other->client)
X		return;
X	if (other->health < 1)
X		return;		// dead people can't pickup
X	if (!ent->item->pickup)
X		return;		// not a grabbable item?
X
X	taken = ent->item->pickup(ent, other);
X
X	if (taken)
X	{
X		// flash the screen
X		other->client->bonus_alpha = 0.25;	
X
X		// show icon and name on status bar
X		other->client->ps.stats[STAT_PICKUP_ICON] = gi.imageindex(ent->item->icon);
X		other->client->ps.stats[STAT_PICKUP_STRING] = CS_ITEMS+ITEM_INDEX(ent->item);
X		other->client->pickup_msg_time = level.time + 3.0;
X
X		// change selected item
X		if (ent->item->use)
X			other->client->pers.selected_item = other->client->ps.stats[STAT_SELECTED_ITEM] = ITEM_INDEX(ent->item);
X
X		// PMM - health sound fix
X		if (ent->item->pickup == Pickup_Health)
X		{
X			if (ent->count == 2)
X				gi.sound(other, CHAN_ITEM, gi.soundindex("items/s_health.wav"), 1, ATTN_NORM, 0);
X			else if (ent->count == 10)
X				gi.sound(other, CHAN_ITEM, gi.soundindex("items/n_health.wav"), 1, ATTN_NORM, 0);
X			else if (ent->count == 25)
X				gi.sound(other, CHAN_ITEM, gi.soundindex("items/l_health.wav"), 1, ATTN_NORM, 0);
X			else // (ent->count == 100)
X				gi.sound(other, CHAN_ITEM, gi.soundindex("items/m_health.wav"), 1, ATTN_NORM, 0);
X		}
X		else if (ent->item->pickup_sound) // PGM - paranoia
X		{
X		//
X			gi.sound(other, CHAN_ITEM, gi.soundindex(ent->item->pickup_sound), 1, ATTN_NORM, 0);
X		}
X	}
X
X	if (!(ent->spawnflags & ITEM_TARGETS_USED))
X	{
X		G_UseTargets (ent, other);
X		ent->spawnflags |= ITEM_TARGETS_USED;
X	}
X
X	if (!taken)
X		return;
X
X	if (!((coop->value) &&  (ent->item->flags & IT_STAY_COOP)) || (ent->spawnflags & (DROPPED_ITEM | DROPPED_PLAYER_ITEM)))
X	{
X		if (ent->flags & FL_RESPAWN)
X			ent->flags &= ~FL_RESPAWN;
X		else
X			G_FreeEdict (ent);
X	}
}
X
//======================================================================
X
static void drop_temp_touch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other == ent->owner)
X		return;
X
X	Touch_Item (ent, other, plane, surf);
}
X
static void drop_make_touchable (edict_t *ent)
{
X	ent->touch = Touch_Item;
X	if (deathmatch->value)
X	{
X		ent->nextthink = level.time + 29;
X		ent->think = G_FreeEdict;
X	}
}
X
edict_t *Drop_Item (edict_t *ent, gitem_t *item)
{
X	edict_t	*dropped;
X	vec3_t	forward, right;
X	vec3_t	offset;
X
X	dropped = G_Spawn();
X
X	dropped->classname = item->classname;
X	dropped->item = item;
X	dropped->spawnflags = DROPPED_ITEM;
X	dropped->s.effects = item->world_model_flags;
X	dropped->s.renderfx = RF_GLOW | RF_IR_VISIBLE;		// PGM
X	VectorSet (dropped->mins, -15, -15, -15);
X	VectorSet (dropped->maxs, 15, 15, 15);
X	gi.setmodel (dropped, dropped->item->world_model);
X	dropped->solid = SOLID_TRIGGER;
X	dropped->movetype = MOVETYPE_TOSS;  
X	dropped->touch = drop_temp_touch;
X	dropped->owner = ent;
X
X	if (ent->client)
X	{
X		trace_t	trace;
X
X		AngleVectors (ent->client->v_angle, forward, right, NULL);
X		VectorSet(offset, 24, 0, -16);
X		G_ProjectSource (ent->s.origin, offset, forward, right, dropped->s.origin);
X		trace = gi.trace (ent->s.origin, dropped->mins, dropped->maxs,
X			dropped->s.origin, ent, CONTENTS_SOLID);
X		VectorCopy (trace.endpos, dropped->s.origin);
X	}
X	else
X	{
X		AngleVectors (ent->s.angles, forward, right, NULL);
X		VectorCopy (ent->s.origin, dropped->s.origin);
X	}
X
X	VectorScale (forward, 100, dropped->velocity);
X	dropped->velocity[2] = 300;
X
X	dropped->think = drop_make_touchable;
X	dropped->nextthink = level.time + 1;
X
X	gi.linkentity (dropped);
X
X	return dropped;
}
X
void Use_Item (edict_t *ent, edict_t *other, edict_t *activator)
{
X	ent->svflags &= ~SVF_NOCLIENT;
X	ent->use = NULL;
X
X	if (ent->spawnflags & ITEM_NO_TOUCH)
X	{
X		ent->solid = SOLID_BBOX;
X		ent->touch = NULL;
X	}
X	else
X	{
X		ent->solid = SOLID_TRIGGER;
X		ent->touch = Touch_Item;
X	}
X
X	gi.linkentity (ent);
}
X
//======================================================================
X
/*
================
droptofloor
================
*/
void droptofloor (edict_t *ent)
{
X	trace_t		tr;
X	vec3_t		dest;
X	float		*v;
X
X	v = tv(-15,-15,-15);
X	VectorCopy (v, ent->mins);
X	v = tv(15,15,15);
X	VectorCopy (v, ent->maxs);
X
X	if (ent->model)
X		gi.setmodel (ent, ent->model);
X	else if (ent->item->world_model)	// PGM we shouldn't need this check, but paranoia...
X		gi.setmodel (ent, ent->item->world_model);
X	ent->solid = SOLID_TRIGGER;
X	ent->movetype = MOVETYPE_TOSS;  
X	ent->touch = Touch_Item;
X
X	v = tv(0,0,-128);
X	VectorAdd (ent->s.origin, v, dest);
X
X	tr = gi.trace (ent->s.origin, ent->mins, ent->maxs, dest, ent, MASK_SOLID);
X	if (tr.startsolid)
X	{
X		gi.dprintf ("droptofloor: %s startsolid at %s\n", ent->classname, vtos(ent->s.origin));
X		G_FreeEdict (ent);
X		return;
X	}
X
X	VectorCopy (tr.endpos, ent->s.origin);
X
X	if (ent->team)
X	{
X		ent->flags &= ~FL_TEAMSLAVE;
X		ent->chain = ent->teamchain;
X		ent->teamchain = NULL;
X
X		ent->svflags |= SVF_NOCLIENT;
X		ent->solid = SOLID_NOT;
X		if (ent == ent->teammaster)
X		{
X			ent->nextthink = level.time + FRAMETIME;
X			ent->think = DoRespawn;
X		}
X	}
X
X	if (ent->spawnflags & ITEM_NO_TOUCH)
X	{
X		ent->solid = SOLID_BBOX;
X		ent->touch = NULL;
X		ent->s.effects &= ~EF_ROTATE;
X		ent->s.renderfx &= ~RF_GLOW;
X	}
X
X	if (ent->spawnflags & ITEM_TRIGGER_SPAWN)
X	{
X		ent->svflags |= SVF_NOCLIENT;
X		ent->solid = SOLID_NOT;
X		ent->use = Use_Item;
X	}
X
X	gi.linkentity (ent);
}
X
X
/*
===============
PrecacheItem
X
Precaches all data needed for a given item.
This will be called for each item spawned in a level,
and for each item in each client's inventory.
===============
*/
void PrecacheItem (gitem_t *it)
{
X	char	*s, *start;
X	char	data[MAX_QPATH];
X	int		len;
X	gitem_t	*ammo;
X
X	if (!it)
X		return;
X
X	if (it->pickup_sound)
X		gi.soundindex (it->pickup_sound);
X	if (it->world_model)
X		gi.modelindex (it->world_model);
X	if (it->view_model)
X		gi.modelindex (it->view_model);
X	if (it->icon)
X		gi.imageindex (it->icon);
X
X	// parse everything for its ammo
X	if (it->ammo && it->ammo[0])
X	{
X		ammo = FindItem (it->ammo);
X		if (ammo != it)
X			PrecacheItem (ammo);
X	}
X
X	// parse the space seperated precache string for other items
X	s = it->precaches;
X	if (!s || !s[0])
X		return;
X
X	while (*s)
X	{
X		start = s;
X		while (*s && *s != ' ')
X			s++;
X
X		len = s-start;
X		if (len >= MAX_QPATH || len < 5)
X			gi.error ("PrecacheItem: %s has bad precache string", it->classname);
X		memcpy (data, start, len);
X		data[len] = 0;
X		if (*s)
X			s++;
X
X		// determine type based on extension
X		if (!strcmp(data+len-3, "md2"))
X			gi.modelindex (data);
X		else if (!strcmp(data+len-3, "sp2"))
X			gi.modelindex (data);
X		else if (!strcmp(data+len-3, "wav"))
X			gi.soundindex (data);
X		if (!strcmp(data+len-3, "pcx"))
X			gi.imageindex (data);
X	}
}
X
X
//=================
// Item_TriggeredSpawn - create the item marked for spawn creation
//=================
void Item_TriggeredSpawn (edict_t *self, edict_t *other, edict_t *activator)
{
//	self->nextthink = level.time + 2 * FRAMETIME;    // items start after other solids
//	self->think = droptofloor;
X	self->svflags &= ~SVF_NOCLIENT;
X	self->use = NULL;
X	if(strcmp(self->classname, "key_power_cube"))	// leave them be on key_power_cube..
X		self->spawnflags = 0;
X	droptofloor (self);
}
X
//=================
// SetTriggeredSpawn - set up an item to spawn in later.
//=================
void SetTriggeredSpawn (edict_t *ent)
{
X	// don't do anything on key_power_cubes.
X	if(!strcmp(ent->classname, "key_power_cube"))
X		return;
X
X	ent->think = NULL;
X	ent->nextthink = 0;
X	ent->use = Item_TriggeredSpawn;
X	ent->svflags |= SVF_NOCLIENT;
X	ent->solid = SOLID_NOT;
}
X
/*
============
SpawnItem
X
Sets the clipping size and plants the object on the floor.
X
Items can't be immediately dropped to floor, because they might
be on an entity that hasn't spawned yet.
============
*/
void SpawnItem (edict_t *ent, gitem_t *item)
{
#if KILL_DISRUPTOR
X	if ((!strcmp(ent->classname, "ammo_disruptor")) || (!strcmp(ent->classname, "weapon_disintegrator")))
X	{
X		G_FreeEdict (ent);
X		return;
X	}
#endif
X
// PGM - since the item may be freed by the following rules, go ahead
//		 and move the precache until AFTER the following rules have been checked.
//		 keep an eye on this.
//	PrecacheItem (item);
X
X	if (ent->spawnflags > 1)		// PGM
X	{
X		if (strcmp(ent->classname, "key_power_cube") != 0)
X		{
X			ent->spawnflags = 0;
X			gi.dprintf("%s at %s has invalid spawnflags set\n", ent->classname, vtos(ent->s.origin));
X		}
X	}
X
X	// some items will be prevented in deathmatch
X	if (deathmatch->value)
X	{
X		if ( (int)dmflags->value & DF_NO_ARMOR )
X		{
X			if (item->pickup == Pickup_Armor || item->pickup == Pickup_PowerArmor)
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X		}
X		if ( (int)dmflags->value & DF_NO_ITEMS )
X		{
X			if (item->pickup == Pickup_Powerup)
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X			//=====
X			//ROGUE
X			if (item->pickup  == Pickup_Sphere)
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X			if (item->pickup == Pickup_Doppleganger)
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X			//ROGUE
X			//=====
X		}
X		if ( (int)dmflags->value & DF_NO_HEALTH )
X		{
X			if (item->pickup == Pickup_Health || item->pickup == Pickup_Adrenaline || item->pickup == Pickup_AncientHead)
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X		}
X		if ( (int)dmflags->value & DF_INFINITE_AMMO )
X		{
X			if ( (item->flags == IT_AMMO) || (strcmp(ent->classname, "weapon_bfg") == 0) )
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X		}
X
//==========
//ROGUE
X		if ( (int)dmflags->value & DF_NO_MINES )
X		{
X			if ( !strcmp(ent->classname, "ammo_prox") || 
X				 !strcmp(ent->classname, "ammo_tesla") )
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X		}
X		if ( (int)dmflags->value & DF_NO_NUKES )
X		{
X			if ( !strcmp(ent->classname, "ammo_nuke") )
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X		}
X		if ( (int)dmflags->value & DF_NO_SPHERES )
X		{
X			if (item->pickup  == Pickup_Sphere)
X			{
X				G_FreeEdict (ent);
X				return;
X			}
X		}
//ROGUE
//==========
X
X	}
//==========
//ROGUE
// DM only items
X	if (!deathmatch->value)
X	{
X		if (item->pickup == Pickup_Doppleganger || item->pickup == Pickup_Nuke)
X		{
X			G_FreeEdict (ent);
X			return;
X		}
X		if ((item->use == Use_Vengeance) || (item->use == Use_Hunter))
X		{
X			G_FreeEdict (ent);
X			return;
X		}
X	}
//ROGUE
//==========
X
//PGM 
X	PrecacheItem (item);		
//PGM
X
X	if (coop->value && (strcmp(ent->classname, "key_power_cube") == 0))
X	{
X		ent->spawnflags |= (1 << (8 + level.power_cubes));
X		level.power_cubes++;
X	}
X
X	// don't let them drop items that stay in a coop game
X	if ((coop->value) && (item->flags & IT_STAY_COOP))
X	{
X		item->drop = NULL;
X	}
X
X	ent->item = item;
X	ent->nextthink = level.time + 2 * FRAMETIME;    // items start after other solids
X	ent->think = droptofloor;
X	ent->s.effects = item->world_model_flags;
X	ent->s.renderfx = RF_GLOW;
X	if (ent->model)
X		gi.modelindex (ent->model);
X
X	if (ent->spawnflags & 1)
X		SetTriggeredSpawn (ent);
}
X
//======================================================================
X
gitem_t	itemlist[] = 
{
X	{
X		NULL
X	},	// leave index 0 alone
X
X	//
X	// ARMOR
X	//
X
/*QUAKED item_armor_body (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_armor_body", 
X		Pickup_Armor,
X		NULL,
X		NULL,
X		NULL,
X		"misc/ar1_pkup.wav",
X		"models/items/armor/body/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_bodyarmor",
/* pickup */	"Body Armor",
/* width */		3,
X		0,
X		NULL,
X		IT_ARMOR,
X		0,
X		&bodyarmor_info,
X		ARMOR_BODY,
/* precache */ ""
X	},
X
/*QUAKED item_armor_combat (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_armor_combat", 
X		Pickup_Armor,
X		NULL,
X		NULL,
X		NULL,
X		"misc/ar1_pkup.wav",
X		"models/items/armor/combat/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_combatarmor",
/* pickup */	"Combat Armor",
/* width */		3,
X		0,
X		NULL,
X		IT_ARMOR,
X		0,
X		&combatarmor_info,
X		ARMOR_COMBAT,
/* precache */ ""
X	},
X
/*QUAKED item_armor_jacket (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_armor_jacket", 
X		Pickup_Armor,
X		NULL,
X		NULL,
X		NULL,
X		"misc/ar1_pkup.wav",
X		"models/items/armor/jacket/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_jacketarmor",
/* pickup */	"Jacket Armor",
/* width */		3,
X		0,
X		NULL,
X		IT_ARMOR,
X		0,
X		&jacketarmor_info,
X		ARMOR_JACKET,
/* precache */ ""
X	},
X
/*QUAKED item_armor_shard (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_armor_shard", 
X		Pickup_Armor,
X		NULL,
X		NULL,
X		NULL,
X		"misc/ar2_pkup.wav",
X		"models/items/armor/shard/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_jacketarmor",
/* pickup */	"Armor Shard",
/* width */		3,
X		0,
X		NULL,
X		IT_ARMOR,
X		0,
X		NULL,
X		ARMOR_SHARD,
/* precache */ ""
X	},
X
X
/*QUAKED item_power_screen (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_power_screen", 
X		Pickup_PowerArmor,
X		Use_PowerArmor,
X		Drop_PowerArmor,
X		NULL,
X		"misc/ar3_pkup.wav",
X		"models/items/armor/screen/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_powerscreen",
/* pickup */	"Power Screen",
/* width */		0,
X		60,
X		NULL,
X		IT_ARMOR,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED item_power_shield (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_power_shield",
X		Pickup_PowerArmor,
X		Use_PowerArmor,
X		Drop_PowerArmor,
X		NULL,
X		"misc/ar3_pkup.wav",
X		"models/items/armor/shield/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_powershield",
/* pickup */	"Power Shield",
/* width */		0,
X		60,
X		NULL,
X		IT_ARMOR,
X		0,
X		NULL,
X		0,
/* precache */ "misc/power2.wav misc/power1.wav"
X	},
X
X
X	//
X	// WEAPONS 
X	//
X
/* weapon_blaster (.3 .3 1) (-16 -16 -16) (16 16 16)
always owned, never in the world
*/
X	{
X		"weapon_blaster", 
X		NULL,
X		Use_Weapon,
X		NULL,
X		Weapon_Blaster,
X		"misc/w_pkup.wav",
X		NULL, 0,
X		"models/weapons/v_blast/tris.md2",
/* icon */		"w_blaster",
/* pickup */	"Blaster",
X		0,
X		0,
X		NULL,
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_BLASTER,
X		NULL,
X		0,
/* precache */ "weapons/blastf1a.wav misc/lasfly.wav"
X	},
X
/*QUAKED weapon_shotgun (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_shotgun", 
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_Shotgun,
X		"misc/w_pkup.wav",
X		"models/weapons/g_shotg/tris.md2", EF_ROTATE,
X		"models/weapons/v_shotg/tris.md2",
/* icon */		"w_shotgun",
/* pickup */	"Shotgun",
X		0,
X		1,
X		"Shells",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_SHOTGUN,
X		NULL,
X		0,
/* precache */ "weapons/shotgf1b.wav weapons/shotgr1b.wav"
X	},
X
/*QUAKED weapon_supershotgun (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_supershotgun", 
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_SuperShotgun,
X		"misc/w_pkup.wav",
X		"models/weapons/g_shotg2/tris.md2", EF_ROTATE,
X		"models/weapons/v_shotg2/tris.md2",
/* icon */		"w_sshotgun",
/* pickup */	"Super Shotgun",
X		0,
X		2,
X		"Shells",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_SUPERSHOTGUN,
X		NULL,
X		0,
/* precache */ "weapons/sshotf1b.wav"
X	},
X
/*QUAKED weapon_machinegun (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_machinegun", 
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_Machinegun,
X		"misc/w_pkup.wav",
X		"models/weapons/g_machn/tris.md2", EF_ROTATE,
X		"models/weapons/v_machn/tris.md2",
/* icon */		"w_machinegun",
/* pickup */	"Machinegun",
X		0,
X		1,
X		"Bullets",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_MACHINEGUN,
X		NULL,
X		0,
/* precache */ "weapons/machgf1b.wav weapons/machgf2b.wav weapons/machgf3b.wav weapons/machgf4b.wav weapons/machgf5b.wav"
X	},
X
/*QUAKED weapon_chaingun (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_chaingun", 
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_Chaingun,
X		"misc/w_pkup.wav",
X		"models/weapons/g_chain/tris.md2", EF_ROTATE,
X		"models/weapons/v_chain/tris.md2",
/* icon */		"w_chaingun",
/* pickup */	"Chaingun",
X		0,
X		1,
X		"Bullets",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_CHAINGUN,
X		NULL,
X		0,
/* precache */ "weapons/chngnu1a.wav weapons/chngnl1a.wav weapons/machgf3b.wav` weapons/chngnd1a.wav"
X	},
X
X	// ROGUE
/*QUAKED weapon_etf_rifle (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_etf_rifle",									// classname
X		Pickup_Weapon,										// pickup function
X		Use_Weapon,											// use function
X		Drop_Weapon,										// drop function
X		Weapon_ETF_Rifle,									// weapon think function
X		"misc/w_pkup.wav",									// pick up sound
X		"models/weapons/g_etf_rifle/tris.md2", EF_ROTATE,		// world model, world model flags
X		"models/weapons/v_etf_rifle/tris.md2",					// view model
X		"w_etf_rifle",										// icon
X		"ETF Rifle",										// name printed when picked up 
X		0,													// number of digits for statusbar
X		1,													// amount used / contained
X		"Flechettes",										// ammo type used 
X		IT_WEAPON,											// inventory flags
X		WEAP_ETFRIFLE,										// visible weapon
X		NULL,												// info (void *)
X		0,													// tag
X		"weapons/nail1.wav models/proj/flechette/tris.md2",	// precaches
X	},
X
X	// rogue
/*QUAKED ammo_grenades (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_grenades",
X		Pickup_Ammo,
X		Use_Weapon,
X		Drop_Ammo,
X		Weapon_Grenade,
X		"misc/am_pkup.wav",
X		"models/items/ammo/grenades/medium/tris.md2", 0,
X		"models/weapons/v_handgr/tris.md2",
/* icon */		"a_grenades",
/* pickup */	"Grenades",
/* width */		3,
X		5,
X		"grenades",
X		IT_AMMO|IT_WEAPON,
X		WEAP_GRENADES,
X		NULL,
X		AMMO_GRENADES,
/* precache */ "weapons/hgrent1a.wav weapons/hgrena1b.wav weapons/hgrenc1b.wav weapons/hgrenb1a.wav weapons/hgrenb2a.wav "
X	},
X
/*QUAKED weapon_grenadelauncher (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_grenadelauncher",
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_GrenadeLauncher,
X		"misc/w_pkup.wav",
X		"models/weapons/g_launch/tris.md2", EF_ROTATE,
X		"models/weapons/v_launch/tris.md2",
/* icon */		"w_glauncher",
/* pickup */	"Grenade Launcher",
X		0,
X		1,
X		"Grenades",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_GRENADELAUNCHER,
X		NULL,
X		0,
/* precache */ "models/objects/grenade/tris.md2 weapons/grenlf1a.wav weapons/grenlr1b.wav weapons/grenlb1b.wav"
X	},
X
X	// ROGUE
/*QUAKED weapon_proxlauncher (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_proxlauncher",								// classname
X		Pickup_Weapon,										// pickup
X		Use_Weapon,											// use
X		Drop_Weapon,										// drop
X		Weapon_ProxLauncher,								// weapon think
X		"misc/w_pkup.wav",									// pick up sound
X		"models/weapons/g_plaunch/tris.md2", EF_ROTATE,		// world model, world model flags
X		"models/weapons/v_plaunch/tris.md2",				// view model
X		"w_proxlaunch",										// icon
X		"Prox Launcher",									// name printed when picked up
X		0,													// number of digits for statusbar
X		1,													// amount used
X		"Prox",												// ammo type used
X		IT_WEAPON,											// inventory flags
X		WEAP_PROXLAUNCH,									// visible weapon
X		NULL,												// info (void *)
X		AMMO_PROX,											// tag
X		"weapons/grenlf1a.wav weapons/grenlr1b.wav weapons/grenlb1b.wav weapons/proxwarn.wav weapons/proxopen.wav",
X	},
X	// rogue
X
/*QUAKED weapon_rocketlauncher (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_rocketlauncher",
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_RocketLauncher,
X		"misc/w_pkup.wav",
X		"models/weapons/g_rocket/tris.md2", EF_ROTATE,
X		"models/weapons/v_rocket/tris.md2",
/* icon */		"w_rlauncher",
/* pickup */	"Rocket Launcher",
X		0,
X		1,
X		"Rockets",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_ROCKETLAUNCHER,
X		NULL,
X		0,
/* precache */ "models/objects/rocket/tris.md2 weapons/rockfly.wav weapons/rocklf1a.wav weapons/rocklr1b.wav models/objects/debris2/tris.md2"
X	},
X
/*QUAKED weapon_hyperblaster (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_hyperblaster", 
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_HyperBlaster,
X		"misc/w_pkup.wav",
X		"models/weapons/g_hyperb/tris.md2", EF_ROTATE,
X		"models/weapons/v_hyperb/tris.md2",
/* icon */		"w_hyperblaster",
/* pickup */	"HyperBlaster",
X		0,
X		1,
X		"Cells",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_HYPERBLASTER,
X		NULL,
X		0,
/* precache */ "weapons/hyprbu1a.wav weapons/hyprbl1a.wav weapons/hyprbf1a.wav weapons/hyprbd1a.wav misc/lasfly.wav"
X	},
X
X	// ROGUE
/*QUAKED weapon_plasmabeam (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/ 
X	{
X		"weapon_plasmabeam",								// classname
X		Pickup_Weapon,										// pickup function
X		Use_Weapon,											// use function
X		Drop_Weapon,										// drop function
X		Weapon_Heatbeam,									// weapon think function
X		"misc/w_pkup.wav",									// pick up sound
X		"models/weapons/g_beamer/tris.md2", EF_ROTATE,		// world model, world model flags
X		"models/weapons/v_beamer/tris.md2",					// view model
X		"w_heatbeam",											// icon
X		"Plasma Beam",											// name printed when picked up 
X		0,													// number of digits for statusbar
X		// FIXME - if this changes, change it in NoAmmoWeaponChange as well
X		2,													// amount used / contained
X		"Cells",											// ammo type used 
X		IT_WEAPON,											// inventory flags
X		WEAP_PLASMA,										// visible weapon
X		NULL,												// info (void *)
X		0,													// tag
X		"models/weapons/v_beamer2/tris.md2 weapons/bfg__l1a.wav",		// precaches
X	},
X	//rogue
/*QUAKED weapon_railgun (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_railgun", 
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_Railgun,
X		"misc/w_pkup.wav",
X		"models/weapons/g_rail/tris.md2", EF_ROTATE,
X		"models/weapons/v_rail/tris.md2",
/* icon */		"w_railgun",
/* pickup */	"Railgun",
X		0,
X		1,
X		"Slugs",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_RAILGUN,
X		NULL,
X		0,
/* precache */ "weapons/rg_hum.wav"
X	},
X
/*QUAKED weapon_bfg (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_bfg",
X		Pickup_Weapon,
X		Use_Weapon,
X		Drop_Weapon,
X		Weapon_BFG,
X		"misc/w_pkup.wav",
X		"models/weapons/g_bfg/tris.md2", EF_ROTATE,
X		"models/weapons/v_bfg/tris.md2",
/* icon */		"w_bfg",
/* pickup */	"BFG10K",
X		0,
X		50,
X		"Cells",
X		IT_WEAPON|IT_STAY_COOP,
X		WEAP_BFG,
X		NULL,
X		0,
/* precache */ "sprites/s_bfg1.sp2 sprites/s_bfg2.sp2 sprites/s_bfg3.sp2 weapons/bfg__f1y.wav weapons/bfg__l1a.wav weapons/bfg__x1b.wav weapons/bfg_hum.wav"
X	},
X
// =========================
// ROGUE WEAPONS
/*QUAKED weapon_chainfist (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_chainfist",									// classname
X		Pickup_Weapon,										// pickup function
X		Use_Weapon,											// use function
X		Drop_Weapon,										// drop function
X		Weapon_ChainFist,									// weapon think function
X		"misc/w_pkup.wav",									// pick up sound
X		"models/weapons/g_chainf/tris.md2", EF_ROTATE,		// world model, world model flags
X		"models/weapons/v_chainf/tris.md2",					// view model
X		"w_chainfist",										// icon
X		"Chainfist",										// name printed when picked up 
X		0,													// number of digits for statusbar
X		0,													// amount used / contained
X		NULL,												// ammo type used 
X		IT_WEAPON | IT_MELEE,								// inventory flags
X		WEAP_CHAINFIST,										// visible weapon
X		NULL,												// info (void *)
X		1,													// tag
X		"weapons/sawidle.wav weapons/sawhit.wav",			// precaches
X	},
X
/*QUAKED weapon_disintegrator (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"weapon_disintegrator",								// classname
X		Pickup_Weapon,										// pickup function
X		Use_Weapon,											// use function
X		Drop_Weapon,										// drop function
X		Weapon_Disintegrator,								// weapon think function
X		"misc/w_pkup.wav",									// pick up sound
X		"models/weapons/g_dist/tris.md2", EF_ROTATE,		// world model, world model flags
X		"models/weapons/v_dist/tris.md2",					// view model
X		"w_disintegrator",									// icon
X		"Disruptor",										// name printed when picked up 
X		0,													// number of digits for statusbar
X		1,													// amount used / contained
X		"Rounds",											// ammo type used 
#ifdef KILL_DISRUPTOR
X		IT_NOT_GIVEABLE,
#else
X		IT_WEAPON,											// inventory flags
#endif
X		WEAP_DISRUPTOR,										// visible weapon
X		NULL,												// info (void *)
X		1,													// tag
X		"models/items/spawngro/tris.md2 models/proj/disintegrator/tris.md2 weapons/disrupt.wav weapons/disint2.wav weapons/disrupthit.wav",	// precaches
X	},
X
// ROGUE WEAPONS
// =========================
X
X
X	//
X	// AMMO ITEMS
X	//
X
/*QUAKED ammo_shells (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_shells",
X		Pickup_Ammo,
X		NULL,
X		Drop_Ammo,
X		NULL,
X		"misc/am_pkup.wav",
X		"models/items/ammo/shells/medium/tris.md2", 0,
X		NULL,
/* icon */		"a_shells",
/* pickup */	"Shells",
/* width */		3,
X		10,
X		NULL,
X		IT_AMMO,
X		0,
X		NULL,
X		AMMO_SHELLS,
/* precache */ ""
X	},
X
/*QUAKED ammo_bullets (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_bullets",
X		Pickup_Ammo,
X		NULL,
X		Drop_Ammo,
X		NULL,
X		"misc/am_pkup.wav",
X		"models/items/ammo/bullets/medium/tris.md2", 0,
X		NULL,
/* icon */		"a_bullets",
/* pickup */	"Bullets",
/* width */		3,
X		50,
X		NULL,
X		IT_AMMO,
X		0,
X		NULL,
X		AMMO_BULLETS,
/* precache */ ""
X	},
X
/*QUAKED ammo_cells (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_cells",
X		Pickup_Ammo,
X		NULL,
X		Drop_Ammo,
X		NULL,
X		"misc/am_pkup.wav",
X		"models/items/ammo/cells/medium/tris.md2", 0,
X		NULL,
/* icon */		"a_cells",
/* pickup */	"Cells",
/* width */		3,
X		50,
X		NULL,
X		IT_AMMO,
X		0,
X		NULL,
X		AMMO_CELLS,
/* precache */ ""
X	},
X
/*QUAKED ammo_rockets (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_rockets",
X		Pickup_Ammo,
X		NULL,
X		Drop_Ammo,
X		NULL,
X		"misc/am_pkup.wav",
X		"models/items/ammo/rockets/medium/tris.md2", 0,
X		NULL,
/* icon */		"a_rockets",
/* pickup */	"Rockets",
/* width */		3,
X		5,
X		NULL,
X		IT_AMMO,
X		0,
X		NULL,
X		AMMO_ROCKETS,
/* precache */ ""
X	},
X
/*QUAKED ammo_slugs (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_slugs",
X		Pickup_Ammo,
X		NULL,
X		Drop_Ammo,
X		NULL,
X		"misc/am_pkup.wav",
X		"models/items/ammo/slugs/medium/tris.md2", 0,
X		NULL,
/* icon */		"a_slugs",
/* pickup */	"Slugs",
/* width */		3,
X		10,
X		NULL,
X		IT_AMMO,
X		0,
X		NULL,
X		AMMO_SLUGS,
/* precache */ ""
X	},
X
// =======================================
// ROGUE AMMO
X
/*QUAKED ammo_flechettes (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_flechettes",
X		Pickup_Ammo,
X		NULL,
X		Drop_Ammo,
X		NULL,
X		"misc/am_pkup.wav",
X		"models/ammo/am_flechette/tris.md2", 0,
X		NULL,
X		"a_flechettes",
X		"Flechettes",
X		3,
X		50,
X		NULL,
X		IT_AMMO,
X		0,
X		NULL,
X		AMMO_FLECHETTES
X	},
/*QUAKED ammo_prox (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_prox",										// Classname
X		Pickup_Ammo,										// pickup function
X		NULL,												// use function
X		Drop_Ammo,											// drop function
X		NULL,												// weapon think function
X		"misc/am_pkup.wav",									// pickup sound
X		"models/ammo/am_prox/tris.md2", 0,					// world model, world model flags
X		NULL,												// view model
X		"a_prox",											// icon
X		"Prox",												// Name printed when picked up
X		3,													// number of digits for status bar
X		5,													// amount contained
X		NULL,												// ammo type used
X		IT_AMMO,											// inventory flags
X		0,													// vwep index
X		NULL,												// info (void *)
X		AMMO_PROX,											// tag
X		"models/weapons/g_prox/tris.md2 weapons/proxwarn.wav"	// precaches
X	},
X
/*QUAKED ammo_tesla (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_tesla",
X		Pickup_Ammo,
X		Use_Weapon,						// PGM
X		Drop_Ammo,
X		Weapon_Tesla,					// PGM
X		"misc/am_pkup.wav",
//		"models/weapons/g_tesla/tris.md2", 0,
X		"models/ammo/am_tesl/tris.md2", 0,
X		"models/weapons/v_tesla/tris.md2",
X		"a_tesla",
X		"Tesla",
X		3,
X		5,
X		"Tesla",												// PGM
X		IT_AMMO | IT_WEAPON,						// inventory flags
X		0,
X		NULL,										// info (void *)
X		AMMO_TESLA,									// tag
X		"models/weapons/v_tesla2/tris.md2 weapons/teslaopen.wav weapons/hgrenb1a.wav weapons/hgrenb2a.wav models/weapons/g_tesla/tris.md2"			// precache
X	},
X
/*QUAKED ammo_nuke (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_nuke",
X		Pickup_Nuke,
X		Use_Nuke,						// PMM
X		Drop_Ammo,
X		NULL,							// PMM
X		"misc/am_pkup.wav",
X		"models/weapons/g_nuke/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_nuke",
/* pickup */	"A-M Bomb",
/* width */		3,
X		300, /* quantity (used for respawn time) */
X		"A-M Bomb",
X		IT_POWERUP,	
X		0,
X		NULL,
X		0,
X		"weapons/nukewarn2.wav world/rumble.wav"
X	},
X
/*QUAKED ammo_disruptor (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"ammo_disruptor",
X		Pickup_Ammo,
X		NULL,
X		Drop_Ammo,
X		NULL,
X		"misc/am_pkup.wav",
X		"models/ammo/am_disr/tris.md2", 0,
X		NULL,
X		"a_disruptor",
X		"Rounds",		// FIXME 
X		3,
X		15,
X		NULL,
#ifdef KILL_DISRUPTOR
X		IT_NOT_GIVEABLE,
#else
X		IT_AMMO,											// inventory flags
#endif
X		0,
X		NULL,
#ifdef KILL_DISRUPTOR
X		0,
#else
X		AMMO_DISRUPTOR,
#endif
X	},
// ROGUE AMMO
// =======================================
X
X	//
X	// POWERUP ITEMS
X	//
/*QUAKED item_quad (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_quad", 
X		Pickup_Powerup,
X		Use_Quad,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/quaddama/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_quad",
/* pickup */	"Quad Damage",
/* width */		2,
X		60,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
/* precache */ "items/damage.wav items/damage2.wav items/damage3.wav"
X	},
X
/*QUAKED item_invulnerability (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_invulnerability",
X		Pickup_Powerup,
X		Use_Invulnerability,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/invulner/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_invulnerability",
/* pickup */	"Invulnerability",
/* width */		2,
X		300,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
/* precache */ "items/protect.wav items/protect2.wav items/protect4.wav"
X	},
X
/*QUAKED item_silencer (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_silencer",
X		Pickup_Powerup,
X		Use_Silencer,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/silencer/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_silencer",
/* pickup */	"Silencer",
/* width */		2,
X		60,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED item_breather (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_breather",
X		Pickup_Powerup,
X		Use_Breather,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/breather/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_rebreather",
/* pickup */	"Rebreather",
/* width */		2,
X		60,
X		NULL,
X		IT_STAY_COOP|IT_POWERUP,
X		0,
X		NULL,
X		0,
/* precache */ "items/airout.wav"
X	},
X
/*QUAKED item_enviro (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_enviro",
X		Pickup_Powerup,
X		Use_Envirosuit,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/enviro/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_envirosuit",
/* pickup */	"Environment Suit",
/* width */		2,
X		60,
X		NULL,
X		IT_STAY_COOP|IT_POWERUP,
X		0,
X		NULL,
X		0,
/* precache */ "items/airout.wav"
X	},
X
/*QUAKED item_ancient_head (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
Special item that gives +2 to maximum health
*/
X	{
X		"item_ancient_head",
X		Pickup_AncientHead,
X		NULL,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/items/c_head/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_fixme",
/* pickup */	"Ancient Head",
/* width */		2,
X		60,
X		NULL,
X		0,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED item_adrenaline (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
gives +1 to maximum health
*/
X	{
X		"item_adrenaline",
X		Pickup_Adrenaline,
X		NULL,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/items/adrenal/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_adrenaline",
/* pickup */	"Adrenaline",
/* width */		2,
X		60,
X		NULL,
X		0,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED item_bandolier (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_bandolier",
X		Pickup_Bandolier,
X		NULL,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/items/band/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_bandolier",
/* pickup */	"Bandolier",
/* width */		2,
X		60,
X		NULL,
X		0,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED item_pack (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_pack",
X		Pickup_Pack,
X		NULL,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/items/pack/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_pack",
/* pickup */	"Ammo Pack",
/* width */		2,
X		180,
X		NULL,
X		0,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
// ======================================
// PGM
X
/*QUAKED item_ir_goggles (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
gives +1 to maximum health
*/
X	{
X		"item_ir_goggles",
X		Pickup_Powerup,
X		Use_IR,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/goggles/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_ir",
/* pickup */	"IR Goggles",
/* width */		2,
X		60,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
/* precache */ "misc/ir_start.wav"
X	},
X
/*QUAKED item_double (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_double", 
X		Pickup_Powerup,
X		Use_Double,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/ddamage/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_double",
/* pickup */	"Double Damage",
/* width */		2,
X		60,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
/* precache */ "misc/ddamage1.wav misc/ddamage2.wav misc/ddamage3.wav"
X	},
X
/*Q U A K E D item_torch (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
/*
X	{
X		"item_torch", 
X		Pickup_Powerup,
X		Use_Torch,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/objects/fire/tris.md2", EF_ROTATE,
X		NULL,
X		"p_torch",
X		"torch",
X		2,
X		60,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
X	},
*/
X
/*QUAKED item_compass (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_compass", 
X		Pickup_Powerup,
X		Use_Compass,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/objects/fire/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_compass",
/* pickup */	"compass",
/* width */		2,
X		60,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
X	},
X
/*QUAKED item_sphere_vengeance (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_sphere_vengeance", 
X		Pickup_Sphere,
X		Use_Vengeance,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/items/vengnce/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_vengeance",
/* pickup */	"vengeance sphere",
/* width */		2,
X		60,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
X		"spheres/v_idle.wav"		//precache
X	},
X
/*QUAKED item_sphere_hunter (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_sphere_hunter", 
X		Pickup_Sphere,
X		Use_Hunter,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/items/hunter/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_hunter",
/* pickup */	"hunter sphere",
/* width */		2,
X		120,
X		NULL,
X		IT_POWERUP,
X		0,
X		NULL,
X		0,
X		"spheres/h_idle.wav spheres/h_active.wav spheres/h_lurk.wav"		//precache
X	},
X
/*QUAKED item_sphere_defender (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_sphere_defender", 
X		Pickup_Sphere,
X		Use_Defender,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		"models/items/defender/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"p_defender",
/* pickup */	"defender sphere",
/* width */		2,
X		60,													// respawn time
X		NULL,												// ammo type used
X		IT_POWERUP,											// inventory flags
X		0,
X		NULL,												// info (void *)
X		0,													// tag
X		"models/proj/laser2/tris.md2 models/items/shell/tris.md2 spheres/d_idle.wav"		// precache
X	},
X
/*QUAKED item_doppleganger (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"item_doppleganger",								// classname
X		Pickup_Doppleganger,								// pickup function
X		Use_Doppleganger,									// use function
X		Drop_General,										// drop function
X		NULL,												// weapon think function
X		"items/pkup.wav",									// pick up sound
X		"models/items/dopple/tris.md2",						// world model
X		EF_ROTATE,											// world model flags
X		NULL,												// view model
X		"p_doppleganger",									// icon
X		"Doppleganger",										// name printed when picked up 
X		0,													// number of digits for statusbar
X		90,													// respawn time
X		NULL,												// ammo type used 
X		IT_POWERUP,											// inventory flags
X		0,
X		NULL,												// info (void *)
X		0,													// tag
X		"models/objects/dopplebase/tris.md2 models/items/spawngro2/tris.md2 models/items/hunter/tris.md2 models/items/vengnce/tris.md2",		// precaches
X	},
X
X	{
//		"dm_tag_token",										// classname
X		NULL,												// classname
X		Tag_PickupToken,									// pickup function
X		NULL,												// use function
X		NULL,												// drop function
X		NULL,												// weapon think function
X		"items/pkup.wav",									// pick up sound
X		"models/items/tagtoken/tris.md2",					// world model
X		EF_ROTATE | EF_TAGTRAIL,							// world model flags
X		NULL,												// view model
X		"i_tagtoken",										// icon
X		"Tag Token",										// name printed when picked up 
X		0,													// number of digits for statusbar
X		0,													// amount used / contained
X		NULL,												// ammo type used 
X		IT_POWERUP | IT_NOT_GIVEABLE,						// inventory flags
X		0,
X		NULL,												// info (void *)
X		1,													// tag
X		NULL,												// precaches
X	},
X
// PGM
// ======================================
X
X
X	//
X	// KEYS
X	//
/*QUAKED key_data_cd (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
key for computer centers
*/
X	{
X		"key_data_cd",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/data_cd/tris.md2", EF_ROTATE,
X		NULL,
X		"k_datacd",
X		"Data CD",
X		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_power_cube (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN NO_TOUCH
warehouse circuits
*/
X	{
X		"key_power_cube",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/power/tris.md2", EF_ROTATE,
X		NULL,
X		"k_powercube",
X		"Power Cube",
X		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_pyramid (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
key for the entrance of jail3
*/
X	{
X		"key_pyramid",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/pyramid/tris.md2", EF_ROTATE,
X		NULL,
X		"k_pyramid",
X		"Pyramid Key",
X		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_data_spinner (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
key for the city computer
*/
X	{
X		"key_data_spinner",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/spinner/tris.md2", EF_ROTATE,
X		NULL,
X		"k_dataspin",
X		"Data Spinner",
X		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_pass (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
security pass for the security level
*/
X	{
X		"key_pass",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/pass/tris.md2", EF_ROTATE,
X		NULL,
X		"k_security",
X		"Security Pass",
X		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_blue_key (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
normal door key - blue
*/
X	{
X		"key_blue_key",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/key/tris.md2", EF_ROTATE,
X		NULL,
X		"k_bluekey",
X		"Blue Key",
X		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_red_key (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
normal door key - red
*/
X	{
X		"key_red_key",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/red_key/tris.md2", EF_ROTATE,
X		NULL,
X		"k_redkey",
X		"Red Key",
X		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_commander_head (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
tank commander's head
*/
X	{
X		"key_commander_head",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/monsters/commandr/head/tris.md2", EF_GIB,
X		NULL,
/* icon */		"k_comhead",
/* pickup */	"Commander's Head",
/* width */		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
/*QUAKED key_airstrike_target (0 .5 .8) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
tank commander's head
*/
X	{
X		"key_airstrike_target",
X		Pickup_Key,
X		NULL,
X		Drop_General,
X		NULL,
X		"items/pkup.wav",
X		"models/items/keys/target/tris.md2", EF_ROTATE,
X		NULL,
/* icon */		"i_airstrike",
/* pickup */	"Airstrike Marker",
/* width */		2,
X		0,
X		NULL,
X		IT_STAY_COOP|IT_KEY,
X		0,
X		NULL,
X		0,
/* precache */ ""
X	},
X
// ======================================
// PGM
X
/*QUAKED key_nuke_container (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"key_nuke_container",								// classname
X		Pickup_Key,											// pickup function
X		NULL,												// use function
X		Drop_General,										// drop function
X		NULL,												// weapon think function
X		"items/pkup.wav",									// pick up sound
X		"models/weapons/g_nuke/tris.md2",					// world model
X		EF_ROTATE,											// world model flags
X		NULL,												// view model
X		"i_contain",										// icon
X		"Antimatter Pod",									// name printed when picked up 
X		2,													// number of digits for statusbar
X		0,													// respawn time
X		NULL,												// ammo type used 
X		IT_STAY_COOP|IT_KEY,								// inventory flags
X		0,
X		NULL,												// info (void *)
X		0,													// tag
X		NULL,												// precaches
X	},
X
/*QUAKED key_nuke (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
X	{
X		"key_nuke",											// classname
X		Pickup_Key,											// pickup function
X		NULL,												// use function
X		Drop_General,										// drop function
X		NULL,												// weapon think function
X		"items/pkup.wav",									// pick up sound
X		"models/weapons/g_nuke/tris.md2",					// world model
X		EF_ROTATE,											// world model flags
X		NULL,												// view model
X		"i_nuke",											// icon
X		"Antimatter Bomb",									// name printed when picked up 
X		2,													// number of digits for statusbar
X		0,													// respawn time
X		NULL,												// ammo type used 
X		IT_STAY_COOP|IT_KEY,								// inventory flags
X		0,
X		NULL,												// info (void *)
X		0,													// tag
X		NULL,												// precaches
X	},
X
// PGM
// ======================================
X
X	{
X		NULL,
X		Pickup_Health,
X		NULL,
X		NULL,
X		NULL,
X		"items/pkup.wav",
X		NULL, 0,
X		NULL,
/* icon */		"i_health",
/* pickup */	"Health",
/* width */		3,
X		0,
X		NULL,
X		0,
X		0,
X		NULL,
X		0,
/* precache */ "items/s_health.wav items/n_health.wav items/l_health.wav items/m_health.wav"  // PMM - health sound fix
X	},
X
X	// end of list marker
X	{NULL}
};
X
X
/*QUAKED item_health (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
void SP_item_health (edict_t *self)
{
X	if ( deathmatch->value && ((int)dmflags->value & DF_NO_HEALTH) )
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->model = "models/items/healing/medium/tris.md2";
X	self->count = 10;
X	SpawnItem (self, FindItem ("Health"));
X	gi.soundindex ("items/n_health.wav");
}
X
/*QUAKED item_health_small (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
void SP_item_health_small (edict_t *self)
{
X	if ( deathmatch->value && ((int)dmflags->value & DF_NO_HEALTH) )
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->model = "models/items/healing/stimpack/tris.md2";
X	self->count = 2;
X	SpawnItem (self, FindItem ("Health"));
X	self->style = HEALTH_IGNORE_MAX;
X	gi.soundindex ("items/s_health.wav");
}
X
/*QUAKED item_health_large (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
void SP_item_health_large (edict_t *self)
{
X	if ( deathmatch->value && ((int)dmflags->value & DF_NO_HEALTH) )
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->model = "models/items/healing/large/tris.md2";
X	self->count = 25;
X	SpawnItem (self, FindItem ("Health"));
X	gi.soundindex ("items/l_health.wav");
}
X
/*QUAKED item_health_mega (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
*/
void SP_item_health_mega (edict_t *self)
{
X	if ( deathmatch->value && ((int)dmflags->value & DF_NO_HEALTH) )
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->model = "models/items/mega_h/tris.md2";
X	self->count = 100;
X	SpawnItem (self, FindItem ("Health"));
X	gi.soundindex ("items/m_health.wav");
X	self->style = HEALTH_IGNORE_MAX|HEALTH_TIMED;
}
X
X
void InitItems (void)
{
X	game.num_items = sizeof(itemlist)/sizeof(itemlist[0]) - 1;
}
X
X
X
/*
===============
SetItemNames
X
Called by worldspawn
===============
*/
void SetItemNames (void)
{
X	int		i;
X	gitem_t	*it;
X
X	for (i=0 ; i<game.num_items ; i++)
X	{
X		it = &itemlist[i];
X		gi.configstring (CS_ITEMS+i, it->pickup_name);
X	}
X
X	jacket_armor_index = ITEM_INDEX(FindItem("Jacket Armor"));
X	combat_armor_index = ITEM_INDEX(FindItem("Combat Armor"));
X	body_armor_index   = ITEM_INDEX(FindItem("Body Armor"));
X	power_screen_index = ITEM_INDEX(FindItem("Power Screen"));
X	power_shield_index = ITEM_INDEX(FindItem("Power Shield"));
}
X
X
//===============
//ROGUE
void SP_xatrix_item (edict_t *self)
{
X	gitem_t	*item;
X	int		i;
X	char	*spawnClass;
X
X	if(!self->classname)
X		return;
X
X	if(!strcmp(self->classname, "ammo_magslug"))
X		spawnClass = "ammo_flechettes";
X	else if(!strcmp(self->classname, "ammo_trap"))
X		spawnClass = "weapon_proxlauncher";
X	else if(!strcmp(self->classname, "item_quadfire"))
X	{
X		float	chance;
X
X		chance = random();
X		if(chance < 0.2)
X			spawnClass = "item_sphere_hunter";
X		else if (chance < 0.6)
X			spawnClass = "item_sphere_vengeance";
X		else
X			spawnClass = "item_sphere_defender";
X	}
X	else if(!strcmp(self->classname, "weapon_boomer"))
X		spawnClass = "weapon_etf_rifle";
X	else if(!strcmp(self->classname, "weapon_phalanx"))
X		spawnClass = "weapon_plasmabeam";
X
X
X	// check item spawn functions
X	for (i=0,item=itemlist ; i<game.num_items ; i++,item++)
X	{
X		if (!item->classname)
X			continue;
X		if (!strcmp(item->classname, spawnClass))
X		{	// found it
X			SpawnItem (self, item);
X			return;
X		}
X	}
}
//ROGUE
//===============
SHAR_EOF
  $shar_touch -am 1130175398 'g_items.c' &&
  chmod 0664 'g_items.c' ||
  $echo 'restore of' 'g_items.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_items.c:' 'MD5 check failed'
3dc93aa29919246c52fc05788f4750b9  g_items.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_items.c'`"
    test 71570 -eq "$shar_count" ||
    $echo 'g_items.c:' 'original size' '71570,' 'current size' "$shar_count!"
  fi
fi
# ============= g_local.h ==============
if test -f 'g_local.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_local.h' '(file already exists)'
else
  $echo 'x -' extracting 'g_local.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_local.h' &&
// g_local.h -- local definitions for game module
X
#include "q_shared.h"
X
// define GAME_INCLUDE so that game.h does not define the
// short, server-visible gclient_t and edict_t structures,
// because we define the full size ones in this file
#define	GAME_INCLUDE
#include "game.h"
X
// the "gameversion" client command will print this plus compile date
#define	GAMEVERSION	"baseq2"
X
// protocol bytes that can be directly added to messages
#define	svc_muzzleflash		1
#define	svc_muzzleflash2	2
#define	svc_temp_entity		3
#define	svc_layout			4
#define	svc_inventory		5
#define	svc_stufftext		11
X
//==================================================================
X
#ifndef _WIN32
#include <nan.h>
#define min(a,b) ((a) < (b) ? (a) : (b))
#define max(a,b) ((a) > (b) ? (a) : (b))
#ifdef __sun__
#define _isnan(a) (NaN((a)))
#else
#define _isnan(a) ((a)==NAN)
#endif
#endif
X
//==================================================================
X
// view pitching times
#define DAMAGE_TIME		0.5
#define	FALL_TIME		0.3
X
// ROGUE- id killed this weapon
#define	KILL_DISRUPTOR	1
// rogue
X
// edict->spawnflags
// these are set with checkboxes on each entity in the map editor
#define	SPAWNFLAG_NOT_EASY			0x00000100
#define	SPAWNFLAG_NOT_MEDIUM		0x00000200
#define	SPAWNFLAG_NOT_HARD			0x00000400
#define	SPAWNFLAG_NOT_DEATHMATCH	0x00000800
#define	SPAWNFLAG_NOT_COOP			0x00001000
X
// edict->flags
#define	FL_FLY					0x00000001
#define	FL_SWIM					0x00000002	// implied immunity to drowining
#define FL_IMMUNE_LASER			0x00000004
#define	FL_INWATER				0x00000008
#define	FL_GODMODE				0x00000010
#define	FL_NOTARGET				0x00000020
#define FL_IMMUNE_SLIME			0x00000040
#define FL_IMMUNE_LAVA			0x00000080
#define	FL_PARTIALGROUND		0x00000100	// not all corners are valid
#define	FL_WATERJUMP			0x00000200	// player jumping out of water
#define	FL_TEAMSLAVE			0x00000400	// not the first on the team
#define FL_NO_KNOCKBACK			0x00000800
#define FL_POWER_ARMOR			0x00001000	// power armor (if any) is active
#define FL_RESPAWN				0x80000000	// used for item respawning
X
//ROGUE
#define FL_MECHANICAL			0x00002000	// entity is mechanical, use sparks not blood
#define FL_SAM_RAIMI			0x00004000	// entity is in sam raimi cam mode
#define FL_DISGUISED			0x00008000	// entity is in disguise, monsters will not recognize.
#define	FL_NOGIB				0x00010000	// player has been vaporized by a nuke, drop no gibs
//ROGUE
X
#define	FRAMETIME		0.1
X
// memory tags to allow dynamic memory to be cleaned up
#define	TAG_GAME	765		// clear when unloading the dll
#define	TAG_LEVEL	766		// clear when loading a new level
X
X
#define MELEE_DISTANCE	80
X
#define BODY_QUEUE_SIZE		8
X
typedef enum
{
X	DAMAGE_NO,
X	DAMAGE_YES,			// will take damage if hit
X	DAMAGE_AIM			// auto targeting recognizes this
} damage_t;
X
typedef enum 
{
X	WEAPON_READY, 
X	WEAPON_ACTIVATING,
X	WEAPON_DROPPING,
X	WEAPON_FIRING
} weaponstate_t;
X
typedef enum
{
X	AMMO_BULLETS,
X	AMMO_SHELLS,
X	AMMO_ROCKETS,
X	AMMO_GRENADES,
X	AMMO_CELLS,
X	AMMO_SLUGS,
X
X	//ROGUE
X	AMMO_FLECHETTES,
X	AMMO_TESLA,
#ifdef KILL_DISRUPTOR
X	AMMO_PROX
#else
X	AMMO_PROX,
X	AMMO_DISRUPTOR
#endif
} ammo_t;
X
X
//deadflag
#define DEAD_NO					0
#define DEAD_DYING				1
#define DEAD_DEAD				2
#define DEAD_RESPAWNABLE		3
X
//range
#define RANGE_MELEE				0
#define RANGE_NEAR				1
#define RANGE_MID				2
#define RANGE_FAR				3
X
//gib types
#define GIB_ORGANIC				0
#define GIB_METALLIC			1
X
//monster ai flags
#define AI_STAND_GROUND			0x00000001
#define AI_TEMP_STAND_GROUND	0x00000002
#define AI_SOUND_TARGET			0x00000004
#define AI_LOST_SIGHT			0x00000008
#define AI_PURSUIT_LAST_SEEN	0x00000010
#define AI_PURSUE_NEXT			0x00000020
#define AI_PURSUE_TEMP			0x00000040
#define AI_HOLD_FRAME			0x00000080
#define AI_GOOD_GUY				0x00000100
#define AI_BRUTAL				0x00000200
#define AI_NOSTEP				0x00000400
#define AI_DUCKED				0x00000800
#define AI_COMBAT_POINT			0x00001000
#define AI_MEDIC				0x00002000
#define AI_RESURRECTING			0x00004000
X
//ROGUE
#define AI_WALK_WALLS			0x00008000
#define AI_MANUAL_STEERING		0x00010000
#define AI_TARGET_ANGER			0x00020000
#define AI_DODGING				0x00040000
#define AI_CHARGING				0x00080000
#define AI_HINT_PATH			0x00100000
#define	AI_IGNORE_SHOTS			0x00200000
// PMM - FIXME - last second added for E3 .. there's probably a better way to do this, but
// this works
#define	AI_DO_NOT_COUNT			0x00400000	// set for healed monsters
#define	AI_SPAWNED_CARRIER		0x00800000	// both do_not_count and spawned are set for spawned monsters
#define	AI_SPAWNED_MEDIC_C		0x01000000	// both do_not_count and spawned are set for spawned monsters
#define	AI_SPAWNED_WIDOW		0x02000000	// both do_not_count and spawned are set for spawned monsters
#define AI_SPAWNED_MASK			0x03800000	// mask to catch all three flavors of spawned
#define	AI_BLOCKED				0x04000000	// used by blocked_checkattack: set to say I'm attacking while blocked 
X											// (prevents run-attacks)
//ROGUE
X
//monster attack state
#define AS_STRAIGHT				1
#define AS_SLIDING				2
#define	AS_MELEE				3
#define	AS_MISSILE				4
#define	AS_BLIND				5	// PMM - used by boss code to do nasty things even if it can't see you
X
// armor types
#define ARMOR_NONE				0
#define ARMOR_JACKET			1
#define ARMOR_COMBAT			2
#define ARMOR_BODY				3
#define ARMOR_SHARD				4
X
// power armor types
#define POWER_ARMOR_NONE		0
#define POWER_ARMOR_SCREEN		1
#define POWER_ARMOR_SHIELD		2
X
// handedness values
#define RIGHT_HANDED			0
#define LEFT_HANDED				1
#define CENTER_HANDED			2
X
X
// game.serverflags values
#define SFL_CROSS_TRIGGER_1		0x00000001
#define SFL_CROSS_TRIGGER_2		0x00000002
#define SFL_CROSS_TRIGGER_3		0x00000004
#define SFL_CROSS_TRIGGER_4		0x00000008
#define SFL_CROSS_TRIGGER_5		0x00000010
#define SFL_CROSS_TRIGGER_6		0x00000020
#define SFL_CROSS_TRIGGER_7		0x00000040
#define SFL_CROSS_TRIGGER_8		0x00000080
#define SFL_CROSS_TRIGGER_MASK	0x000000ff
X
X
// noise types for PlayerNoise
#define PNOISE_SELF				0
#define PNOISE_WEAPON			1
#define PNOISE_IMPACT			2
X
X
// edict->movetype values
typedef enum
{
MOVETYPE_NONE,			// never moves
MOVETYPE_NOCLIP,		// origin and angles change with no interaction
MOVETYPE_PUSH,			// no clip to world, push on box contact
MOVETYPE_STOP,			// no clip to world, stops on box contact
X
MOVETYPE_WALK,			// gravity
MOVETYPE_STEP,			// gravity, special edge handling
MOVETYPE_FLY,
MOVETYPE_TOSS,			// gravity
MOVETYPE_FLYMISSILE,	// extra size to monsters
MOVETYPE_BOUNCE,
MOVETYPE_NEWTOSS		// PGM - for deathball
} movetype_t;
X
X
X
typedef struct
{
X	int		base_count;
X	int		max_count;
X	float	normal_protection;
X	float	energy_protection;
X	int		armor;
} gitem_armor_t;
X
X
// gitem_t->flags
#define	IT_WEAPON			0x00000001		// use makes active weapon
#define	IT_AMMO				0x00000002
#define IT_ARMOR			0x00000004
#define IT_STAY_COOP		0x00000008
#define IT_KEY				0x00000010
#define IT_POWERUP			0x00000020
X
// ROGUE
#define IT_MELEE			0x00000040
#define IT_NOT_GIVEABLE		0x00000080	// item can not be given
// ROGUE
X
// gitem_t->weapmodel for weapons indicates model index
#define WEAP_BLASTER			1 
#define WEAP_SHOTGUN			2 
#define WEAP_SUPERSHOTGUN		3 
#define WEAP_MACHINEGUN			4 
#define WEAP_CHAINGUN			5 
#define WEAP_GRENADES			6 
#define WEAP_GRENADELAUNCHER	7 
#define WEAP_ROCKETLAUNCHER		8 
#define WEAP_HYPERBLASTER		9 
#define WEAP_RAILGUN			10
#define WEAP_BFG				11
X
#define WEAP_DISRUPTOR			12		// PGM
#define WEAP_ETFRIFLE			13		// PGM
#define WEAP_PLASMA				14		// PGM
#define WEAP_PROXLAUNCH			15		// PGM
#define WEAP_CHAINFIST			16		// PGM
X
typedef struct gitem_s
{
X	char		*classname;	// spawning name
X	qboolean	(*pickup)(struct edict_s *ent, struct edict_s *other);
X	void		(*use)(struct edict_s *ent, struct gitem_s *item);
X	void		(*drop)(struct edict_s *ent, struct gitem_s *item);
X	void		(*weaponthink)(struct edict_s *ent);
X	char		*pickup_sound;
X	char		*world_model;
X	int			world_model_flags;
X	char		*view_model;
X
X	// client side info
X	char		*icon;
X	char		*pickup_name;	// for printing on pickup
X	int			count_width;		// number of digits to display by icon
X
X	int			quantity;		// for ammo how much, for weapons how much is used per shot
X	char		*ammo;			// for weapons
X	int			flags;			// IT_* flags
X
X	int			weapmodel;		// weapon model index (for weapons)
X
X	void		*info;
X	int			tag;
X
X	char		*precaches;		// string of all models, sounds, and images this item will use
} gitem_t;
X
X
X
//
// this structure is left intact through an entire game
// it should be initialized at dll load time, and read/written to
// the server.ssv file for savegames
//
typedef struct
{
X	char		helpmessage1[512];
X	char		helpmessage2[512];
X	int			helpchanged;	// flash F1 icon if non 0, play sound
X								// and increment only if 1, 2, or 3
X
X	gclient_t	*clients;		// [maxclients]
X
X	// can't store spawnpoint in level, because
X	// it would get overwritten by the savegame restore
X	char		spawnpoint[512];	// needed for coop respawns
X
X	// store latched cvars here that we want to get at often
X	int			maxclients;
X	int			maxentities;
X
X	// cross level triggers
X	int			serverflags;
X
X	// items
X	int			num_items;
X
X	qboolean	autosaved;
} game_locals_t;
X
X
//
// this structure is cleared as each map is entered
// it is read/written to the level.sav file for savegames
//
typedef struct
{
X	int			framenum;
X	float		time;
X
X	char		level_name[MAX_QPATH];	// the descriptive name (Outer Base, etc)
X	char		mapname[MAX_QPATH];		// the server name (base1, etc)
X	char		nextmap[MAX_QPATH];		// go here when fraglimit is hit
X
X	// intermission state
X	float		intermissiontime;		// time the intermission was started
X	char		*changemap;
X	int			exitintermission;
X	vec3_t		intermission_origin;
X	vec3_t		intermission_angle;
X
X	edict_t		*sight_client;	// changed once each frame for coop games
X
X	edict_t		*sight_entity;
X	int			sight_entity_framenum;
X	edict_t		*sound_entity;
X	int			sound_entity_framenum;
X	edict_t		*sound2_entity;
X	int			sound2_entity_framenum;
X
X	int			pic_health;
X
X	int			total_secrets;
X	int			found_secrets;
X
X	int			total_goals;
X	int			found_goals;
X
X	int			total_monsters;
X	int			killed_monsters;
X
X	edict_t		*current_entity;	// entity running from G_RunFrame
X	int			body_que;			// dead bodies
X
X	int			power_cubes;		// ugly necessity for coop
X
X	// ROGUE
X	edict_t		*disguise_violator;
X	int			disguise_violation_framenum;
X	// ROGUE
} level_locals_t;
X
X
// spawn_temp_t is only used to hold entity field values that
// can be set from the editor, but aren't actualy present
// in edict_t during gameplay
typedef struct
{
X	// world vars
X	char		*sky;
X	float		skyrotate;
X	vec3_t		skyaxis;
X	char		*nextmap;
X
X	int			lip;
X	int			distance;
X	int			height;
X	char		*noise;
X	float		pausetime;
X	char		*item;
X	char		*gravity;
X
X	float		minyaw;
X	float		maxyaw;
X	float		minpitch;
X	float		maxpitch;
} spawn_temp_t;
X
X
typedef struct
{
X	// fixed data
X	vec3_t		start_origin;
X	vec3_t		start_angles;
X	vec3_t		end_origin;
X	vec3_t		end_angles;
X
X	int			sound_start;
X	int			sound_middle;
X	int			sound_end;
X
X	float		accel;
X	float		speed;
X	float		decel;
X	float		distance;
X
X	float		wait;
X
X	// state data
X	int			state;
X	vec3_t		dir;
X	float		current_speed;
X	float		move_speed;
X	float		next_speed;
X	float		remaining_distance;
X	float		decel_distance;
X	void		(*endfunc)(edict_t *);
} moveinfo_t;
X
X
typedef struct
{
X	void	(*aifunc)(edict_t *self, float dist);
X	float	dist;
X	void	(*thinkfunc)(edict_t *self);
} mframe_t;
X
typedef struct
{
X	int			firstframe;
X	int			lastframe;
X	mframe_t	*frame;
X	void		(*endfunc)(edict_t *self);
} mmove_t;
X
typedef struct
{
X	mmove_t		*currentmove;
X	unsigned int	aiflags;		// PGM - unsigned, since we're close to the max
X	int			nextframe;
X	float		scale;
X
X	void		(*stand)(edict_t *self);
X	void		(*idle)(edict_t *self);
X	void		(*search)(edict_t *self);
X	void		(*walk)(edict_t *self);
X	void		(*run)(edict_t *self);
X	void		(*dodge)(edict_t *self, edict_t *other, float eta, trace_t *tr);
X	void		(*attack)(edict_t *self);
X	void		(*melee)(edict_t *self);
X	void		(*sight)(edict_t *self, edict_t *other);
X	qboolean	(*checkattack)(edict_t *self);
X
X	float		pausetime;
X	float		attack_finished;
X
X	vec3_t		saved_goal;
X	float		search_time;
X	float		trail_time;
X	vec3_t		last_sighting;
X	int			attack_state;
X	int			lefty;
X	float		idle_time;
X	int			linkcount;
X
X	int			power_armor_type;
X	int			power_armor_power;
X
//ROGUE
X	qboolean	(*blocked)(edict_t *self, float dist);
//	edict_t		*last_hint;			// last hint_path the monster touched
X	float		last_hint_time;		// last time the monster checked for hintpaths.
X	edict_t		*goal_hint;			// which hint_path we're trying to get to
X	int			medicTries;
X	edict_t		*badMedic1, *badMedic2;	// these medics have declared this monster "unhealable"
X	edict_t		*healer;	// this is who is healing this monster
X	void		(*duck)(edict_t *self, float eta);
X	void		(*unduck)(edict_t *self);
X	void		(*sidestep)(edict_t *self);
X	//  while abort_duck would be nice, only monsters which duck but don't sidestep would use it .. only the brain
X	//  not really worth it.  sidestep is an implied abort_duck
//	void		(*abort_duck)(edict_t *self);
X	float		base_height;
X	float		next_duck_time;
X	float		duck_wait_time;
X	edict_t		*last_player_enemy;
X	// blindfire stuff .. the boolean says whether the monster will do it, and blind_fire_time is the timing
X	// (set in the monster) of the next shot
X	qboolean	blindfire;		// will the monster blindfire?
X	float		blind_fire_delay;
X	vec3_t		blind_fire_target;
X	// used by the spawners to not spawn too much and keep track of #s of monsters spawned
X	int			monster_slots;
X	int			monster_used;
X	edict_t		*commander;
X	// powerup timers, used by widow, our friend
X	float		quad_framenum;
X	float		invincible_framenum;
X	float		double_framenum;
//ROGUE
} monsterinfo_t;
X
// ROGUE
// this determines how long to wait after a duck to duck again.  this needs to be longer than
// the time after the monster_duck_up in all of the animation sequences
#define	DUCK_INTERVAL	0.5
// ROGUE
X
extern	game_locals_t	game;
extern	level_locals_t	level;
extern	game_import_t	gi;
extern	game_export_t	globals;
extern	spawn_temp_t	st;
X
extern	int	sm_meat_index;
extern	int	snd_fry;
X
extern	int	jacket_armor_index;
extern	int	combat_armor_index;
extern	int	body_armor_index;
X
X
// means of death
#define MOD_UNKNOWN			0
#define MOD_BLASTER			1
#define MOD_SHOTGUN			2
#define MOD_SSHOTGUN		3
#define MOD_MACHINEGUN		4
#define MOD_CHAINGUN		5
#define MOD_GRENADE			6
#define MOD_G_SPLASH		7
#define MOD_ROCKET			8
#define MOD_R_SPLASH		9
#define MOD_HYPERBLASTER	10
#define MOD_RAILGUN			11
#define MOD_BFG_LASER		12
#define MOD_BFG_BLAST		13
#define MOD_BFG_EFFECT		14
#define MOD_HANDGRENADE		15
#define MOD_HG_SPLASH		16
#define MOD_WATER			17
#define MOD_SLIME			18
#define MOD_LAVA			19
#define MOD_CRUSH			20
#define MOD_TELEFRAG		21
#define MOD_FALLING			22
#define MOD_SUICIDE			23
#define MOD_HELD_GRENADE	24
#define MOD_EXPLOSIVE		25
#define MOD_BARREL			26
#define MOD_BOMB			27
#define MOD_EXIT			28
#define MOD_SPLASH			29
#define MOD_TARGET_LASER	30
#define MOD_TRIGGER_HURT	31
#define MOD_HIT				32
#define MOD_TARGET_BLASTER	33
#define MOD_FRIENDLY_FIRE	0x8000000
X
//========
//ROGUE
#define MOD_CHAINFIST			40
#define MOD_DISINTEGRATOR		41
#define MOD_ETF_RIFLE			42
#define MOD_BLASTER2			43
#define MOD_HEATBEAM			44
#define MOD_TESLA				45
#define MOD_PROX				46
#define MOD_NUKE				47
#define MOD_VENGEANCE_SPHERE	48
#define MOD_HUNTER_SPHERE		49
#define MOD_DEFENDER_SPHERE		50
#define MOD_TRACKER				51
#define MOD_DBALL_CRUSH			52
#define MOD_DOPPLE_EXPLODE		53
#define MOD_DOPPLE_VENGEANCE	54
#define MOD_DOPPLE_HUNTER		55
//ROGUE
//========
X
extern	int	meansOfDeath;
X
X
extern	edict_t			*g_edicts;
X
#define	FOFS(x) (int)&(((edict_t *)0)->x)
#define	STOFS(x) (int)&(((spawn_temp_t *)0)->x)
#define	LLOFS(x) (int)&(((level_locals_t *)0)->x)
#define	CLOFS(x) (int)&(((gclient_t *)0)->x)
X
#define random()	((rand () & 0x7fff) / ((float)0x7fff))
#define crandom()	(2.0 * (random() - 0.5))
X
extern	cvar_t	*maxentities;
extern	cvar_t	*deathmatch;
extern	cvar_t	*coop;
extern	cvar_t	*dmflags;
extern	cvar_t	*skill;
extern	cvar_t	*fraglimit;
extern	cvar_t	*timelimit;
extern	cvar_t	*password;
extern	cvar_t	*spectator_password;
extern	cvar_t	*g_select_empty;
extern	cvar_t	*dedicated;
X
extern	cvar_t	*filterban;
X
extern	cvar_t	*sv_gravity;
extern	cvar_t	*sv_maxvelocity;
X
extern	cvar_t	*gun_x, *gun_y, *gun_z;
extern	cvar_t	*sv_rollspeed;
extern	cvar_t	*sv_rollangle;
X
extern	cvar_t	*run_pitch;
extern	cvar_t	*run_roll;
extern	cvar_t	*bob_up;
extern	cvar_t	*bob_pitch;
extern	cvar_t	*bob_roll;
X
extern	cvar_t	*sv_cheats;
extern	cvar_t	*maxclients;
extern	cvar_t	*maxspectators;
X
extern	cvar_t	*flood_msgs;
extern	cvar_t	*flood_persecond;
extern	cvar_t	*flood_waitdelay;
X
extern	cvar_t	*sv_maplist;
X
extern	cvar_t	*sv_stopspeed;		// PGM - this was a define in g_phys.c
X
//ROGUE
extern	cvar_t	*g_showlogic;
extern	cvar_t	*gamerules;
extern	cvar_t	*huntercam;
extern	cvar_t	*strong_mines;
extern	cvar_t	*randomrespawn;
X
// this is for the count of monsters
#define ENT_SLOTS_LEFT		(ent->monsterinfo.monster_slots - ent->monsterinfo.monster_used)
#define SELF_SLOTS_LEFT		(self->monsterinfo.monster_slots - self->monsterinfo.monster_used)
//ROGUE
X
#define world	(&g_edicts[0])
X
// item spawnflags
#define ITEM_TRIGGER_SPAWN		0x00000001
#define ITEM_NO_TOUCH			0x00000002
// 6 bits reserved for editor flags
// 8 bits used as power cube id bits for coop games
#define DROPPED_ITEM			0x00010000
#define	DROPPED_PLAYER_ITEM		0x00020000
#define ITEM_TARGETS_USED		0x00040000
X
//
// fields are needed for spawning from the entity string
// and saving / loading games
//
#define FFL_SPAWNTEMP		1
#define FFL_NOSPAWN			2
X
typedef enum {
X	F_INT, 
X	F_FLOAT,
X	F_LSTRING,			// string on disk, pointer in memory, TAG_LEVEL
X	F_GSTRING,			// string on disk, pointer in memory, TAG_GAME
X	F_VECTOR,
X	F_ANGLEHACK,
X	F_EDICT,			// index on disk, pointer in memory
X	F_ITEM,				// index on disk, pointer in memory
X	F_CLIENT,			// index on disk, pointer in memory
X	F_FUNCTION,
X	F_MMOVE,
X	F_IGNORE
} fieldtype_t;
X
typedef struct
{
X	char	*name;
X	int		ofs;
X	fieldtype_t	type;
X	int		flags;
} field_t;
X
X
extern	field_t fields[];
extern	gitem_t	itemlist[];
X
X
//
// g_cmds.c
//
void Cmd_Help_f (edict_t *ent);
void Cmd_Score_f (edict_t *ent);
X
//
// g_items.c
//
void PrecacheItem (gitem_t *it);
void InitItems (void);
void SetItemNames (void);
gitem_t	*FindItem (char *pickup_name);
gitem_t	*FindItemByClassname (char *classname);
#define	ITEM_INDEX(x) ((x)-itemlist)
edict_t *Drop_Item (edict_t *ent, gitem_t *item);
void SetRespawn (edict_t *ent, float delay);
void ChangeWeapon (edict_t *ent);
void SpawnItem (edict_t *ent, gitem_t *item);
void Think_Weapon (edict_t *ent);
int ArmorIndex (edict_t *ent);
int PowerArmorType (edict_t *ent);
gitem_t	*GetItemByIndex (int index);
qboolean Add_Ammo (edict_t *ent, gitem_t *item, int count);
void Touch_Item (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf);
X
//
// g_utils.c
//
qboolean	KillBox (edict_t *ent);
void	G_ProjectSource (vec3_t point, vec3_t distance, vec3_t forward, vec3_t right, vec3_t result);
edict_t *G_Find (edict_t *from, int fieldofs, char *match);
edict_t *findradius (edict_t *from, vec3_t org, float rad);
edict_t *G_PickTarget (char *targetname);
void	G_UseTargets (edict_t *ent, edict_t *activator);
void	G_SetMovedir (vec3_t angles, vec3_t movedir);
X
void	G_InitEdict (edict_t *e);
edict_t	*G_Spawn (void);
void	G_FreeEdict (edict_t *e);
X
void	G_TouchTriggers (edict_t *ent);
void	G_TouchSolids (edict_t *ent);
X
char	*G_CopyString (char *in);
X
float	*tv (float x, float y, float z);
char	*vtos (vec3_t v);
X
float vectoyaw (vec3_t vec);
void vectoangles (vec3_t vec, vec3_t angles);
X
//ROGUE
void	G_ProjectSource2 (vec3_t point, vec3_t distance, vec3_t forward, vec3_t right, vec3_t up, vec3_t result);
float	vectoyaw2 (vec3_t vec);
void	vectoangles2 (vec3_t vec, vec3_t angles);
edict_t *findradius2 (edict_t *from, vec3_t org, float rad);
//ROGUE
X
//
// g_combat.c
//
qboolean OnSameTeam (edict_t *ent1, edict_t *ent2);
qboolean CanDamage (edict_t *targ, edict_t *inflictor);
void T_Damage (edict_t *targ, edict_t *inflictor, edict_t *attacker, vec3_t dir, vec3_t point, vec3_t normal, int damage, int knockback, int dflags, int mod);
void T_RadiusDamage (edict_t *inflictor, edict_t *attacker, float damage, edict_t *ignore, float radius, int mod);
X
//ROGUE
void T_RadiusNukeDamage (edict_t *inflictor, edict_t *attacker, float damage, edict_t *ignore, float radius, int mod);
void T_RadiusClassDamage (edict_t *inflictor, edict_t *attacker, float damage, char *ignoreClass, float radius, int mod);
void cleanupHealTarget (edict_t *ent);
//ROGUE
X
// damage flags
#define DAMAGE_RADIUS			0x00000001	// damage was indirect
#define DAMAGE_NO_ARMOR			0x00000002	// armour does not protect from this damage
#define DAMAGE_ENERGY			0x00000004	// damage is from an energy based weapon
#define DAMAGE_NO_KNOCKBACK		0x00000008	// do not affect velocity, just view angles
#define DAMAGE_BULLET			0x00000010  // damage is from a bullet (used for ricochets)
#define DAMAGE_NO_PROTECTION	0x00000020  // armor, shields, invulnerability, and godmode have no effect
//ROGUE
#define DAMAGE_DESTROY_ARMOR	0x00000040	// damage is done to armor and health.
#define DAMAGE_NO_REG_ARMOR		0x00000080	// damage skips regular armor
#define DAMAGE_NO_POWER_ARMOR	0x00000100	// damage skips power armor
//ROGUE
X
X
#define DEFAULT_BULLET_HSPREAD	300
#define DEFAULT_BULLET_VSPREAD	500
#define DEFAULT_SHOTGUN_HSPREAD	1000
#define DEFAULT_SHOTGUN_VSPREAD	500
#define DEFAULT_DEATHMATCH_SHOTGUN_COUNT	12
#define DEFAULT_SHOTGUN_COUNT	12
#define DEFAULT_SSHOTGUN_COUNT	20
X
//
// g_monster.c
//
void monster_fire_bullet (edict_t *self, vec3_t start, vec3_t dir, int damage, int kick, int hspread, int vspread, int flashtype);
void monster_fire_shotgun (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int hspread, int vspread, int count, int flashtype);
void monster_fire_blaster (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int flashtype, int effect);
void monster_fire_grenade (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, int flashtype);
void monster_fire_rocket (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int flashtype);
void monster_fire_railgun (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int flashtype);
void monster_fire_bfg (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, int kick, float damage_radius, int flashtype);
void M_droptofloor (edict_t *ent);
void monster_think (edict_t *self);
void walkmonster_start (edict_t *self);
void swimmonster_start (edict_t *self);
void flymonster_start (edict_t *self);
void AttackFinished (edict_t *self, float time);
void monster_death_use (edict_t *self);
void M_CatagorizePosition (edict_t *ent);
qboolean M_CheckAttack (edict_t *self);
void M_FlyCheck (edict_t *self);
void M_CheckGround (edict_t *ent);
//ROGUE
void monster_fire_blaster2 (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int flashtype, int effect);
void monster_fire_tracker (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, edict_t *enemy, int flashtype);
void monster_fire_heat (edict_t *self, vec3_t start, vec3_t dir, vec3_t offset, int damage, int kick, int flashtype);
void stationarymonster_start (edict_t *self);	
void monster_done_dodge (edict_t *self);
//ROGUE
X
X
//
// g_misc.c
//
void ThrowHead (edict_t *self, char *gibname, int damage, int type);
void ThrowClientHead (edict_t *self, int damage);
void ThrowGib (edict_t *self, char *gibname, int damage, int type);
void BecomeExplosion1(edict_t *self);
X
//
// g_ai.c
//
void AI_SetSightClient (void);
X
void ai_stand (edict_t *self, float dist);
void ai_move (edict_t *self, float dist);
void ai_walk (edict_t *self, float dist);
void ai_turn (edict_t *self, float dist);
void ai_run (edict_t *self, float dist);
void ai_charge (edict_t *self, float dist);
int range (edict_t *self, edict_t *other);
X
void FoundTarget (edict_t *self);
qboolean infront (edict_t *self, edict_t *other);
qboolean visible (edict_t *self, edict_t *other);
qboolean FacingIdeal(edict_t *self);
X
//
// g_weapon.c
//
void ThrowDebris (edict_t *self, char *modelname, float speed, vec3_t origin);
qboolean fire_hit (edict_t *self, vec3_t aim, int damage, int kick);
void fire_bullet (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int hspread, int vspread, int mod);
void fire_shotgun (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int hspread, int vspread, int count, int mod);
void fire_blaster (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, int effect, qboolean hyper);
void fire_grenade (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, float timer, float damage_radius);
void fire_grenade2 (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, float timer, float damage_radius, qboolean held);
void fire_rocket (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, float damage_radius, int radius_damage);
void fire_rail (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick);
void fire_bfg (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, float damage_radius);
X
//
// g_ptrail.c
//
void PlayerTrail_Init (void);
void PlayerTrail_Add (vec3_t spot);
void PlayerTrail_New (vec3_t spot);
edict_t *PlayerTrail_PickFirst (edict_t *self);
edict_t *PlayerTrail_PickNext (edict_t *self);
edict_t	*PlayerTrail_LastSpot (void);
X
//
// g_client.c
//
void respawn (edict_t *ent);
void BeginIntermission (edict_t *targ);
void PutClientInServer (edict_t *ent);
void InitClientPersistant (gclient_t *client);
void InitClientResp (gclient_t *client);
void InitBodyQue (void);
void ClientBeginServerFrame (edict_t *ent);
X
//
// g_player.c
//
void player_pain (edict_t *self, edict_t *other, float kick, int damage);
void player_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
X
//
// g_svcmds.c
//
void	ServerCommand (void);
qboolean SV_FilterPacket (char *from);
X
//
// p_view.c
//
void ClientEndServerFrame (edict_t *ent);
X
//
// p_hud.c
//
void MoveClientToIntermission (edict_t *client);
void G_SetStats (edict_t *ent);
void G_SetSpectatorStats (edict_t *ent);
void G_CheckChaseStats (edict_t *ent);
void ValidateSelectedItem (edict_t *ent);
void DeathmatchScoreboardMessage (edict_t *client, edict_t *killer);
X
//
// g_pweapon.c
//
void PlayerNoise(edict_t *who, vec3_t where, int type);
X
//
// m_move.c
//
qboolean M_CheckBottom (edict_t *ent);
qboolean M_walkmove (edict_t *ent, float yaw, float dist);
void M_MoveToGoal (edict_t *ent, float dist);
void M_ChangeYaw (edict_t *ent);
X
//
// g_phys.c
//
void G_RunEntity (edict_t *ent);
X
//
// g_main.c
//
void SaveClientData (void);
void FetchClientEntData (edict_t *ent);
X
//
// g_chase.c
//
void UpdateChaseCam(edict_t *ent);
void ChaseNext(edict_t *ent);
void ChasePrev(edict_t *ent);
void GetChaseTarget(edict_t *ent);
X
X
//====================
// ROGUE PROTOTYPES
//
// g_newweap.c
//
//extern float nuke_framenum;
X
void fire_flechette (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int kick);
void fire_prox (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed);		
void fire_nuke (edict_t *self, vec3_t start, vec3_t aimdir, int speed);		
void fire_flame (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed);
void fire_burst (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed);
void fire_maintain (edict_t *, edict_t *, vec3_t start, vec3_t aimdir, int damage, int speed);
void fire_incendiary_grenade (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, float timer, float damage_radius);
void fire_player_melee (edict_t *self, vec3_t start, vec3_t aim, int reach, int damage, int kick, int quiet, int mod);
void fire_tesla (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed);
void fire_blaster2 (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, int effect, qboolean hyper);
void fire_heat (edict_t *self, vec3_t start, vec3_t aimdir, vec3_t offset, int damage, int kick, qboolean monster);
void fire_tracker (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, edict_t *enemy);
X
//
// g_newai.c
//
qboolean blocked_checkshot (edict_t *self, float shotChance);
qboolean blocked_checkplat (edict_t *self, float dist);
qboolean blocked_checkjump (edict_t *self, float dist, float maxDown, float maxUp);
qboolean blocked_checknewenemy (edict_t *self);
qboolean monsterlost_checkhint (edict_t *self);
qboolean inback (edict_t *self, edict_t *other);
float realrange (edict_t *self, edict_t *other);
edict_t *SpawnBadArea(vec3_t mins, vec3_t maxs, float lifespan, edict_t *owner);
edict_t *CheckForBadArea(edict_t *ent);
qboolean MarkTeslaArea(edict_t *self, edict_t *tesla);
void InitHintPaths (void);
void PredictAim (edict_t *target, vec3_t start, float bolt_speed, qboolean eye_height, float offset, vec3_t aimdir, vec3_t aimpoint);
qboolean below (edict_t *self, edict_t *other);
void drawbbox (edict_t *self);
void M_MonsterDodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr);
void monster_duck_down (edict_t *self);
void monster_duck_hold (edict_t *self);
void monster_duck_up (edict_t *self);
qboolean has_valid_enemy (edict_t *self);
void TargetTesla (edict_t *self, edict_t *tesla);
void hintpath_stop (edict_t *self);
edict_t * PickCoopTarget (edict_t *self);
int CountPlayers (void);
void monster_jump_start (edict_t *self);
qboolean monster_jump_finished (edict_t *self);
X
X
//
// g_sphere.c
//
void Defender_Launch (edict_t *self);
void Vengeance_Launch (edict_t *self);
void Hunter_Launch (edict_t *self);
X
//
// g_newdm.c
//
void InitGameRules(void);
edict_t *DoRandomRespawn (edict_t *ent);
void PrecacheForRandomRespawn (void);
qboolean Tag_PickupToken (edict_t *ent, edict_t *other);
void Tag_DropToken (edict_t *ent, gitem_t *item);
void Tag_PlayerDeath(edict_t *targ, edict_t *inflictor, edict_t *attacker);
void fire_doppleganger (edict_t *ent, vec3_t start, vec3_t aimdir);
X
//
// g_spawn.c
//
edict_t *CreateMonster(vec3_t origin, vec3_t angles, char *classname);
edict_t *CreateFlyMonster (vec3_t origin, vec3_t angles, vec3_t mins, vec3_t maxs, char *classname);
edict_t *CreateGroundMonster (vec3_t origin, vec3_t angles, vec3_t mins, vec3_t maxs, char *classname, int height);
qboolean FindSpawnPoint (vec3_t startpoint, vec3_t mins, vec3_t maxs, vec3_t spawnpoint, float maxMoveUp);
qboolean CheckSpawnPoint (vec3_t origin, vec3_t mins, vec3_t maxs);
qboolean CheckGroundSpawnPoint (vec3_t origin, vec3_t entMins, vec3_t entMaxs, float height, float gravity);
void DetermineBBox (char *classname, vec3_t mins, vec3_t maxs);
void SpawnGrow_Spawn (vec3_t startpos, int size);
void Widowlegs_Spawn (vec3_t startpos, vec3_t angles);
X
//
// p_client.c
//
void RemoveAttackingPainDaemons (edict_t *self);
X
X
// ROGUE PROTOTYPES
//====================
X
//============================================================================
X
// client_t->anim_priority
#define	ANIM_BASIC		0		// stand / run
#define	ANIM_WAVE		1
#define	ANIM_JUMP		2
#define	ANIM_PAIN		3
#define	ANIM_ATTACK		4
#define	ANIM_DEATH		5
#define	ANIM_REVERSE	6
X
X
// client data that stays across multiple level loads
typedef struct
{
X	char		userinfo[MAX_INFO_STRING];
X	char		netname[16];
X	int			hand;
X
X	qboolean	connected;			// a loadgame will leave valid entities that
X									// just don't have a connection yet
X
X	// values saved and restored from edicts when changing levels
X	int			health;
X	int			max_health;
X	int			savedFlags;
X
X	int			selected_item;
X	int			inventory[MAX_ITEMS];
X
X	// ammo capacities
X	int			max_bullets;
X	int			max_shells;
X	int			max_rockets;
X	int			max_grenades;
X	int			max_cells;
X	int			max_slugs;
X
X	gitem_t		*weapon;
X	gitem_t		*lastweapon;
X
X	int			power_cubes;	// used for tracking the cubes in coop games
X	int			score;			// for calculating total unit score in coop games
X
X	int			game_helpchanged;
X	int			helpchanged;
X
X	qboolean	spectator;			// client is a spectator
X
//=========
//ROGUE
X	int			max_tesla;
X	int			max_prox;
X	int			max_mines;
X	int			max_flechettes;
#ifndef KILL_DISRUPTOR
X	int			max_rounds;
#endif
//ROGUE
//=========
} client_persistant_t;
X
// client data that stays across deathmatch respawns
typedef struct
{
X	client_persistant_t	coop_respawn;	// what to set client->pers to on a respawn
X	int			enterframe;			// level.framenum the client entered the game
X	int			score;				// frags, etc
X	vec3_t		cmd_angles;			// angles sent over in the last command
X
X	qboolean	spectator;			// client is a spectator
} client_respawn_t;
X
// this structure is cleared on each PutClientInServer(),
// except for 'client->pers'
struct gclient_s
{
X	// known to server
X	player_state_t	ps;				// communicated by server to clients
X	int				ping;
X
X	// private to game
X	client_persistant_t	pers;
X	client_respawn_t	resp;
X	pmove_state_t		old_pmove;	// for detecting out-of-pmove changes
X
X	qboolean	showscores;			// set layout stat
X	qboolean	showinventory;		// set layout stat
X	qboolean	showhelp;
X	qboolean	showhelpicon;
X
X	int			ammo_index;
X
X	int			buttons;
X	int			oldbuttons;
X	int			latched_buttons;
X
X	qboolean	weapon_thunk;
X
X	gitem_t		*newweapon;
X
X	// sum up damage over an entire frame, so
X	// shotgun blasts give a single big kick
X	int			damage_armor;		// damage absorbed by armor
X	int			damage_parmor;		// damage absorbed by power armor
X	int			damage_blood;		// damage taken out of health
X	int			damage_knockback;	// impact damage
X	vec3_t		damage_from;		// origin for vector calculation
X
X	float		killer_yaw;			// when dead, look at killer
X
X	weaponstate_t	weaponstate;
X	vec3_t		kick_angles;	// weapon kicks
X	vec3_t		kick_origin;
X	float		v_dmg_roll, v_dmg_pitch, v_dmg_time;	// damage kicks
X	float		fall_time, fall_value;		// for view drop on fall
X	float		damage_alpha;
X	float		bonus_alpha;
X	vec3_t		damage_blend;
X	vec3_t		v_angle;			// aiming direction
X	float		bobtime;			// so off-ground doesn't change it
X	vec3_t		oldviewangles;
X	vec3_t		oldvelocity;
X
X	float		next_drown_time;
X	int			old_waterlevel;
X	int			breather_sound;
X
X	int			machinegun_shots;	// for weapon raising
X
X	// animation vars
X	int			anim_end;
X	int			anim_priority;
X	qboolean	anim_duck;
X	qboolean	anim_run;
X
X	// powerup timers
X	float		quad_framenum;
X	float		invincible_framenum;
X	float		breather_framenum;
X	float		enviro_framenum;
X
X	qboolean	grenade_blew_up;
X	float		grenade_time;
X	int			silencer_shots;
X	int			weapon_sound;
X
X	float		pickup_msg_time;
X
X	float		flood_locktill;		// locked from talking
X	float		flood_when[10];		// when messages were said
X	int			flood_whenhead;		// head pointer for when said
X
X	float		respawn_time;		// can respawn when time > this
X
X	edict_t		*chase_target;		// player we are chasing
X	qboolean	update_chase;		// need to update chase info?
X
//=======
//ROGUE
X	float		double_framenum;
X	float		ir_framenum;
//	float		torch_framenum;
X	float		nuke_framenum;
X	float		tracker_pain_framenum;
X
X	edict_t		*owned_sphere;		// this points to the player's sphere
//ROGUE
//=======
};
X
X
struct edict_s
{
X	entity_state_t	s;
X	struct gclient_s	*client;	// NULL if not a player
X									// the server expects the first part
X									// of gclient_s to be a player_state_t
X									// but the rest of it is opaque
X
X	qboolean	inuse;
X	int			linkcount;
X
X	// FIXME: move these fields to a server private sv_entity_t
X	link_t		area;				// linked to a division node or leaf
X	
X	int			num_clusters;		// if -1, use headnode instead
X	int			clusternums[MAX_ENT_CLUSTERS];
X	int			headnode;			// unused if num_clusters != -1
X	int			areanum, areanum2;
X
X	//================================
X
X	int			svflags;
X	vec3_t		mins, maxs;
X	vec3_t		absmin, absmax, size;
X	solid_t		solid;
X	int			clipmask;
X	edict_t		*owner;
X
X
X	// DO NOT MODIFY ANYTHING ABOVE THIS, THE SERVER
X	// EXPECTS THE FIELDS IN THAT ORDER!
X
X	//================================
X	int			movetype;
X	int			flags;
X
X	char		*model;
X	float		freetime;			// sv.time when the object was freed
X	
X	//
X	// only used locally in game, not by server
X	//
X	char		*message;
X	char		*classname;
X	int			spawnflags;
X
X	float		timestamp;
X
X	float		angle;			// set in qe3, -1 = up, -2 = down
X	char		*target;
X	char		*targetname;
X	char		*killtarget;
X	char		*team;
X	char		*pathtarget;
X	char		*deathtarget;
X	char		*combattarget;
X	edict_t		*target_ent;
X
X	float		speed, accel, decel;
X	vec3_t		movedir;
X	vec3_t		pos1, pos2;
X
X	vec3_t		velocity;
X	vec3_t		avelocity;
X	int			mass;
X	float		air_finished;
X	float		gravity;		// per entity gravity multiplier (1.0 is normal)
X								// use for lowgrav artifact, flares
X
X	edict_t		*goalentity;
X	edict_t		*movetarget;
X	float		yaw_speed;
X	float		ideal_yaw;
X
X	float		nextthink;
X	void		(*prethink) (edict_t *ent);
X	void		(*think)(edict_t *self);
X	void		(*blocked)(edict_t *self, edict_t *other);	//move to moveinfo?
X	void		(*touch)(edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf);
X	void		(*use)(edict_t *self, edict_t *other, edict_t *activator);
X	void		(*pain)(edict_t *self, edict_t *other, float kick, int damage);
X	void		(*die)(edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
X
X	float		touch_debounce_time;		// are all these legit?  do we need more/less of them?
X	float		pain_debounce_time;
X	float		damage_debounce_time;
X	float		fly_sound_debounce_time;	//move to clientinfo
X	float		last_move_time;
X
X	int			health;
X	int			max_health;
X	int			gib_health;
X	int			deadflag;
X	qboolean	show_hostile;
X
X	float		powerarmor_time;
X
X	char		*map;			// target_changelevel
X
X	int			viewheight;		// height above origin where eyesight is determined
X	int			takedamage;
X	int			dmg;
X	int			radius_dmg;
X	float		dmg_radius;
X	int			sounds;			//make this a spawntemp var?
X	int			count;
X
X	edict_t		*chain;
X	edict_t		*enemy;
X	edict_t		*oldenemy;
X	edict_t		*activator;
X	edict_t		*groundentity;
X	int			groundentity_linkcount;
X	edict_t		*teamchain;
X	edict_t		*teammaster;
X
X	edict_t		*mynoise;		// can go in client only
X	edict_t		*mynoise2;
X
X	int			noise_index;
X	int			noise_index2;
X	float		volume;
X	float		attenuation;
X
X	// timing variables
X	float		wait;
X	float		delay;			// before firing targets
X	float		random;
X
X	float		teleport_time;
X
X	int			watertype;
X	int			waterlevel;
X
X	vec3_t		move_origin;
X	vec3_t		move_angles;
X
X	// move this to clientinfo?
X	int			light_level;
X
X	int			style;			// also used as areaportal number
X
X	gitem_t		*item;			// for bonus items
X
X	// common data blocks
X	moveinfo_t		moveinfo;
X	monsterinfo_t	monsterinfo;
X
//=========
//ROGUE
X	int			plat2flags;
X	vec3_t		offset;
X	vec3_t		gravityVector;
X	edict_t		*bad_area;
X	edict_t		*hint_chain;
X	edict_t		*monster_hint_chain;
X	edict_t		*target_hint_chain;
X	int			hint_chain_id;
X	// FIXME - debug help!
X	float		lastMoveTime;
//ROGUE
//=========
};
X
//=============
//ROGUE
#define ROGUE_GRAVITY	1
X
#define SPHERE_DEFENDER			0x0001
#define SPHERE_HUNTER			0x0002
#define SPHERE_VENGEANCE		0x0004
#define SPHERE_DOPPLEGANGER		0x0100
X
#define SPHERE_TYPE				0x00FF
#define SPHERE_FLAGS			0xFF00
X
//
// deathmatch games
//
#define		RDM_TAG			2
#define		RDM_DEATHBALL	3
X
typedef struct dm_game_rs
{
X	void		(*GameInit)(void);
X	void		(*PostInitSetup)(void);
X	void		(*ClientBegin) (edict_t *ent);
X	void		(*SelectSpawnPoint) (edict_t *ent, vec3_t origin, vec3_t angles);
X	void		(*PlayerDeath)(edict_t *targ, edict_t *inflictor, edict_t *attacker);
X	void		(*Score)(edict_t *attacker, edict_t *victim, int scoreChange);
X	void		(*PlayerEffects)(edict_t *ent);
X	void		(*DogTag)(edict_t *ent, edict_t *killer, char **pic);
X	void		(*PlayerDisconnect)(edict_t *ent);
X	int			(*ChangeDamage)(edict_t *targ, edict_t *attacker, int damage, int mod);
X	int			(*ChangeKnockback)(edict_t *targ, edict_t *attacker, int knockback, int mod);
X	int			(*CheckDMRules)(void);
} dm_game_rt;
X
extern dm_game_rt	DMGame;
X
void Tag_GameInit (void);
void Tag_PostInitSetup (void);
void Tag_PlayerDeath (edict_t *targ, edict_t *inflictor, edict_t *attacker);
void Tag_Score (edict_t *attacker, edict_t *victim, int scoreChange);
void Tag_PlayerEffects (edict_t *ent);
void Tag_DogTag (edict_t *ent, edict_t *killer, char **pic);
void Tag_PlayerDisconnect (edict_t *ent);
int  Tag_ChangeDamage (edict_t *targ, edict_t *attacker, int damage, int mod);
X
void DBall_GameInit (void);
void DBall_ClientBegin (edict_t *ent);
void DBall_SelectSpawnPoint (edict_t *ent, vec3_t origin, vec3_t angles);
int  DBall_ChangeKnockback (edict_t *targ, edict_t *attacker, int knockback, int mod);
int  DBall_ChangeDamage (edict_t *targ, edict_t *attacker, int damage, int mod);
void DBall_PostInitSetup (void);
int  DBall_CheckDMRules (void);
//void Tag_PlayerDeath (edict_t *targ, edict_t *inflictor, edict_t *attacker);
//void Tag_Score (edict_t *attacker, edict_t *victim, int scoreChange);
//void Tag_PlayerEffects (edict_t *ent);
//void Tag_DogTag (edict_t *ent, edict_t *killer, char **pic);
//void Tag_PlayerDisconnect (edict_t *ent);
//int  Tag_ChangeDamage (edict_t *targ, edict_t *attacker, int damage);
X
//ROGUE
//============
SHAR_EOF
  $shar_touch -am 1130175398 'g_local.h' &&
  chmod 0664 'g_local.h' ||
  $echo 'restore of' 'g_local.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_local.h:' 'MD5 check failed'
b0b1da8aaa260b4659c3ccd022eb4dc3  g_local.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_local.h'`"
    test 40901 -eq "$shar_count" ||
    $echo 'g_local.h:' 'original size' '40901,' 'current size' "$shar_count!"
  fi
fi
# ============= g_main.c ==============
if test -f 'g_main.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_main.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_main.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_main.c' &&
X
#include "g_local.h"
X
game_locals_t	game;
level_locals_t	level;
game_import_t	gi;
game_export_t	globals;
spawn_temp_t	st;
X
int	sm_meat_index;
int	snd_fry;
int meansOfDeath;
X
edict_t		*g_edicts;
X
cvar_t	*deathmatch;
cvar_t	*coop;
cvar_t	*dmflags;
cvar_t	*skill;
cvar_t	*fraglimit;
cvar_t	*timelimit;
cvar_t	*password;
cvar_t	*spectator_password;
cvar_t	*maxclients;
cvar_t	*maxspectators;
cvar_t	*maxentities;
cvar_t	*g_select_empty;
cvar_t	*dedicated;
X
cvar_t	*filterban;
X
cvar_t	*sv_maxvelocity;
cvar_t	*sv_gravity;
X
cvar_t	*sv_rollspeed;
cvar_t	*sv_rollangle;
cvar_t	*gun_x;
cvar_t	*gun_y;
cvar_t	*gun_z;
X
cvar_t	*run_pitch;
cvar_t	*run_roll;
cvar_t	*bob_up;
cvar_t	*bob_pitch;
cvar_t	*bob_roll;
X
cvar_t	*sv_cheats;
X
cvar_t	*flood_msgs;
cvar_t	*flood_persecond;
cvar_t	*flood_waitdelay;
X
cvar_t	*sv_maplist;
X
cvar_t	*sv_stopspeed;	//PGM	 (this was a define in g_phys.c)
X
//ROGUE cvars
cvar_t	*g_showlogic;
cvar_t	*gamerules;
cvar_t	*huntercam;
cvar_t	*strong_mines;
cvar_t	*randomrespawn;
//ROGUE
X
void SpawnEntities (char *mapname, char *entities, char *spawnpoint);
void ClientThink (edict_t *ent, usercmd_t *cmd);
qboolean ClientConnect (edict_t *ent, char *userinfo);
void ClientUserinfoChanged (edict_t *ent, char *userinfo);
void ClientDisconnect (edict_t *ent);
void ClientBegin (edict_t *ent);
void ClientCommand (edict_t *ent);
void RunEntity (edict_t *ent);
void WriteGame (char *filename, qboolean autosave);
void ReadGame (char *filename);
void WriteLevel (char *filename);
void ReadLevel (char *filename);
void InitGame (void);
void G_RunFrame (void);
X
X
//===================================================================
X
X
void ShutdownGame (void)
{
X	gi.dprintf ("==== ShutdownGame ====\n");
X
X	gi.FreeTags (TAG_LEVEL);
X	gi.FreeTags (TAG_GAME);
}
X
X
/*
=================
GetGameAPI
X
Returns a pointer to the structure with all entry points
and global variables
=================
*/
game_export_t *GetGameAPI (game_import_t *import)
{
X	gi = *import;
X
X	globals.apiversion = GAME_API_VERSION;
X	globals.Init = InitGame;
X	globals.Shutdown = ShutdownGame;
X	globals.SpawnEntities = SpawnEntities;
X
X	globals.WriteGame = WriteGame;
X	globals.ReadGame = ReadGame;
X	globals.WriteLevel = WriteLevel;
X	globals.ReadLevel = ReadLevel;
X
X	globals.ClientThink = ClientThink;
X	globals.ClientConnect = ClientConnect;
X	globals.ClientUserinfoChanged = ClientUserinfoChanged;
X	globals.ClientDisconnect = ClientDisconnect;
X	globals.ClientBegin = ClientBegin;
X	globals.ClientCommand = ClientCommand;
X
X	globals.RunFrame = G_RunFrame;
X
X	globals.ServerCommand = ServerCommand;
X
X	globals.edict_size = sizeof(edict_t);
X
X	return &globals;
}
X
#ifndef GAME_HARD_LINKED
// this is only here so the functions in q_shared.c and q_shwin.c can link
void Sys_Error (char *error, ...)
{
X	va_list		argptr;
X	char		text[1024];
X
X	va_start (argptr, error);
X	vsprintf (text, error, argptr);
X	va_end (argptr);
X
X	gi.error (ERR_FATAL, "%s", text);
}
X
void Com_Printf (char *msg, ...)
{
X	va_list		argptr;
X	char		text[1024];
X
X	va_start (argptr, msg);
X	vsprintf (text, msg, argptr);
X	va_end (argptr);
X
X	gi.dprintf ("%s", text);
}
X
#endif
X
//======================================================================
X
X
/*
=================
ClientEndServerFrames
=================
*/
void ClientEndServerFrames (void)
{
X	int		i;
X	edict_t	*ent;
X
X	// calc the player views now that all pushing
X	// and damage has been added
X	for (i=0 ; i<maxclients->value ; i++)
X	{
X		ent = g_edicts + 1 + i;
X		if (!ent->inuse || !ent->client)
X			continue;
X		ClientEndServerFrame (ent);
X	}
X
}
X
/*
=================
CreateTargetChangeLevel
X
Returns the created target changelevel
=================
*/
edict_t *CreateTargetChangeLevel(char *map)
{
X	edict_t *ent;
X
X	ent = G_Spawn ();
X	ent->classname = "target_changelevel";
X	Com_sprintf(level.nextmap, sizeof(level.nextmap), "%s", map);
X	ent->map = level.nextmap;
X	return ent;
}
X
/*
=================
EndDMLevel
X
The timelimit or fraglimit has been exceeded
=================
*/
void EndDMLevel (void)
{
X	edict_t		*ent;
X	char *s, *t, *f;
X	static const char *seps = " ,\n\r";
X
X	// stay on same level flag
X	if ((int)dmflags->value & DF_SAME_LEVEL)
X	{
X		BeginIntermission (CreateTargetChangeLevel (level.mapname) );
X		return;
X	}
X
X	// see if it's in the map list
X	if (*sv_maplist->string) {
X		s = strdup(sv_maplist->string);
X		f = NULL;
X		t = strtok(s, seps);
X		while (t != NULL) {
X			if (Q_stricmp(t, level.mapname) == 0) {
X				// it's in the list, go to the next one
X				t = strtok(NULL, seps);
X				if (t == NULL) { // end of list, go to first one
X					if (f == NULL) // there isn't a first one, same level
X						BeginIntermission (CreateTargetChangeLevel (level.mapname) );
X					else
X						BeginIntermission (CreateTargetChangeLevel (f) );
X				} else
X					BeginIntermission (CreateTargetChangeLevel (t) );
X				free(s);
X				return;
X			}
X			if (!f)
X				f = t;
X			t = strtok(NULL, seps);
X		}
X		free(s);
X	}
X
X	if (level.nextmap[0]) // go to a specific map
X		BeginIntermission (CreateTargetChangeLevel (level.nextmap) );
X	else {	// search for a changelevel
X		ent = G_Find (NULL, FOFS(classname), "target_changelevel");
X		if (!ent)
X		{	// the map designer didn't include a changelevel,
X			// so create a fake ent that goes back to the same level
X			BeginIntermission (CreateTargetChangeLevel (level.mapname) );
X			return;
X		}
X		BeginIntermission (ent);
X	}
}
X
/*
=================
CheckDMRules
=================
*/
void CheckDMRules (void)
{
X	int			i;
X	gclient_t	*cl;
X
X	if (level.intermissiontime)
X		return;
X
X	if (!deathmatch->value)
X		return;
X
//=======
//ROGUE
X	if (gamerules && gamerules->value && DMGame.CheckDMRules)
X	{
X		if(DMGame.CheckDMRules())
X			return;
X	}
//ROGUE
//=======
X
X	if (timelimit->value)
X	{
X		if (level.time >= timelimit->value*60)
X		{
X			gi.bprintf (PRINT_HIGH, "Timelimit hit.\n");
X			EndDMLevel ();
X			return;
X		}
X	}
X
X	if (fraglimit->value)
X	{
X		for (i=0 ; i<maxclients->value ; i++)
X		{
X			cl = game.clients + i;
X			if (!g_edicts[i+1].inuse)
X				continue;
X
X			if (cl->resp.score >= fraglimit->value)
X			{
X				gi.bprintf (PRINT_HIGH, "Fraglimit hit.\n");
X				EndDMLevel ();
X				return;
X			}
X		}
X	}
}
X
X
/*
=============
ExitLevel
=============
*/
void ExitLevel (void)
{
X	int		i;
X	edict_t	*ent;
X	char	command [256];
X
X	Com_sprintf (command, sizeof(command), "gamemap \"%s\"\n", level.changemap);
X	gi.AddCommandString (command);
X	level.changemap = NULL;
X	level.exitintermission = 0;
X	level.intermissiontime = 0;
X	ClientEndServerFrames ();
X
X	// clear some things before going to next level
X	for (i=0 ; i<maxclients->value ; i++)
X	{
X		ent = g_edicts + 1 + i;
X		if (!ent->inuse)
X			continue;
X		if (ent->health > ent->client->pers.max_health)
X			ent->health = ent->client->pers.max_health;
X	}
X
}
X
/*
================
G_RunFrame
X
Advances the world by 0.1 seconds
================
*/
void G_RunFrame (void)
{
X	int		i;
X	edict_t	*ent;
X
X	level.framenum++;
X	level.time = level.framenum*FRAMETIME;
X
X	// choose a client for monsters to target this frame
X	AI_SetSightClient ();
X
X	// exit intermissions
X
X	if (level.exitintermission)
X	{
X		ExitLevel ();
X		return;
X	}
X
X	//
X	// treat each object in turn
X	// even the world gets a chance to think
X	//
X	ent = &g_edicts[0];
X	for (i=0 ; i<globals.num_edicts ; i++, ent++)
X	{
X		if (!ent->inuse)
X			continue;
X
X		level.current_entity = ent;
X
X		VectorCopy (ent->s.origin, ent->s.old_origin);
X
X		// if the ground entity moved, make sure we are still on it
X		if ((ent->groundentity) && (ent->groundentity->linkcount != ent->groundentity_linkcount))
X		{
X			ent->groundentity = NULL;
X			if ( !(ent->flags & (FL_SWIM|FL_FLY)) && (ent->svflags & SVF_MONSTER) )
X			{
X				M_CheckGround (ent);
X			}
X		}
X
X		if (i > 0 && i <= maxclients->value)
X		{
X			ClientBeginServerFrame (ent);
X			continue;
X		}
X
X		G_RunEntity (ent);
X	}
X
X	// see if it is time to end a deathmatch
X	CheckDMRules ();
X
X	// build the playerstate_t structures for all players
X	ClientEndServerFrames ();
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_main.c' &&
  chmod 0664 'g_main.c' ||
  $echo 'restore of' 'g_main.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_main.c:' 'MD5 check failed'
a4befd4875da3b7768772d54c99d92e9  g_main.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_main.c'`"
    test 7883 -eq "$shar_count" ||
    $echo 'g_main.c:' 'original size' '7883,' 'current size' "$shar_count!"
  fi
fi
# ============= g_misc.c ==============
if test -f 'g_misc.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_misc.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_misc.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_misc.c' &&
// g_misc.c
X
#include "g_local.h"
X
extern void M_WorldEffects (edict_t *ent);
X
/*QUAKED func_group (0 0 0) ?
Used to group brushes together just for editor convenience.
*/
X
//=====================================================
X
void Use_Areaportal (edict_t *ent, edict_t *other, edict_t *activator)
{
X	ent->count ^= 1;		// toggle state
//	gi.dprintf ("portalstate: %i = %i\n", ent->style, ent->count);
X	gi.SetAreaPortalState (ent->style, ent->count);
}
X
/*QUAKED func_areaportal (0 0 0) ?
X
This is a non-visible object that divides the world into
areas that are seperated when this portal is not activated.
Usually enclosed in the middle of a door.
*/
void SP_func_areaportal (edict_t *ent)
{
X	ent->use = Use_Areaportal;
X	ent->count = 0;		// always start closed;
}
X
//=====================================================
X
X
/*
=================
Misc functions
=================
*/
void VelocityForDamage (int damage, vec3_t v)
{
X	v[0] = 100.0 * crandom();
X	v[1] = 100.0 * crandom();
X	v[2] = 200.0 + 100.0 * random();
X
X	if (damage < 50)
X		VectorScale (v, 0.7, v);
X	else 
X		VectorScale (v, 1.2, v);
}
X
void ClipGibVelocity (edict_t *ent)
{
X	if (ent->velocity[0] < -300)
X		ent->velocity[0] = -300;
X	else if (ent->velocity[0] > 300)
X		ent->velocity[0] = 300;
X	if (ent->velocity[1] < -300)
X		ent->velocity[1] = -300;
X	else if (ent->velocity[1] > 300)
X		ent->velocity[1] = 300;
X	if (ent->velocity[2] < 200)
X		ent->velocity[2] = 200;	// always some upwards
X	else if (ent->velocity[2] > 500)
X		ent->velocity[2] = 500;
}
X
X
/*
=================
gibs
=================
*/
void gib_think (edict_t *self)
{
X	self->s.frame++;
X	self->nextthink = level.time + FRAMETIME;
X
X	if (self->s.frame == 10)
X	{
X		self->think = G_FreeEdict;
X		self->nextthink = level.time + 8 + random()*10;
X	}
}
X
void gib_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	vec3_t	normal_angles, right;
X
X	if (!self->groundentity)
X		return;
X
X	self->touch = NULL;
X
X	if (plane)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/fhit3.wav"), 1, ATTN_NORM, 0);
X
X		vectoangles (plane->normal, normal_angles);
X		AngleVectors (normal_angles, NULL, right, NULL);
X		vectoangles (right, self->s.angles);
X
X		if (self->s.modelindex == sm_meat_index)
X		{
X			self->s.frame++;
X			self->think = gib_think;
X			self->nextthink = level.time + FRAMETIME;
X		}
X	}
}
X
void gib_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	G_FreeEdict (self);
}
X
void ThrowGib (edict_t *self, char *gibname, int damage, int type)
{
X	edict_t *gib;
X	vec3_t	vd;
X	vec3_t	origin;
X	vec3_t	size;
X	float	vscale;
X
X	gib = G_Spawn();
X
X	VectorScale (self->size, 0.5, size);
X	VectorAdd (self->absmin, size, origin);
X	gib->s.origin[0] = origin[0] + crandom() * size[0];
X	gib->s.origin[1] = origin[1] + crandom() * size[1];
X	gib->s.origin[2] = origin[2] + crandom() * size[2];
X
X	gi.setmodel (gib, gibname);
X	gib->solid = SOLID_NOT;
X	gib->s.effects |= EF_GIB;
X	gib->flags |= FL_NO_KNOCKBACK;
X	gib->takedamage = DAMAGE_YES;
X	gib->die = gib_die;
X
X	if (type == GIB_ORGANIC)
X	{
X		gib->movetype = MOVETYPE_TOSS;
X		gib->touch = gib_touch;
X		vscale = 0.5;
X	}
X	else
X	{
X		gib->movetype = MOVETYPE_BOUNCE;
X		vscale = 1.0;
X	}
X
X	VelocityForDamage (damage, vd);
X	VectorMA (self->velocity, vscale, vd, gib->velocity);
X	ClipGibVelocity (gib);
X	gib->avelocity[0] = random()*600;
X	gib->avelocity[1] = random()*600;
X	gib->avelocity[2] = random()*600;
X
X	gib->think = G_FreeEdict;
X	gib->nextthink = level.time + 10 + random()*10;
X
//PGM
X	gib->s.renderfx |= RF_IR_VISIBLE;
//PGM
X
X	gi.linkentity (gib);
}
X
void ThrowHead (edict_t *self, char *gibname, int damage, int type)
{
X	vec3_t	vd;
X	float	vscale;
X
X	self->s.skinnum = 0;
X	self->s.frame = 0;
X	VectorClear (self->mins);
X	VectorClear (self->maxs);
X
X	self->s.modelindex2 = 0;
X	gi.setmodel (self, gibname);
X	self->solid = SOLID_NOT;
X	self->s.effects |= EF_GIB;
X	self->s.effects &= ~EF_FLIES;
X	self->s.sound = 0;
X	self->flags |= FL_NO_KNOCKBACK;
X	self->svflags &= ~SVF_MONSTER;
X	self->takedamage = DAMAGE_YES;
X	self->die = gib_die;
X
X	if (type == GIB_ORGANIC)
X	{
X		self->movetype = MOVETYPE_TOSS;
X		self->touch = gib_touch;
X		vscale = 0.5;
X	}
X	else
X	{
X		self->movetype = MOVETYPE_BOUNCE;
X		vscale = 1.0;
X	}
X
X	VelocityForDamage (damage, vd);
X	VectorMA (self->velocity, vscale, vd, self->velocity);
X	ClipGibVelocity (self);
X
X	self->avelocity[YAW] = crandom()*600;
X
X	self->think = G_FreeEdict;
X	self->nextthink = level.time + 10 + random()*10;
X
X	gi.linkentity (self);
}
X
X
void ThrowClientHead (edict_t *self, int damage)
{
X	vec3_t	vd;
X	char	*gibname;
X
X	if (rand()&1)
X	{
X		gibname = "models/objects/gibs/head2/tris.md2";
X		self->s.skinnum = 1;		// second skin is player
X	}
X	else
X	{
X		gibname = "models/objects/gibs/skull/tris.md2";
X		self->s.skinnum = 0;
X	}
X
X	self->s.origin[2] += 32;
X	self->s.frame = 0;
X	gi.setmodel (self, gibname);
X	VectorSet (self->mins, -16, -16, 0);
X	VectorSet (self->maxs, 16, 16, 16);
X
X	self->takedamage = DAMAGE_NO;
X	self->solid = SOLID_NOT;
X	self->s.effects = EF_GIB;
X	self->s.sound = 0;
X	self->flags |= FL_NO_KNOCKBACK;
X
X	self->movetype = MOVETYPE_BOUNCE;
X	VelocityForDamage (damage, vd);
X	VectorAdd (self->velocity, vd, self->velocity);
X
X	if (self->client)	// bodies in the queue don't have a client anymore
X	{
X		self->client->anim_priority = ANIM_DEATH;
X		self->client->anim_end = self->s.frame;
X	}
X	else
X	{
X		self->think = NULL;
X		self->nextthink = 0;
X	}
X
X	gi.linkentity (self);
}
X
X
/*
=================
debris
=================
*/
void debris_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	G_FreeEdict (self);
}
X
void ThrowDebris (edict_t *self, char *modelname, float speed, vec3_t origin)
{
X	edict_t	*chunk;
X	vec3_t	v;
X
X	chunk = G_Spawn();
X	VectorCopy (origin, chunk->s.origin);
X	gi.setmodel (chunk, modelname);
X	v[0] = 100 * crandom();
X	v[1] = 100 * crandom();
X	v[2] = 100 + 100 * crandom();
X	VectorMA (self->velocity, speed, v, chunk->velocity);
X	chunk->movetype = MOVETYPE_BOUNCE;
X	chunk->solid = SOLID_NOT;
X	chunk->avelocity[0] = random()*600;
X	chunk->avelocity[1] = random()*600;
X	chunk->avelocity[2] = random()*600;
X	chunk->think = G_FreeEdict;
X	chunk->nextthink = level.time + 5 + random()*5;
X	chunk->s.frame = 0;
X	chunk->flags = 0;
X	chunk->classname = "debris";
X	chunk->takedamage = DAMAGE_YES;
X	chunk->die = debris_die;
X	gi.linkentity (chunk);
}
X
X
void BecomeExplosion1 (edict_t *self)
{
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	G_FreeEdict (self);
}
X
X
void BecomeExplosion2 (edict_t *self)
{
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION2);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	G_FreeEdict (self);
}
X
X
/*QUAKED path_corner (.5 .3 0) (-8 -8 -8) (8 8 8) TELEPORT
Target: next path corner
Pathtarget: gets used when an entity that has
X	this path_corner targeted touches it
*/
X
void path_corner_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	vec3_t		v;
X	edict_t		*next;
X
X	if (other->movetarget != self)
X		return;
X	
X	if (other->enemy)
X		return;
X
X	if (self->pathtarget)
X	{
X		char *savetarget;
X
X		savetarget = self->target;
X		self->target = self->pathtarget;
X		G_UseTargets (self, other);
X		self->target = savetarget;
X	}
X
X	if (self->target)
X		next = G_PickTarget(self->target);
X	else
X		next = NULL;
X
X	if ((next) && (next->spawnflags & 1))
X	{
X		VectorCopy (next->s.origin, v);
X		v[2] += next->mins[2];
X		v[2] -= other->mins[2];
X		VectorCopy (v, other->s.origin);
X		next = G_PickTarget(next->target);
X		other->s.event = EV_OTHER_TELEPORT;
X	}
X
X	other->goalentity = other->movetarget = next;
X
X	if (self->wait)
X	{
X		other->monsterinfo.pausetime = level.time + self->wait;
X		other->monsterinfo.stand (other);
X		return;
X	}
X
X	if (!other->movetarget)
X	{
X		other->monsterinfo.pausetime = level.time + 100000000;
X		other->monsterinfo.stand (other);
X	}
X	else
X	{
X		VectorSubtract (other->goalentity->s.origin, other->s.origin, v);
X		other->ideal_yaw = vectoyaw (v);
X	}
}
X
void SP_path_corner (edict_t *self)
{
X	if (!self->targetname)
X	{
X		gi.dprintf ("path_corner with no targetname at %s\n", vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->solid = SOLID_TRIGGER;
X	self->touch = path_corner_touch;
X	VectorSet (self->mins, -8, -8, -8);
X	VectorSet (self->maxs, 8, 8, 8);
X	self->svflags |= SVF_NOCLIENT;
X	gi.linkentity (self);
}
X
X
/*QUAKED point_combat (0.5 0.3 0) (-8 -8 -8) (8 8 8) Hold
Makes this the target of a monster and it will head here
when first activated before going after the activator.  If
hold is selected, it will stay here.
*/
void point_combat_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t	*activator;
X
X	if (other->movetarget != self)
X		return;
X
X	if (self->target)
X	{
X		other->target = self->target;
X		other->goalentity = other->movetarget = G_PickTarget(other->target);
X		if (!other->goalentity)
X		{
X			gi.dprintf("%s at %s target %s does not exist\n", self->classname, vtos(self->s.origin), self->target);
X			other->movetarget = self;
X		}
X		self->target = NULL;
X	}
X	else if ((self->spawnflags & 1) && !(other->flags & (FL_SWIM|FL_FLY)))
X	{
X		other->monsterinfo.pausetime = level.time + 100000000;
X		other->monsterinfo.aiflags |= AI_STAND_GROUND;
X		other->monsterinfo.stand (other);
X	}
X
X	if (other->movetarget == self)
X	{
X		other->target = NULL;
X		other->movetarget = NULL;
X		other->goalentity = other->enemy;
X		other->monsterinfo.aiflags &= ~AI_COMBAT_POINT;
X	}
X
X	if (self->pathtarget)
X	{
X		char *savetarget;
X
X		savetarget = self->target;
X		self->target = self->pathtarget;
X		if (other->enemy && other->enemy->client)
X			activator = other->enemy;
X		else if (other->oldenemy && other->oldenemy->client)
X			activator = other->oldenemy;
X		else if (other->activator && other->activator->client)
X			activator = other->activator;
X		else
X			activator = other;
X		G_UseTargets (self, activator);
X		self->target = savetarget;
X	}
}
X
void SP_point_combat (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X	self->solid = SOLID_TRIGGER;
X	self->touch = point_combat_touch;
X	VectorSet (self->mins, -8, -8, -16);
X	VectorSet (self->maxs, 8, 8, 16);
X	self->svflags = SVF_NOCLIENT;
X	gi.linkentity (self);
};
X
X
/*QUAKED viewthing (0 .5 .8) (-8 -8 -8) (8 8 8)
Just for the debugging level.  Don't use
*/
void TH_viewthing(edict_t *ent)
{
X	ent->s.frame = (ent->s.frame + 1) % 7;
X	ent->nextthink = level.time + FRAMETIME;
}
X
void SP_viewthing(edict_t *ent)
{
X	gi.dprintf ("viewthing spawned\n");
X
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	ent->s.renderfx = RF_FRAMELERP;
X	VectorSet (ent->mins, -16, -16, -24);
X	VectorSet (ent->maxs, 16, 16, 32);
X	ent->s.modelindex = gi.modelindex ("models/objects/banner/tris.md2");
X	gi.linkentity (ent);
X	ent->nextthink = level.time + 0.5;
X	ent->think = TH_viewthing;
X	return;
}
X
X
/*QUAKED info_null (0 0.5 0) (-4 -4 -4) (4 4 4)
Used as a positional target for spotlights, etc.
*/
void SP_info_null (edict_t *self)
{
X	G_FreeEdict (self);
};
X
X
/*QUAKED info_notnull (0 0.5 0) (-4 -4 -4) (4 4 4)
Used as a positional target for lightning.
*/
void SP_info_notnull (edict_t *self)
{
X	VectorCopy (self->s.origin, self->absmin);
X	VectorCopy (self->s.origin, self->absmax);
};
X
X
/*QUAKED light (0 1 0) (-8 -8 -8) (8 8 8) START_OFF
Non-displayed light.
Default light value is 300.
Default style is 0.
If targeted, will toggle between on and off.
Default _cone value is 10 (used to set size of light for spotlights)
*/
X
#define START_OFF	1
X
static void light_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->spawnflags & START_OFF)
X	{
X		gi.configstring (CS_LIGHTS+self->style, "m");
X		self->spawnflags &= ~START_OFF;
X	}
X	else
X	{
X		gi.configstring (CS_LIGHTS+self->style, "a");
X		self->spawnflags |= START_OFF;
X	}
}
X
void SP_light (edict_t *self)
{
X	// no targeted lights in deathmatch, because they cause global messages
X	if (!self->targetname || deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (self->style >= 32)
X	{
X		self->use = light_use;
X		if (self->spawnflags & START_OFF)
X			gi.configstring (CS_LIGHTS+self->style, "a");
X		else
X			gi.configstring (CS_LIGHTS+self->style, "m");
X	}
}
X
X
/*QUAKED func_wall (0 .5 .8) ? TRIGGER_SPAWN TOGGLE START_ON ANIMATED ANIMATED_FAST
This is just a solid wall if not inhibited
X
TRIGGER_SPAWN	the wall will not be present until triggered
X				it will then blink in to existance; it will
X				kill anything that was in it's way
X
TOGGLE			only valid for TRIGGER_SPAWN walls
X				this allows the wall to be turned on and off
X
START_ON		only valid for TRIGGER_SPAWN walls
X				the wall will initially be present
*/
X
void func_wall_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->solid == SOLID_NOT)
X	{
X		self->solid = SOLID_BSP;
X		self->svflags &= ~SVF_NOCLIENT;
X		KillBox (self);
X	}
X	else
X	{
X		self->solid = SOLID_NOT;
X		self->svflags |= SVF_NOCLIENT;
X	}
X	gi.linkentity (self);
X
X	if (!(self->spawnflags & 2))
X		self->use = NULL;
}
X
void SP_func_wall (edict_t *self)
{
X	self->movetype = MOVETYPE_PUSH;
X	gi.setmodel (self, self->model);
X
X	if (self->spawnflags & 8)
X		self->s.effects |= EF_ANIM_ALL;
X	if (self->spawnflags & 16)
X		self->s.effects |= EF_ANIM_ALLFAST;
X
X	// just a wall
X	if ((self->spawnflags & 7) == 0)
X	{
X		self->solid = SOLID_BSP;
X		gi.linkentity (self);
X		return;
X	}
X
X	// it must be TRIGGER_SPAWN
X	if (!(self->spawnflags & 1))
X	{
//		gi.dprintf("func_wall missing TRIGGER_SPAWN\n");
X		self->spawnflags |= 1;
X	}
X
X	// yell if the spawnflags are odd
X	if (self->spawnflags & 4)
X	{
X		if (!(self->spawnflags & 2))
X		{
X			gi.dprintf("func_wall START_ON without TOGGLE\n");
X			self->spawnflags |= 2;
X		}
X	}
X
X	self->use = func_wall_use;
X	if (self->spawnflags & 4)
X	{
X		self->solid = SOLID_BSP;
X	}
X	else
X	{
X		self->solid = SOLID_NOT;
X		self->svflags |= SVF_NOCLIENT;
X	}
X	gi.linkentity (self);
}
X
X
/*QUAKED func_object (0 .5 .8) ? TRIGGER_SPAWN ANIMATED ANIMATED_FAST
This is solid bmodel that will fall if it's support it removed.
*/
X
void func_object_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	// only squash thing we fall on top of
X	if (!plane)
X		return;
X	if (plane->normal[2] < 1.0)
X		return;
X	if (other->takedamage == DAMAGE_NO)
X		return;
X	T_Damage (other, self, self, vec3_origin, self->s.origin, vec3_origin, self->dmg, 1, 0, MOD_CRUSH);
}
X
void func_object_release (edict_t *self)
{
X	self->movetype = MOVETYPE_TOSS;
X	self->touch = func_object_touch;
}
X
void func_object_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->solid = SOLID_BSP;
X	self->svflags &= ~SVF_NOCLIENT;
X	self->use = NULL;
X	KillBox (self);
X	func_object_release (self);
}
X
void SP_func_object (edict_t *self)
{
X	gi.setmodel (self, self->model);
X
X	self->mins[0] += 1;
X	self->mins[1] += 1;
X	self->mins[2] += 1;
X	self->maxs[0] -= 1;
X	self->maxs[1] -= 1;
X	self->maxs[2] -= 1;
X
X	if (!self->dmg)
X		self->dmg = 100;
X
X	if (self->spawnflags == 0)
X	{
X		self->solid = SOLID_BSP;
X		self->movetype = MOVETYPE_PUSH;
X		self->think = func_object_release;
X		self->nextthink = level.time + 2 * FRAMETIME;
X	}
X	else
X	{
X		self->solid = SOLID_NOT;
X		self->movetype = MOVETYPE_PUSH;
X		self->use = func_object_use;
X		self->svflags |= SVF_NOCLIENT;
X	}
X
X	if (self->spawnflags & 2)
X		self->s.effects |= EF_ANIM_ALL;
X	if (self->spawnflags & 4)
X		self->s.effects |= EF_ANIM_ALLFAST;
X
X	self->clipmask = MASK_MONSTERSOLID;
X
X	gi.linkentity (self);
}
X
X
/*QUAKED func_explosive (0 .5 .8) ? Trigger_Spawn ANIMATED ANIMATED_FAST INACTIVE
Any brush that you want to explode or break apart.  If you want an
ex0plosion, set dmg and it will do a radius explosion of that amount
at the center of the bursh.
X
If targeted it will not be shootable.
X
INACTIVE - specifies that the entity is not explodable until triggered. If you use this you must
target the entity you want to trigger it. This is the only entity approved to activate it.
X
health defaults to 100.
X
mass defaults to 75.  This determines how much debris is emitted when
it explodes.  You get one large chunk per 100 of mass (up to 8) and
one small chunk per 25 of mass (up to 16).  So 800 gives the most.
*/
void func_explosive_explode (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	vec3_t	origin;
X	vec3_t	chunkorigin;
X	vec3_t	size;
X	int		count;
X	int		mass;
X	edict_t	*master;
X	qboolean	done = false;
X
X	// bmodel origins are (0 0 0), we need to adjust that here
X	VectorScale (self->size, 0.5, size);
X	VectorAdd (self->absmin, size, origin);
X	VectorCopy (origin, self->s.origin);
X
X	self->takedamage = DAMAGE_NO;
X
X	if (self->dmg)
X		T_RadiusDamage (self, attacker, self->dmg, NULL, self->dmg+40, MOD_EXPLOSIVE);
X
X	VectorSubtract (self->s.origin, inflictor->s.origin, self->velocity);
X	VectorNormalize (self->velocity);
X	VectorScale (self->velocity, 150, self->velocity);
X
X	// start chunks towards the center
X	VectorScale (size, 0.5, size);
X
X	mass = self->mass;
X	if (!mass)
X		mass = 75;
X
X	// big chunks
X	if (mass >= 100)
X	{
X		count = mass / 100;
X		if (count > 8)
X			count = 8;
X		while(count--)
X		{
X			chunkorigin[0] = origin[0] + crandom() * size[0];
X			chunkorigin[1] = origin[1] + crandom() * size[1];
X			chunkorigin[2] = origin[2] + crandom() * size[2];
X			ThrowDebris (self, "models/objects/debris1/tris.md2", 1, chunkorigin);
X		}
X	}
X
X	// small chunks
X	count = mass / 25;
X	if (count > 16)
X		count = 16;
X	while(count--)
X	{
X		chunkorigin[0] = origin[0] + crandom() * size[0];
X		chunkorigin[1] = origin[1] + crandom() * size[1];
X		chunkorigin[2] = origin[2] + crandom() * size[2];
X		ThrowDebris (self, "models/objects/debris2/tris.md2", 2, chunkorigin);
X	}
X
X	// PMM - if we're part of a train, clean ourselves out of it
X	if (self->flags & FL_TEAMSLAVE)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Removing func_explosive from train!\n");
X
X		if (self->teammaster)
X		{
X			master = self->teammaster;
X			if(master && master->inuse)		// because mappers (other than jim (usually)) are stupid....
X			{
X				while (!done)
X				{
X					if (master->teamchain == self)
X					{
X						master->teamchain = self->teamchain;
X						done = true;
X					}
X					master = master->teamchain;
X					if (!master)
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("Couldn't find myself in master's chain, ignoring!\n");
X					}
X				}
X			}
X		}
X		else
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("No master to free myself from, ignoring!\n");
X		}
X	}
X
X	G_UseTargets (self, attacker);
X
X	if (self->dmg)
X		BecomeExplosion1 (self);
X	else
X		G_FreeEdict (self);
}
X
void func_explosive_use(edict_t *self, edict_t *other, edict_t *activator)
{
X	func_explosive_explode (self, self, other, self->health, vec3_origin);
}
X
//PGM
void func_explosive_activate(edict_t *self, edict_t *other, edict_t *activator)
{
X	int approved;
X
X	approved = 0;
X	// PMM - looked like target and targetname were flipped here
X	if (other != NULL && other->target)
X	{
X		if(!strcmp(other->target, self->targetname))
X			approved = 1;
X	}
X	if (!approved && activator!=NULL && activator->target)
X	{
X		if(!strcmp(activator->target, self->targetname))
X			approved = 1;
X	}
X
X	if (!approved)
X	{
//		gi.dprintf("func_explosive_activate: incorrect activator\n");
X		return;
X	}
X
X	// PMM - according to mappers, they don't need separate cases for blowupable and triggerable
//	if (self->target)
//	{
X		self->use = func_explosive_use;
//	}
//	else
//	{
X		if (!self->health)
X			self->health = 100;
X		self->die = func_explosive_explode;
X		self->takedamage = DAMAGE_YES;
//	}
}
//PGM
X
void func_explosive_spawn (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->solid = SOLID_BSP;
X	self->svflags &= ~SVF_NOCLIENT;
X	self->use = NULL;
X	KillBox (self);
X	gi.linkentity (self);
}
X
void SP_func_explosive (edict_t *self)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->movetype = MOVETYPE_PUSH;
X
X	gi.modelindex ("models/objects/debris1/tris.md2");
X	gi.modelindex ("models/objects/debris2/tris.md2");
X
X	gi.setmodel (self, self->model);
X
X	if (self->spawnflags & 1)
X	{
X		self->svflags |= SVF_NOCLIENT;
X		self->solid = SOLID_NOT;
X		self->use = func_explosive_spawn;
X	}
//PGM
X	else if(self->spawnflags & 8)
X	{
X		self->solid = SOLID_BSP;
X		if(self->targetname)
X			self->use = func_explosive_activate;
X	}
//PGM
X	else
X	{
X		self->solid = SOLID_BSP;
X		if (self->targetname)
X			self->use = func_explosive_use;
X	}
X
X	if (self->spawnflags & 2)
X		self->s.effects |= EF_ANIM_ALL;
X	if (self->spawnflags & 4)
X		self->s.effects |= EF_ANIM_ALLFAST;
X
//PGM
X	if ((self->use != func_explosive_use) && (self->use != func_explosive_activate))
//PGM
X	{
X		if (!self->health)
X			self->health = 100;
X		self->die = func_explosive_explode;
X		self->takedamage = DAMAGE_YES;
X	}
X
X	gi.linkentity (self);
}
X
X
/*QUAKED misc_explobox (0 .5 .8) (-16 -16 0) (16 16 40)
Large exploding box.  You can override its mass (100),
health (80), and dmg (150).
*/
X
void barrel_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
X
{
X	float	ratio;
X	vec3_t	v;
X
X	if ((!other->groundentity) || (other->groundentity == self))
X		return;
X
X	ratio = (float)other->mass / (float)self->mass;
X	VectorSubtract (self->s.origin, other->s.origin, v);
X	M_walkmove (self, vectoyaw(v), 20 * ratio * FRAMETIME);
}
X
void barrel_explode (edict_t *self)
{
X	vec3_t	org;
X	float	spd;
X	vec3_t	save;
X
X	T_RadiusDamage (self, self->activator, self->dmg, NULL, self->dmg+40, MOD_BARREL);
X
X	VectorCopy (self->s.origin, save);
X	VectorMA (self->absmin, 0.5, self->size, self->s.origin);
X
X	// a few big chunks
X	spd = 1.5 * (float)self->dmg / 200.0;
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris1/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris1/tris.md2", spd, org);
X
X	// bottom corners
X	spd = 1.75 * (float)self->dmg / 200.0;
X	VectorCopy (self->absmin, org);
X	ThrowDebris (self, "models/objects/debris3/tris.md2", spd, org);
X	VectorCopy (self->absmin, org);
X	org[0] += self->size[0];
X	ThrowDebris (self, "models/objects/debris3/tris.md2", spd, org);
X	VectorCopy (self->absmin, org);
X	org[1] += self->size[1];
X	ThrowDebris (self, "models/objects/debris3/tris.md2", spd, org);
X	VectorCopy (self->absmin, org);
X	org[0] += self->size[0];
X	org[1] += self->size[1];
X	ThrowDebris (self, "models/objects/debris3/tris.md2", spd, org);
X
X	// a bunch of little chunks
X	spd = 2 * self->dmg / 200;
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X	org[0] = self->s.origin[0] + crandom() * self->size[0];
X	org[1] = self->s.origin[1] + crandom() * self->size[1];
X	org[2] = self->s.origin[2] + crandom() * self->size[2];
X	ThrowDebris (self, "models/objects/debris2/tris.md2", spd, org);
X
X	VectorCopy (save, self->s.origin);
X	if (self->groundentity)
X		BecomeExplosion2 (self);
X	else
X		BecomeExplosion1 (self);
}
X
void barrel_delay (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	self->takedamage = DAMAGE_NO;
X	self->nextthink = level.time + 2 * FRAMETIME;
X	self->think = barrel_explode;
X	self->activator = attacker;
}
X
//=========
//PGM  - change so barrels will think and hence, blow up
void barrel_think (edict_t *self)
{
X	// the think needs to be first since later stuff may override.
X	self->think = barrel_think;
X	self->nextthink = level.time + FRAMETIME;
X
X	M_CatagorizePosition (self);
X	self->flags |= FL_IMMUNE_SLIME;
X	self->air_finished = level.time + 100;
X	M_WorldEffects (self);
}
X
void barrel_start (edict_t *self)
{
X	M_droptofloor(self);
X	self->think = barrel_think;
X	self->nextthink = level.time + FRAMETIME;
}
//PGM
//=========
X
void SP_misc_explobox (edict_t *self)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (self);
X		return;
X	}
X
X	gi.modelindex ("models/objects/debris1/tris.md2");
X	gi.modelindex ("models/objects/debris2/tris.md2");
X	gi.modelindex ("models/objects/debris3/tris.md2");
X
X	self->solid = SOLID_BBOX;
X	self->movetype = MOVETYPE_STEP;
X
X	self->model = "models/objects/barrels/tris.md2";
X	self->s.modelindex = gi.modelindex (self->model);
X	VectorSet (self->mins, -16, -16, 0);
X	VectorSet (self->maxs, 16, 16, 40);
X
X	if (!self->mass)
X		self->mass = 400;
X	if (!self->health)
X		self->health = 10;
X	if (!self->dmg)
X		self->dmg = 150;
X
X	self->die = barrel_delay;
X	self->takedamage = DAMAGE_YES;
X	self->monsterinfo.aiflags = AI_NOSTEP;
X
X	self->touch = barrel_touch;
X
//PGM - change so barrels will think and hence, blow up
X	self->think = barrel_start;
X	self->nextthink = level.time + 2 * FRAMETIME;
//PGM
X
X	gi.linkentity (self);
}
X
X
//
// miscellaneous specialty items
//
X
/*QUAKED misc_blackhole (1 .5 0) (-8 -8 -8) (8 8 8)
*/
X
void misc_blackhole_use (edict_t *ent, edict_t *other, edict_t *activator)
{
X	/*
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_BOSSTPORT);
X	gi.WritePosition (ent->s.origin);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X	*/
X	G_FreeEdict (ent);
}
X
void misc_blackhole_think (edict_t *self)
{
X	if (++self->s.frame < 19)
X		self->nextthink = level.time + FRAMETIME;
X	else
X	{		
X		self->s.frame = 0;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
void SP_misc_blackhole (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_NOT;
X	VectorSet (ent->mins, -64, -64, 0);
X	VectorSet (ent->maxs, 64, 64, 8);
X	ent->s.modelindex = gi.modelindex ("models/objects/black/tris.md2");
X	ent->s.renderfx = RF_TRANSLUCENT;
X	ent->use = misc_blackhole_use;
X	ent->think = misc_blackhole_think;
X	ent->nextthink = level.time + 2 * FRAMETIME;
X	gi.linkentity (ent);
}
X
/*QUAKED misc_eastertank (1 .5 0) (-32 -32 -16) (32 32 32)
*/
X
void misc_eastertank_think (edict_t *self)
{
X	if (++self->s.frame < 293)
X		self->nextthink = level.time + FRAMETIME;
X	else
X	{		
X		self->s.frame = 254;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
void SP_misc_eastertank (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	VectorSet (ent->mins, -32, -32, -16);
X	VectorSet (ent->maxs, 32, 32, 32);
X	ent->s.modelindex = gi.modelindex ("models/monsters/tank/tris.md2");
X	ent->s.frame = 254;
X	ent->think = misc_eastertank_think;
X	ent->nextthink = level.time + 2 * FRAMETIME;
X	gi.linkentity (ent);
}
X
/*QUAKED misc_easterchick (1 .5 0) (-32 -32 0) (32 32 32)
*/
X
X
void misc_easterchick_think (edict_t *self)
{
X	if (++self->s.frame < 247)
X		self->nextthink = level.time + FRAMETIME;
X	else
X	{		
X		self->s.frame = 208;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
void SP_misc_easterchick (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	VectorSet (ent->mins, -32, -32, 0);
X	VectorSet (ent->maxs, 32, 32, 32);
X	ent->s.modelindex = gi.modelindex ("models/monsters/bitch/tris.md2");
X	ent->s.frame = 208;
X	ent->think = misc_easterchick_think;
X	ent->nextthink = level.time + 2 * FRAMETIME;
X	gi.linkentity (ent);
}
X
/*QUAKED misc_easterchick2 (1 .5 0) (-32 -32 0) (32 32 32)
*/
X
X
void misc_easterchick2_think (edict_t *self)
{
X	if (++self->s.frame < 287)
X		self->nextthink = level.time + FRAMETIME;
X	else
X	{		
X		self->s.frame = 248;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
void SP_misc_easterchick2 (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	VectorSet (ent->mins, -32, -32, 0);
X	VectorSet (ent->maxs, 32, 32, 32);
X	ent->s.modelindex = gi.modelindex ("models/monsters/bitch/tris.md2");
X	ent->s.frame = 248;
X	ent->think = misc_easterchick2_think;
X	ent->nextthink = level.time + 2 * FRAMETIME;
X	gi.linkentity (ent);
}
X
X
/*QUAKED monster_commander_body (1 .5 0) (-32 -32 0) (32 32 48)
Not really a monster, this is the Tank Commander's decapitated body.
There should be a item_commander_head that has this as it's target.
*/
X
void commander_body_think (edict_t *self)
{
X	if (++self->s.frame < 24)
X		self->nextthink = level.time + FRAMETIME;
X	else
X		self->nextthink = 0;
X
X	if (self->s.frame == 22)
X		gi.sound (self, CHAN_BODY, gi.soundindex ("tank/thud.wav"), 1, ATTN_NORM, 0);
}
X
void commander_body_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->think = commander_body_think;
X	self->nextthink = level.time + FRAMETIME;
X	gi.sound (self, CHAN_BODY, gi.soundindex ("tank/pain.wav"), 1, ATTN_NORM, 0);
}
X
void commander_body_drop (edict_t *self)
{
X	self->movetype = MOVETYPE_TOSS;
X	self->s.origin[2] += 2;
}
X
void SP_monster_commander_body (edict_t *self)
{
X	self->movetype = MOVETYPE_NONE;
X	self->solid = SOLID_BBOX;
X	self->model = "models/monsters/commandr/tris.md2";
X	self->s.modelindex = gi.modelindex (self->model);
X	VectorSet (self->mins, -32, -32, 0);
X	VectorSet (self->maxs, 32, 32, 48);
X	self->use = commander_body_use;
X	self->takedamage = DAMAGE_YES;
X	self->flags = FL_GODMODE;
X	self->s.renderfx |= RF_FRAMELERP;
X	gi.linkentity (self);
X
X	gi.soundindex ("tank/thud.wav");
X	gi.soundindex ("tank/pain.wav");
X
X	self->think = commander_body_drop;
X	self->nextthink = level.time + 5 * FRAMETIME;
}
X
X
/*QUAKED misc_banner (1 .5 0) (-4 -4 -4) (4 4 4)
The origin is the bottom of the banner.
The banner is 128 tall.
*/
void misc_banner_think (edict_t *ent)
{
X	ent->s.frame = (ent->s.frame + 1) % 16;
X	ent->nextthink = level.time + FRAMETIME;
}
X
void SP_misc_banner (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_NOT;
X	ent->s.modelindex = gi.modelindex ("models/objects/banner/tris.md2");
X	ent->s.frame = rand() % 16;
X	gi.linkentity (ent);
X
X	ent->think = misc_banner_think;
X	ent->nextthink = level.time + FRAMETIME;
}
X
/*QUAKED misc_deadsoldier (1 .5 0) (-16 -16 0) (16 16 16) ON_BACK ON_STOMACH BACK_DECAP FETAL_POS SIT_DECAP IMPALED
This is the dead player model. Comes in 6 exciting different poses!
*/
void misc_deadsoldier_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
//	if (self->health > -80)
X	if (self->health > -30)
X		return;
X
X	gi.sound (self, CHAN_BODY, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X	for (n= 0; n < 4; n++)
X		ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X	ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
}
X
void SP_misc_deadsoldier (edict_t *ent)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (ent);
X		return;
X	}
X
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	ent->s.modelindex=gi.modelindex ("models/deadbods/dude/tris.md2");
X
X	// Defaults to frame 0
X	if (ent->spawnflags & 2)
X		ent->s.frame = 1;
X	else if (ent->spawnflags & 4)
X		ent->s.frame = 2;
X	else if (ent->spawnflags & 8)
X		ent->s.frame = 3;
X	else if (ent->spawnflags & 16)
X		ent->s.frame = 4;
X	else if (ent->spawnflags & 32)
X		ent->s.frame = 5;
X	else
X		ent->s.frame = 0;
X
X	VectorSet (ent->mins, -16, -16, 0);
X	VectorSet (ent->maxs, 16, 16, 16);
X	ent->deadflag = DEAD_DEAD;
X	ent->takedamage = DAMAGE_YES;
X	ent->svflags |= SVF_MONSTER|SVF_DEADMONSTER;
X	ent->die = misc_deadsoldier_die;
X	ent->monsterinfo.aiflags |= AI_GOOD_GUY;
X
X	gi.linkentity (ent);
}
X
/*QUAKED misc_viper (1 .5 0) (-16 -16 0) (16 16 32)
This is the Viper for the flyby bombing.
It is trigger_spawned, so you must have something use it for it to show up.
There must be a path for it to follow once it is activated.
X
"speed"		How fast the Viper should fly
*/
X
extern void train_use (edict_t *self, edict_t *other, edict_t *activator);
extern void func_train_find (edict_t *self);
X
void misc_viper_use  (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->svflags &= ~SVF_NOCLIENT;
X	self->use = train_use;
X	train_use (self, other, activator);
}
X
void SP_misc_viper (edict_t *ent)
{
X	if (!ent->target)
X	{
X		gi.dprintf ("misc_viper without a target at %s\n", vtos(ent->absmin));
X		G_FreeEdict (ent);
X		return;
X	}
X
X	if (!ent->speed)
X		ent->speed = 300;
X
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_NOT;
X	ent->s.modelindex = gi.modelindex ("models/ships/viper/tris.md2");
X	VectorSet (ent->mins, -16, -16, 0);
X	VectorSet (ent->maxs, 16, 16, 32);
X
X	ent->think = func_train_find;
X	ent->nextthink = level.time + FRAMETIME;
X	ent->use = misc_viper_use;
X	ent->svflags |= SVF_NOCLIENT;
X	ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = ent->speed;
X
X	gi.linkentity (ent);
}
X
X
/*QUAKED misc_bigviper (1 .5 0) (-176 -120 -24) (176 120 72) 
This is a large stationary viper as seen in Paul's intro
*/
void SP_misc_bigviper (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	VectorSet (ent->mins, -176, -120, -24);
X	VectorSet (ent->maxs, 176, 120, 72);
X	ent->s.modelindex = gi.modelindex ("models/ships/bigviper/tris.md2");
X	gi.linkentity (ent);
}
X
X
/*QUAKED misc_viper_bomb (1 0 0) (-8 -8 -8) (8 8 8)
"dmg"	how much boom should the bomb make?
*/
void misc_viper_bomb_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	G_UseTargets (self, self->activator);
X
X	self->s.origin[2] = self->absmin[2] + 1;
X	T_RadiusDamage (self, self, self->dmg, NULL, self->dmg+40, MOD_BOMB);
X	BecomeExplosion2 (self);
}
X
void misc_viper_bomb_prethink (edict_t *self)
{
X	vec3_t	v;
X	float	diff;
X
X	self->groundentity = NULL;
X
X	diff = self->timestamp - level.time;
X	if (diff < -1.0)
X		diff = -1.0;
X
X	VectorScale (self->moveinfo.dir, 1.0 + diff, v);
X	v[2] = diff;
X
X	diff = self->s.angles[2];
X	vectoangles (v, self->s.angles);
X	self->s.angles[2] = diff + 10;
}
X
void misc_viper_bomb_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t	*viper;
X
X	self->solid = SOLID_BBOX;
X	self->svflags &= ~SVF_NOCLIENT;
X	self->s.effects |= EF_ROCKET;
X	self->use = NULL;
X	self->movetype = MOVETYPE_TOSS;
X	self->prethink = misc_viper_bomb_prethink;
X	self->touch = misc_viper_bomb_touch;
X	self->activator = activator;
X
X	viper = G_Find (NULL, FOFS(classname), "misc_viper");
X	VectorScale (viper->moveinfo.dir, viper->moveinfo.speed, self->velocity);
X
X	self->timestamp = level.time;
X	VectorCopy (viper->moveinfo.dir, self->moveinfo.dir);
}
X
void SP_misc_viper_bomb (edict_t *self)
{
X	self->movetype = MOVETYPE_NONE;
X	self->solid = SOLID_NOT;
X	VectorSet (self->mins, -8, -8, -8);
X	VectorSet (self->maxs, 8, 8, 8);
X
X	self->s.modelindex = gi.modelindex ("models/objects/bomb/tris.md2");
X
X	if (!self->dmg)
X		self->dmg = 1000;
X
X	self->use = misc_viper_bomb_use;
X	self->svflags |= SVF_NOCLIENT;
X
X	gi.linkentity (self);
}
X
X
/*QUAKED misc_strogg_ship (1 .5 0) (-16 -16 0) (16 16 32)
This is a Storgg ship for the flybys.
It is trigger_spawned, so you must have something use it for it to show up.
There must be a path for it to follow once it is activated.
X
"speed"		How fast it should fly
*/
X
extern void train_use (edict_t *self, edict_t *other, edict_t *activator);
extern void func_train_find (edict_t *self);
X
void misc_strogg_ship_use  (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->svflags &= ~SVF_NOCLIENT;
X	self->use = train_use;
X	train_use (self, other, activator);
}
X
void SP_misc_strogg_ship (edict_t *ent)
{
X	if (!ent->target)
X	{
X		gi.dprintf ("%s without a target at %s\n", ent->classname, vtos(ent->absmin));
X		G_FreeEdict (ent);
X		return;
X	}
X
X	if (!ent->speed)
X		ent->speed = 300;
X
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_NOT;
X	ent->s.modelindex = gi.modelindex ("models/ships/strogg1/tris.md2");
X	VectorSet (ent->mins, -16, -16, 0);
X	VectorSet (ent->maxs, 16, 16, 32);
X
X	ent->think = func_train_find;
X	ent->nextthink = level.time + FRAMETIME;
X	ent->use = misc_strogg_ship_use;
X	ent->svflags |= SVF_NOCLIENT;
X	ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = ent->speed;
X
X	gi.linkentity (ent);
}
X
X
/*QUAKED misc_satellite_dish (1 .5 0) (-64 -64 0) (64 64 128)
*/
void misc_satellite_dish_think (edict_t *self)
{
X	self->s.frame++;
X	if (self->s.frame < 38)
X		self->nextthink = level.time + FRAMETIME;
}
X
void misc_satellite_dish_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->s.frame = 0;
X	self->think = misc_satellite_dish_think;
X	self->nextthink = level.time + FRAMETIME;
}
X
void SP_misc_satellite_dish (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	VectorSet (ent->mins, -64, -64, 0);
X	VectorSet (ent->maxs, 64, 64, 128);
X	ent->s.modelindex = gi.modelindex ("models/objects/satellite/tris.md2");
X	ent->use = misc_satellite_dish_use;
X	gi.linkentity (ent);
}
X
X
/*QUAKED light_mine1 (0 1 0) (-2 -2 -12) (2 2 12)
*/
void SP_light_mine1 (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	ent->s.modelindex = gi.modelindex ("models/objects/minelite/light1/tris.md2");
X	gi.linkentity (ent);
}
X
X
/*QUAKED light_mine2 (0 1 0) (-2 -2 -12) (2 2 12)
*/
void SP_light_mine2 (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_BBOX;
X	ent->s.modelindex = gi.modelindex ("models/objects/minelite/light2/tris.md2");
X	gi.linkentity (ent);
}
X
X
/*QUAKED misc_gib_arm (1 0 0) (-8 -8 -8) (8 8 8)
Intended for use with the target_spawner
*/
void SP_misc_gib_arm (edict_t *ent)
{
X	gi.setmodel (ent, "models/objects/gibs/arm/tris.md2");
X	ent->solid = SOLID_NOT;
X	ent->s.effects |= EF_GIB;
X	ent->takedamage = DAMAGE_YES;
X	ent->die = gib_die;
X	ent->movetype = MOVETYPE_TOSS;
X	ent->svflags |= SVF_MONSTER;
X	ent->deadflag = DEAD_DEAD;
X	ent->avelocity[0] = random()*200;
X	ent->avelocity[1] = random()*200;
X	ent->avelocity[2] = random()*200;
X	ent->think = G_FreeEdict;
X	ent->nextthink = level.time + 30;
X	gi.linkentity (ent);
}
X
/*QUAKED misc_gib_leg (1 0 0) (-8 -8 -8) (8 8 8)
Intended for use with the target_spawner
*/
void SP_misc_gib_leg (edict_t *ent)
{
X	gi.setmodel (ent, "models/objects/gibs/leg/tris.md2");
X	ent->solid = SOLID_NOT;
X	ent->s.effects |= EF_GIB;
X	ent->takedamage = DAMAGE_YES;
X	ent->die = gib_die;
X	ent->movetype = MOVETYPE_TOSS;
X	ent->svflags |= SVF_MONSTER;
X	ent->deadflag = DEAD_DEAD;
X	ent->avelocity[0] = random()*200;
X	ent->avelocity[1] = random()*200;
X	ent->avelocity[2] = random()*200;
X	ent->think = G_FreeEdict;
X	ent->nextthink = level.time + 30;
X	gi.linkentity (ent);
}
X
/*QUAKED misc_gib_head (1 0 0) (-8 -8 -8) (8 8 8)
Intended for use with the target_spawner
*/
void SP_misc_gib_head (edict_t *ent)
{
X	gi.setmodel (ent, "models/objects/gibs/head/tris.md2");
X	ent->solid = SOLID_NOT;
X	ent->s.effects |= EF_GIB;
X	ent->takedamage = DAMAGE_YES;
X	ent->die = gib_die;
X	ent->movetype = MOVETYPE_TOSS;
X	ent->svflags |= SVF_MONSTER;
X	ent->deadflag = DEAD_DEAD;
X	ent->avelocity[0] = random()*200;
X	ent->avelocity[1] = random()*200;
X	ent->avelocity[2] = random()*200;
X	ent->think = G_FreeEdict;
X	ent->nextthink = level.time + 30;
X	gi.linkentity (ent);
}
X
//=====================================================
X
/*QUAKED target_character (0 0 1) ?
used with target_string (must be on same "team")
"count" is position in the string (starts at 1)
*/
X
void SP_target_character (edict_t *self)
{
X	self->movetype = MOVETYPE_PUSH;
X	gi.setmodel (self, self->model);
X	self->solid = SOLID_BSP;
X	self->s.frame = 12;
X	gi.linkentity (self);
X	return;
}
X
X
/*QUAKED target_string (0 0 1) (-8 -8 -8) (8 8 8)
*/
X
void target_string_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t *e;
X	int		n, l;
X	char	c;
X
X	l = strlen(self->message);
X	for (e = self->teammaster; e; e = e->teamchain)
X	{
X		if (!e->count)
X			continue;
X		n = e->count - 1;
X		if (n > l)
X		{
X			e->s.frame = 12;
X			continue;
X		}
X
X		c = self->message[n];
X		if (c >= '0' && c <= '9')
X			e->s.frame = c - '0';
X		else if (c == '-')
X			e->s.frame = 10;
X		else if (c == ':')
X			e->s.frame = 11;
X		else
X			e->s.frame = 12;
X	}
}
X
void SP_target_string (edict_t *self)
{
X	if (!self->message)
X		self->message = "";
X	self->use = target_string_use;
}
X
X
/*QUAKED func_clock (0 0 1) (-8 -8 -8) (8 8 8) TIMER_UP TIMER_DOWN START_OFF MULTI_USE
target a target_string with this
X
The default is to be a time of day clock
X
TIMER_UP and TIMER_DOWN run for "count" seconds and the fire "pathtarget"
If START_OFF, this entity must be used before it starts
X
"style"		0 "xx"
X			1 "xx:xx"
X			2 "xx:xx:xx"
*/
X
#define	CLOCK_MESSAGE_SIZE	16
X
// don't let field width of any clock messages change, or it
// could cause an overwrite after a game load
X
static void func_clock_reset (edict_t *self)
{
X	self->activator = NULL;
X	if (self->spawnflags & 1)
X	{
X		self->health = 0;
X		self->wait = self->count;
X	}
X	else if (self->spawnflags & 2)
X	{
X		self->health = self->count;
X		self->wait = 0;
X	}
}
X
static void func_clock_format_countdown (edict_t *self)
{
X	if (self->style == 0)
X	{
X		Com_sprintf (self->message, CLOCK_MESSAGE_SIZE, "%2i", self->health);
X		return;
X	}
X
X	if (self->style == 1)
X	{
X		Com_sprintf(self->message, CLOCK_MESSAGE_SIZE, "%2i:%2i", self->health / 60, self->health % 60);
X		if (self->message[3] == ' ')
X			self->message[3] = '0';
X		return;
X	}
X
X	if (self->style == 2)
X	{
X		Com_sprintf(self->message, CLOCK_MESSAGE_SIZE, "%2i:%2i:%2i", self->health / 3600, (self->health - (self->health / 3600) * 3600) / 60, self->health % 60);
X		if (self->message[3] == ' ')
X			self->message[3] = '0';
X		if (self->message[6] == ' ')
X			self->message[6] = '0';
X		return;
X	}
}
X
void func_clock_think (edict_t *self)
{
X	if (!self->enemy)
X	{
X		self->enemy = G_Find (NULL, FOFS(targetname), self->target);
X		if (!self->enemy)
X			return;
X	}
X
X	if (self->spawnflags & 1)
X	{
X		func_clock_format_countdown (self);
X		self->health++;
X	}
X	else if (self->spawnflags & 2)
X	{
X		func_clock_format_countdown (self);
X		self->health--;
X	}
X	else
X	{
X		struct tm	*ltime;
X		time_t		gmtime;
X
X		time(&gmtime);
X		ltime = localtime(&gmtime);
X		Com_sprintf (self->message, CLOCK_MESSAGE_SIZE, "%2i:%2i:%2i", ltime->tm_hour, ltime->tm_min, ltime->tm_sec);
X		if (self->message[3] == ' ')
X			self->message[3] = '0';
X		if (self->message[6] == ' ')
X			self->message[6] = '0';
X	}
X
X	self->enemy->message = self->message;
X	self->enemy->use (self->enemy, self, self);
X
X	if (((self->spawnflags & 1) && (self->health > self->wait)) ||
X		((self->spawnflags & 2) && (self->health < self->wait)))
X	{
X		if (self->pathtarget)
X		{
X			char *savetarget;
X			char *savemessage;
X
X			savetarget = self->target;
X			savemessage = self->message;
X			self->target = self->pathtarget;
X			self->message = NULL;
X			G_UseTargets (self, self->activator);
X			self->target = savetarget;
X			self->message = savemessage;
X		}
X
X		if (!(self->spawnflags & 8))
X			return;
X
X		func_clock_reset (self);
X
X		if (self->spawnflags & 4)
X			return;
X	}
X
X	self->nextthink = level.time + 1;
}
X
void func_clock_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (!(self->spawnflags & 8))
X		self->use = NULL;
X	if (self->activator)
X		return;
X	self->activator = activator;
X	self->think (self);
}
X
void SP_func_clock (edict_t *self)
{
X	if (!self->target)
X	{
X		gi.dprintf("%s with no target at %s\n", self->classname, vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	if ((self->spawnflags & 2) && (!self->count))
X	{
X		gi.dprintf("%s with no count at %s\n", self->classname, vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	if ((self->spawnflags & 1) && (!self->count))
X		self->count = 60*60;;
X
X	func_clock_reset (self);
X
X	self->message = gi.TagMalloc (CLOCK_MESSAGE_SIZE, TAG_LEVEL);
X
X	self->think = func_clock_think;
X
X	if (self->spawnflags & 4)
X		self->use = func_clock_use;
X	else
X		self->nextthink = level.time + 1;
}
X
//=================================================================================
X
void teleporter_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t		*dest;
X	int			i;
X
X	if (!other->client)
X		return;
X	dest = G_Find (NULL, FOFS(targetname), self->target);
X	if (!dest)
X	{
X		gi.dprintf ("Couldn't find destination\n");
X		return;
X	}
X
X	// unlink to make sure it can't possibly interfere with KillBox
X	gi.unlinkentity (other);
X
X	VectorCopy (dest->s.origin, other->s.origin);
X	VectorCopy (dest->s.origin, other->s.old_origin);
X	other->s.origin[2] += 10;
X
X	// clear the velocity and hold them in place briefly
X	VectorClear (other->velocity);
X	other->client->ps.pmove.pm_time = 160>>3;		// hold time
X	other->client->ps.pmove.pm_flags |= PMF_TIME_TELEPORT;
X
X	// draw the teleport splash at source and on the player
X	self->owner->s.event = EV_PLAYER_TELEPORT;
X	other->s.event = EV_PLAYER_TELEPORT;
X
X	// set angles
X	for (i=0 ; i<3 ; i++)
X		other->client->ps.pmove.delta_angles[i] = ANGLE2SHORT(dest->s.angles[i] - other->client->resp.cmd_angles[i]);
X
X	VectorClear (other->s.angles);
X	VectorClear (other->client->ps.viewangles);
X	VectorClear (other->client->v_angle);
X
X	// kill anything at the destination
X	KillBox (other);
X
X	gi.linkentity (other);
}
X
/*QUAKED misc_teleporter (1 0 0) (-32 -32 -24) (32 32 -16)
Stepping onto this disc will teleport players to the targeted misc_teleporter_dest object.
*/
void SP_misc_teleporter (edict_t *ent)
{
X	edict_t		*trig;
X
X	if (!ent->target)
X	{
X		gi.dprintf ("teleporter without a target.\n");
X		G_FreeEdict (ent);
X		return;
X	}
X
X	gi.setmodel (ent, "models/objects/dmspot/tris.md2");
X	ent->s.skinnum = 1;
X	ent->s.effects = EF_TELEPORTER;
X	ent->s.sound = gi.soundindex ("world/amb10.wav");
X	ent->solid = SOLID_BBOX;
X
X	VectorSet (ent->mins, -32, -32, -24);
X	VectorSet (ent->maxs, 32, 32, -16);
X	gi.linkentity (ent);
X
X	trig = G_Spawn ();
X	trig->touch = teleporter_touch;
X	trig->solid = SOLID_TRIGGER;
X	trig->target = ent->target;
X	trig->owner = ent;
X	VectorCopy (ent->s.origin, trig->s.origin);
X	VectorSet (trig->mins, -8, -8, 8);
X	VectorSet (trig->maxs, 8, 8, 24);
X	gi.linkentity (trig);
X	
}
X
/*QUAKED misc_teleporter_dest (1 0 0) (-32 -32 -24) (32 32 -16)
Point teleporters at these.
*/
void SP_misc_teleporter_dest (edict_t *ent)
{
X	gi.setmodel (ent, "models/objects/dmspot/tris.md2");
X	ent->s.skinnum = 0;
X	ent->solid = SOLID_BBOX;
//	ent->s.effects |= EF_FLIES;
X	VectorSet (ent->mins, -32, -32, -24);
X	VectorSet (ent->maxs, 32, 32, -16);
X	gi.linkentity (ent);
}
X
//======================
//ROGUE
void misc_nuke_core_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if(self->svflags & SVF_NOCLIENT)
X		self->svflags &= ~SVF_NOCLIENT;
X	else
X		self->svflags |= SVF_NOCLIENT;
}
X
/*QUAKED misc_nuke_core (1 0 0) (-16 -16 -16) (16 16 16)
toggles visible/not visible. starts visible.
*/
void SP_misc_nuke_core (edict_t *ent)
{
X	gi.setmodel (ent, "models/objects/core/tris.md2");
X	gi.linkentity (ent);
X
X	ent->use = misc_nuke_core_use;
}
//ROGUE
//======================
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_misc.c' &&
  chmod 0664 'g_misc.c' ||
  $echo 'restore of' 'g_misc.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_misc.c:' 'MD5 check failed'
a2739c9e97132cf0b284bc44b21ce68e  g_misc.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_misc.c'`"
    test 47803 -eq "$shar_count" ||
    $echo 'g_misc.c:' 'original size' '47803,' 'current size' "$shar_count!"
  fi
fi
# ============= g_monster.c ==============
if test -f 'g_monster.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_monster.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_monster.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_monster.c' &&
#include "g_local.h"
X
X
//
// monster weapons
//
X
//FIXME mosnters should call these with a totally accurate direction
// and we can mess it up based on skill.  Spread should be for normal
// and we can tighten or loosen based on skill.  We could muck with
// the damages too, but I'm not sure that's such a good idea.
void monster_fire_bullet (edict_t *self, vec3_t start, vec3_t dir, int damage, int kick, int hspread, int vspread, int flashtype)
{
X	fire_bullet (self, start, dir, damage, kick, hspread, vspread, MOD_UNKNOWN);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
X
void monster_fire_shotgun (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int hspread, int vspread, int count, int flashtype)
{
X	fire_shotgun (self, start, aimdir, damage, kick, hspread, vspread, count, MOD_UNKNOWN);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
X
void monster_fire_blaster (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int flashtype, int effect)
{
X	fire_blaster (self, start, dir, damage, speed, effect, false);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}	
X
//ROGUE
void monster_fire_blaster2 (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int flashtype, int effect)
{
X	fire_blaster2 (self, start, dir, damage, speed, effect, false);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
X
// FIXME -- add muzzle flash
void monster_fire_tracker (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, edict_t *enemy, int flashtype)
{
X	fire_tracker (self, start, dir, damage, speed, enemy);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
X
void monster_fire_heat (edict_t *self, vec3_t start, vec3_t dir, vec3_t offset, int damage, int kick, int flashtype)
{
X	fire_heat (self, start, dir, offset, damage, kick, true);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
//ROGUE
X
void monster_fire_grenade (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, int flashtype)
{
X	fire_grenade (self, start, aimdir, damage, speed, 2.5, damage+40);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
X
void monster_fire_rocket (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int flashtype)
{
X	fire_rocket (self, start, dir, damage, speed, damage+20, damage);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}	
X
void monster_fire_railgun (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int flashtype)
{
X	// PMM
X	if (!(gi.pointcontents (start) & MASK_SOLID))
X		fire_rail (self, start, aimdir, damage, kick);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
X
void monster_fire_bfg (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, int kick, float damage_radius, int flashtype)
{
X	fire_bfg (self, start, aimdir, damage, speed, damage_radius);
X
X	gi.WriteByte (svc_muzzleflash2);
X	gi.WriteShort (self - g_edicts);
X	gi.WriteByte (flashtype);
X	gi.multicast (start, MULTICAST_PVS);
}
X
X
X
//
// Monster utility functions
//
X
void M_FliesOff (edict_t *self)
{
X	self->s.effects &= ~EF_FLIES;
X	self->s.sound = 0;
}
X
void M_FliesOn (edict_t *self)
{
X	if (self->waterlevel)
X		return;
X	self->s.effects |= EF_FLIES;
X	self->s.sound = gi.soundindex ("infantry/inflies1.wav");
X	self->think = M_FliesOff;
X	self->nextthink = level.time + 60;
}
X
void M_FlyCheck (edict_t *self)
{
X	if (self->waterlevel)
X		return;
X
X	if (random() > 0.5)
X		return;
X
X	self->think = M_FliesOn;
X	self->nextthink = level.time + 5 + 10 * random();
}
X
void AttackFinished (edict_t *self, float time)
{
X	self->monsterinfo.attack_finished = level.time + time;
}
X
X
void M_CheckGround (edict_t *ent)
{
X	vec3_t		point;
X	trace_t		trace;
X
X	if (ent->flags & (FL_SWIM|FL_FLY))
X		return;
X
#ifdef ROGUE_GRAVITY
X	if ((ent->velocity[2] * ent->gravityVector[2]) < -100)		// PGM
#else
X	if (ent->velocity[2] > 100)
#endif
X	{
X		ent->groundentity = NULL;
X		return;
X	}
X
// if the hull point one-quarter unit down is solid the entity is on ground
X	point[0] = ent->s.origin[0];
X	point[1] = ent->s.origin[1];
#ifdef ROGUE_GRAVITY
X	point[2] = ent->s.origin[2] + (0.25 * ent->gravityVector[2]);	//PGM
#else
X	point[2] = ent->s.origin[2] - 0.25;
#endif
X
X	trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, point, ent, MASK_MONSTERSOLID);
X
X	// check steepness
#ifdef ROGUE_GRAVITY
//PGM
X	if ( ent->gravityVector[2] < 0)		// normal gravity
X	{
X		if ( trace.plane.normal[2] < 0.7 && !trace.startsolid)
X		{
X			ent->groundentity = NULL;
X			return;
X		}
X	}
X	else								// inverted gravity
X	{
X		if ( trace.plane.normal[2] > -0.7 && !trace.startsolid)
X		{
X			ent->groundentity = NULL;
X			return;
X		}
X	}
//PGM
#else
X	if ( trace.plane.normal[2] < 0.7 && !trace.startsolid)
X	{
X		ent->groundentity = NULL;
X		return;
X	}
#endif
X
//	ent->groundentity = trace.ent;
//	ent->groundentity_linkcount = trace.ent->linkcount;
//	if (!trace.startsolid && !trace.allsolid)
//		VectorCopy (trace.endpos, ent->s.origin);
X	if (!trace.startsolid && !trace.allsolid)
X	{
X		VectorCopy (trace.endpos, ent->s.origin);
X		ent->groundentity = trace.ent;
X		ent->groundentity_linkcount = trace.ent->linkcount;
X		ent->velocity[2] = 0;
X	}
}
X
X
void M_CatagorizePosition (edict_t *ent)
{
X	vec3_t		point;
X	int			cont;
X
//
// get waterlevel
//
X	point[0] = ent->s.origin[0];
X	point[1] = ent->s.origin[1];
X	point[2] = ent->s.origin[2] + ent->mins[2] + 1;	
X	cont = gi.pointcontents (point);
X
X	if (!(cont & MASK_WATER))
X	{
X		ent->waterlevel = 0;
X		ent->watertype = 0;
X		return;
X	}
X
X	ent->watertype = cont;
X	ent->waterlevel = 1;
X	point[2] += 26;
X	cont = gi.pointcontents (point);
X	if (!(cont & MASK_WATER))
X		return;
X
X	ent->waterlevel = 2;
X	point[2] += 22;
X	cont = gi.pointcontents (point);
X	if (cont & MASK_WATER)
X		ent->waterlevel = 3;
}
X
X
void M_WorldEffects (edict_t *ent)
{
X	int		dmg;
X
X	if (ent->health > 0)
X	{
X		if (!(ent->flags & FL_SWIM))
X		{
X			if (ent->waterlevel < 3)
X			{
X				ent->air_finished = level.time + 12;
X			}
X			else if (ent->air_finished < level.time)
X			{	// drown!
X				if (ent->pain_debounce_time < level.time)
X				{
X					dmg = 2 + 2 * floor(level.time - ent->air_finished);
X					if (dmg > 15)
X						dmg = 15;
X					T_Damage (ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR, MOD_WATER);
X					ent->pain_debounce_time = level.time + 1;
X				}
X			}
X		}
X		else
X		{
X			if (ent->waterlevel > 0)
X			{
X				ent->air_finished = level.time + 9;
X			}
X			else if (ent->air_finished < level.time)
X			{	// suffocate!
X				if (ent->pain_debounce_time < level.time)
X				{
X					dmg = 2 + 2 * floor(level.time - ent->air_finished);
X					if (dmg > 15)
X						dmg = 15;
X					T_Damage (ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR, MOD_WATER);
X					ent->pain_debounce_time = level.time + 1;
X				}
X			}
X		}
X	}
X	
X	if (ent->waterlevel == 0)
X	{
X		if (ent->flags & FL_INWATER)
X		{	
X			gi.sound (ent, CHAN_BODY, gi.soundindex("player/watr_out.wav"), 1, ATTN_NORM, 0);
X			ent->flags &= ~FL_INWATER;
X		}
X		return;
X	}
X
X	if ((ent->watertype & CONTENTS_LAVA) && !(ent->flags & FL_IMMUNE_LAVA))
X	{
X		if (ent->damage_debounce_time < level.time)
X		{
X			ent->damage_debounce_time = level.time + 0.2;
X			T_Damage (ent, world, world, vec3_origin, ent->s.origin, vec3_origin, 10*ent->waterlevel, 0, 0, MOD_LAVA);
X		}
X	}
X	if ((ent->watertype & CONTENTS_SLIME) && !(ent->flags & FL_IMMUNE_SLIME))
X	{
X		if (ent->damage_debounce_time < level.time)
X		{
X			ent->damage_debounce_time = level.time + 1;
X			T_Damage (ent, world, world, vec3_origin, ent->s.origin, vec3_origin, 4*ent->waterlevel, 0, 0, MOD_SLIME);
X		}
X	}
X	
X	if ( !(ent->flags & FL_INWATER) )
X	{	
X		if (!(ent->svflags & SVF_DEADMONSTER))
X		{
X			if (ent->watertype & CONTENTS_LAVA)
X				if (random() <= 0.5)
X					gi.sound (ent, CHAN_BODY, gi.soundindex("player/lava1.wav"), 1, ATTN_NORM, 0);
X				else
X					gi.sound (ent, CHAN_BODY, gi.soundindex("player/lava2.wav"), 1, ATTN_NORM, 0);
X			else if (ent->watertype & CONTENTS_SLIME)
X				gi.sound (ent, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
X			else if (ent->watertype & CONTENTS_WATER)
X				gi.sound (ent, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
X		}
X
X		ent->flags |= FL_INWATER;
X		ent->damage_debounce_time = 0;
X	}
}
X
X
void M_droptofloor (edict_t *ent)
{
X	vec3_t		end;
X	trace_t		trace;
X
#ifdef ROGUE_GRAVITY
//PGM
X	if(ent->gravityVector[2] < 0)
X	{
X		ent->s.origin[2] += 1;
X		VectorCopy (ent->s.origin, end);
X		end[2] -= 256;
X	}
X	else
X	{
X		ent->s.origin[2] -= 1;
X		VectorCopy (ent->s.origin, end);
X		end[2] += 256;
X	}
//PGM
#else
X	ent->s.origin[2] += 1;
X	VectorCopy (ent->s.origin, end);
X	end[2] -= 256;
#endif
X
X	trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, end, ent, MASK_MONSTERSOLID);
X
X	if (trace.fraction == 1 || trace.allsolid)
X		return;
X
X	VectorCopy (trace.endpos, ent->s.origin);
X
X	gi.linkentity (ent);
X	M_CheckGround (ent);
X	M_CatagorizePosition (ent);
}
X
X
void M_SetEffects (edict_t *ent)
{
X	int remaining;
X
X	ent->s.effects &= ~(EF_COLOR_SHELL|EF_POWERSCREEN|EF_DOUBLE|EF_QUAD|EF_PENT);
X	ent->s.renderfx &= ~(RF_SHELL_RED|RF_SHELL_GREEN|RF_SHELL_BLUE|RF_SHELL_DOUBLE);
X
X	if (ent->monsterinfo.aiflags & AI_RESURRECTING)
X	{
X		ent->s.effects |= EF_COLOR_SHELL;
X		ent->s.renderfx |= RF_SHELL_RED;
X	}
X
X	if (ent->health <= 0)
X		return;
X
X	if (ent->powerarmor_time > level.time)
X	{
X		if (ent->monsterinfo.power_armor_type == POWER_ARMOR_SCREEN)
X		{
X			ent->s.effects |= EF_POWERSCREEN;
X		}
X		else if (ent->monsterinfo.power_armor_type == POWER_ARMOR_SHIELD)
X		{
X			ent->s.effects |= EF_COLOR_SHELL;
X			ent->s.renderfx |= RF_SHELL_GREEN;
X		}
X	}
X	// PMM - new monster powerups
X	if (ent->monsterinfo.quad_framenum > level.framenum)
X	{
X		remaining = ent->monsterinfo.quad_framenum - level.framenum;
X		if (remaining > 30 || (remaining & 4) )
X			ent->s.effects |= EF_QUAD;
X	}
X	else
X		ent->s.effects &= ~EF_QUAD;
X
X	if (ent->monsterinfo.double_framenum > level.framenum)
X	{
X		remaining = ent->monsterinfo.double_framenum - level.framenum;
X		if (remaining > 30 || (remaining & 4) )
X			ent->s.effects |= EF_DOUBLE;
X	}
X	else
X		ent->s.effects &= ~EF_DOUBLE;
X
X	if (ent->monsterinfo.invincible_framenum > level.framenum)
X	{
X		remaining = ent->monsterinfo.invincible_framenum - level.framenum;
X		if (remaining > 30 || (remaining & 4) )
X			ent->s.effects |= EF_PENT;
X	}
X	else
X		ent->s.effects &= ~EF_PENT;
X
X	// PMM
X	// PMM - testing
//	ent->s.effects |= EF_COLOR_SHELL;
//	ent->s.renderfx |= RF_SHELL_HALF_DAM;
/*
X	if (fmod (level.time, 4.0) > 2.0)
X	{
X		gi.dprintf ("invulnerable ");
X		ent->s.renderfx |= RF_SHELL_RED;
X	}
X	else
X		ent->s.renderfx &= ~RF_SHELL_RED;
X
X	if (fmod (level.time, 8.0) > 4.0)
X	{
X		gi.dprintf ("shield ");
X		ent->s.renderfx |= RF_SHELL_GREEN;
X	}
X	else
X		ent->s.renderfx &= ~RF_SHELL_GREEN;
X
X	if (fmod (level.time, 16.0) > 8.0)
X	{
X		gi.dprintf ("quad ");
X		ent->s.renderfx |= RF_SHELL_BLUE;\
X	}
X	else
X		ent->s.renderfx &= ~RF_SHELL_BLUE;
X
X	if (fmod (level.time, 32.0) > 16.0)
X	{
X		gi.dprintf ("double ");
X		ent->s.renderfx |= RF_SHELL_DOUBLE;
X	}
X	else
X		ent->s.renderfx &= ~RF_SHELL_DOUBLE;
X
X	if (fmod (level.time, 64.0) > 32.0)
X	{
X		gi.dprintf ("half ");
X		ent->s.renderfx |= RF_SHELL_HALF_DAM;
X	}
X	else
X		ent->s.renderfx &= ~RF_SHELL_HALF_DAM;
X
X	gi.dprintf ("\n");
*/
}
X
X
void M_MoveFrame (edict_t *self)
{
X	mmove_t	*move;
X	int		index;
X
X	move = self->monsterinfo.currentmove;
X	self->nextthink = level.time + FRAMETIME;
X
X	if ((self->monsterinfo.nextframe) && (self->monsterinfo.nextframe >= move->firstframe) && (self->monsterinfo.nextframe <= move->lastframe))
X	{
X		self->s.frame = self->monsterinfo.nextframe;
X		self->monsterinfo.nextframe = 0;
X	}
X	else
X	{
X		if (self->s.frame == move->lastframe)
X		{
X			if (move->endfunc)
X			{
X				move->endfunc (self);
X
X				// regrab move, endfunc is very likely to change it
X				move = self->monsterinfo.currentmove;
X
X				// check for death
X				if (self->svflags & SVF_DEADMONSTER)
X					return;
X			}
X		}
X
X		if (self->s.frame < move->firstframe || self->s.frame > move->lastframe)
X		{
X			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X			self->s.frame = move->firstframe;
X		}
X		else
X		{
X			if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
X			{
X				self->s.frame++;
X				if (self->s.frame > move->lastframe)
X					self->s.frame = move->firstframe;
X			}
X		}
X	}
X
X	index = self->s.frame - move->firstframe;
X
X	if (move->frame[index].aifunc)
X		if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
X			move->frame[index].aifunc (self, move->frame[index].dist * self->monsterinfo.scale);
X		else
X			move->frame[index].aifunc (self, 0);
X
X	if (move->frame[index].thinkfunc)
X		move->frame[index].thinkfunc (self);
}
X
X
void monster_think (edict_t *self)
{
X	M_MoveFrame (self);
X	if (self->linkcount != self->monsterinfo.linkcount)
X	{
X		self->monsterinfo.linkcount = self->linkcount;
X		M_CheckGround (self);
X	}
X	M_CatagorizePosition (self);
X	M_WorldEffects (self);
X	M_SetEffects (self);
}
X
X
/*
================
monster_use
X
Using a monster makes it angry at the current activator
================
*/
void monster_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->enemy)
X		return;
X	if (self->health <= 0)
X		return;
X	if (activator->flags & FL_NOTARGET)
X		return;
X	if (!(activator->client) && !(activator->monsterinfo.aiflags & AI_GOOD_GUY))
X		return;
X	if (activator->flags & FL_DISGUISED)		// PGM
X		return;									// PGM
X
// delay reaction so if the monster is teleported, its sound is still heard
X	self->enemy = activator;
X	FoundTarget (self);
}
X
X
void monster_start_go (edict_t *self);
X
X
void monster_triggered_spawn (edict_t *self)
{
X	self->s.origin[2] += 1;
X	KillBox (self);
X
X	self->solid = SOLID_BBOX;
X	self->movetype = MOVETYPE_STEP;
X	self->svflags &= ~SVF_NOCLIENT;
X	self->air_finished = level.time + 12;
X	gi.linkentity (self);
X
X	monster_start_go (self);
X
X	if (self->enemy && !(self->spawnflags & 1) && !(self->enemy->flags & FL_NOTARGET))
X	{
X		if(!(self->enemy->flags & FL_DISGUISED))		// PGM
X			FoundTarget (self);
X		else // PMM - just in case, make sure to clear the enemy so FindTarget doesn't get confused
X			self->enemy = NULL;
X	}
X	else
X	{
X		self->enemy = NULL;
X	}
}
X
void monster_triggered_spawn_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	// we have a one frame delay here so we don't telefrag the guy who activated us
X	self->think = monster_triggered_spawn;
X	self->nextthink = level.time + FRAMETIME;
X	if (activator->client)
X		self->enemy = activator;
X	self->use = monster_use;
}
X
void monster_triggered_start (edict_t *self)
{
X	self->solid = SOLID_NOT;
X	self->movetype = MOVETYPE_NONE;
X	self->svflags |= SVF_NOCLIENT;
X	self->nextthink = 0;
X	self->use = monster_triggered_spawn_use;
}
X
X
/*
================
monster_death_use
X
When a monster dies, it fires all of its targets with the current
enemy as activator.
================
*/
void monster_death_use (edict_t *self)
{
X	self->flags &= ~(FL_FLY|FL_SWIM);
X	self->monsterinfo.aiflags &= AI_GOOD_GUY;
X
X	if (self->item)
X	{
X		Drop_Item (self, self->item);
X		self->item = NULL;
X	}
X
X	if (self->deathtarget)
X		self->target = self->deathtarget;
X
X	if (!self->target)
X		return;
X
X	G_UseTargets (self, self->enemy);
}
X
X
//============================================================================
X
qboolean monster_start (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return false;
X	}
X
X	if ((self->spawnflags & 4) && !(self->monsterinfo.aiflags & AI_GOOD_GUY))
X	{
X		self->spawnflags &= ~4;
X		self->spawnflags |= 1;
//		gi.dprintf("fixed spawnflags on %s at %s\n", self->classname, vtos(self->s.origin));
X	}
X
X	if ((!(self->monsterinfo.aiflags & AI_GOOD_GUY)) && (!(self->monsterinfo.aiflags & AI_DO_NOT_COUNT)))
X		level.total_monsters++;
X
X	self->nextthink = level.time + FRAMETIME;
X	self->svflags |= SVF_MONSTER;
X	self->s.renderfx |= RF_FRAMELERP;
X	self->takedamage = DAMAGE_AIM;
X	self->air_finished = level.time + 12;
X	self->use = monster_use;
X	self->max_health = self->health;
X	self->clipmask = MASK_MONSTERSOLID;
X
X	self->s.skinnum = 0;
X	self->deadflag = DEAD_NO;
X	self->svflags &= ~SVF_DEADMONSTER;
X
X	if (!self->monsterinfo.checkattack)
X		self->monsterinfo.checkattack = M_CheckAttack;
X	VectorCopy (self->s.origin, self->s.old_origin);
X
X	if (st.item)
X	{
X		self->item = FindItemByClassname (st.item);
X		if (!self->item)
X			gi.dprintf("%s at %s has bad item: %s\n", self->classname, vtos(self->s.origin), st.item);
X	}
X
X	// randomize what frame they start on
X	if (self->monsterinfo.currentmove)
X		self->s.frame = self->monsterinfo.currentmove->firstframe + (rand() % (self->monsterinfo.currentmove->lastframe - self->monsterinfo.currentmove->firstframe + 1));
X
X	// PMM - get this so I don't have to do it in all of the monsters
X	self->monsterinfo.base_height = self->maxs[2];
X
X	// PMM - clear these
X	self->monsterinfo.quad_framenum = 0;
X	self->monsterinfo.double_framenum = 0;
X	self->monsterinfo.invincible_framenum = 0;
X
X	return true;
}
X
void monster_start_go (edict_t *self)
{
X	vec3_t	v;
X
X	if (self->health <= 0)
X		return;
X
X	// check for target to combat_point and change to combattarget
X	if (self->target)
X	{
X		qboolean	notcombat;
X		qboolean	fixup;
X		edict_t		*target;
X
X		target = NULL;
X		notcombat = false;
X		fixup = false;
X		while ((target = G_Find (target, FOFS(targetname), self->target)) != NULL)
X		{
X			if (strcmp(target->classname, "point_combat") == 0)
X			{
X				self->combattarget = self->target;
X				fixup = true;
X			}
X			else
X			{
X				notcombat = true;
X			}
X		}
X		if (notcombat && self->combattarget)
X			gi.dprintf("%s at %s has target with mixed types\n", self->classname, vtos(self->s.origin));
X		if (fixup)
X			self->target = NULL;
X	}
X
X	// validate combattarget
X	if (self->combattarget)
X	{
X		edict_t		*target;
X
X		target = NULL;
X		while ((target = G_Find (target, FOFS(targetname), self->combattarget)) != NULL)
X		{
X			if (strcmp(target->classname, "point_combat") != 0)
X			{
X				gi.dprintf("%s at (%i %i %i) has a bad combattarget %s : %s at (%i %i %i)\n",
X					self->classname, (int)self->s.origin[0], (int)self->s.origin[1], (int)self->s.origin[2],
X					self->combattarget, target->classname, (int)target->s.origin[0], (int)target->s.origin[1],
X					(int)target->s.origin[2]);
X			}
X		}
X	}
X
X	if (self->target)
X	{
X		self->goalentity = self->movetarget = G_PickTarget(self->target);
X		if (!self->movetarget)
X		{
X			gi.dprintf ("%s can't find target %s at %s\n", self->classname, self->target, vtos(self->s.origin));
X			self->target = NULL;
X			self->monsterinfo.pausetime = 100000000;
X			self->monsterinfo.stand (self);
X		}
X		else if (strcmp (self->movetarget->classname, "path_corner") == 0)
X		{
X			VectorSubtract (self->goalentity->s.origin, self->s.origin, v);
X			self->ideal_yaw = self->s.angles[YAW] = vectoyaw(v);
X			self->monsterinfo.walk (self);
X			self->target = NULL;
X		}
X		else
X		{
X			self->goalentity = self->movetarget = NULL;
X			self->monsterinfo.pausetime = 100000000;
X			self->monsterinfo.stand (self);
X		}
X	}
X	else
X	{
X		self->monsterinfo.pausetime = 100000000;
X		self->monsterinfo.stand (self);
X	}
X
X	self->think = monster_think;
X	self->nextthink = level.time + FRAMETIME;
}
X
X
void walkmonster_start_go (edict_t *self)
{
X	if (!(self->spawnflags & 2) && level.time < 1)
X	{
X		M_droptofloor (self);
X
X		if (self->groundentity)
X			if (!M_walkmove (self, 0, 0))
X				gi.dprintf ("%s in solid at %s\n", self->classname, vtos(self->s.origin));
X	}
X	
X	if (!self->yaw_speed)
X		self->yaw_speed = 20;
X	// PMM - stalkers are too short for this
X	if (!(strcmp(self->classname, "monster_stalker")))
X		self->viewheight = 15;
X	else
X		self->viewheight = 25;
X
X	monster_start_go (self);
X
X	if (self->spawnflags & 2)
X		monster_triggered_start (self);
}
X
void walkmonster_start (edict_t *self)
{
X	self->think = walkmonster_start_go;
X	monster_start (self);
}
X
X
void flymonster_start_go (edict_t *self)
{
X	if (!M_walkmove (self, 0, 0))
X		gi.dprintf ("%s in solid at %s\n", self->classname, vtos(self->s.origin));
X
X	if (!self->yaw_speed)
X		self->yaw_speed = 10;
X	self->viewheight = 25;
X
X	monster_start_go (self);
X
X	if (self->spawnflags & 2)
X		monster_triggered_start (self);
}
X
X
void flymonster_start (edict_t *self)
{
X	self->flags |= FL_FLY;
X	self->think = flymonster_start_go;
X	monster_start (self);
}
X
X
void swimmonster_start_go (edict_t *self)
{
X	if (!self->yaw_speed)
X		self->yaw_speed = 10;
X	self->viewheight = 10;
X
X	monster_start_go (self);
X
X	if (self->spawnflags & 2)
X		monster_triggered_start (self);
}
X
void swimmonster_start (edict_t *self)
{
X	self->flags |= FL_SWIM;
X	self->think = swimmonster_start_go;
X	monster_start (self);
}
X
//ROGUE
X
void stationarymonster_start_go (edict_t *self);
X
void stationarymonster_triggered_spawn (edict_t *self)
{
X	KillBox (self);
X
X	self->solid = SOLID_BBOX;
X	self->movetype = MOVETYPE_NONE;
X	self->svflags &= ~SVF_NOCLIENT;
X	self->air_finished = level.time + 12;
X	gi.linkentity (self);
X
X	// FIXME - why doesn't this happen with real monsters?
X	self->spawnflags &= ~2;
X
X	stationarymonster_start_go (self);
X
X	if (self->enemy && !(self->spawnflags & 1) && !(self->enemy->flags & FL_NOTARGET))
X	{
X		if(!(self->enemy->flags & FL_DISGUISED))		// PGM
X			FoundTarget (self);
X		else // PMM - just in case, make sure to clear the enemy so FindTarget doesn't get confused
X			self->enemy = NULL;
X	}
X	else
X	{
X		self->enemy = NULL;
X	}
}
X
void stationarymonster_triggered_spawn_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	// we have a one frame delay here so we don't telefrag the guy who activated us
X	self->think = stationarymonster_triggered_spawn;
X	self->nextthink = level.time + FRAMETIME;
X	if (activator->client)
X		self->enemy = activator;
X	self->use = monster_use;
}
X
void stationarymonster_triggered_start (edict_t *self)
{
X	self->solid = SOLID_NOT;
X	self->movetype = MOVETYPE_NONE;
X	self->svflags |= SVF_NOCLIENT;
X	self->nextthink = 0;
X	self->use = stationarymonster_triggered_spawn_use;
}
X
void stationarymonster_start_go (edict_t *self)
{
// PGM - only turrets use this, so remove the error message. They're supposed to be in solid.
X
//	if (!M_walkmove (self, 0, 0))
//		gi.dprintf ("%s in solid at %s\n", self->classname, vtos(self->s.origin));
X	
X	if (!self->yaw_speed)
X		self->yaw_speed = 20;
//	self->viewheight = 25;
X
X	monster_start_go (self);
X
X	if (self->spawnflags & 2)
X		stationarymonster_triggered_start (self);
}
X
void stationarymonster_start (edict_t *self)
{
X	self->think = stationarymonster_start_go;
X	monster_start (self);
}
X
void monster_done_dodge (edict_t *self)
{
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("%s done dodging\n", self->classname);
X	self->monsterinfo.aiflags &= ~AI_DODGING;
}
//ROGUE
SHAR_EOF
  $shar_touch -am 1130175398 'g_monster.c' &&
  chmod 0664 'g_monster.c' ||
  $echo 'restore of' 'g_monster.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_monster.c:' 'MD5 check failed'
7f2c8d4defa59e4d74edb52487a97925  g_monster.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_monster.c'`"
    test 23122 -eq "$shar_count" ||
    $echo 'g_monster.c:' 'original size' '23122,' 'current size' "$shar_count!"
  fi
fi
# ============= g_newai.c ==============
if test -f 'g_newai.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_newai.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_newai.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_newai.c' &&
X
#include "g_local.h"
X
//===============================
// BLOCKED Logic
//===============================
X
/*
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_DEBUGTRAIL);
X		gi.WritePosition (pt1);
X		gi.WritePosition (pt2);
X		gi.multicast (pt1, MULTICAST_PVS);	
X
X		self->nextthink = level.time + 10;
*/
X
// plat states, copied from g_func.c
X
#define	STATE_TOP			0
#define	STATE_BOTTOM		1
#define STATE_UP			2
#define STATE_DOWN			3
X
qboolean face_wall (edict_t *self);
void HuntTarget (edict_t *self);
X
// PMM
qboolean parasite_drain_attack_ok (vec3_t start, vec3_t end);
X
X
// blocked_checkshot
//	shotchance: 0-1, chance they'll take the shot if it's clear.
qboolean blocked_checkshot (edict_t *self, float shotChance)
{
X	qboolean	playerVisible;
X
X	if(!self->enemy)
X		return false;
X
X	// blocked checkshot is only against players. this will
X	// filter out player sounds and other shit they should
X	// not be firing at.
X	if(!(self->enemy->client))
X		return false;
X
X	if (random() < shotChance)
X		return false;
X
X	// PMM - special handling for the parasite
X	if (!strcmp(self->classname, "monster_parasite"))
X	{
X		vec3_t	f, r, offset, start, end;
X		trace_t	tr;
X		AngleVectors (self->s.angles, f, r, NULL);
X		VectorSet (offset, 24, 0, 6);
X		G_ProjectSource (self->s.origin, offset, f, r, start);
X
X		VectorCopy (self->enemy->s.origin, end);
X		if (!parasite_drain_attack_ok(start, end))
X		{
X			end[2] = self->enemy->s.origin[2] + self->enemy->maxs[2] - 8;
X			if (!parasite_drain_attack_ok(start, end))
X			{
X				end[2] = self->enemy->s.origin[2] + self->enemy->mins[2] + 8;
X				if (!parasite_drain_attack_ok(start, end))
X					return false;
X			}
X		}
X		VectorCopy (self->enemy->s.origin, end);
X
X		tr = gi.trace (start, NULL, NULL, end, self, MASK_SHOT);
X		if (tr.ent != self->enemy)
X		{
X			self->monsterinfo.aiflags |= AI_BLOCKED;
X			
X			if(self->monsterinfo.attack)
X				self->monsterinfo.attack(self);
X			
X			self->monsterinfo.aiflags &= ~AI_BLOCKED;
X			return true;
X		}
X	}
X
X	playerVisible = visible (self, self->enemy);
X	// always shoot at teslas
X	if(playerVisible)
X	{
X		if (!strcmp(self->enemy->classname, "tesla"))
X		{
//			if(g_showlogic && g_showlogic->value)
//				gi.dprintf("blocked: taking a shot\n");
X
X			// turn on AI_BLOCKED to let the monster know the attack is being called
X			// by the blocked functions...
X			self->monsterinfo.aiflags |= AI_BLOCKED;
X			
X			if(self->monsterinfo.attack)
X				self->monsterinfo.attack(self);
X			
X			self->monsterinfo.aiflags &= ~AI_BLOCKED;
X			return true;
X		}
X	}
X
X	return false;
}
X
// blocked_checkplat
//	dist: how far they are trying to walk.
qboolean blocked_checkplat (edict_t *self, float dist)
{
X	int			playerPosition;
X	trace_t		trace;
X	vec3_t		pt1, pt2;
X	vec3_t		forward;
X	edict_t		*plat;
X
X	if(!self->enemy)
X		return false;
X
X	// check player's relative altitude
X	if(self->enemy->absmin[2] >= self->absmax[2])
X		playerPosition = 1;
X	else if(self->enemy->absmax[2] <= self->absmin[2])
X		playerPosition = -1;
X	else
X		playerPosition = 0;
X
X	// if we're close to the same position, don't bother trying plats.
X	if(playerPosition == 0)
X		return false;
X
X	plat = NULL;
X
X	// see if we're already standing on a plat.
X	if(self->groundentity && self->groundentity != world)
X	{
X		if(!strncmp(self->groundentity->classname, "func_plat", 8))
X			plat = self->groundentity;
X	}
X
X	// if we're not, check to see if we'll step onto one with this move
X	if(!plat)
X	{
X		AngleVectors (self->s.angles, forward, NULL, NULL);
X		VectorMA(self->s.origin, dist, forward, pt1);
X		VectorCopy (pt1, pt2);
X		pt2[2] -= 384;
X
X		trace = gi.trace(pt1, vec3_origin, vec3_origin, pt2, self, MASK_MONSTERSOLID);
X		if(trace.fraction < 1 && !trace.allsolid && !trace.startsolid)
X		{
X			if(!strncmp(trace.ent->classname, "func_plat", 8))
X			{
X				plat = trace.ent;
X			}
X		}
X	}
X
X	// if we've found a plat, trigger it.
X	if(plat && plat->use)
X	{
X		if (playerPosition == 1)
X		{
X			if((self->groundentity == plat && plat->moveinfo.state == STATE_BOTTOM) ||
X				(self->groundentity != plat && plat->moveinfo.state == STATE_TOP))
X			{
//				if(g_showlogic && g_showlogic->value)
//					gi.dprintf("player above, and plat will raise. using!\n");
X				plat->use (plat, self, self);
X				return true;			
X			}
X		}
X		else if(playerPosition == -1)
X		{
X			if((self->groundentity == plat && plat->moveinfo.state == STATE_TOP) ||
X				(self->groundentity != plat && plat->moveinfo.state == STATE_BOTTOM))
X			{
//				if(g_showlogic && g_showlogic->value)
//					gi.dprintf("player below, and plat will lower. using!\n");
X				plat->use (plat, self, self);
X				return true;
X			}
X		}
//		if(g_showlogic && g_showlogic->value)
//			gi.dprintf("hit a plat, not using. ppos: %d   plat: %d\n", playerPosition, plat->moveinfo.state);
X	}
X
X	return false;
}
X
// blocked_checkjump
//	dist: how far they are trying to walk.
//  maxDown/maxUp: how far they'll ok a jump for. set to 0 to disable that direction.
qboolean blocked_checkjump (edict_t *self, float dist, float maxDown, float maxUp)
{
X	int			playerPosition;
X	trace_t		trace;
X	vec3_t		pt1, pt2;
X	vec3_t		forward, up;
X
X	if(!self->enemy)
X		return false;
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X
X	if(self->enemy->absmin[2] > (self->absmin[2] + 16))
X		playerPosition = 1;
X	else if(self->enemy->absmin[2] < (self->absmin[2] - 16))
X		playerPosition = -1;
X	else
X		playerPosition = 0;
X
X	if(playerPosition == -1 && maxDown)
X	{
X		// check to make sure we can even get to the spot we're going to "fall" from
X		VectorMA(self->s.origin, 48, forward, pt1);
X		trace = gi.trace(self->s.origin, self->mins, self->maxs, pt1, self, MASK_MONSTERSOLID);
X		if(trace.fraction < 1)
X		{
//			gi.dprintf("can't get thar from hear...\n");
X			return false;
X		}
X
X		VectorCopy (pt1, pt2);
X		pt2[2] = self->mins[2] - maxDown - 1;
X
X		trace = gi.trace(pt1, vec3_origin, vec3_origin, pt2, self, MASK_MONSTERSOLID | MASK_WATER);
X		if(trace.fraction < 1 && !trace.allsolid && !trace.startsolid)
X		{
X			if((self->absmin[2] - trace.endpos[2]) >= 24 && trace.contents & MASK_SOLID)
X			{
X				if( (self->enemy->absmin[2] - trace.endpos[2]) > 32)
X				{
//					if(g_showlogic && g_showlogic->value)
//						gi.dprintf("That'll take me too far down...%0.1f\n", (self->enemy->absmin[2] - trace.endpos[2]));
X					return false;
X				}	
X
X				if(trace.plane.normal[2] < 0.9)
X				{
//					gi.dprintf("Floor angle too much! %s\n", vtos(trace.plane.normal));
X					return false;
X				}
//				if(g_showlogic && g_showlogic->value)
//					gi.dprintf("Geronimo! %0.1f\n", (self->absmin[2] - trace.endpos[2]));
X				return true;
X			}
//			else if(g_showlogic && g_showlogic->value)
//			{
//				if(!(trace.contents & MASK_SOLID))
//					gi.dprintf("Ooooh... Bad stuff down there...\n");
//				else
//					gi.dprintf("Too far to fall\n");
//			}
X		}
//		else if(g_showlogic && g_showlogic->value)
//			gi.dprintf("Ooooh... Too far to fall...\n");
X	}
X	else if(playerPosition == 1 && maxUp)
X	{
X		VectorMA(self->s.origin, 48, forward, pt1);
X		VectorCopy(pt1, pt2);
X		pt1[2] = self->absmax[2] + maxUp;
X
X		trace = gi.trace(pt1, vec3_origin, vec3_origin, pt2, self, MASK_MONSTERSOLID | MASK_WATER);
X		if(trace.fraction < 1 && !trace.allsolid && !trace.startsolid)
X		{
X			if((trace.endpos[2] - self->absmin[2]) <= maxUp && trace.contents & MASK_SOLID)
X			{
//				if(g_showlogic && g_showlogic->value)
//					gi.dprintf("Jumping Up! %0.1f\n", (trace.endpos[2] - self->absmin[2]));
X				
X				face_wall(self);
X				return true;
X			}
//			else if(g_showlogic && g_showlogic->value)
//				gi.dprintf("Too high to jump %0.1f\n", (trace.endpos[2] - self->absmin[2]));
X		}
//		else if(g_showlogic && g_showlogic->value)
//				gi.dprintf("Not something I could jump onto\n");
X	}
//	else if(g_showlogic && g_showlogic->value)
//		gi.dprintf("Player at similar level. No need to jump up?\n");
X
X	return false;
}
X
// checks to see if another coop player is nearby, and will switch.
qboolean blocked_checknewenemy (edict_t *self)
{
/*
X	int		player;
X	edict_t *ent;
X
X	if (!(coop->value))
X		return false;
X
X	for (player = 1; player <= game.maxclients; player++)
X	{
X		ent = &g_edicts[player];
X		if (!ent->inuse)
X			continue;
X		if (!ent->client)
X			continue;
X		if (ent == self->enemy)
X			continue;
X
X		if (visible (self, ent))
X		{
X			if (g_showlogic && g_showlogic->value)
X				gi.dprintf ("B_CNE: %s acquired new enemy %s\n", self->classname, ent->client->pers.netname);
X
X			self->enemy = ent;
X			FoundTarget (self);
X			return true;
X		}
X	}
X
X	return false;
*/
X	return false;
}
X
// *************************
// HINT PATHS
// *************************
X
#define HINT_ENDPOINT		0x0001
#define	MAX_HINT_CHAINS		100
X
int	hint_paths_present;
edict_t *hint_path_start[MAX_HINT_CHAINS];
int	num_hint_paths;
X
//
// AI code
//
X
// =============
// hintpath_findstart - given any hintpath node, finds the start node
// =============
edict_t	*hintpath_findstart(edict_t *ent)
{
X	edict_t		*e;
X	edict_t		*last;
X	int			field;
X
X	if(ent->target)		// starting point
X	{
X		last = world;
X		field = FOFS(targetname);
X		e = G_Find(NULL, field, ent->target);
X		while(e)
X		{
X			last = e;
X			if(!e->target)
X				break;
X			e = G_Find(NULL, field, e->target);
X		}
X	}
X	else				// end point
X	{
X		last = world;
X		field = FOFS(target);
X		e = G_Find(NULL, field, ent->targetname);
X		while(e)
X		{
X			last = e;
X			if(!e->targetname)
X				break;
X			e = G_Find(NULL, field, e->targetname);
X		}
X	}
X
X	if(!(last->spawnflags & HINT_ENDPOINT))
X	{
//		gi.dprintf ("end of chain is not HINT_ENDPOINT\n");
X		return NULL;
X	}
X
X	if(last == world)
X		last = NULL;
X	return last;
}
X
// =============
// hintpath_other_end - given one endpoint of a hintpath, returns the other end.
// =============
edict_t	*hintpath_other_end(edict_t *ent)
{
X	edict_t		*e;
X	edict_t		*last;
X	int			field;
X
X	if(ent->target)		// starting point
X	{
X		last = world;
X		field = FOFS(targetname);
X		e = G_Find(NULL, field, ent->target);
X		while(e)
X		{
X			last = e;
X			if(!e->target)
X				break;
X			e = G_Find(NULL, field, e->target);
X		}
X	}
X	else				// end point
X	{
X		last = world;
X		field = FOFS(target);
X		e = G_Find(NULL, field, ent->targetname);
X		while(e)
X		{
X			last = e;
X			if(!e->targetname)
X				break;
X			e = G_Find(NULL, field, e->targetname);
X		}
X	}
X
X	if(!(last->spawnflags & HINT_ENDPOINT))
X	{
//		gi.dprintf ("end of chain is not HINT_ENDPOINT\n");
X		return NULL;
X	}
X
X	if(last == world)
X		last = NULL;
X	return last;
}
X
// =============
// hintpath_go - starts a monster (self) moving towards the hintpath (point)
//		disables all contrary AI flags.
// =============
void hintpath_go (edict_t *self, edict_t *point)
{
X	vec3_t	dir;
X	vec3_t	angles;
X
X	VectorSubtract(point->s.origin, self->s.origin, dir);
X	vectoangles2(dir, angles);
X
X	self->ideal_yaw = angles[YAW];
X	self->goalentity = self->movetarget = point;
X	self->monsterinfo.pausetime = 0;
X	self->monsterinfo.aiflags |= AI_HINT_PATH;
X	self->monsterinfo.aiflags &= ~(AI_SOUND_TARGET | AI_PURSUIT_LAST_SEEN | AI_PURSUE_NEXT | AI_PURSUE_TEMP);
X	// run for it
X	self->monsterinfo.search_time = level.time;
X	self->monsterinfo.run (self);
}
X
// =============
// hintpath_stop - bails a monster out of following hint paths
// =============
void hintpath_stop (edict_t *self)
{
X	self->goalentity = NULL;
X	self->movetarget = NULL;
//	self->monsterinfo.last_hint = NULL;
X	self->monsterinfo.last_hint_time = level.time;
X	self->monsterinfo.goal_hint = NULL;
X	self->monsterinfo.aiflags &= ~AI_HINT_PATH;
X	if (has_valid_enemy(self))
X	{
X		// if we can see our target, go nuts
X		if (visible(self, self->enemy))
X		{
X			FoundTarget (self);
X			return;
X		}
X		// otherwise, keep chasing
X		HuntTarget (self);
X		return;
X	}
X	// if our enemy is no longer valid, forget about our enemy and go into stand
X	self->enemy = NULL;
X		// we need the pausetime otherwise the stand code
X		// will just revert to walking with no target and
X		// the monsters will wonder around aimlessly trying
X		// to hunt the world entity
X	self->monsterinfo.pausetime = level.time + 100000000;
X	self->monsterinfo.stand (self);
}
X
// =============
// monsterlost_checkhint - the monster (self) will check around for valid hintpaths.
//		a valid hintpath is one where the two endpoints can see both the monster
//		and the monster's enemy. if only one person is visible from the endpoints,
//		it will not go for it.
// =============
qboolean monsterlost_checkhint2 (edict_t *self);
X
qboolean monsterlost_checkhint (edict_t *self)
{
X	edict_t		*e, *monster_pathchain, *target_pathchain, *checkpoint;
X	edict_t		*closest;
X	float		closest_range = 1000000;
X	edict_t		*start, *destination;
X	int			field;
X	int			count1=0, count2=0, count3=0, count4=0, count5=0;
X	float		r;
X	int			i;
X	qboolean	hint_path_represented[MAX_HINT_CHAINS];
X
X	// if there are no hint paths on this map, exit immediately.
X	if(!hint_paths_present)
X		return false;
X
X	if(!self->enemy)
X		return false;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		return false;
X	
X	if (!strcmp(self->classname, "monster_turret"))
X		return false;
X
X	monster_pathchain = NULL;
X
X	field = FOFS(classname);
X
X	// find all the hint_paths.
X	// FIXME - can we not do this every time?
X	for (i=0; i < num_hint_paths; i++)
X	{
X		e = hint_path_start[i];
X		while(e)
X		{
X			count1++;
X			if (e->monster_hint_chain)
X			{
//				gi.dprintf ("uh, oh, I didn't clean up after myself\n");
X				e->monster_hint_chain = NULL;
X			}
X			if (monster_pathchain)
X			{
X				checkpoint->monster_hint_chain = e;
X				checkpoint = e;
X			}
X			else
X			{
X				monster_pathchain = e;
X				checkpoint = e;
X			}
X			e = e->hint_chain;
X		}
X	}
X	
X	// filter them by distance and visibility to the monster
X	e = monster_pathchain;
X	checkpoint = NULL;
X	while (e)
X	{
X		r = realrange (self, e);
X
//		if (r > 512)
//			count3++;
X
X		if (r > 512)
X		{
X			count2++;
//			if (g_showlogic && g_showlogic->value)
//			{
//				gi.dprintf ("MONSTER (%s) DISTANCE:  ", self->classname);
//				if (e->targetname)
//					gi.dprintf ("targetname %s\n", e->targetname);
//				else
//					gi.dprintf ("start -> %s\n", e->target);
//			}
X			if (checkpoint)
X			{
X				checkpoint->monster_hint_chain = e->monster_hint_chain;
X				e->monster_hint_chain = NULL;
X				e = checkpoint->monster_hint_chain;
X				continue;
X			}
X			else
X			{
X				// use checkpoint as temp pointer
X				checkpoint = e;
X				e = e->monster_hint_chain;
X				checkpoint->monster_hint_chain = NULL;
X				// and clear it again
X				checkpoint = NULL;
X				// since we have yet to find a valid one (or else checkpoint would be set) move the
X				// start of monster_pathchain
X				monster_pathchain = e;
X				continue;
X			}
X		}
X		if (!visible(self, e))
X		{
X			count4++;
//			if (g_showlogic && g_showlogic->value)
//			{
//				gi.dprintf ("MONSTER (%s) VISIBILITY:  ", self->classname);
//				if (e->targetname)
//					gi.dprintf ("targetname %s\n", e->targetname);
//				else
//					gi.dprintf ("start -> %s\n", e->target);
//			}
X			if (checkpoint)
X			{
X				checkpoint->monster_hint_chain = e->monster_hint_chain;
X				e->monster_hint_chain = NULL;
X				e = checkpoint->monster_hint_chain;
X				continue;
X			}
X			else
X			{
X				// use checkpoint as temp pointer
X				checkpoint = e;
X				e = e->monster_hint_chain;
X				checkpoint->monster_hint_chain = NULL;
X				// and clear it again
X				checkpoint = NULL;
X				// since we have yet to find a valid one (or else checkpoint would be set) move the
X				// start of monster_pathchain
X				monster_pathchain = e;
X				continue;
X			}
X		}
X		// if it passes all the tests, it's a keeper
//		if (g_showlogic && g_showlogic->value)
//		{
//			gi.dprintf ("MONSTER (%s) ACCEPT:  ", self->classname);
//			if (e->targetname)
//				gi.dprintf ("targetname %s\n", e->targetname);
//			else
//				gi.dprintf ("start -> %s\n", e->target);
//		}
X		count5++;
X		checkpoint = e;
X		e = e->monster_hint_chain;
X	}
X
X	// at this point, we have a list of all of the eligible hint nodes for the monster
X	// we now take them, figure out what hint chains they're on, and traverse down those chains,
X	// seeing whether any can see the player
X	//
X	// first, we figure out which hint chains we have represented in monster_pathchain
X	if (count5 == 0)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("No eligible hint paths found.\n");
X		return false;
X	}
X
X	for (i=0; i < num_hint_paths; i++)
X	{
X		hint_path_represented[i] = false;
X	}
X	e = monster_pathchain;
X	checkpoint = NULL;
X	while (e)
X	{
X		if ((e->hint_chain_id < 0) || (e->hint_chain_id > num_hint_paths))
X		{
//			if (g_showlogic && g_showlogic->value)
//				gi.dprintf ("bad hint_chain_id! %d\n", e->hint_chain_id);
X			return false;
X		}
X		hint_path_represented[e->hint_chain_id] = true;
X		e = e->monster_hint_chain;
X	}
X
X	count1 = 0;
X	count2 = 0;
X	count3 = 0;
X	count4 = 0;
X	count5 = 0;
X
X	// now, build the target_pathchain which contains all of the hint_path nodes we need to check for
X	// validity (within range, visibility)
X	target_pathchain = NULL;
X	checkpoint = NULL;
X	for (i=0; i < num_hint_paths; i++)
X	{
X		// if this hint chain is represented in the monster_hint_chain, add all of it's nodes to the target_pathchain
X		// for validity checking
X		if (hint_path_represented[i])
X		{
X			e = hint_path_start[i];
X			while (e)
X			{
X				if (target_pathchain)
X				{
X					checkpoint->target_hint_chain = e;
X					checkpoint = e;
X				}
X				else
X				{
X					target_pathchain = e;
X					checkpoint = e;
X				}
X				e = e->hint_chain;
X			}
X		}
X	}
X
X	// target_pathchain is a list of all of the hint_path nodes we need to check for validity relative to the target
X	e = target_pathchain;
X	checkpoint = NULL;
X	while (e)
X	{
X		r = realrange (self->enemy, e);
X
//		if (r > 512)
//			count3++;
X
X		if (r > 512)
X		{
X			count2++;
//			if (g_showlogic && g_showlogic->value)
//			{
//				gi.dprintf ("TARGET RANGE:  ");
//				if (e->targetname)
//					gi.dprintf ("targetname %s\n", e->targetname);
//				else
//					gi.dprintf ("start -> %s\n", e->target);
//			}
X			if (checkpoint)
X			{
X				checkpoint->target_hint_chain = e->target_hint_chain;
X				e->target_hint_chain = NULL;
X				e = checkpoint->target_hint_chain;
X				continue;
X			}
X			else
X			{
X				// use checkpoint as temp pointer
X				checkpoint = e;
X				e = e->target_hint_chain;
X				checkpoint->target_hint_chain = NULL;
X				// and clear it again
X				checkpoint = NULL;
X				target_pathchain = e;
X				continue;
X			}
X		}
X		if (!visible(self->enemy, e))
X		{
X			count4++;
//			if (g_showlogic && g_showlogic->value)
//			{
//				gi.dprintf ("TARGET VISIBILITY:  ");
//				if (e->targetname)
//					gi.dprintf ("targetname %s\n", e->targetname);
//				else
//					gi.dprintf ("start -> %s\n", e->target);
//			}
X			if (checkpoint)
X			{
X				checkpoint->target_hint_chain = e->target_hint_chain;
X				e->target_hint_chain = NULL;
X				e = checkpoint->target_hint_chain;
X				continue;
X			}
X			else
X			{
X				// use checkpoint as temp pointer
X				checkpoint = e;
X				e = e->target_hint_chain;
X				checkpoint->target_hint_chain = NULL;
X				// and clear it again
X				checkpoint = NULL;
X				target_pathchain = e;
X				continue;
X			}
X		}
X		// if it passes all the tests, it's a keeper
//		if (g_showlogic && g_showlogic->value)
//		{
//			gi.dprintf ("TARGET ACCEPT:  ");
//			if (e->targetname)
//				gi.dprintf ("targetname %s\n", e->targetname);
//			else
//				gi.dprintf ("start -> %s\n", e->target);
//		}
X		count5++;
X		checkpoint = e;
X		e = e->target_hint_chain;
X	}
X	
X	// at this point we should have:
X	// monster_pathchain - a list of "monster valid" hint_path nodes linked together by monster_hint_chain
X	// target_pathcain - a list of "target valid" hint_path nodes linked together by target_hint_chain.  these
X	//                   are filtered such that only nodes which are on the same chain as "monster valid" nodes
X	//
X	// Now, we figure out which "monster valid" node we want to use
X	// 
X	// To do this, we first off make sure we have some target nodes.  If we don't, there are no valid hint_path nodes
X	// for us to take
X	//
X	// If we have some, we filter all of our "monster valid" nodes by which ones have "target valid" nodes on them
X	//
X	// Once this filter is finished, we select the closest "monster valid" node, and go to it.
X
X	if (count5 == 0)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("No valid target nodes found\n");
X		return false;
X	}
X
X	// reuse the hint_chain_represented array, this time to see which chains are represented by the target
X	for (i=0; i < num_hint_paths; i++)
X	{
X		hint_path_represented[i] = false;
X	}
X
X	e = target_pathchain;
X	checkpoint = NULL;
X	while (e)
X	{
X		if ((e->hint_chain_id < 0) || (e->hint_chain_id > num_hint_paths))
X		{
//			gi.dprintf ("bad hint_chain_id! %d\n", e->hint_chain_id);
X			return false;
X		}
X		hint_path_represented[e->hint_chain_id] = true;
X		e = e->target_hint_chain;
X	}
X	
X	// traverse the monster_pathchain - if the hint_node isn't represented in the "target valid" chain list, 
X	// remove it
X	// if it is on the list, check it for range from the monster.  If the range is the closest, keep it
X	//
X	closest = NULL;
X	e = monster_pathchain;
X	while (e)
X	{
X		if (!(hint_path_represented[e->hint_chain_id]))
X		{
X			checkpoint = e->monster_hint_chain;
X			e->monster_hint_chain = NULL;
X			e = checkpoint;
X			continue;
X		}
X		r = realrange(self, e);
X		if (r < closest_range)
X			closest = e;
X		e = e->monster_hint_chain;
X	}
X
X	if (!closest)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Failed to find closest node for monster.  Shouldn't happen.\n");
X		return false;
X	}
X
X	start = closest;
X	// now we know which one is the closest to the monster .. this is the one the monster will go to
X	// we need to finally determine what the DESTINATION node is for the monster .. walk down the hint_chain,
X	// and find the closest one to the player
X
X	closest = NULL;
X	closest_range = 10000000;
X	e = target_pathchain;
X	while (e)
X	{
X		if (start->hint_chain_id == e->hint_chain_id)
X		{
X			r = realrange(self, e);
X			if (r < closest_range)
X				closest = e;
X		}
X		e = e->target_hint_chain;
X	}
X
X	if (!closest)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Failed to find closest node for target.  Shouldn't happen.\n");
X		return false;
X	}
X	
X	destination = closest;
X
X	self->monsterinfo.goal_hint = destination;
//	self->monsterinfo.last_hint = NULL;
X	hintpath_go(self, start);
X
//	if(g_showlogic && g_showlogic->value)
//	{
//		gi.dprintf ("found path.  proceed to ");
//		if (start->targetname)
//			gi.dprintf ("%s to get to ", start->targetname);
//		else
//			gi.dprintf ("start (->%s) to get to ", start->target);
//		if (destination->targetname)
//			gi.dprintf ("%s.", destination->targetname);
//		else
//			gi.dprintf ("start (->%s)", destination->target);
//	}
//		gi.dprintf("found path. proceed to %s to get to %s\n", vtos(start->s.origin), vtos(destination->s.origin));
X
X	return true;
}
/*
qboolean monsterlost_checkhint2 (edict_t *self)
{
X	edict_t		*e, *e2, *goPoint;
X	int			field;
X	int			playerVisible, selfVisible;
X
X	// if there are no hint paths on this map, exit immediately.
X	if(!hint_paths_present)
X		return false;
X
X	if(!self->enemy)
X		return false;
X
X	goPoint = NULL;
X	field = FOFS(classname);
X	
X	// check all the hint_paths.
X	e = G_Find(NULL, field, "hint_path");
X	while(e)
X	{
X		// if it's an endpoint, check for "validity"
X		if(e->spawnflags & HINT_ENDPOINT)
X		{
X			// check visibility from this spot
X			selfVisible = visible(e, self);
X			playerVisible = visible(e, self->enemy);
//			gi.dprintf("checking endpoint at %s %d %d\n", vtos(e->s.origin),selfVisible,playerVisible);
X
X			// at least one of us is visible from this endpoint.
X			// now check the other one if needed.
X			if(selfVisible || playerVisible)
X			{
X				// if endpoint 1 saw me, set my destination to it.
X				if(selfVisible)
X					goPoint = e;
X
X				// if both aren't visible, try the other endpoint
X				if(!selfVisible || !playerVisible)
X				{
X					e2 = hintpath_other_end(e);
X					if(!e2)		// could not connect to the other endpoint
X					{
X						gi.dprintf("Unlinked hint paths!\n");
X						return false;
X					}
X
X					// if endpoint 1 saw the enemy, see if endpoint 2 sees me
X					if(!selfVisible)
X						selfVisible = visible(e2, self);
X					// if endpoint 1 saw me, see if endpoint 2 sees the enemy
X					else if(!playerVisible)
X						playerVisible = visible(e2, self->enemy);
X
X					// if endpoint 2 saw me, set my destination to it.
X					if(!goPoint && selfVisible)
X						goPoint = e2;
X
//					gi.dprintf("checking other endpoint at %s %d %d\n", vtos(e2->s.origin),selfVisible,playerVisible);
X				}
X
X				// if both are visible from at least one endpoint,
X				// go for it.
X				if(selfVisible && playerVisible)
X				{
X					// set me to go to goPoint
X					if(g_showlogic && g_showlogic->value)
X						gi.dprintf("found path. proceed to %s\n", vtos(goPoint->s.origin));
X					
X					// since this is a new hint path trip, set last_hint to NULL
X					self->monsterinfo.last_hint = NULL;
X					hintpath_go(self, goPoint);
X					return true;
X				}
X			}
X		}
X		e = G_Find(e, field, "hint_path");
X	}
X
X	// if we got here, we didn't find a valid path
X	if(g_showlogic && g_showlogic->value)
X		gi.dprintf("blocked_checkhint: found no paths\n");
X	return false;
}
*/
//
// Path code
//
X
// =============
// hint_path_touch - someone's touched the hint_path
// =============
void hint_path_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t		*e, *goal, *next;
//	int			chain;			 // direction - (-1) = upstream, (1) = downstream, (0) = done
X	qboolean	goalFound = false;
X
X	// make sure we're the target of it's obsession
X	if(other->movetarget == self)
X	{
X		goal = other->monsterinfo.goal_hint;
X		
X		// if the monster is where he wants to be
X		if (goal == self)
X		{
//			if(g_showlogic && g_showlogic->value)
//				gi.dprintf("Got to goal, detatching\n");
X			hintpath_stop (other);
X			return;
X		}
X		else
X		{
X			// if we aren't, figure out which way we want to go
X			e = hint_path_start[self->hint_chain_id];
X			while (e)
X			{
X				// if we get up to ourselves on the hint chain, we're going down it
X				if (e == self)
X				{
X					next = e->hint_chain;
X					break;
X				}
X				if (e == goal)
X					goalFound = true;
X				// if we get to where the next link on the chain is this hint_path and have found the goal on the way
X				// we're going upstream, so remember who the previous link is
X				if ((e->hint_chain == self) && goalFound)
X				{
X					next = e;
X					break;
X				}
X				e = e->hint_chain;
X			}
X		}
X
X		// if we couldn't find it, have the monster go back to normal hunting.
X		if(!next)
X		{
//			if(g_showlogic && g_showlogic->value)
//				gi.dprintf("couldn't figure out next node, dropping hint path\n");
X			hintpath_stop(other);
X			return;
X		}
X
X		// set the last_hint entry to this hint_path, and
X		// send him on his way
//		other->monsterinfo.last_hint = self;
//		if(g_showlogic && g_showlogic->value)
//		{
//			gi.dprintf("moving to next point, ");
//			if (next->targetname)
//				gi.dprintf ("targetname %s\n", next->targetname);
//			else
//				gi.dprintf ("start -> %s\n", next->target);
//		}
X		hintpath_go(other, next);
X
X		// have the monster freeze if the hint path we just touched has a wait time
X		// on it, for example, when riding a plat.
X		if(self->wait)
X		{
//			if(g_showlogic && g_showlogic->value)
//				gi.dprintf("monster waiting %0.1f\n", self->wait);
X			other->nextthink = level.time + self->wait;
X		}
X	}
}
/*
void hint_path_touch2 (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t		*next, *last;
X	int			chain;
X
X	// make sure we're the target of it's obsession
X	if(other->movetarget == self)
X	{
X		chain = 0;		// direction the monster is going in the chain
X		next = NULL;	// next hint_path
X
//		gi.dprintf("hint_path %s\n", vtos(self->s.origin));
X		// is this the first hintpath targeted? if so, we can do this easily.
X		if(other->monsterinfo.last_hint == NULL)
X		{
X			if(self->target)		// forward chaining
X				chain = 1;
X			else					// backward chaining
X				chain = -1;
X		}
X		else
X		{
X			// shortcut to last_hint
X			last = other->monsterinfo.last_hint;
X
X			// make sure it's valid...
X			if ( (last < g_edicts) || (last >= &g_edicts[globals.num_edicts]))
X			{
X				if(g_showlogic && g_showlogic->value)
X				{
X					gi.dprintf("bogus last_hint encountered.\n");
X					gi.dprintf("detaching from hint path %d\n", chain);
X				}
X				hintpath_stop (other);
X				return;
X			}
X			
X			// if we're an endpoint, then the monster is done moving.
X			if(self->spawnflags & HINT_ENDPOINT)
X			{
X				chain = 0;
X			}
X			// if last hint's target is our targetname, it's forward chaining.
X			else if(last->target && self->targetname && !strcmp(last->target, self->targetname))
X			{
X				chain = 1;
X			}
X			// if last hint's targetname is our target, it's backward chaining.
X			// FIXME - last->targetname was 1, not NULL ????  was a screwed up hintpath
X			else if(self->target && last->targetname && !strcmp(last->targetname, self->target))
X			{
X				chain = -1;
X			}
X			else	// if it gets here, i'm not sure how
X			{
X				gi.dprintf("hit an uncovered possibility in hint_path_touch\n");
X				chain = 0;
X			}
X		}
X
X		// find the "next" hint_path
X		if(chain == 1 && self->target)						// forward chaining
X			next = G_Find(NULL, FOFS(targetname), self->target);
X		else if(chain == -1 && self->targetname)			// backward chaining
X			next = G_Find(NULL, FOFS(target), self->targetname);
X
X		// if we couldn't find it, have the monster go back to normal hunting.
X		if(!next)
X		{
X			if(g_showlogic && g_showlogic->value)
X				gi.dprintf("detaching from hint path %d\n", chain);
X			hintpath_stop(other);
X			return;
X		}
X
X		// set the last_hint entry to this hint_path, and
X		// send him on his way
X		other->monsterinfo.last_hint = self;
X		if(g_showlogic && g_showlogic->value)
X			gi.dprintf("moving to next point, %s\n", vtos(next->s.origin));
X		hintpath_go(other, next);
X
X		// have the monster freeze if the hint path we just touched has a wait time
X		// on it, for example, when riding a plat.
X		if(self->wait)
X		{
X			if(g_showlogic && g_showlogic->value)
X				gi.dprintf("monster waiting %0.1f\n", self->wait);
X			other->nextthink = level.time + self->wait;
X		}
X	}
}
*/
X
/*QUAKED hint_path (.5 .3 0) (-8 -8 -8) (8 8 8) END
Target: next hint path
X
END - set this flag on the endpoints of each hintpath.
X
"wait" - set this if you want the monster to freeze when they touch this hintpath
*/
void SP_hint_path (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict(self);
X		return;
X	}
X
X	if (!self->targetname && !self->target)
X	{
X		gi.dprintf ("unlinked hint_path at %s\n", vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->solid = SOLID_TRIGGER;
X	self->touch = hint_path_touch;
X	VectorSet (self->mins, -8, -8, -8);
X	VectorSet (self->maxs, 8, 8, 8);
X	self->svflags |= SVF_NOCLIENT;
X	gi.linkentity (self);
}
X
//int	hint_paths_present;
//edict_t *hint_path_start[100];
//int	num_hint_paths;
X
// ============
// InitHintPaths - Called by InitGame (g_save) to enable quick exits if valid
// ============
void InitHintPaths (void)
{
X	edict_t		*e, *current;
X	int			field, i, count2;
X	qboolean	errors = false;
X
X	hint_paths_present = 0;
X	
X	// check all the hint_paths.
X	field = FOFS(classname);
X	e = G_Find(NULL, field, "hint_path");
X	if(e)
X	{
//		gi.dprintf("hint paths present on map\n");
X		hint_paths_present = 1;
X	}
X	else
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("hint paths not present on map\n");
X		return;
X	}
X
X	memset (hint_path_start, 0, MAX_HINT_CHAINS*sizeof (edict_t *));
X	num_hint_paths = 0;
X	while(e)
X	{
X		if(e->spawnflags & HINT_ENDPOINT)
X		{
X			if (e->target) // start point
X			{
X				if (e->targetname) // this is a bad end, ignore it
X				{
X					gi.dprintf ("Hint path at %s marked as endpoint with both target (%s) and targetname (%s)\n",
X						vtos (e->s.origin), e->target, e->targetname);
X					errors = true;
X				}
X				else
X				{
X					if (num_hint_paths >= MAX_HINT_CHAINS)
X					{
//						gi.dprintf ("Only %d hint chains allowed.  Connect some together!\n", MAX_HINT_CHAINS);
X						break;
X					}
X					hint_path_start[num_hint_paths++] = e;
X				}
X			}
X		}
X		e = G_Find(e, field, "hint_path");
X	}
X
X	field = FOFS(targetname);
X	for (i=0; i< num_hint_paths; i++)
X	{
X		count2 = 1;
X		current = hint_path_start[i];
X		current->hint_chain_id = i;
//		gi.dprintf ("start ");
X		e = G_Find(NULL, field, current->target);
X		if (G_Find(e, field, current->target))
X		{
X			gi.dprintf ("\nForked hint path at %s detected for chain %d, target %s\n", 
X				vtos (current->s.origin), num_hint_paths, current->target);
X			hint_path_start[i]->hint_chain = NULL;
X			count2 = 0;
X			errors = true;
X			continue;
X		}
X		while (e)
X		{
X			if (e->hint_chain)
X			{
X				gi.dprintf ("\nCircular hint path at %s detected for chain %d, targetname %s\n", 
X					vtos (e->s.origin), num_hint_paths, e->targetname);
X				hint_path_start[i]->hint_chain = NULL;
X				count2 = 0;
X				errors = true;
X				break;
X			}
X			count2++;
X			current->hint_chain = e;
X			current = e;
X			current->hint_chain_id = i;
//			gi.dprintf ("-> %s ", current->targetname);
X			if (!current->target)
X				break;
X			e = G_Find(NULL, field, current->target);
X			if (G_Find(e, field, current->target))
X			{
X				gi.dprintf ("\nForked hint path at %s detected for chain %d, target %s\n", 
X					vtos (current->s.origin), num_hint_paths, current->target);
X				hint_path_start[i]->hint_chain = NULL;
X				count2 = 0;
X				break;
X			}
X		}
//		if ((g_showlogic) && (g_showlogic->value))
//			if (count2)
//			{
//				goodcount++;
//				gi.dprintf ("\nhint_path #%d, %d elements\n\n", i, count2);
//			}
//			else
//				gi.dprintf ("\nhint_path #%d invalid\n\n", i);
X	}
//	if (errors)
//		gi.error ("hint_path processing failed, fix errors\n");
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("hint_path processing done, %d hint paths linked\n", num_hint_paths);
}
X
// *****************************
//	MISCELLANEOUS STUFF
// *****************************
X
// PMM - inback
// use to see if opponent is behind you (not to side)
// if it looks a lot like infront, well, there's a reason
X
qboolean inback (edict_t *self, edict_t *other)
{
X	vec3_t	vec;
X	float	dot;
X	vec3_t	forward;
X	
X	AngleVectors (self->s.angles, forward, NULL, NULL);
X	VectorSubtract (other->s.origin, self->s.origin, vec);
X	VectorNormalize (vec);
X	dot = DotProduct (vec, forward);
X	
X	if (dot < -0.3)
X		return true;
X	return false;
}
X
float realrange (edict_t *self, edict_t *other)
{
X	vec3_t dir;
X	
X	VectorSubtract (self->s.origin, other->s.origin, dir);
X
X	return VectorLength(dir);
}
X
qboolean face_wall (edict_t *self)
{
X	vec3_t	pt;
X	vec3_t	forward;
X	vec3_t	ang;
X	trace_t	tr;
X
X	AngleVectors (self->s.angles, forward, NULL, NULL);
X	VectorMA(self->s.origin, 64, forward, pt);
X	tr = gi.trace(self->s.origin, vec3_origin, vec3_origin, pt, self, MASK_MONSTERSOLID);
X	if(tr.fraction < 1 && !tr.allsolid && !tr.startsolid)
X	{
X		vectoangles2(tr.plane.normal, ang);
X		self->ideal_yaw = ang[YAW] + 180;
X		if(self->ideal_yaw > 360)
X			self->ideal_yaw -= 360;
X
//		if(g_showlogic && g_showlogic->value)
//			gi.dprintf("facing wall, dir %0.1f/%0.1f\n", ang[YAW], self->ideal_yaw);
X		M_ChangeYaw(self);
X		return true;
X	}
X
X	return false;
}
X
//
// Monster "Bad" Areas
// 
X
void badarea_touch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
//	drawbbox(ent);
}
X
edict_t *SpawnBadArea(vec3_t mins, vec3_t maxs, float lifespan, edict_t *owner)
{
X	edict_t *badarea;
X	vec3_t	origin;
X	
X	VectorAdd(mins, maxs, origin);
X	VectorScale(origin, 0.5, origin);
X
X	VectorSubtract(maxs, origin, maxs);
X	VectorSubtract(mins, origin, mins);
X
X	badarea = G_Spawn();
X	VectorCopy(origin, badarea->s.origin);
X	VectorCopy(maxs, badarea->maxs);
X	VectorCopy(mins, badarea->mins);
X	badarea->touch = badarea_touch;
X	badarea->movetype = MOVETYPE_NONE;
X	badarea->solid = SOLID_TRIGGER;
X	badarea->classname = "bad_area";
X	gi.linkentity (badarea);
X
//	gi.dprintf("(%s)-(%s)\n", vtos(badarea->absmin), vtos(badarea->absmax));
X
X	if(lifespan)
X	{
X		badarea->think = G_FreeEdict;
X		badarea->nextthink = level.time + lifespan;
X	}
X	if(owner)
X	{
X		badarea->owner = owner;
X	}
X
//	drawbbox(badarea);
X	return badarea;
}
X
// CheckForBadArea
//		This is a customized version of G_TouchTriggers that will check
//		for bad area triggers and return them if they're touched.
edict_t *CheckForBadArea(edict_t *ent)
{
X	int			i, num;
X	edict_t		*touch[MAX_EDICTS], *hit;
X	vec3_t		mins, maxs;
X
X	VectorAdd(ent->s.origin, ent->mins, mins);
X	VectorAdd(ent->s.origin, ent->maxs, maxs);
X
X	num = gi.BoxEdicts (mins, maxs, touch, MAX_EDICTS, AREA_TRIGGERS);
X
//	drawbbox(ent);
X
X	// be careful, it is possible to have an entity in this
X	// list removed before we get to it (killtriggered)
X	for (i=0 ; i<num ; i++)
X	{
X		hit = touch[i];
X		if (!hit->inuse)
X			continue;
X		if (hit->touch == badarea_touch)
X		{
X			return hit;
X		}
X	}
X	
X	return NULL;
}
X
#define TESLA_DAMAGE_RADIUS		128
X
qboolean MarkTeslaArea(edict_t *self, edict_t *tesla)
{
X	vec3_t	mins, maxs;
X	edict_t *e;
X	edict_t *tail;
X	edict_t *area;
X
X	if(!tesla || !self)
X		return false;
X
X	area = NULL;
X
X	// make sure this tesla doesn't have a bad area around it already...
X	e = tesla->teamchain;
X	tail = tesla;
X	while (e)
X	{
X		tail = tail->teamchain;
X		if(!strcmp(e->classname, "bad_area"))
X		{
//			gi.dprintf("tesla already has a bad area marked\n");
X			return false;
X		}
X		e = e->teamchain;
X	}
X
X	// see if we can grab the trigger directly
X	if(tesla->teamchain && tesla->teamchain->inuse)
X	{
X		edict_t *trigger;
X
X		trigger = tesla->teamchain;
X
//		VectorAdd (trigger->s.origin, trigger->mins, mins);
//		VectorAdd (trigger->s.origin, trigger->maxs, maxs);
X		VectorCopy(trigger->absmin, mins);
X		VectorCopy(trigger->absmax, maxs);
X
X		if(tesla->air_finished)
X			area = SpawnBadArea (mins, maxs, tesla->air_finished, tesla);
X		else
X			area = SpawnBadArea (mins, maxs, tesla->nextthink, tesla);
X	}
X	// otherwise we just guess at how long it'll last.
X	else
X	{
X	
X		VectorSet (mins, -TESLA_DAMAGE_RADIUS, -TESLA_DAMAGE_RADIUS, tesla->mins[2]);
X		VectorSet (maxs, TESLA_DAMAGE_RADIUS, TESLA_DAMAGE_RADIUS, TESLA_DAMAGE_RADIUS);
X
X		area = SpawnBadArea(mins, maxs, 30, tesla);
X	}
X
X	// if we spawned a bad area, then link it to the tesla
X	if(area)
X	{
//		gi.dprintf("bad area marker spawned and linked to tesla\n");
X		tail->teamchain = area;
X	}
X	return true;
}
X
// predictive calculator
// target is who you want to shoot
// start is where the shot comes from
// bolt_speed is how fast the shot is
// eye_height is a boolean to say whether or not to adjust to targets eye_height
// offset is how much time to miss by
// aimdir is the resulting aim direction (pass in NULL if you don't want it)
// aimpoint is the resulting aimpoint (pass in NULL if don't want it)
void PredictAim (edict_t *target, vec3_t start, float bolt_speed, qboolean eye_height, float offset, vec3_t aimdir, vec3_t aimpoint)
{
X	vec3_t dir, vec;
X	float dist, time;
X
X	if (!target || !target->inuse)
X	{
X		VectorCopy (vec3_origin, aimdir);
X		return;
X	}
X
X	VectorSubtract(target->s.origin, start, dir);
X	if (eye_height)
X		dir[2] += target->viewheight;
X	dist = VectorLength(dir);
X	time = dist / bolt_speed;
X
X
X	VectorMA(target->s.origin, time - offset, target->velocity, vec);
X
X	if (eye_height)
X		vec[2] += target->viewheight;
X
X	if (aimdir)
X	{
X		VectorSubtract (vec, start, aimdir);
X		VectorNormalize (aimdir);
X	}
X	
X	if (aimpoint)
X	{
X		VectorCopy (vec, aimpoint);
X	}
}
X
X
qboolean below (edict_t *self, edict_t *other)
{
X	vec3_t	vec;
X	float	dot;
X	vec3_t	down;
X	
X	VectorSubtract (other->s.origin, self->s.origin, vec);
X	VectorNormalize (vec);
X	VectorSet (down, 0, 0, -1);
X	dot = DotProduct (vec, down);
X	
X	if (dot > 0.95)  // 18 degree arc below
X		return true;
X	return false;
}
X
void drawbbox (edict_t *self)
{
X	int	lines[4][3] = {
X		{1, 2, 4},
X		{1, 2, 7},
X		{1, 4, 5},
X		{2, 4, 7}
X	};
X
X	int starts[4] = {0, 3, 5, 6};
X
X	vec3_t pt[8];
X	int i, j, k;
X	vec3_t coords[2];
X	vec3_t newbox;
X	vec3_t f,r,u, dir;
X
X	VectorCopy (self->absmin, coords[0]);
X	VectorCopy (self->absmax, coords[1]);
X
X	for (i=0; i<=1; i++)
X	{
X		for (j=0; j<=1; j++)
X		{
X			for (k=0; k<=1; k++)
X			{
X				pt[4*i+2*j+k][0] = coords[i][0];
X				pt[4*i+2*j+k][1] = coords[j][1];
X				pt[4*i+2*j+k][2] = coords[k][2];
X			}
X		}
X	}
X	
X	for (i=0; i<= 3; i++)
X	{
X		for (j=0; j<= 2; j++)
X		{
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_DEBUGTRAIL);
X			gi.WritePosition (pt[starts[i]]);
X			gi.WritePosition (pt[lines[i][j]]);
X			gi.multicast (pt[starts[i]], MULTICAST_ALL);	
X		}
X	}
X
X	vectoangles2 (self->s.angles, dir);
X	AngleVectors (dir, f, r, u);
X
X	VectorMA (self->s.origin, 50, f, newbox);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_DEBUGTRAIL);
X	gi.WritePosition (self->s.origin);
X	gi.WritePosition (newbox);
X	gi.multicast (self->s.origin, MULTICAST_PVS);	
X	VectorClear (newbox);
X
X	VectorMA (self->s.origin, 50, r, newbox);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_DEBUGTRAIL);
X	gi.WritePosition (self->s.origin);
X	gi.WritePosition (newbox);
X	gi.multicast (self->s.origin, MULTICAST_PVS);	
X	VectorClear (newbox);
X
X	VectorMA (self->s.origin, 50, u, newbox);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_DEBUGTRAIL);
X	gi.WritePosition (self->s.origin);
X	gi.WritePosition (newbox);
X	gi.multicast (self->s.origin, MULTICAST_PVS);	
X	VectorClear (newbox);
}
X
//
// New dodge code
//
void M_MonsterDodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
X	float	r = random();
X	float	height;
X	qboolean	ducker = false, dodger = false;
X
X	// this needs to be here since this can be called after the monster has "died"
X	if (self->health < 1)
X		return;
X
X	if ((self->monsterinfo.duck) && (self->monsterinfo.unduck))
X		ducker = true;
X	if ((self->monsterinfo.sidestep) && !(self->monsterinfo.aiflags & AI_STAND_GROUND))
X		dodger = true;
X
X	if ((!ducker) && (!dodger))
X		return;
X
//	if ((g_showlogic) && (g_showlogic->value))
//	{
//		if (self->monsterinfo.aiflags & AI_DODGING)
//			gi.dprintf ("dodging - ");
//		if (self->monsterinfo.aiflags & AI_DUCKED)
//			gi.dprintf ("ducked - ");
//	}
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget (self);
X	}
X
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("timeout\n");
X		return;
X	}
X
X	// skill level determination..
X	if (r > (0.25*((skill->value)+1)))
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("skillout\n");
X		return;
X	}
X
X	// stop charging, since we're going to dodge (somehow) instead
//	soldier_stop_charge (self);
X
X	if (ducker)
X	{
X		height = self->absmax[2]-32-1;  // the -1 is because the absmax is s.origin + maxs + 1
X
X		// FIXME, make smarter
X		// if we only duck, and ducking won't help or we're already ducking, do nothing
X		//
X		// need to add monsterinfo.abort_duck() and monsterinfo.next_duck_time
X
X		if ((!dodger) && ((tr->endpos[2] <= height) || (self->monsterinfo.aiflags & AI_DUCKED)))
X			return;
X	}
X	else
X		height = self->absmax[2];
X
X	if (dodger)
X	{
X		// if we're already dodging, just finish the sequence, i.e. don't do anything else
X		if (self->monsterinfo.aiflags & AI_DODGING)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("already dodging\n");
X			return;
X		}
X
X		// if we're ducking already, or the shot is at our knees
X		if ((tr->endpos[2] <= height) || (self->monsterinfo.aiflags & AI_DUCKED))
X		{
X			vec3_t right, diff;
X
X			AngleVectors (self->s.angles, NULL, right, NULL);
X			VectorSubtract (tr->endpos, self->s.origin, diff);
X
X			if (DotProduct (right, diff) < 0)
X			{
X				self->monsterinfo.lefty = 0;
//				gi.dprintf ("left\n");
X			} else {
X				self->monsterinfo.lefty = 1;
//				gi.dprintf ("right\n");
X			}
X	
X			// if we are currently ducked, unduck
X
X			if ((ducker) && (self->monsterinfo.aiflags & AI_DUCKED))
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("unducking - ");
X				self->monsterinfo.unduck(self);
X			}
X
X			self->monsterinfo.aiflags |= AI_DODGING;
X			self->monsterinfo.attack_state = AS_SLIDING;
X
X			// call the monster specific code here
X			self->monsterinfo.sidestep (self);
X			return;
X		}
X	}
X
X	if (ducker)
X	{
X		if (self->monsterinfo.next_duck_time > level.time)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("ducked too often, not ducking\n");
X			return;
X		}
X
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("ducking!\n");
X
X		monster_done_dodge (self);
X		// set this prematurely; it doesn't hurt, and prevents extra iterations
X		self->monsterinfo.aiflags |= AI_DUCKED;
X
X		self->monsterinfo.duck (self, eta);
X	}
}
X
void monster_duck_down (edict_t *self)
{
//	if (self->monsterinfo.aiflags & AI_DUCKED)
//		return;
X	self->monsterinfo.aiflags |= AI_DUCKED;
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("duck down!\n");
//	self->maxs[2] -= 32;
X	self->maxs[2] = self->monsterinfo.base_height - 32;
X	self->takedamage = DAMAGE_YES;
X	if (self->monsterinfo.duck_wait_time < level.time)
X		self->monsterinfo.duck_wait_time = level.time + 1;
X	gi.linkentity (self);
}
X
void monster_duck_hold (edict_t *self)
{
X	if (level.time >= self->monsterinfo.duck_wait_time)
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X	else
X		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
}
X
void monster_duck_up (edict_t *self)
{
X	self->monsterinfo.aiflags &= ~AI_DUCKED;
//	self->maxs[2] += 32;
X	self->maxs[2] = self->monsterinfo.base_height;
X	self->takedamage = DAMAGE_AIM;
X	self->monsterinfo.next_duck_time = level.time + DUCK_INTERVAL;
X	gi.linkentity (self);
}
X
//=========================
//=========================
qboolean has_valid_enemy (edict_t *self)
{
X	if (!self->enemy)
X		return false;
X
X	if (!self->enemy->inuse)
X		return false;
X
X	if (self->enemy->health < 1)
X		return false;
X
X	return true;
}
X
void TargetTesla (edict_t *self, edict_t *tesla)
{
X	if ((!self) || (!tesla))
X		return;
X
X	// PMM - medic bails on healing things
X	if (self->monsterinfo.aiflags & AI_MEDIC)
X	{
X		if (self->enemy)
X			cleanupHealTarget(self->enemy);
X		self->monsterinfo.aiflags &= ~AI_MEDIC;
X	}
X
X	// store the player enemy in case we lose track of him.
X	if(self->enemy && self->enemy->client)
X		self->monsterinfo.last_player_enemy = self->enemy;
X
X	if(self->enemy != tesla)
X	{
X		self->oldenemy = self->enemy;
X		self->enemy = tesla;
X		if(self->monsterinfo.attack)
X		{
X			if (self->health <= 0)
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("bad tesla attack avoided!\n");
X				return;
X			}
X			self->monsterinfo.attack(self);
X		}
X		else
X		{
X			FoundTarget(self);
X		}
X	}
}
X
// this returns a randomly selected coop player who is visible to self
// returns NULL if bad
X
edict_t * PickCoopTarget (edict_t *self)
{
X	// no more than 4 players in coop, so..
X	edict_t *targets[4];
X	int		num_targets = 0, targetID;
X	edict_t *ent;
X	int		player;
X
X	// if we're not in coop, this is a noop
X	if (!coop || !coop->value)
X		return NULL;
X
X	memset (targets, 0, 4*sizeof(edict_t *));
X
X	for (player = 1; player <= game.maxclients; player++)
X	{
X		ent = &g_edicts[player];
X		if (!ent->inuse)
X			continue;
X		if (!ent->client)
X			continue;
X		if (visible(self, ent))
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("%s: found coop player %s - ", self->classname, ent->client->pers.netname);
X			targets[num_targets++] = ent;
X		}
X	}
X
/*
X	ent = g_edicts+1; // skip the worldspawn
X	// cycle through players
X	while (ent)
X	{
X		if ((ent->client) && (ent->inuse))
X		{
X			if (visible(self, ent))
X			{
X				if ((g_showlogic) && (g_showlogic->value))
X					gi.dprintf ("%s: found coop player %s - ", self->classname, ent->client->pers.netname);
X				targets[num_targets++] = ent;
X			}
X			ent++;
X		}
X		else
X			ent = NULL;
X	}
*/
X
X	if (!num_targets)
X		return NULL;
X
X	// get a number from 0 to (num_targets-1)
X	targetID = (random() * (float)num_targets);
X	
X	// just in case we got a 1.0 from random
X	if (targetID == num_targets)
X		targetID--;
X
//	if (g_showlogic && g_showlogic->value)
//		gi.dprintf ("using player %s\n", targets[targetID]->client->pers.netname);
X	return targets[targetID];
}
X
// only meant to be used in coop
int CountPlayers (void)
{
X	edict_t *ent;
X	int		count = 0;
X	int		player;
X
X	// if we're not in coop, this is a noop
X	if (!coop || !coop->value)
X		return 1;
X
X	for (player = 1; player <= game.maxclients; player++)
X	{
X		ent = &g_edicts[player];
X		if (!ent->inuse)
X			continue;
X		if (!ent->client)
X			continue;
X		count++;
X	}
/*
X	ent = g_edicts+1; // skip the worldspawn
X	while (ent)
X	{
X		if ((ent->client) && (ent->inuse))
X		{
X			ent++;
X			count++;
X		}
X		else
X			ent = NULL;
X	}
*/
X	return count;
}
X
//*******************
// JUMPING AIDS
//*******************
X
void monster_jump_start (edict_t *self)
{
X	self->timestamp = level.time;
}
X
qboolean monster_jump_finished (edict_t *self)
{
X	if ((level.time - self->timestamp) > 3)
X	{
//		if (g_showlogic && g_showlogic->value)
//		{
//			gi.dprintf("%s jump timed out!\n", self->classname);
//		}
X		return true;
X	}
}
X
X
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_newai.c' &&
  chmod 0664 'g_newai.c' ||
  $echo 'restore of' 'g_newai.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_newai.c:' 'MD5 check failed'
6de61123de1026e3cecca2ec750f8946  g_newai.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_newai.c'`"
    test 48669 -eq "$shar_count" ||
    $echo 'g_newai.c:' 'original size' '48669,' 'current size' "$shar_count!"
  fi
fi
# ============= g_newdm.c ==============
if test -f 'g_newdm.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_newdm.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_newdm.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_newdm.c' &&
// g_newdm.c
// pmack
// june 1998
X
#include "g_local.h"
#include "m_player.h"
X
dm_game_rt	DMGame;
X
// ****************************
// General DM Stuff
// ****************************
X
void InitGameRules(void)
{
X	int		gameNum;
X
X	// clear out the game rule structure before we start
X	memset(&DMGame, 0, sizeof(dm_game_rt));
X
X	if(gamerules && gamerules->value)
X	{
X		gameNum = gamerules->value;
X		switch(gameNum)
X		{
X			case RDM_TAG:
X				DMGame.GameInit = Tag_GameInit;
X				DMGame.PostInitSetup = Tag_PostInitSetup;
X				DMGame.PlayerDeath = Tag_PlayerDeath;
X				DMGame.Score = Tag_Score;
X				DMGame.PlayerEffects = Tag_PlayerEffects;
X				DMGame.DogTag = Tag_DogTag;
X				DMGame.PlayerDisconnect = Tag_PlayerDisconnect;
X				DMGame.ChangeDamage = Tag_ChangeDamage;
X				break;
/*
X			case RDM_DEATHBALL:
X				DMGame.GameInit = DBall_GameInit;
X				DMGame.ChangeKnockback = DBall_ChangeKnockback;
X				DMGame.ChangeDamage = DBall_ChangeDamage;
X				DMGame.ClientBegin = DBall_ClientBegin;
X				DMGame.SelectSpawnPoint = DBall_SelectSpawnPoint;
X				DMGame.PostInitSetup = DBall_PostInitSetup;
X				DMGame.CheckDMRules = DBall_CheckDMRules;
X				break;
*/
X			// reset gamerules if it's not a valid number
X			default:
X				gamerules->value = 0;
X				break;
X		}
X	}
X
X	// if we're set up to play, initialize the game as needed.
X	if(DMGame.GameInit)
X		DMGame.GameInit();
}
X
//=================
//=================
#define IT_TYPE_MASK	(IT_WEAPON|IT_AMMO|IT_POWERUP|IT_ARMOR|IT_KEY)
X
extern void ED_CallSpawn (edict_t *ent);
extern qboolean Pickup_Health (edict_t *ent, edict_t *other);
extern qboolean Pickup_Adrenaline (edict_t *ent, edict_t *other);
extern qboolean Pickup_Armor (edict_t *ent, edict_t *other);
extern qboolean Pickup_PowerArmor (edict_t *ent, edict_t *other);
X
char *FindSubstituteItem (edict_t *ent)
{
X	int		i;
X	int		itflags, myflags;
X	float	rnd;
X	int		count;
X	int		pick;
X	gitem_t	*it;
X
X	// there are only two classes of power armor, and we don't want
X	// to give out power screens. therefore, power shields should
X	// remain power shields. (powerscreens shouldn't be there at all...)
X	if (ent->item->pickup == Pickup_PowerArmor)
X		return NULL;
X
X	// health is special case
X	if ((ent->item->pickup == Pickup_Health) ||	(ent->item->pickup == Pickup_Adrenaline))
X	{
X		// health pellets stay health pellets
X		if(!strcmp(ent->classname, "item_health_small"))
X			return NULL;
X
X		rnd = random();
X		if(rnd < 0.6)
X			return "item_health";
X		else if(rnd < 0.9)
X			return "item_health_large";
X		else if(rnd < 0.99)
X			return "item_adrenaline";
X		else
X			return "item_health_mega";
X	}
X	// armor is also special case
X	else if(ent->item->pickup == Pickup_Armor)
X	{
X		// armor shards stay armor shards
X		if (ent->item->tag == ARMOR_SHARD)
X			return NULL;
X
X		rnd = random();
X		if(rnd < 0.6)
X			return "item_armor_jacket";
X		else if(rnd < 0.9)
X			return "item_armor_combat";
X		else
X			return "item_armor_body";
X	}
X
X
X	// we want to stay within the item class
X	myflags = ent->item->flags & IT_TYPE_MASK;
X	if ((myflags & IT_AMMO) && (myflags & IT_WEAPON))
X			myflags = IT_AMMO;
X
X	count = 0;
X
X	// first pass, count the matching items
X	it = itemlist;
X	for (i=0 ; i<game.num_items ; i++, it++)
X	{
X		itflags = it->flags;
X		
X		if (!itflags || (itflags & IT_NOT_GIVEABLE))
X			continue;
X
X		// prox,grenades,etc should count as ammo.
X		if ((itflags & IT_AMMO) && (itflags & IT_WEAPON))
X			itflags = IT_AMMO;
X
X		// don't respawn spheres if they're dmflag disabled.
X		if ( (int)dmflags->value & DF_NO_SPHERES )
X		{
X			if (!strcmp (ent->classname, "item_sphere_vengeance") ||
X				!strcmp (ent->classname, "item_sphere_hunter") ||
X				!strcmp (ent->classname, "item_spehre_defender"))
X			{
X				continue;
X			}
X		}
X
X		if ( ((int)dmflags->value & DF_NO_NUKES) && !strcmp(ent->classname, "ammo_nuke") )
X			continue;
X
X		if ( ((int)dmflags->value & DF_NO_MINES) && 
X				(!strcmp(ent->classname, "ammo_prox") || !strcmp(ent->classname, "ammo_tesla")))
X			continue;
X
X		if ((itflags & IT_TYPE_MASK) == (myflags & IT_TYPE_MASK))
X			count++;
X	}
X
X	if(!count)
X		return NULL;
X
X	pick = ceil(random() * count);
X	count = 0;
X
X	// second pass, pick one.
X	it = itemlist;
X	for (i=0 ; i<game.num_items ; i++, it++)
X	{
X		itflags = it->flags;
X		
X		if (!itflags || (itflags & IT_NOT_GIVEABLE))
X			continue;
X
X		// prox,grenades,etc should count as ammo.
X		if ((itflags & IT_AMMO) && (itflags & IT_WEAPON))
X			itflags = IT_AMMO;
X
X		if ( ((int)dmflags->value & DF_NO_NUKES) && !strcmp(ent->classname, "ammo_nuke") )
X			continue;
X
X		if ( ((int)dmflags->value & DF_NO_MINES) && 
X				(!strcmp(ent->classname, "ammo_prox") || !strcmp(ent->classname, "ammo_tesla")))
X			continue;
X
X		if ((itflags & IT_TYPE_MASK) == (myflags & IT_TYPE_MASK))
X		{
X			count++;
X			if(pick == count)
X				return it->classname;
X		}
X	}
X
X	return NULL;
}
X
//=================
//=================
edict_t *DoRandomRespawn (edict_t *ent)
{
X	edict_t *newEnt;
X	char	*classname;
X	
X	classname = FindSubstituteItem (ent);
X	if (classname == NULL)
X		return NULL;
X
X	gi.unlinkentity (ent);
X
X	newEnt = G_Spawn();
X	newEnt->classname = classname;
X	VectorCopy (ent->s.origin, newEnt->s.origin);
X	VectorCopy (ent->s.old_origin, newEnt->s.old_origin);
X	VectorCopy (ent->mins, newEnt->mins);
X	VectorCopy (ent->maxs, newEnt->maxs);
X	
X	VectorSet (newEnt->gravityVector, 0, 0, -1);
X
X	ED_CallSpawn (newEnt);
X
X	newEnt->s.renderfx |= RF_IR_VISIBLE;
X
X	return newEnt;
}
X
//=================
//=================
void PrecacheForRandomRespawn (void)
{
X	gitem_t	*it;
X	int		i;
X	int		itflags;
X
X	it = itemlist;
X	for (i=0 ; i<game.num_items ; i++, it++)
X	{
X		itflags = it->flags;
X		
X		if (!itflags || (itflags & IT_NOT_GIVEABLE))
X			continue;
X
X		PrecacheItem(it);
X	}
}
X
// ***************************
//  DOPPLEGANGER
// ***************************
X
extern edict_t *Sphere_Spawn (edict_t *owner, int spawnflags);
X
void fire_doppleganger (edict_t *ent, vec3_t start, vec3_t aimdir);
void doppleganger_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
X
void doppleganger_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	edict_t *sphere;
X	float	dist;
X	vec3_t	dir;
X
X	if((self->enemy) && (self->enemy != self->teammaster))
X	{
X		VectorSubtract(self->enemy->s.origin, self->s.origin, dir);
X		dist = VectorLength(dir);
X
X		if(dist > 768)
X		{
X			sphere = Sphere_Spawn (self, SPHERE_HUNTER | SPHERE_DOPPLEGANGER);
X			sphere->pain(sphere, attacker, 0, 0);
X		}
X		else //if(dist > 256)
X		{
X			sphere = Sphere_Spawn (self, SPHERE_VENGEANCE | SPHERE_DOPPLEGANGER);
X			sphere->pain(sphere, attacker, 0, 0);
X		}
//		else
//		{
//			T_RadiusClassDamage (self, self->teammaster, 175, "doppleganger", 384, MOD_DOPPLE_EXPLODE);
//		}
X	}
X
X	if(self->teamchain)
X		BecomeExplosion1(self->teamchain);
X	BecomeExplosion1(self);
}
X
void doppleganger_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	self->enemy = other;
}
X
void doppleganger_timeout (edict_t *self)
{
//	T_RadiusClassDamage (self, self->teammaster, 140, "doppleganger", 256, MOD_DOPPLE_EXPLODE);
X
X	if(self->teamchain)
X		BecomeExplosion1(self->teamchain);
X	BecomeExplosion1(self);
}
X
void body_think (edict_t *self)
{
X	float r;
X
X	if(abs(self->ideal_yaw - anglemod(self->s.angles[YAW])) < 2)
X	{
X		if(self->timestamp < level.time)
X		{
X			r = random();
X			if(r < 0.10)
X			{
X				self->ideal_yaw = random() * 350.0;
X				self->timestamp = level.time + 1;
X			}
X		}
X	}
X	else
X		M_ChangeYaw(self);
X
X	self->s.frame ++;
X	if (self->s.frame > FRAME_stand40)
X		self->s.frame = FRAME_stand01;
X
X	self->nextthink = level.time + 0.1;
}
X
void fire_doppleganger (edict_t *ent, vec3_t start, vec3_t aimdir)
{
X	edict_t		*base;
X	edict_t		*body;
X	vec3_t		dir;
X	vec3_t		forward, right, up;
X	int			number;
X
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	base = G_Spawn();
X	VectorCopy (start, base->s.origin);
X	VectorCopy (dir, base->s.angles);
X	VectorClear (base->velocity);
X	VectorClear (base->avelocity);
X	base->movetype = MOVETYPE_TOSS;
X	base->solid = SOLID_BBOX;
X	base->s.renderfx |= RF_IR_VISIBLE;
X	base->s.angles[PITCH]=0;
X	VectorSet (base->mins, -16, -16, -24);
X	VectorSet (base->maxs, 16, 16, 32);
//	base->s.modelindex = gi.modelindex ("models/objects/dopplebase/tris.md2");
X	base->s.modelindex = 0;
X	base->teammaster = ent;
X	base->svflags |= SVF_DAMAGEABLE;
X	base->takedamage = DAMAGE_AIM;
X	base->health = 30;
X	base->pain = doppleganger_pain;
X	base->die = doppleganger_die;
X
X	// FIXME - remove with style
X	base->nextthink = level.time + 30;
X	base->think = doppleganger_timeout;
X
X	base->classname = "doppleganger";
X
X	gi.linkentity (base);
X
X	body = G_Spawn();
X	number = body->s.number;
X	body->s = ent->s;
X	body->s.sound = 0;
X	body->s.event = 0;
//	body->s.modelindex2 = 0;		// no attached items (CTF flag, etc)
X	body->s.number = number;
X	body->yaw_speed = 30;
X	body->ideal_yaw = 0;
X	VectorCopy (start, body->s.origin);
X	body->s.origin[2] += 8;
X	body->think = body_think;
X	body->nextthink = level.time + FRAMETIME;
X	gi.linkentity (body);
X
X	base->teamchain = body;
X	body->teammaster = base;
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_newdm.c' &&
  chmod 0664 'g_newdm.c' ||
  $echo 'restore of' 'g_newdm.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_newdm.c:' 'MD5 check failed'
4c31e87f55099b90aa17a8fe68577013  g_newdm.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_newdm.c'`"
    test 8993 -eq "$shar_count" ||
    $echo 'g_newdm.c:' 'original size' '8993,' 'current size' "$shar_count!"
  fi
fi
# ============= g_newfnc.c ==============
if test -f 'g_newfnc.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_newfnc.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_newfnc.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_newfnc.c' &&
#include "g_local.h"
X
//void plat_CalcMove (edict_t *ent, vec3_t dest, void(*func)(edict_t*));
void Move_Calc (edict_t *ent, vec3_t dest, void(*func)(edict_t*));
X
void fd_secret_move1(edict_t *self);
void fd_secret_move2(edict_t *self);
void fd_secret_move3(edict_t *self);
void fd_secret_move4(edict_t *self);
void fd_secret_move5(edict_t *self);
void fd_secret_move6(edict_t *self);
void fd_secret_done(edict_t *self);
X
/*
=============================================================================
X
SECRET DOORS
X
=============================================================================
*/
X
#define SEC_OPEN_ONCE		1          // stays open
#define SEC_1ST_LEFT		2          // 1st move is left of arrow
#define SEC_1ST_DOWN		4          // 1st move is down from arrow
#define SEC_NO_SHOOT		8          // only opened by trigger
#define SEC_YES_SHOOT		16		   // shootable even if targeted
#define SEC_MOVE_RIGHT		32
#define SEC_MOVE_FORWARD	64
X
void fd_secret_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t *ent;
X
//	gi.dprintf("fd_secret_use\n");
X	if (self->flags & FL_TEAMSLAVE)
X		return;
X
X	// trigger all paired doors
X	for (ent = self ; ent ; ent = ent->teamchain)
X		Move_Calc(ent, ent->moveinfo.start_origin, fd_secret_move1);
X
}
X
void fd_secret_killed (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
//	gi.dprintf("fd_secret_killed\n");
X	self->health = self->max_health;
X	self->takedamage = DAMAGE_NO;
X
X	if (self->flags & FL_TEAMSLAVE && self->teammaster && self->teammaster->takedamage != DAMAGE_NO)
X		fd_secret_killed (self->teammaster, inflictor, attacker, damage, point);
X	else
X		fd_secret_use (self, inflictor, attacker);
}
X
// Wait after first movement...
void fd_secret_move1(edict_t *self) 
{
//	gi.dprintf("fd_secret_move1\n");
X	self->nextthink = level.time + 1.0;
X	self->think = fd_secret_move2;
}
X
// Start moving sideways w/sound...
void fd_secret_move2(edict_t *self)
{
//	gi.dprintf("fd_secret_move2\n");
X	Move_Calc(self, self->moveinfo.end_origin, fd_secret_move3);
}
X
// Wait here until time to go back...
void fd_secret_move3(edict_t *self)
{
//	gi.dprintf("fd_secret_move3\n");
X	if (!(self->spawnflags & SEC_OPEN_ONCE))
X	{
X		self->nextthink = level.time + self->wait;
X		self->think = fd_secret_move4;
X	}
}
X
// Move backward...
void fd_secret_move4(edict_t *self)
{
//	gi.dprintf("fd_secret_move4\n");
X	Move_Calc(self, self->moveinfo.start_origin, fd_secret_move5);          
}
X
// Wait 1 second...
void fd_secret_move5(edict_t *self)
{
//	gi.dprintf("fd_secret_move5\n");
X	self->nextthink = level.time + 1.0;
X	self->think = fd_secret_move6;
}
X
void fd_secret_move6(edict_t *self)
{
//	gi.dprintf("fd_secret_move6\n");
X	Move_Calc(self, self->move_origin, fd_secret_done);
}
X
void fd_secret_done(edict_t *self)
{
//	gi.dprintf("fd_secret_done\n");
X	if (!self->targetname || self->spawnflags & SEC_YES_SHOOT)
X	{
X		self->health = 1;
X		self->takedamage = DAMAGE_YES;
X		self->die = fd_secret_killed;   
X	}
}
X
void secret_blocked(edict_t *self, edict_t *other)
{
X	if (!(self->flags & FL_TEAMSLAVE))
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, 0, 0, MOD_CRUSH);
X
//	if (time < self->attack_finished)
//		return;
//	self->attack_finished = time + 0.5;
//	T_Damage (other, self, self, self->dmg);
}
X
/*
================
secret_touch
X
Prints messages
================
*/
void secret_touch(edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other->health <= 0)
X		return;
X
X	if (!(other->client))
X		return;
X
X	if (self->monsterinfo.attack_finished > level.time)
X		return;
X
X	self->monsterinfo.attack_finished = level.time + 2;
X	
X	if (self->message)
X	{
X		gi.centerprintf (other, self->message);
//		fixme - put this sound back??
//		gi.sound (other, CHAN_BODY, "misc/talk.wav", 1, ATTN_NORM);
X	}
}
X
X
/*QUAKED func_door_secret2 (0 .5 .8) ? open_once 1st_left 1st_down no_shoot always_shoot slide_right slide_forward
Basic secret door. Slides back, then to the left. Angle determines direction.
X
FLAGS:
open_once = not implemented yet
1st_left = 1st move is left/right of arrow
1st_down = 1st move is forwards/backwards
no_shoot = not implemented yet
always_shoot = even if targeted, keep shootable
reverse_left = the sideways move will be to right of arrow
reverse_back = the to/fro move will be forward
X
VALUES:
wait = # of seconds before coming back (5 default)
dmg  = damage to inflict when blocked (2 default)
X
*/
X
void SP_func_door_secret2 (edict_t *ent)
{
X	vec3_t	forward,right,up;
X	float	lrSize, fbSize;
X
X	ent->moveinfo.sound_start = gi.soundindex  ("doors/dr1_strt.wav");
X	ent->moveinfo.sound_middle = gi.soundindex  ("doors/dr1_mid.wav");
X	ent->moveinfo.sound_end = gi.soundindex  ("doors/dr1_end.wav");
X
X	if (!ent->dmg)
X		ent->dmg = 2;
X		
X	AngleVectors(ent->s.angles, forward, right, up);
X	VectorCopy(ent->s.origin, ent->move_origin);
X	VectorCopy(ent->s.angles, ent->move_angles);
X
X	G_SetMovedir (ent->s.angles, ent->movedir);
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_BSP;
X	gi.setmodel (ent, ent->model);
X
X	if(ent->move_angles[1] == 0 || ent->move_angles[1] == 180)
X	{
X		lrSize = ent->size[1];
X		fbSize = ent->size[0];
X	}		
X	else if(ent->move_angles[1] == 90 || ent->move_angles[1] == 270)
X	{
X		lrSize = ent->size[0];
X		fbSize = ent->size[1];
X	}		
X	else
X	{
X		gi.dprintf("Secret door not at 0,90,180,270!\n");
X	}
X
X	if(ent->spawnflags & SEC_MOVE_FORWARD)
X		VectorScale(forward, fbSize, forward);
X	else
X	{
X		VectorScale(forward, fbSize * -1 , forward);
X	}
X
X	if(ent->spawnflags & SEC_MOVE_RIGHT)
X		VectorScale(right, lrSize, right);
X	else
X	{
X		VectorScale(right, lrSize * -1, right);
X	}
X
X	if(ent->spawnflags & SEC_1ST_DOWN)
X	{
X		VectorAdd(ent->s.origin, forward, ent->moveinfo.start_origin);
X		VectorAdd(ent->moveinfo.start_origin, right, ent->moveinfo.end_origin);
X	}
X	else
X	{
X		VectorAdd(ent->s.origin, right, ent->moveinfo.start_origin);
X		VectorAdd(ent->moveinfo.start_origin, forward, ent->moveinfo.end_origin);
X	}
X
X	ent->touch = secret_touch;
X	ent->blocked = secret_blocked;
X	ent->use = fd_secret_use;
X	ent->moveinfo.speed = 50;
X	ent->moveinfo.accel = 50;
X	ent->moveinfo.decel = 50;
X
X	if (!ent->targetname || ent->spawnflags & SEC_YES_SHOOT)
X	{
X		ent->health = 1;
X		ent->max_health = ent->health;
X		ent->takedamage = DAMAGE_YES;
X		ent->die = fd_secret_killed;
X	}
X	if (!ent->wait)
X		ent->wait = 5;          // 5 seconds before closing
X
X	gi.linkentity(ent);
}
X
// ==================================================
X
#define FWALL_START_ON		1
X
void force_wall_think(edict_t *self)
{
X	if(!self->wait)
X	{
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_FORCEWALL);
X		gi.WritePosition (self->pos1);
X		gi.WritePosition (self->pos2);
X		gi.WriteByte  (self->style);
X		gi.multicast (self->offset, MULTICAST_PVS);
X	}
X
X	self->think = force_wall_think;
X	self->nextthink = level.time + 0.1;
}
X
void force_wall_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if(!self->wait)
X	{
X		self->wait = 1;
X		self->think = NULL;
X		self->nextthink = 0;
X		self->solid = SOLID_NOT;
X		gi.linkentity( self );
X	}
X	else
X	{
X		self->wait = 0;
X		self->think = force_wall_think;
X		self->nextthink = level.time + 0.1;
X		self->solid = SOLID_BSP;
X		KillBox(self);		// Is this appropriate?
X		gi.linkentity (self);
X	}
}
X
/*QUAKED func_force_wall (1 0 1) ? start_on
A vertical particle force wall. Turns on and solid when triggered.
If someone is in the force wall when it turns on, they're telefragged.
X
start_on - forcewall begins activated. triggering will turn it off.
style - color of particles to use.
X	208: green, 240: red, 241: blue, 224: orange
*/
void SP_func_force_wall(edict_t *ent)
{
X	gi.setmodel (ent, ent->model);
X
X	ent->offset[0] = (ent->absmax[0] + ent->absmin[0]) / 2;
X	ent->offset[1] = (ent->absmax[1] + ent->absmin[1]) / 2;
X	ent->offset[2] = (ent->absmax[2] + ent->absmin[2]) / 2;
X
X	ent->pos1[2] = ent->absmax[2];
X	ent->pos2[2] = ent->absmax[2];
X	if(ent->size[0] > ent->size[1])
X	{
X		ent->pos1[0] = ent->absmin[0];
X		ent->pos2[0] = ent->absmax[0];
X		ent->pos1[1] = ent->offset[1];
X		ent->pos2[1] = ent->offset[1];
X	}
X	else
X	{
X		ent->pos1[0] = ent->offset[0];
X		ent->pos2[0] = ent->offset[0];
X		ent->pos1[1] = ent->absmin[1];
X		ent->pos2[1] = ent->absmax[1];
X	}
X	
X	if(!ent->style)
X		ent->style = 208;
X
X	ent->movetype = MOVETYPE_NONE;
X	ent->wait = 1;
X
X	if(ent->spawnflags & FWALL_START_ON)
X	{
X		ent->solid = SOLID_BSP;
X		ent->think = force_wall_think;
X		ent->nextthink = level.time + 0.1;
X	}
X	else
X		ent->solid = SOLID_NOT;
X
X	ent->use = force_wall_use;
X
X	ent->svflags = SVF_NOCLIENT;
X	
X	gi.linkentity(ent);
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_newfnc.c' &&
  chmod 0664 'g_newfnc.c' ||
  $echo 'restore of' 'g_newfnc.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_newfnc.c:' 'MD5 check failed'
fba6d47e1b35794b2eeba5626850dd6f  g_newfnc.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_newfnc.c'`"
    test 8550 -eq "$shar_count" ||
    $echo 'g_newfnc.c:' 'original size' '8550,' 'current size' "$shar_count!"
  fi
fi
# ============= g_newtarg.c ==============
if test -f 'g_newtarg.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_newtarg.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_newtarg.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_newtarg.c' &&
#include "g_local.h"
X
//==========================================================
X
/*QUAKED target_steam (1 0 0) (-8 -8 -8) (8 8 8)
Creates a steam effect (particles w/ velocity in a line).
X
X  speed = velocity of particles (default 50)
X  count = number of particles (default 32)
X  sounds = color of particles (default 8 for steam)
X     the color range is from this color to this color + 6
X  wait = seconds to run before stopping (overrides default
X     value derived from func_timer)
X
X  best way to use this is to tie it to a func_timer that "pokes"
X  it every second (or however long you set the wait time, above)
X
X  note that the width of the base is proportional to the speed
X  good colors to use:
X  6-9 - varying whites (darker to brighter)
X  224 - sparks
X  176 - blue water
X  80  - brown water
X  208 - slime
X  232 - blood
*/
X
void use_target_steam (edict_t *self, edict_t *other, edict_t *activator)
{
X	// FIXME - this needs to be a global
X	static int	nextid;
X	vec3_t		point;
X
X	if (nextid > 20000)
X		nextid = nextid %20000;
X
X	nextid++;
X	
X	// automagically set wait from func_timer unless they set it already, or
X	// default to 1000 if not called by a func_timer (eek!)
X	if (!self->wait)
X		if (other)
X			self->wait = other->wait * 1000;
X		else
X			self->wait = 1000;
X
X	if (self->enemy)
X	{
X		VectorMA (self->enemy->absmin, 0.5, self->enemy->size, point);
X		VectorSubtract (point, self->s.origin, self->movedir);
X		VectorNormalize (self->movedir);
X	}
X
X	VectorMA (self->s.origin, self->plat2flags*0.5, self->movedir, point);
X	if (self->wait > 100)
X	{
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_STEAM);
X		gi.WriteShort (nextid);
X		gi.WriteByte (self->count);
X		gi.WritePosition (self->s.origin);
X		gi.WriteDir (self->movedir);
X		gi.WriteByte (self->sounds&0xff);
X		gi.WriteShort ( (short int)(self->plat2flags) );
X		gi.WriteLong ( (int)(self->wait) );
X		gi.multicast (self->s.origin, MULTICAST_PVS);
X	}
X	else
X	{
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_STEAM);
X		gi.WriteShort ((short int)-1);
X		gi.WriteByte (self->count);
X		gi.WritePosition (self->s.origin);
X		gi.WriteDir (self->movedir);
X		gi.WriteByte (self->sounds&0xff);
X		gi.WriteShort ( (short int)(self->plat2flags) );
X		gi.multicast (self->s.origin, MULTICAST_PVS);
X	}
}
X
void target_steam_start (edict_t *self)
{
X	edict_t	*ent;
X
X	self->use = use_target_steam;
X
X	if (self->target)
X	{
X		ent = G_Find (NULL, FOFS(targetname), self->target);
X		if (!ent)
X			gi.dprintf ("%s at %s: %s is a bad target\n", self->classname, vtos(self->s.origin), self->target);
X		self->enemy = ent;
X	}
X	else
X	{
X		G_SetMovedir (self->s.angles, self->movedir);
X	}
X
X	if (!self->count)
X		self->count = 32;
X	if (!self->plat2flags)
X		self->plat2flags = 75;
X	if (!self->sounds)
X		self->sounds = 8;
X	if (self->wait)
X		self->wait *= 1000;  // we want it in milliseconds, not seconds
X
X	// paranoia is good
X	self->sounds &= 0xff;
X	self->count &= 0xff;
X
X	self->svflags = SVF_NOCLIENT;
X
X	gi.linkentity (self);
}
X
void SP_target_steam (edict_t *self)
{
X	self->plat2flags = self->speed;
X
X	if (self->target)
X	{
X		self->think = target_steam_start;
X		self->nextthink = level.time + 1;
X	}
X	else
X		target_steam_start (self);
}
X
X
//==========================================================
// target_anger
//==========================================================
X
void target_anger_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t		*target;
X	edict_t		*t;
X
X	t = NULL;
X	target = G_Find (t, FOFS(targetname), self->killtarget);
X
X	if (target && self->target)
X	{
X		// Make whatever a "good guy" so the monster will try to kill it!
X		target->monsterinfo.aiflags |= AI_GOOD_GUY;
X		target->svflags |= SVF_MONSTER;
X		target->health = 300;
X
X		t = NULL;
X		while ((t = G_Find (t, FOFS(targetname), self->target)))
X		{
X			if (t == self)
X			{
X				gi.dprintf ("WARNING: entity used itself.\n");
X			}
X			else
X			{
X				if (t->use)
X				{
X					if (t->health < 0)
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("target_anger with dead monster!\n");
X						return;
X					}
X					t->enemy = target;
X					t->monsterinfo.aiflags |= AI_TARGET_ANGER;
X					FoundTarget (t);
X				}
X			}
X			if (!self->inuse)
X			{
X				gi.dprintf("entity was removed while using targets\n");
X				return;
X			}
X		}
X	}
X
}
X
/*QUAKED target_anger (1 0 0) (-8 -8 -8) (8 8 8)
This trigger will cause an entity to be angry at another entity when a player touches it. Target the
entity you want to anger, and killtarget the entity you want it to be angry at.
X
target - entity to piss off
killtarget - entity to be pissed off at
*/
void SP_target_anger (edict_t *self)
{	
X	if (!self->target)
X	{
X		gi.dprintf("target_anger without target!\n");
X		G_FreeEdict (self);
X		return;
X	}
X	if (!self->killtarget)
X	{
X		gi.dprintf("target_anger without killtarget!\n");
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->use = target_anger_use;
X	self->svflags = SVF_NOCLIENT;
}
X
// ================
// target_spawn
// ================
/*
extern edict_t *CreateMonster(vec3_t origin, vec3_t angles, char *classname);
X
void target_spawn_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t		*newEnt;
X
X	newEnt = CreateMonster (self->s.origin, self->s.angles, "monster_infantry");
X	if(newEnt)
X		newEnt->enemy = other;
}
*/
X
/*Q U AKED target_spawn (1 0 0) (-32 -32 -24) (32 32 72) 
*/
/*
void SP_target_spawn (edict_t *self)
{
X	self->use = target_spawn_use;
X	self->svflags = SVF_NOCLIENT;
}
*/
X
// ***********************************
// target_killplayers
// ***********************************
X
void target_killplayers_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	int		i;
X	edict_t	*ent, *player;
X
X	// kill the players
X	for (i=0 ; i<game.maxclients ; i++)
X	{
X		player = &g_edicts[1+i];
X		if (!player->inuse)
X			continue;
X
X		// nail it
X		T_Damage (player, self, self, vec3_origin, self->s.origin, vec3_origin, 100000, 0, DAMAGE_NO_PROTECTION, MOD_TELEFRAG);
X	}
X
X	// kill any visible monsters
X	for (ent = g_edicts; ent < &g_edicts[globals.num_edicts] ; ent++)
X	{
X		if (!ent->inuse)
X			continue;
X		if (ent->health < 1)
X			continue;
X		if (!ent->takedamage)
X			continue;
X		
X		for(i=0;i<game.maxclients ; i++)
X		{
X			player = &g_edicts[1+i];
X			if(!player->inuse)
X				continue;
X			
X			if(visible(player, ent))
X			{
X				T_Damage (ent, self, self, vec3_origin, ent->s.origin, vec3_origin, 
X							ent->health, 0, DAMAGE_NO_PROTECTION, MOD_TELEFRAG);
X				break;
X			}
X		}
X	}
X
}
X
/*QUAKED target_killplayers (1 0 0) (-8 -8 -8) (8 8 8)
When triggered, this will kill all the players on the map.
*/
void SP_target_killplayers (edict_t *self)
{
X	self->use = target_killplayers_use;
X	self->svflags = SVF_NOCLIENT;
}
X
/*QUAKED target_blacklight (1 0 1) (-16 -16 -24) (16 16 24) 
Pulsing black light with sphere in the center
*/
void blacklight_think (edict_t *self)
{
X	self->s.angles[0] = rand()%360;
X	self->s.angles[1] = rand()%360;
X	self->s.angles[2] = rand()%360;
X	self->nextthink = level.time + 0.1;
}
X
void SP_target_blacklight(edict_t *ent)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (ent);
X		return;
X	}
X
X	VectorClear (ent->mins);
X	VectorClear (ent->maxs);
X
X	ent->s.effects |= (EF_TRACKERTRAIL|EF_TRACKER);
X	ent->think = blacklight_think;
X	ent->s.modelindex = gi.modelindex ("models/items/spawngro2/tris.md2");
X	ent->s.frame = 1;
X	ent->nextthink = level.time + 0.1;
X	gi.linkentity (ent);
}
X
/*QUAKED target_orb (1 0 1) (-16 -16 -24) (16 16 24) 
Translucent pulsing orb with speckles
*/
void orb_think (edict_t *self)
{
X	self->s.angles[0] = rand()%360;
X	self->s.angles[1] = rand()%360;
X	self->s.angles[2] = rand()%360;
//	self->s.effects |= (EF_TRACKERTRAIL|EF_DOUBLE);
X	self->nextthink = level.time + 0.1;
}
X
void SP_target_orb(edict_t *ent)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (ent);
X		return;
X	}
X
X	VectorClear (ent->mins);
X	VectorClear (ent->maxs);
X
//	ent->s.effects |= EF_TRACKERTRAIL;
X	ent->think = orb_think;
X	ent->nextthink = level.time + 0.1;
X	ent->s.modelindex = gi.modelindex ("models/items/spawngro2/tris.md2");
X	ent->s.frame = 2;
X	ent->s.effects |= EF_SPHERETRANS;
X	gi.linkentity (ent);
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_newtarg.c' &&
  chmod 0664 'g_newtarg.c' ||
  $echo 'restore of' 'g_newtarg.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_newtarg.c:' 'MD5 check failed'
4490374da5aa0e0f1bc5529acca38cb0  g_newtarg.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_newtarg.c'`"
    test 8094 -eq "$shar_count" ||
    $echo 'g_newtarg.c:' 'original size' '8094,' 'current size' "$shar_count!"
  fi
fi
# ============= g_newtrig.c ==============
if test -f 'g_newtrig.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_newtrig.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_newtrig.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_newtrig.c' &&
// g_newtrig.c
// pmack
// october 1997
X
#include "g_local.h"
X
#define TELEPORT_PLAYER_ONLY	1
#define TELEPORT_SILENT			2
#define TELEPORT_CTF_ONLY		4
#define TELEPORT_START_ON		8
X
extern void TeleportEffect (vec3_t origin);
X
/*QUAKED info_teleport_destination (.5 .5 .5) (-16 -16 -24) (16 16 32)
Destination marker for a teleporter.
*/
void SP_info_teleport_destination (edict_t *self)
{
}
X
/*QUAKED trigger_teleport (.5 .5 .5) ? player_only silent ctf_only start_on
Any object touching this will be transported to the corresponding 
info_teleport_destination entity. You must set the "target" field, 
and create an object with a "targetname" field that matches.
X
If the trigger_teleport has a targetname, it will only teleport 
entities when it has been fired.
X
player_only: only players are teleported
silent: <not used right now>
ctf_only: <not used right now>
start_on: when trigger has targetname, start active, deactivate when used.
*/
void trigger_teleport_touch(edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t *dest;
X	int		i;
X
X	if(/*(self->spawnflags & TELEPORT_PLAYER_ONLY) &&*/ !(other->client))
X		return;
X
X	if(self->delay)
X		return;
X
X	dest = G_Find (NULL, FOFS(targetname), self->target);
X	if(!dest)
X	{
X		gi.dprintf("Teleport Destination not found!\n");
X		return;
X	}
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_TELEPORT_EFFECT);
X	gi.WritePosition (other->s.origin);
X	gi.multicast (other->s.origin, MULTICAST_PVS);
X
X	// unlink to make sure it can't possibly interfere with KillBox
X	gi.unlinkentity (other);
X
X	VectorCopy (dest->s.origin, other->s.origin);
X	VectorCopy (dest->s.origin, other->s.old_origin);
X	other->s.origin[2] += 10;
X
X	// clear the velocity and hold them in place briefly
X	VectorClear (other->velocity);
X	if(other->client)
X	{
X		other->client->ps.pmove.pm_time = 160>>3;		// hold time
X		other->client->ps.pmove.pm_flags |= PMF_TIME_TELEPORT;
X
X		// draw the teleport splash at source and on the player
//		self->s.event = EV_PLAYER_TELEPORT;
X		other->s.event = EV_PLAYER_TELEPORT;
X
X		// set angles
X		for (i=0 ; i<3 ; i++)
X			other->client->ps.pmove.delta_angles[i] = ANGLE2SHORT(dest->s.angles[i] - other->client->resp.cmd_angles[i]);
X
X		VectorClear (other->client->ps.viewangles);
X		VectorClear (other->client->v_angle);
X	}
X
X
X	VectorClear (other->s.angles);
X
X	// kill anything at the destination
X	KillBox (other);
X
X	gi.linkentity (other);
}
X
void trigger_teleport_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if(self->delay)
X		self->delay = 0;
X	else
X		self->delay = 1;
}
X
void SP_trigger_teleport(edict_t *self)
{
X	if (!self->wait)
X		self->wait = 0.2;
X
X	self->delay = 0;
X		
X	if (self->targetname)
X	{
X		self->use = trigger_teleport_use;
X		if(!(self->spawnflags & TELEPORT_START_ON))
X			self->delay = 1;
X	}
X
X	self->touch = trigger_teleport_touch;
X
X	self->solid = SOLID_TRIGGER;
X	self->movetype = MOVETYPE_NONE;
//	self->flags |= FL_NOCLIENT;
X
X	if (!VectorCompare(self->s.angles, vec3_origin))
X		G_SetMovedir (self->s.angles, self->movedir);
X
X	gi.setmodel (self, self->model);
X	gi.linkentity (self);
}
X
// ***************************
// TRIGGER_DISGUISE
// ***************************
X
/*QUAKED trigger_disguise (.5 .5 .5) ? TOGGLE START_ON REMOVE
Anything passing through this trigger when it is active will
be marked as disguised.
X
TOGGLE - field is turned off and on when used.
START_ON - field is active when spawned.
REMOVE - field removes the disguise
*/
X
void trigger_disguise_touch(edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other->client)
X	{
X		if(self->spawnflags & 4)
X			other->flags &= ~FL_DISGUISED;
X		else
X			other->flags |= FL_DISGUISED;
X	}
}
X
void trigger_disguise_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if(self->solid == SOLID_NOT)
X		self->solid = SOLID_TRIGGER;
X	else
X		self->solid = SOLID_NOT;
X
X	gi.linkentity(self);
}
X
void SP_trigger_disguise (edict_t *self)
{
X	if(self->spawnflags & 2)
X		self->solid = SOLID_TRIGGER;
X	else
X		self->solid = SOLID_NOT;
X
X	self->touch = trigger_disguise_touch;
X	self->use = trigger_disguise_use;
X	self->movetype = MOVETYPE_NONE;
X	self->svflags = SVF_NOCLIENT;
X
X	gi.setmodel (self, self->model);
X	gi.linkentity(self);
X
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_newtrig.c' &&
  chmod 0664 'g_newtrig.c' ||
  $echo 'restore of' 'g_newtrig.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_newtrig.c:' 'MD5 check failed'
082f72d90fc4481a923fbd8ed69aa1de  g_newtrig.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_newtrig.c'`"
    test 4194 -eq "$shar_count" ||
    $echo 'g_newtrig.c:' 'original size' '4194,' 'current size' "$shar_count!"
  fi
fi
# ============= g_newweap.c ==============
if test -f 'g_newweap.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_newweap.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_newweap.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_newweap.c' &&
#include "g_local.h"
X
#define INCLUDE_ETF_RIFLE		1
#define INCLUDE_PROX			1
//#define INCLUDE_FLAMETHROWER	1
//#define INCLUDE_INCENDIARY		1
#define INCLUDE_NUKE			1
#define INCLUDE_MELEE			1
#define INCLUDE_TESLA			1
#define INCLUDE_BEAMS			1
X
extern void check_dodge (edict_t *self, vec3_t start, vec3_t dir, int speed);
extern void hurt_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf);
extern void droptofloor (edict_t *ent);
extern void Grenade_Explode (edict_t *ent);
X
extern void drawbbox (edict_t *ent);
X
#ifdef INCLUDE_ETF_RIFLE
/*
========================
fire_flechette
========================
*/
void flechette_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	vec3_t		dir;
X
X	if (other == self->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (self->client)
X		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
X
X	if (other->takedamage)
X	{
//gi.dprintf("t_damage %s\n", other->classname);
X		T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal,
X			self->dmg, self->dmg_radius, DAMAGE_NO_REG_ARMOR, MOD_ETF_RIFLE);
X	}
X	else
X	{
X		if(!plane)
X			VectorClear (dir);
X		else
X			VectorScale (plane->normal, 256, dir);
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_FLECHETTE);
X		gi.WritePosition (self->s.origin);
X		gi.WriteDir (dir);
X		gi.multicast (self->s.origin, MULTICAST_PVS);
X
//		T_RadiusDamage(self, self->owner, 24, self, 48, MOD_ETF_RIFLE);
X	}
X
X	G_FreeEdict (self);
}
X
void fire_flechette (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int kick)
{
X	edict_t *flechette;
X
X	VectorNormalize (dir);
X
X	flechette = G_Spawn();
X	VectorCopy (start, flechette->s.origin);
X	VectorCopy (start, flechette->s.old_origin);
X	vectoangles2 (dir, flechette->s.angles);
X
X	VectorScale (dir, speed, flechette->velocity);
X	flechette->movetype = MOVETYPE_FLYMISSILE;
X	flechette->clipmask = MASK_SHOT;
X	flechette->solid = SOLID_BBOX;
X	flechette->s.renderfx = RF_FULLBRIGHT;
X	VectorClear (flechette->mins);
X	VectorClear (flechette->maxs);
X	
X	flechette->s.modelindex = gi.modelindex ("models/proj/flechette/tris.md2");
X
//	flechette->s.sound = gi.soundindex ("");			// FIXME - correct sound!
X	flechette->owner = self;
X	flechette->touch = flechette_touch;
X	flechette->nextthink = level.time + 8000/speed;
X	flechette->think = G_FreeEdict;
X	flechette->dmg = damage;
X	flechette->dmg_radius = kick;
X
X	gi.linkentity (flechette);
X	
X	if (self->client)
X		check_dodge (self, flechette->s.origin, dir, speed);
}
#endif
X
// **************************
// PROX
// **************************
X
#ifdef INCLUDE_PROX
#define PROX_TIME_TO_LIVE	45		// 45, 30, 15, 10
#define PROX_TIME_DELAY		0.5
#define PROX_BOUND_SIZE		96
#define PROX_DAMAGE_RADIUS	192
#define PROX_HEALTH			20
#define	PROX_DAMAGE			90
X
//===============
//===============
void Prox_Explode (edict_t *ent)
{
X	vec3_t		origin;
X	edict_t		*owner;
X
// free the trigger field
X
X	//PMM - changed teammaster to "mover" .. owner of the field is the prox
X	if(ent->teamchain && ent->teamchain->owner == ent)
X		G_FreeEdict(ent->teamchain);
X
X	owner = ent;
X	if(ent->teammaster)
X	{
X		owner = ent->teammaster;
X		PlayerNoise(owner, ent->s.origin, PNOISE_IMPACT);
X	}
X
X	// play quad sound if appopriate
X	if (ent->dmg > PROX_DAMAGE)
X		gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
X
X	ent->takedamage = DAMAGE_NO;
X	T_RadiusDamage(ent, owner, ent->dmg, ent, PROX_DAMAGE_RADIUS, MOD_PROX);
X
X	VectorMA (ent->s.origin, -0.02, ent->velocity, origin);
X	gi.WriteByte (svc_temp_entity);
X	if (ent->groundentity)
X		gi.WriteByte (TE_GRENADE_EXPLOSION);
X	else
X		gi.WriteByte (TE_ROCKET_EXPLOSION);
X	gi.WritePosition (origin);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	G_FreeEdict (ent);
}
X
//===============
//===============
void prox_die(edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
//	gi.dprintf("prox_die\n");
X	// if set off by another prox, delay a little (chained explosions)
X	if (strcmp(inflictor->classname, "prox"))
X	{
X		self->takedamage = DAMAGE_NO;
X		Prox_Explode(self);
X	}
X	else
X	{
X		self->takedamage = DAMAGE_NO;
X		self->think = Prox_Explode;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
//===============
//===============
void Prox_Field_Touch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t *prox;
X
X	if (!(other->svflags & SVF_MONSTER) && !other->client)
X		return;
X
X	// trigger the prox mine if it's still there, and still mine.
X	prox = ent->owner;
X
X	if (other == prox) // don't set self off
X		return;
X
X	if (prox->think == Prox_Explode) // we're set to blow!
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("%f - prox already gone off!\n", level.time);
X		return;
X	}
X
X	if(prox->teamchain == ent)
X	{
X		gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/proxwarn.wav"), 1, ATTN_NORM, 0);
X		prox->think = Prox_Explode;
X		prox->nextthink = level.time + PROX_TIME_DELAY;
X		return;
X	}
X
X	ent->solid = SOLID_NOT;
X	G_FreeEdict(ent);
}
X
//===============
//===============
void prox_seek (edict_t *ent)
{
X	if(level.time > ent->wait)
X	{
X		Prox_Explode(ent);
X	}
X	else
X	{
X		ent->s.frame++;
X		if(ent->s.frame > 13)
X			ent->s.frame = 9;
X		ent->think = prox_seek;
X		ent->nextthink = level.time + 0.1;
X	}
}
X
//===============
//===============
void prox_open (edict_t *ent)
{
X	edict_t *search;
X
X	search = NULL;
//	gi.dprintf("prox_open %d\n", ent->s.frame);	
//	gi.dprintf("%f\n", ent->velocity[2]);
X	if(ent->s.frame == 9)	// end of opening animation
X	{
X		// set the owner to NULL so the owner can shoot it, etc.  needs to be done here so the owner
X		// doesn't get stuck on it while it's opening if fired at point blank wall
X		ent->s.sound = 0;
X		ent->owner = NULL;
X		if(ent->teamchain)
X			ent->teamchain->touch = Prox_Field_Touch;
X		while ((search = findradius(search, ent->s.origin, PROX_DAMAGE_RADIUS+10)) != NULL)
X		{
X			if (!search->classname)			// tag token and other weird shit
X				continue;
X
//			if (!search->takedamage)
//				continue;
X			// if it's a monster or player with health > 0
X			// or it's a player start point
X			// and we can see it
X			// blow up
X			if (
X				(
X					(((search->svflags & SVF_MONSTER) || (search->client)) && (search->health > 0))	|| 
X					(
X						(deathmatch->value) && 
X						(
X						(!strcmp(search->classname, "info_player_deathmatch")) ||
X						(!strcmp(search->classname, "info_player_start")) ||
X						(!strcmp(search->classname, "info_player_coop")) ||
X						(!strcmp(search->classname, "misc_teleporter_dest"))
X						)
X					)
X				) 
X				&& (visible (search, ent))
X			   )
X			{
X				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/proxwarn.wav"), 1, ATTN_NORM, 0);
X				Prox_Explode (ent);
X				return;
X			}
X		}
X
X		if (strong_mines && (strong_mines->value))
X			ent->wait = level.time + PROX_TIME_TO_LIVE;
X		else
X		{
X			switch (ent->dmg/PROX_DAMAGE)
X			{
X				case 1:
X					ent->wait = level.time + PROX_TIME_TO_LIVE;
X					break;
X				case 2:
X					ent->wait = level.time + 30;
X					break;
X				case 4:
X					ent->wait = level.time + 15;
X					break;
X				case 8:
X					ent->wait = level.time + 10;
X					break;
X				default:
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("prox with unknown multiplier %d!\n", ent->dmg/PROX_DAMAGE);
X					ent->wait = level.time + PROX_TIME_TO_LIVE;
X					break;
X			}
X		}
X
//		ent->wait = level.time + PROX_TIME_TO_LIVE;
X		ent->think = prox_seek;
X		ent->nextthink = level.time + 0.2;
X	}
X	else
X	{
X		if (ent->s.frame == 0)
X			gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/proxopen.wav"), 1, ATTN_NORM, 0);
X		//ent->s.sound = gi.soundindex ("weapons/proxopen.wav");
X		ent->s.frame++;
X		ent->think = prox_open;
X		ent->nextthink = level.time + 0.05;	
X	}
}
X
//===============
//===============
void prox_land (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t	*field;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X	int		makeslave = 0;
X	int		movetype = MOVETYPE_NONE;
X	int		stick_ok = 0;
X	vec3_t	land_point;
X
X	// must turn off owner so owner can shoot it and set it off
X	// moved to prox_open so owner can get away from it if fired at pointblank range into
X	// wall
//	ent->owner = NULL;
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("land - %2.2f %2.2f %2.2f\n", ent->velocity[0], ent->velocity[1], ent->velocity[2]);
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict(ent);
X		return;
X	}
X
X	if (plane->normal)
X	{
X		VectorMA (ent->s.origin, -10.0, plane->normal, land_point);
X		if (gi.pointcontents (land_point) & (CONTENTS_SLIME|CONTENTS_LAVA))
X		{
X			Prox_Explode (ent);
X			return;
X		}
X	}
X
X	if ((other->svflags & SVF_MONSTER) || other->client || (other->svflags & SVF_DAMAGEABLE))
X	{
X		if(other != ent->teammaster)
X			Prox_Explode(ent);
X
X		return;
X	}
X
#define STOP_EPSILON	0.1
X
X	else if (other != world)
X	{
X		//Here we need to check to see if we can stop on this entity.
X		//Note that plane can be NULL
X
X		//PMM - code stolen from g_phys (ClipVelocity)
X		vec3_t out;
X		float backoff, change;
X		int i;
X
X		if (!plane->normal) // this happens if you hit a point object, maybe other cases
X		{
X			// Since we can't tell what's going to happen, just blow up
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("bad normal for surface, exploding!\n");
X
X			Prox_Explode(ent);
X			return;
X		}
X
X		if ((other->movetype == MOVETYPE_PUSH) && (plane->normal[2] > 0.7))
X			stick_ok = 1;
X		else
X			stick_ok = 0;
X
X		backoff = DotProduct (ent->velocity, plane->normal) * 1.5;
X		for (i=0 ; i<3 ; i++)
X		{
X			change = plane->normal[i]*backoff;
X			out[i] = ent->velocity[i] - change;
X			if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
X				out[i] = 0;
X		}
X
X		if (out[2] > 60)
X			return;
X
X		movetype = MOVETYPE_BOUNCE;
X
X		// if we're here, we're going to stop on an entity
X		if (stick_ok)
X		{ // it's a happy entity
X			VectorCopy (vec3_origin, ent->velocity);
X			VectorCopy (vec3_origin, ent->avelocity);
X		}
X		else // no-stick.  teflon time
X		{
X			if (plane->normal[2] > 0.7)
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("stuck on entity, blowing up!\n");
X
X				Prox_Explode(ent);
X				return;
X			}
X			return;
X		}
X	}
X	else if (other->s.modelindex != 1)
X		return;
X
X	vectoangles2 (plane->normal, dir);
X	AngleVectors (dir, forward, right, up);
X
X	if (gi.pointcontents (ent->s.origin) & (CONTENTS_LAVA|CONTENTS_SLIME))
X	{
X		Prox_Explode (ent);
X		return;
X	}
X
X	field = G_Spawn();
X
X	VectorCopy (ent->s.origin, field->s.origin);
X	VectorClear(field->velocity);
X	VectorClear(field->avelocity);
X	VectorSet(field->mins, -PROX_BOUND_SIZE, -PROX_BOUND_SIZE, -PROX_BOUND_SIZE);
X	VectorSet(field->maxs, PROX_BOUND_SIZE, PROX_BOUND_SIZE, PROX_BOUND_SIZE);
X	field->movetype = MOVETYPE_NONE;
X	field->solid = SOLID_TRIGGER;
X	field->owner = ent;
X	field->classname = "prox_field";
X	field->teammaster = ent;
X	gi.linkentity (field);
X
X	VectorClear(ent->velocity);
X	VectorClear(ent->avelocity);
X	// rotate to vertical
X	dir[PITCH] = dir[PITCH] + 90;
X	VectorCopy (dir, ent->s.angles);
X	ent->takedamage = DAMAGE_AIM;
X	ent->movetype = movetype;		// either bounce or none, depending on whether we stuck to something
X	ent->die = prox_die;
X	ent->teamchain = field;
X	ent->health = PROX_HEALTH;
X	ent->nextthink = level.time + 0.05;
X	ent->think = prox_open;
X	ent->touch = NULL;
X	ent->solid = SOLID_BBOX;
X	// record who we're attached to
//	ent->teammaster = other;
X
X	gi.linkentity(ent);
}
X
//===============
//===============
void fire_prox (edict_t *self, vec3_t start, vec3_t aimdir, int damage_multiplier, int speed)
{
X	edict_t	*prox;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("start %s    aim %s   speed %d\n", vtos(start), vtos(aimdir), speed);
X	prox = G_Spawn();
X	VectorCopy (start, prox->s.origin);
X	VectorScale (aimdir, speed, prox->velocity);
X	VectorMA (prox->velocity, 200 + crandom() * 10.0, up, prox->velocity);
X	VectorMA (prox->velocity, crandom() * 10.0, right, prox->velocity);
X	VectorCopy (dir, prox->s.angles);
X	prox->s.angles[PITCH]-=90;
X	prox->movetype = MOVETYPE_BOUNCE;
X	prox->solid = SOLID_BBOX; 
X	prox->s.effects |= EF_GRENADE;
X	prox->clipmask = MASK_SHOT|CONTENTS_LAVA|CONTENTS_SLIME;
X	prox->s.renderfx |= RF_IR_VISIBLE;
X	//FIXME - this needs to be bigger.  Has other effects, though.  Maybe have to change origin to compensate
X	// so it sinks in correctly.  Also in lavacheck, might have to up the distance
X	VectorSet (prox->mins, -6, -6, -6);
X	VectorSet (prox->maxs, 6, 6, 6);
X	prox->s.modelindex = gi.modelindex ("models/weapons/g_prox/tris.md2");
X	prox->owner = self;
X	prox->teammaster = self;
X	prox->touch = prox_land;
//	prox->nextthink = level.time + PROX_TIME_TO_LIVE;
X	prox->think = Prox_Explode;
X	prox->dmg = PROX_DAMAGE*damage_multiplier;
X	prox->classname = "prox";
X	prox->svflags |= SVF_DAMAGEABLE;
X	prox->flags |= FL_MECHANICAL;
X
X	switch (damage_multiplier)
X	{
X	case 1:
X		prox->nextthink = level.time + PROX_TIME_TO_LIVE;
X		break;
X	case 2:
X		prox->nextthink = level.time + 30;
X		break;
X	case 4:
X		prox->nextthink = level.time + 15;
X		break;
X	case 8:
X		prox->nextthink = level.time + 10;
X		break;
X	default:
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("prox with unknown multiplier %d!\n", damage_multiplier);
X		prox->nextthink = level.time + PROX_TIME_TO_LIVE;
X		break;
X	}
X
X	gi.linkentity (prox);
}
#endif
X
// *************************
// FLAMETHROWER
// *************************
X
#ifdef INCLUDE_FLAMETHROWER
#define FLAMETHROWER_RADIUS		8
X
void fire_remove (edict_t *ent)
{
X	if(ent == ent->owner->teamchain)
X		ent->owner->teamchain = NULL;
X
X	G_FreeEdict(ent);	
}
X
void fire_flame (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed)
{
X	edict_t *flame;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	flame = G_Spawn();
X
X	// the origin is the first control point, put it speed forward.
X	VectorMA(start, speed, forward, flame->s.origin);
X
X	// record that velocity
X	VectorScale (aimdir, speed, flame->velocity);
X
X	VectorCopy (dir, flame->s.angles);
X	flame->movetype = MOVETYPE_NONE;
X	flame->solid = SOLID_NOT;
X
X	VectorSet(flame->mins, -FLAMETHROWER_RADIUS, -FLAMETHROWER_RADIUS, -FLAMETHROWER_RADIUS);
X	VectorSet(flame->maxs, FLAMETHROWER_RADIUS, FLAMETHROWER_RADIUS, FLAMETHROWER_RADIUS);
X
X	flame->s.sound = gi.soundindex ("weapons/flame.wav");
X	flame->owner = self;
X	flame->dmg = damage;
X	flame->classname = "flame";
X
X	// clear control points and velocities
X	VectorCopy (flame->s.origin, flame->flameinfo.pos1);
X	VectorCopy (flame->velocity, flame->flameinfo.vel1);
X	VectorCopy (flame->s.origin, flame->flameinfo.pos2);
X	VectorCopy (flame->velocity, flame->flameinfo.vel2);
X	VectorCopy (flame->s.origin, flame->flameinfo.pos3);
X	VectorCopy (flame->velocity, flame->flameinfo.vel3);
X	VectorCopy (flame->s.origin, flame->flameinfo.pos4);
X
X	// hook flame stream to owner
X	self->teamchain = flame;
X
X	gi.linkentity (flame);
}
X
// fixme - change to use start location, not entity origin
void fire_maintain (edict_t *ent, edict_t *flame, vec3_t start, vec3_t aimdir, int damage, int speed)
{
X	trace_t	tr;
X
X	// move the control points out the appropriate direction and velocity
X	VectorAdd(flame->flameinfo.pos3, flame->flameinfo.vel3, flame->flameinfo.pos4);
X	VectorAdd(flame->flameinfo.pos2, flame->flameinfo.vel2, flame->flameinfo.pos3);
X	VectorAdd(flame->flameinfo.pos1, flame->flameinfo.vel1, flame->flameinfo.pos2);
X	VectorAdd(flame->s.origin,		 flame->velocity,       flame->flameinfo.pos1);
X
X	// move the velocities for the control points
X	VectorCopy(flame->flameinfo.vel2, flame->flameinfo.vel3);
X	VectorCopy(flame->flameinfo.vel1, flame->flameinfo.vel2);
X	VectorCopy(flame->velocity,		  flame->flameinfo.vel1);
X
X	// set velocity and location for new control point 0.
X	VectorMA(start, speed, aimdir, flame->s.origin);
X	VectorScale(aimdir, speed, flame->velocity);
X	
X	//
X	// does it hit a wall? if so, when?
X	//
X
X	// player fire point to flame origin.
X	tr = gi.trace(start, flame->mins, flame->maxs,
X					flame->s.origin, flame, MASK_SHOT);
X	if(tr.fraction == 1.0)
X	{
X		// origin to point 1
X		tr = gi.trace(flame->s.origin, flame->mins, flame->maxs,
X						flame->flameinfo.pos1, flame, MASK_SHOT);
X		if(tr.fraction == 1.0)
X		{
X			// point 1 to point 2
X			tr = gi.trace(flame->flameinfo.pos1, flame->mins, flame->maxs,
X							flame->flameinfo.pos2, flame, MASK_SHOT);
X			if(tr.fraction == 1.0)
X			{
X				// point 2 to point 3
X				tr = gi.trace(flame->flameinfo.pos2, flame->mins, flame->maxs,
X							flame->flameinfo.pos3, flame, MASK_SHOT);
X				if(tr.fraction == 1.0)
X				{
X					// point 3 to point 4, point 3 valid
X					tr = gi.trace(flame->flameinfo.pos3, flame->mins, flame->maxs,
X								flame->flameinfo.pos4, flame, MASK_SHOT);
X					if(tr.fraction < 1.0) // point 4 blocked
X					{
X						VectorCopy(tr.endpos, flame->flameinfo.pos4);
X					}
X				}
X				else	// point 3 blocked, point 2 valid
X				{
X					VectorCopy(flame->flameinfo.vel2, flame->flameinfo.vel3);
X					VectorCopy(tr.endpos, flame->flameinfo.pos3);
X					VectorCopy(tr.endpos, flame->flameinfo.pos4);
X				}
X			}
X			else	// point 2 blocked, point 1 valid
X			{
X				VectorCopy(flame->flameinfo.vel1, flame->flameinfo.vel2);
X				VectorCopy(flame->flameinfo.vel1, flame->flameinfo.vel3);
X				VectorCopy(tr.endpos, flame->flameinfo.pos2);
X				VectorCopy(tr.endpos, flame->flameinfo.pos3);
X				VectorCopy(tr.endpos, flame->flameinfo.pos4);
X			}
X		}
X		else	// point 1 blocked, origin valid
X		{
X			VectorCopy(flame->velocity, flame->flameinfo.vel1);
X			VectorCopy(flame->velocity, flame->flameinfo.vel2);
X			VectorCopy(flame->velocity, flame->flameinfo.vel3);
X			VectorCopy(tr.endpos, flame->flameinfo.pos1);
X			VectorCopy(tr.endpos, flame->flameinfo.pos2);
X			VectorCopy(tr.endpos, flame->flameinfo.pos3);
X			VectorCopy(tr.endpos, flame->flameinfo.pos4);
X		}
X	}
X	else // origin blocked!
X	{
//		gi.dprintf("point 2 blocked\n");
X		VectorCopy(flame->velocity, flame->flameinfo.vel1);
X		VectorCopy(flame->velocity, flame->flameinfo.vel2);
X		VectorCopy(flame->velocity, flame->flameinfo.vel3);
X		VectorCopy(tr.endpos, flame->s.origin);
X		VectorCopy(tr.endpos, flame->flameinfo.pos1);
X		VectorCopy(tr.endpos, flame->flameinfo.pos2);
X		VectorCopy(tr.endpos, flame->flameinfo.pos3);
X		VectorCopy(tr.endpos, flame->flameinfo.pos4);
X	}
X	
X	if(tr.fraction < 1.0 && tr.ent->takedamage)
X	{
X		T_Damage (tr.ent, flame, ent, flame->velocity, tr.endpos, tr.plane.normal, 
X					damage, 0, DAMAGE_NO_KNOCKBACK | DAMAGE_ENERGY | DAMAGE_FIRE);
X	}
X
X	gi.linkentity(flame);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_FLAME);
X	gi.WriteShort(ent - g_edicts);
X	gi.WriteShort(6);
X	gi.WritePosition (start);
X	gi.WritePosition (flame->s.origin);
X	gi.WritePosition (flame->flameinfo.pos1);
X	gi.WritePosition (flame->flameinfo.pos2);
X	gi.WritePosition (flame->flameinfo.pos3);
X	gi.WritePosition (flame->flameinfo.pos4);
X	gi.multicast (flame->s.origin, MULTICAST_PVS);
}
X
/*QUAKED trap_flameshooter (1 0 0) (-8 -8 -8) (8 8 8)
*/
#define FLAMESHOOTER_VELOCITY			50
#define FLAMESHOOTER_DAMAGE				20
#define FLAMESHOOTER_BURST_VELOCITY		300
#define FLAMESHOOTER_BURST_DAMAGE		30
X
//#define FLAMESHOOTER_PUFF	1
#define FLAMESHOOTER_STREAM	1
X
void flameshooter_think (edict_t *self)
{
X	vec3_t	forward, right, up;
X	edict_t *flame;
X	
X	if(self->delay)
X	{
X		if(self->teamchain)
X			fire_remove (self->teamchain);
X		return;
X	}
X
X	self->s.angles[1] += self->speed;
X	if(self->s.angles[1] > 135 || self->s.angles[1] < 45)
X		self->speed = -self->speed;
X		 
X	AngleVectors (self->s.angles, forward, right, up);
X
#ifdef FLAMESHOOTER_STREAM
X	flame = self->teamchain;
X	if(!self->teamchain)
X		fire_flame (self, self->s.origin, forward, FLAMESHOOTER_DAMAGE, FLAMESHOOTER_VELOCITY);
X	else
X		fire_maintain (self, flame, self->s.origin, forward, FLAMESHOOTER_DAMAGE, FLAMESHOOTER_VELOCITY);
X
X	self->think = flameshooter_think;
X	self->nextthink = level.time + 0.05;
#else
X	fire_burst (self, self->s.origin, forward, FLAMESHOOTER_BURST_DAMAGE, FLAMESHOOTER_BURST_VELOCITY);
X	
X	self->think = flameshooter_think;
X	self->nextthink = level.time + 0.1;
#endif
}
X
void flameshooter_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if(self->delay)
X	{
X		self->delay = 0;
X		self->think = flameshooter_think;
X		self->nextthink = level.time + 0.1;
X	}	
X	else
X		self->delay = 1;
}
X
void SP_trap_flameshooter(edict_t *self)
{
X	vec3_t	tempAngles;
X
X	self->solid = SOLID_NOT;
X	self->movetype = MOVETYPE_NONE;
X
X	self->delay = 0;
X
X	self->use =	flameshooter_use;
X	if(self->delay == 0)
X	{
X		self->think = flameshooter_think;
X		self->nextthink = level.time  + 0.1;
X	}
X
//	self->flags |= FL_NOCLIENT;
X
X	self->speed = 10;
X
//	self->speed = 0;	// FIXME this stops the spraying
X
X	VectorCopy(self->s.angles, tempAngles);
X
X	if (!VectorCompare(self->s.angles, vec3_origin))
X		G_SetMovedir (self->s.angles, self->movedir);
X
X	VectorCopy(tempAngles, self->s.angles);
X
//	gi.setmodel (self, self->model);
X	gi.linkentity (self);
}
X
// *************************
// fire_burst
// *************************
X
#define FLAME_BURST_MAX_SIZE	64
#define FLAME_BURST_FRAMES		20
#define FLAME_BURST_MIDPOINT	10
X
void fire_burst_touch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	int		powerunits;
X	int		damage, radius;
X	vec3_t	origin;
X	
X	if (surf && (surf->flags & SURF_SKY))
X	{
//		gi.dprintf("Hit sky. Removed\n");
X		G_FreeEdict (ent);
X		return;
X	}
X
X	if(other == ent->owner || ent == other)
X		return;
X
X	// don't let flame puffs blow each other up
X	if(other->classname && !strcmp(other->classname, ent->classname))
X		return;
X
X	if(ent->waterlevel)
X	{
//		gi.dprintf("Hit water. Removed\n");
X		G_FreeEdict(ent);		
X	}
X
X	if(!(other->svflags & SVF_MONSTER) && !other->client)
X	{
X		powerunits = FLAME_BURST_FRAMES - ent->s.frame;
X		damage = powerunits * 6;
X		radius = powerunits * 4;
X
//		T_RadiusDamage (inflictor, attacker, damage, ignore, radius)
X		T_RadiusDamage(ent, ent->owner, damage, ent, radius, DAMAGE_FIRE);
X
//		gi.dprintf("Hit world: %d pts, %d rad\n", damage, radius);
X
X		// calculate position for the explosion entity
X		VectorMA (ent->s.origin, -0.02, ent->velocity, origin);
X
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_PLAIN_EXPLOSION);
X		gi.WritePosition (origin);
X		gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X		G_FreeEdict (ent);
X	}
}
X
void fire_burst_think (edict_t *self)
{
X	int	current_radius;
X
X	if(self->waterlevel)
X	{
X		G_FreeEdict(self);
X		return;
X	}
X
X	self->s.frame++;
X	if(self->s.frame >= FLAME_BURST_FRAMES)
X	{
X		G_FreeEdict(self);
X		return;
X	}
X
X	else if(self->s.frame < FLAME_BURST_MIDPOINT)
X	{
X		current_radius = (FLAME_BURST_MAX_SIZE / FLAME_BURST_MIDPOINT) * self->s.frame;
X	}
X	else
X	{
X		current_radius = (FLAME_BURST_MAX_SIZE / FLAME_BURST_MIDPOINT) * (FLAME_BURST_FRAMES - self->s.frame);
X	}
X
X	if(self->s.frame == 3)
X		self->s.skinnum = 1;
X	else if (self->s.frame == 7)
X		self->s.skinnum = 2;
X	else if (self->s.frame == 10)
X		self->s.skinnum = 3;
X	else if (self->s.frame == 13)
X		self->s.skinnum = 4;
X	else if (self->s.frame == 16)
X		self->s.skinnum = 5;
X	else if (self->s.frame == 19)
X		self->s.skinnum = 6;
X
X	if(current_radius < 8)
X		current_radius = 8;
X	else if(current_radius > FLAME_BURST_MAX_SIZE)
X		current_radius = FLAME_BURST_MAX_SIZE;
X
X	T_RadiusDamage(self, self->owner, self->dmg, self, current_radius, DAMAGE_FIRE);
X
X	self->think = fire_burst_think;
X	self->nextthink = level.time + 0.1;
}
X
void fire_burst (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed)
{
X	edict_t *flame;
X	vec3_t	dir;
X	vec3_t	baseVel;
X	vec3_t	forward, right, up;
X
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	flame = G_Spawn();
X	VectorCopy(start, flame->s.origin);
//	VectorScale (aimdir, speed, flame->velocity);
X
X	// scale down so only 30% of player's velocity is taken into account.
X	VectorScale (self->velocity, 0.3, baseVel);
X	VectorMA(baseVel, speed, aimdir, flame->velocity);
X
X	VectorCopy (dir, flame->s.angles);
X	flame->movetype = MOVETYPE_FLY;
X	flame->solid = SOLID_TRIGGER;
X
X	VectorSet(flame->mins, -FLAMETHROWER_RADIUS, -FLAMETHROWER_RADIUS, -FLAMETHROWER_RADIUS);
X	VectorSet(flame->maxs, FLAMETHROWER_RADIUS, FLAMETHROWER_RADIUS, FLAMETHROWER_RADIUS);
X
X	flame->s.sound = gi.soundindex ("weapons/flame.wav");
X	flame->s.modelindex = gi.modelindex ("models/projectiles/puff/tris.md2");
X	flame->owner = self;
X	flame->touch = fire_burst_touch;
X	flame->think = fire_burst_think;
X	flame->nextthink = level.time + 0.1;
X	flame->dmg = damage;
X	flame->classname = "flameburst";
X	flame->s.effects = EF_FIRE_PUFF;
X
X	gi.linkentity (flame);
}
#endif
X
// *************************
//	INCENDIARY GRENADES
// *************************
X
#ifdef INCLUDE_INCENDIARY
void FireThink (edict_t *ent)
{
X	if(level.time > ent->wait)
X		G_FreeEdict(ent);
X	else
X	{
X		ent->s.frame++;
X		if(ent->s.frame>10)
X			ent->s.frame = 0;
X		ent->nextthink = level.time + 0.05;
X		ent->think = FireThink;
X	}
}
X
#define FIRE_HEIGHT		64
#define FIRE_RADIUS		64
#define FIRE_DAMAGE		3
#define FIRE_DURATION	15
X
edict_t *StartFire(edict_t *fireOwner, vec3_t fireOrigin, float fireDuration, float fireDamage)
{
X	edict_t	*fire;
X
X	fire = G_Spawn();
X	VectorCopy (fireOrigin, fire->s.origin);
X	fire->movetype = MOVETYPE_TOSS;
X	fire->solid = SOLID_TRIGGER;
X	VectorSet(fire->mins, -FIRE_RADIUS, -FIRE_RADIUS, 0);
X	VectorSet(fire->maxs, FIRE_RADIUS, FIRE_RADIUS, FIRE_HEIGHT);
X
X	fire->s.sound = gi.soundindex ("weapons/incend.wav");
X	fire->s.modelindex = gi.modelindex ("models/objects/fire/tris.md2");
X
X	fire->owner = fireOwner;
X	fire->touch = hurt_touch;
X	fire->nextthink = level.time + 0.05;
X	fire->wait = level.time + fireDuration;
X	fire->think = FireThink;
//	fire->nextthink = level.time + fireDuration;
//	fire->think = G_FreeEdict;
X	fire->dmg = fireDamage;
X	fire->classname = "incendiary_fire";
X	
X	gi.linkentity (fire);
X
//	gi.sound (fire, CHAN_VOICE, gi.soundindex ("weapons/incend.wav"), 1, ATTN_NORM, 0);
X	return fire;
}
X
static void Incendiary_Explode (edict_t *ent)
{
X	vec3_t		origin;
X
X	if (ent->owner->client)
X		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
X
X	//FIXME: if we are onground then raise our Z just a bit since we are a point?
X	T_RadiusDamage(ent, ent->owner, ent->dmg, NULL, ent->dmg_radius, DAMAGE_FIRE);
X
X	VectorMA (ent->s.origin, -0.02, ent->velocity, origin);
X	gi.WriteByte (svc_temp_entity);
X	if (ent->groundentity)
X		gi.WriteByte (TE_GRENADE_EXPLOSION);
X	else
X		gi.WriteByte (TE_ROCKET_EXPLOSION);
X	gi.WritePosition (origin);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	StartFire(ent->owner, ent->s.origin, FIRE_DURATION, FIRE_DAMAGE);
X
X	G_FreeEdict (ent);
X
}
X
static void Incendiary_Touch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other == ent->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (ent);
X		return;
X	}
X
X	if (!(other->svflags & SVF_MONSTER) && !(ent->client))
//	if (!other->takedamage)
X	{
X		if (ent->spawnflags & 1)
X		{
X			if (random() > 0.5)
X				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb1a.wav"), 1, ATTN_NORM, 0);
X			else
X				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb2a.wav"), 1, ATTN_NORM, 0);
X		}
X		else
X		{
X			if (random() > 0.5)
X				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/grenlb1b.wav"), 1, ATTN_NORM, 0);
X			else
X				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/grenlb2b.wav"), 1, ATTN_NORM, 0);
X		}
X		return;
X	}
X
X	Incendiary_Explode (ent);
}
X
void fire_incendiary_grenade (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, float timer, float damage_radius)
{
X	edict_t	*grenade;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	grenade = G_Spawn();
X	VectorCopy (start, grenade->s.origin);
X	VectorScale (aimdir, speed, grenade->velocity);
X	VectorMA (grenade->velocity, 200 + crandom() * 10.0, up, grenade->velocity);
X	VectorMA (grenade->velocity, crandom() * 10.0, right, grenade->velocity);
X	VectorSet (grenade->avelocity, 300, 300, 300);
X	grenade->movetype = MOVETYPE_BOUNCE;
X	grenade->clipmask = MASK_SHOT;
X	grenade->solid = SOLID_BBOX;
X	grenade->s.effects |= EF_GRENADE;
//	if (self->client)
//		grenade->s.effects &= ~EF_TELEPORT;
X	VectorClear (grenade->mins);
X	VectorClear (grenade->maxs);
X	grenade->s.modelindex = gi.modelindex ("models/projectiles/incend/tris.md2");
X	grenade->owner = self;
X	grenade->touch = Incendiary_Touch;
X	grenade->nextthink = level.time + timer;
X	grenade->think = Incendiary_Explode;
X	grenade->dmg = damage;
X	grenade->dmg_radius = damage_radius;
X	grenade->classname = "incendiary_grenade";
X
X	gi.linkentity (grenade);
}
#endif
X
// *************************
// MELEE WEAPONS
// *************************
X
#ifdef INCLUDE_MELEE
void fire_player_melee (edict_t *self, vec3_t start, vec3_t aim, int reach, int damage, int kick, int quiet, int mod)
{
X	vec3_t		forward, right, up;
X	vec3_t		v;
X	vec3_t		point;
X	trace_t		tr;
X
X	vectoangles2 (aim, v);
X	AngleVectors (v, forward, right, up);
X	VectorNormalize (forward);
X	VectorMA( start, reach, forward, point);
X
X	//see if the hit connects
X	tr = gi.trace(start, NULL, NULL, point, self, MASK_SHOT);
X	if(tr.fraction ==  1.0)
X	{
X		if(!quiet)
X			gi.sound (self, CHAN_WEAPON, gi.soundindex ("weapons/swish.wav"), 1, ATTN_NORM, 0);
X		//FIXME some sound here?
X		return;
X	}
X
X	if(tr.ent->takedamage == DAMAGE_YES || tr.ent->takedamage == DAMAGE_AIM)
X	{
X		// pull the player forward if you do damage
X		VectorMA(self->velocity, 75, forward, self->velocity);
X		VectorMA(self->velocity, 75, up, self->velocity);
X
X		// do the damage
X		// FIXME - make the damage appear at right spot and direction
X		if(mod == MOD_CHAINFIST)
X			T_Damage (tr.ent, self, self, vec3_origin, tr.ent->s.origin, vec3_origin, damage, kick/2, 
X						DAMAGE_DESTROY_ARMOR | DAMAGE_NO_KNOCKBACK, mod);
X		else
X			T_Damage (tr.ent, self, self, vec3_origin, tr.ent->s.origin, vec3_origin, damage, kick/2, DAMAGE_NO_KNOCKBACK, mod);
X
X		if(!quiet)
X			gi.sound (self, CHAN_WEAPON, gi.soundindex ("weapons/meatht.wav"), 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		if(!quiet)
X			gi.sound (self, CHAN_WEAPON, gi.soundindex ("weapons/tink1.wav"), 1, ATTN_NORM, 0);
X
X		VectorScale (tr.plane.normal, 256, point);
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_GUNSHOT);
X		gi.WritePosition (tr.endpos);
X		gi.WriteDir (point);
X		gi.multicast (tr.endpos, MULTICAST_PVS);
X	}
}
#endif
X
// *************************
// NUKE 
// *************************
X
#ifdef INCLUDE_NUKE
#define	NUKE_DELAY			4
#define NUKE_TIME_TO_LIVE	6
//#define NUKE_TIME_TO_LIVE	40
#define NUKE_RADIUS			512
#define NUKE_DAMAGE			400
#define	NUKE_QUAKE_TIME		3
#define NUKE_QUAKE_STRENGTH	100
X
void Nuke_Quake (edict_t *self)
{
X	int		i;
X	edict_t	*e;
X
X	if (self->last_move_time < level.time)
X	{
X		gi.positioned_sound (self->s.origin, self, CHAN_AUTO, self->noise_index, 0.75, ATTN_NONE, 0);
X		self->last_move_time = level.time + 0.5;
X	}
X
X	for (i=1, e=g_edicts+i; i < globals.num_edicts; i++,e++)
X	{
X		if (!e->inuse)
X			continue;
X		if (!e->client)
X			continue;
X		if (!e->groundentity)
X			continue;
X
X		e->groundentity = NULL;
X		e->velocity[0] += crandom()* 150;
X		e->velocity[1] += crandom()* 150;
X		e->velocity[2] = self->speed * (100.0 / e->mass);
X	}
X
X	if (level.time < self->timestamp)
X		self->nextthink = level.time + FRAMETIME;
X	else
X		G_FreeEdict (self);
}
X
X
static void Nuke_Explode (edict_t *ent)
{
//	vec3_t		origin;
X
//	nuke_framenum = level.framenum + 20;
X
X	if (ent->teammaster->client)
X		PlayerNoise(ent->teammaster, ent->s.origin, PNOISE_IMPACT);
X
X	T_RadiusNukeDamage(ent, ent->teammaster, ent->dmg, ent, ent->dmg_radius, MOD_NUKE);
X
//	VectorMA (ent->s.origin, -0.02, ent->velocity, origin);
X	if (ent->dmg > NUKE_DAMAGE)
X		gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
X
X	gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, gi.soundindex ("weapons/grenlx1a.wav"), 1, ATTN_NONE, 0);
/*
X	gi.WriteByte (svc_temp_entity);
X	if (ent->groundentity)
X		gi.WriteByte (TE_GRENADE_EXPLOSION);
X	else
X		gi.WriteByte (TE_ROCKET_EXPLOSION);
X	gi.WritePosition (origin);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
*/
X
X	//	BecomeExplosion1(ent);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1_BIG);
X	gi.WritePosition (ent->s.origin);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_NUKEBLAST);
X	gi.WritePosition (ent->s.origin);
X	gi.multicast (ent->s.origin, MULTICAST_ALL);
X
X	// become a quake
X	ent->svflags |= SVF_NOCLIENT;
X	ent->noise_index = gi.soundindex ("world/rumble.wav");
X	ent->think = Nuke_Quake;
X	ent->speed = NUKE_QUAKE_STRENGTH;
X	ent->timestamp = level.time + NUKE_QUAKE_TIME;
X	ent->nextthink = level.time + FRAMETIME;
X	ent->last_move_time = 0;
}
X
void nuke_die(edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	self->takedamage = DAMAGE_NO;
X	if ((attacker) && !(strcmp(attacker->classname, "nuke")))
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("nuke nuked by a nuke, not nuking\n");
X		G_FreeEdict (self);	
X		return;
X	}
X	Nuke_Explode(self);
}
X
void Nuke_Think(edict_t *ent)
{
X	float attenuation, default_atten = 1.8;
X	int		damage_multiplier, muzzleflash;
X
//	gi.dprintf ("player range: %2.2f    damage radius: %2.2f\n", realrange (ent, ent->teammaster), ent->dmg_radius*2);
X
X	damage_multiplier = ent->dmg/NUKE_DAMAGE;
X	switch (damage_multiplier)
X	{
X	case 1:
X		attenuation = default_atten/1.4;
X		muzzleflash = MZ_NUKE1;
X		break;
X	case 2:
X		attenuation = default_atten/2.0;
X		muzzleflash = MZ_NUKE2;
X		break;
X	case 4:
X		attenuation = default_atten/3.0;
X		muzzleflash = MZ_NUKE4;
X		break;
X	case 8:
X		attenuation = default_atten/5.0;
X		muzzleflash = MZ_NUKE8;
X		break;
X	default:
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("default attenuation used for nuke!\n");
X		attenuation = default_atten;
X		muzzleflash = MZ_NUKE1;
X		break;
X	}
X
X	if(ent->wait < level.time)
X		Nuke_Explode(ent);
X	else if (level.time >= (ent->wait - NUKE_TIME_TO_LIVE))
X	{
X		ent->s.frame++;
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("nuke frame %d\n", ent->s.frame);
X		if(ent->s.frame > 11)
X			ent->s.frame = 6;
X
X		if (gi.pointcontents (ent->s.origin) & (CONTENTS_SLIME|CONTENTS_LAVA))
X		{
X			Nuke_Explode (ent);
X			return;
X		}
X
X		ent->think = Nuke_Think;
X		ent->nextthink = level.time + 0.1;
X		ent->health = 1;
X		ent->owner = NULL;
X
X		gi.WriteByte (svc_muzzleflash);
X		gi.WriteShort (ent-g_edicts);
X		gi.WriteByte (muzzleflash);
X		gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X		if (ent->timestamp <= level.time)
X		{
/*			gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/nukewarn.wav"), 1, ATTN_NORM, 0);
X			ent->timestamp += 10.0;
X		}
*/		
X
X			if ((ent->wait - level.time) <= (NUKE_TIME_TO_LIVE/2.0))
X			{
//				ent->s.sound = gi.soundindex ("weapons/nukewarn.wav");
//				gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, gi.soundindex ("weapons/nukewarn2.wav"), 1, ATTN_NORM, 0);
X				gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, gi.soundindex ("weapons/nukewarn2.wav"), 1, attenuation, 0);
//				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/nukewarn2.wav"), 1, ATTN_NORM, 0);
//				gi.dprintf ("time %2.2f\n", ent->wait-level.time);
X				ent->timestamp = level.time + 0.3;
X			}
X			else
X			{
X				gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, gi.soundindex ("weapons/nukewarn2.wav"), 1, attenuation, 0);
//				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/nukewarn2.wav"), 1, ATTN_NORM, 0);
X				ent->timestamp = level.time + 0.5;
//				gi.dprintf ("time %2.2f\n", ent->wait-level.time);
X			}
X		}
X	}
X	else
X	{
X		if (ent->timestamp <= level.time)
X		{
X			gi.sound (ent, CHAN_NO_PHS_ADD+CHAN_VOICE, gi.soundindex ("weapons/nukewarn2.wav"), 1, attenuation, 0);
//			gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/nukewarn2.wav"), 1, ATTN_NORM, 0);
//				gi.dprintf ("time %2.2f\n", ent->wait-level.time);
X			ent->timestamp = level.time + 1.0;
X		}
X		ent->nextthink = level.time + FRAMETIME;
X	}
}
X
void nuke_bounce (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (random() > 0.5)
X		gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb1a.wav"), 1, ATTN_NORM, 0);
X	else
X		gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb2a.wav"), 1, ATTN_NORM, 0);
}
X
X
extern byte P_DamageModifier(edict_t *ent);
X
void fire_nuke (edict_t *self, vec3_t start, vec3_t aimdir, int speed)
{
X	edict_t	*nuke;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X	int		damage_modifier;
X
X	damage_modifier = (int) P_DamageModifier (self);
X
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	nuke = G_Spawn();
X	VectorCopy (start, nuke->s.origin);
X	VectorScale (aimdir, speed, nuke->velocity);
X
X	VectorMA (nuke->velocity, 200 + crandom() * 10.0, up, nuke->velocity);
X	VectorMA (nuke->velocity, crandom() * 10.0, right, nuke->velocity);
X	VectorClear (nuke->avelocity);
X	VectorClear (nuke->s.angles);
X	nuke->movetype = MOVETYPE_BOUNCE;
X	nuke->clipmask = MASK_SHOT;
X	nuke->solid = SOLID_BBOX;
X	nuke->s.effects |= EF_GRENADE;
X	nuke->s.renderfx |= RF_IR_VISIBLE;
X	VectorSet (nuke->mins, -8, -8, 0);
X	VectorSet (nuke->maxs, 8, 8, 16);
X	nuke->s.modelindex = gi.modelindex ("models/weapons/g_nuke/tris.md2");
X	nuke->owner = self;
X	nuke->teammaster = self;
X	nuke->nextthink = level.time + FRAMETIME;
X	nuke->wait = level.time + NUKE_DELAY + NUKE_TIME_TO_LIVE;
X	nuke->think = Nuke_Think;
X	nuke->touch = nuke_bounce;
X
X	nuke->health = 10000;
X	nuke->takedamage = DAMAGE_YES;
X	nuke->svflags |= SVF_DAMAGEABLE;
X	nuke->dmg = NUKE_DAMAGE * damage_modifier;
X	if (damage_modifier == 1)
X		nuke->dmg_radius = NUKE_RADIUS;
X	else
X		nuke->dmg_radius = NUKE_RADIUS + NUKE_RADIUS*(0.25*(float)damage_modifier);
X	// this yields 1.0, 1.5, 2.0, 3.0 times radius
X	
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("nuke modifier = %d, damage = %d, radius = %f\n", damage_modifier, nuke->dmg, nuke->dmg_radius);
X
X	nuke->classname = "nuke";
X	nuke->die = nuke_die;
X
X	gi.linkentity (nuke);
}
#endif
X
// *************************
// TESLA
// *************************
X
#ifdef INCLUDE_TESLA
#define TESLA_TIME_TO_LIVE		30
#define TESLA_DAMAGE_RADIUS		128
#define TESLA_DAMAGE			3		// 3
#define TESLA_KNOCKBACK			8
X
#define	TESLA_ACTIVATE_TIME		3
X
#define TESLA_EXPLOSION_DAMAGE_MULT		50		// this is the amount the damage is multiplied by for underwater explosions
#define	TESLA_EXPLOSION_RADIUS			200
X
void tesla_remove (edict_t *self)
{
X	edict_t		*cur, *next;
X
X	self->takedamage = DAMAGE_NO;
X	if(self->teamchain)
X	{
X		cur = self->teamchain;
X		while(cur)
X		{
X			next = cur->teamchain;
X			G_FreeEdict ( cur );
X			cur = next;
X		}
X	}
X	else if (self->air_finished)
X		gi.dprintf ("tesla without a field!\n");
X
X	self->owner = self->teammaster;	// Going away, set the owner correctly.
X	// PGM - grenade explode does damage to self->enemy
X	self->enemy = NULL;
X
X	// play quad sound if quadded and an underwater explosion
X	if ((self->dmg_radius) && (self->dmg > (TESLA_DAMAGE*TESLA_EXPLOSION_DAMAGE_MULT)))
X		gi.sound(self, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
X
X	Grenade_Explode(self);
}
X
void tesla_die(edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
//	gi.dprintf("tesla killed\n");
X	tesla_remove(self);
}
X
void tesla_blow (edict_t *self)
{
//	T_RadiusDamage(self, self->owner, TESLA_EXPLOSION_DAMAGE, NULL, TESLA_EXPLOSION_RADIUS, MOD_TESLA);
X	self->dmg = self->dmg * TESLA_EXPLOSION_DAMAGE_MULT;
X	self->dmg_radius = TESLA_EXPLOSION_RADIUS;
X	tesla_remove(self);
}
X
X
void tesla_zap (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
}
X
void tesla_think_active (edict_t *self)
{
X	int		i,num;
X	edict_t	*touch[MAX_EDICTS], *hit;
X	vec3_t	dir, start;
X	trace_t	tr;
X	
X	if(level.time > self->air_finished)
X	{
X		tesla_remove(self);
X		return;
X	}
X
X	VectorCopy(self->s.origin, start);
X	start[2] += 16;
X
X	num = gi.BoxEdicts(self->teamchain->absmin, self->teamchain->absmax, touch, MAX_EDICTS, AREA_SOLID);
X	for(i=0;i<num;i++)
X	{
X		// if the tesla died while zapping things, stop zapping.
X		if(!(self->inuse))
X			break;
X
X		hit=touch[i];
X		if(!hit->inuse)
X			continue;
X		if(hit == self)
X			continue;
X		if(hit->health < 1)
X			continue;
X		// don't hit clients in single-player or coop
X		if(hit->client)
X			if (coop->value || !deathmatch->value)
X				continue;
X		if(!(hit->svflags & (SVF_MONSTER | SVF_DAMAGEABLE)) && !hit->client)
X			continue;
X	
X		tr = gi.trace(start, vec3_origin, vec3_origin, hit->s.origin, self, MASK_SHOT);
X		if(tr.fraction==1 || tr.ent==hit)// || tr.ent->client || (tr.ent->svflags & (SVF_MONSTER | SVF_DAMAGEABLE)))
X		{
X			VectorSubtract(hit->s.origin, start, dir);
X			
X			// PMM - play quad sound if it's above the "normal" damage
X			if (self->dmg > TESLA_DAMAGE)
X				gi.sound(self, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
X
X			// PGM - don't do knockback to walking monsters
X			if((hit->svflags & SVF_MONSTER) && !(hit->flags & (FL_FLY|FL_SWIM)))
X				T_Damage (hit, self, self->teammaster, dir, tr.endpos, tr.plane.normal,
X					self->dmg, 0, 0, MOD_TESLA);
X			else
X				T_Damage (hit, self, self->teammaster, dir, tr.endpos, tr.plane.normal,
X					self->dmg, TESLA_KNOCKBACK, 0, MOD_TESLA);
X
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_LIGHTNING);
X			gi.WriteShort (hit - g_edicts);			// destination entity
X			gi.WriteShort (self - g_edicts);		// source entity
X			gi.WritePosition (tr.endpos);
X			gi.WritePosition (start);
X			gi.multicast (start, MULTICAST_PVS);
X		}
X	}
X
X	if(self->inuse)
X	{
X		self->think = tesla_think_active;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
void tesla_activate (edict_t *self)
{
X	edict_t		*trigger;
X	edict_t		*search;
X
X	if (gi.pointcontents (self->s.origin) & (CONTENTS_SLIME|CONTENTS_LAVA|CONTENTS_WATER))
X	{
X		tesla_blow (self);
X		return;
X	}
X
X	// only check for spawn points in deathmatch
X	if (deathmatch->value)
X	{
X		search = NULL;
X		while ((search = findradius(search, self->s.origin, 1.5*TESLA_DAMAGE_RADIUS)) != NULL)
X		{
X			//if (!search->takedamage)
X			//	continue;
X			// if it's a monster or player with health > 0
X			// or it's a deathmatch start point
X			// and we can see it
X			// blow up
X			if(search->classname)
X			{
X				if (   ( (!strcmp(search->classname, "info_player_deathmatch"))
X					|| (!strcmp(search->classname, "info_player_start"))
X					|| (!strcmp(search->classname, "info_player_coop"))
X					|| (!strcmp(search->classname, "misc_teleporter_dest"))
X					) 
X					&& (visible (search, self))
X				   )
X				{
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("Tesla to close to %s, removing!\n", search->classname);
X					tesla_remove (self);
X					return;
X				}
X			}
X		}
X	}
X
X	trigger = G_Spawn();
//	if (trigger->nextthink)
//	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("tesla_activate:  fixing nextthink\n");
//		trigger->nextthink = 0;
//	}
X	VectorCopy (self->s.origin, trigger->s.origin);
X	VectorSet (trigger->mins, -TESLA_DAMAGE_RADIUS, -TESLA_DAMAGE_RADIUS, self->mins[2]);
X	VectorSet (trigger->maxs, TESLA_DAMAGE_RADIUS, TESLA_DAMAGE_RADIUS, TESLA_DAMAGE_RADIUS);
X	trigger->movetype = MOVETYPE_NONE;
X	trigger->solid = SOLID_TRIGGER;
X	trigger->owner = self;
X	trigger->touch = tesla_zap;
X	trigger->classname = "tesla trigger";
X	// doesn't need to be marked as a teamslave since the move code for bounce looks for teamchains
X	gi.linkentity (trigger);
X
X	VectorClear (self->s.angles);
X	// clear the owner if in deathmatch
X	if (deathmatch->value)
X		self->owner = NULL;
X	self->teamchain = trigger;
X	self->think = tesla_think_active;
X	self->nextthink = level.time + FRAMETIME;
X	self->air_finished = level.time + TESLA_TIME_TO_LIVE;
}
X
void tesla_think (edict_t *ent)
{
X	if (gi.pointcontents (ent->s.origin) & (CONTENTS_SLIME|CONTENTS_LAVA))
X	{
X		tesla_remove (ent);
X		return;
X	}
X	VectorClear (ent->s.angles);
X
X	if(!(ent->s.frame))
X		gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/teslaopen.wav"), 1, ATTN_NORM, 0); 
X
X	ent->s.frame++;
X	if(ent->s.frame > 14)
X	{
X		ent->s.frame = 14;
X		ent->think = tesla_activate;
X		ent->nextthink = level.time + 0.1;
X	}
X	else
X	{
X		if(ent->s.frame > 9)
X		{
X			if(ent->s.frame == 10)
X			{
X				if (ent->owner && ent->owner->client)
X				{
X					PlayerNoise(ent->owner, ent->s.origin, PNOISE_WEAPON);		// PGM
X				}
X				ent->s.skinnum = 1;
X			}
X			else if(ent->s.frame == 12)
X				ent->s.skinnum = 2;
X			else if(ent->s.frame == 14)
X				ent->s.skinnum = 3;
X		}
X		ent->think = tesla_think;
X		ent->nextthink = level.time + 0.1;
X	}
}
X
void tesla_lava (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	vec3_t	land_point;
X
X	if (plane->normal)
X	{
X		VectorMA (ent->s.origin, -20.0, plane->normal, land_point);
X		if (gi.pointcontents (land_point) & (CONTENTS_SLIME|CONTENTS_LAVA))
X		{
X			tesla_blow (ent);
X			return;
X		}
X	}
X	if (random() > 0.5)
X		gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb1a.wav"), 1, ATTN_NORM, 0);
X	else
X		gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb2a.wav"), 1, ATTN_NORM, 0);
}
X
void fire_tesla (edict_t *self, vec3_t start, vec3_t aimdir, int damage_multiplier, int speed)
{
X	edict_t	*tesla;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	tesla = G_Spawn();
X	VectorCopy (start, tesla->s.origin);
X	VectorScale (aimdir, speed, tesla->velocity);
X	VectorMA (tesla->velocity, 200 + crandom() * 10.0, up, tesla->velocity);
X	VectorMA (tesla->velocity, crandom() * 10.0, right, tesla->velocity);
//	VectorCopy (dir, tesla->s.angles);
X	VectorClear (tesla->s.angles);
X	tesla->movetype = MOVETYPE_BOUNCE;
X	tesla->solid = SOLID_BBOX;
X	tesla->s.effects |= EF_GRENADE;
X	tesla->s.renderfx |= RF_IR_VISIBLE;
//	VectorClear (tesla->mins);
//	VectorClear (tesla->maxs);
X	VectorSet (tesla->mins, -12, -12, 0);
X	VectorSet (tesla->maxs, 12, 12, 20);
X	tesla->s.modelindex = gi.modelindex ("models/weapons/g_tesla/tris.md2");
X	
X	tesla->owner = self;		// PGM - we don't want it owned by self YET.
X	tesla->teammaster = self;
X
X	tesla->wait = level.time + TESLA_TIME_TO_LIVE;
X	tesla->think = tesla_think;
X	tesla->nextthink = level.time + TESLA_ACTIVATE_TIME;
X
X	// blow up on contact with lava & slime code
X	tesla->touch = tesla_lava;
X
X	if(deathmatch->value)
X		// PMM - lowered from 50 - 7/29/1998
X		tesla->health = 20;
X	else
X		tesla->health = 30;		// FIXME - change depending on skill?
X
X	tesla->takedamage = DAMAGE_YES;
X	tesla->die = tesla_die;
X	tesla->dmg = TESLA_DAMAGE*damage_multiplier;
//	tesla->dmg = 0;
X	tesla->classname = "tesla";
X	tesla->svflags |= SVF_DAMAGEABLE;
X	tesla->clipmask = MASK_SHOT|CONTENTS_SLIME|CONTENTS_LAVA;
X	tesla->flags |= FL_MECHANICAL;
X
X	gi.linkentity (tesla);
}
#endif
X
// *************************
//  HEATBEAM
// *************************
X
#ifdef INCLUDE_BEAMS
static void fire_beams (edict_t *self, vec3_t start, vec3_t aimdir, vec3_t offset, int damage, int kick, int te_beam, int te_impact, int mod)
{
X	trace_t		tr;
X	vec3_t		dir;
X	vec3_t		forward, right, up;
X	vec3_t		end;
X	vec3_t		water_start, endpoint;
X	qboolean	water = false, underwater = false;
X	int			content_mask = MASK_SHOT | MASK_WATER;
X	vec3_t		beam_endpt;
X
//	tr = gi.trace (self->s.origin, NULL, NULL, start, self, MASK_SHOT);
//	if (!(tr.fraction < 1.0))
//	{
X	vectoangles2 (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	VectorMA (start, 8192, forward, end);
X
X	if (gi.pointcontents (start) & MASK_WATER)
X	{
//		gi.dprintf ("Heat beam under water\n");
X		underwater = true;
X		VectorCopy (start, water_start);
X		content_mask &= ~MASK_WATER;
X	}
X
X	tr = gi.trace (start, NULL, NULL, end, self, content_mask);
X
X	// see if we hit water
X	if (tr.contents & MASK_WATER)
X	{
X		water = true;
X		VectorCopy (tr.endpos, water_start);
X
X		if (!VectorCompare (start, tr.endpos))
X		{
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_HEATBEAM_SPARKS);
//			gi.WriteByte (50);
X			gi.WritePosition (water_start);
X			gi.WriteDir (tr.plane.normal);
//			gi.WriteByte (8);
//			gi.WriteShort (60);
X			gi.multicast (tr.endpos, MULTICAST_PVS);
X		}
X		// re-trace ignoring water this time
X		tr = gi.trace (water_start, NULL, NULL, end, self, MASK_SHOT);
X	}
X	VectorCopy (tr.endpos, endpoint);
//	}
X
X	// halve the damage if target underwater
X	if (water)
X	{
X		damage = damage /2;
X	}
X
X	// send gun puff / flash
X	if (!((tr.surface) && (tr.surface->flags & SURF_SKY)))
X	{
X		if (tr.fraction < 1.0)
X		{
X			if (tr.ent->takedamage)
X			{
X				T_Damage (tr.ent, self, self, aimdir, tr.endpos, tr.plane.normal, damage, kick, DAMAGE_ENERGY, mod);
X			}
X			else
X			{
X				if ((!water) && (strncmp (tr.surface->name, "sky", 3)))
X				{
X					// This is the truncated steam entry - uses 1+1+2 extra bytes of data
X					gi.WriteByte (svc_temp_entity);
X					gi.WriteByte (TE_HEATBEAM_STEAM);
//					gi.WriteByte (20);
X					gi.WritePosition (tr.endpos);
X					gi.WriteDir (tr.plane.normal);
//					gi.WriteByte (0xe0);
//					gi.WriteShort (60);
X					gi.multicast (tr.endpos, MULTICAST_PVS);
X
X					if (self->client)
X						PlayerNoise(self, tr.endpos, PNOISE_IMPACT);
X				}
X			}
X		}
X	}
X
X	// if went through water, determine where the end and make a bubble trail
X	if ((water) || (underwater))
X	{
X		vec3_t	pos;
X
X		VectorSubtract (tr.endpos, water_start, dir);
X		VectorNormalize (dir);
X		VectorMA (tr.endpos, -2, dir, pos);
X		if (gi.pointcontents (pos) & MASK_WATER)
X			VectorCopy (pos, tr.endpos);
X		else
X			tr = gi.trace (pos, NULL, NULL, water_start, tr.ent, MASK_WATER);
X
X		VectorAdd (water_start, tr.endpos, pos);
X		VectorScale (pos, 0.5, pos);
X
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_BUBBLETRAIL2);
//		gi.WriteByte (8);
X		gi.WritePosition (water_start);
X		gi.WritePosition (tr.endpos);
X		gi.multicast (pos, MULTICAST_PVS);
X	}
X
X	if ((!underwater) && (!water))
X	{
X		VectorCopy (tr.endpos, beam_endpt);
X	}
X	else
X	{
X		VectorCopy (endpoint, beam_endpt);
X	}
X	
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (te_beam);
X	gi.WriteShort (self - g_edicts);
X	gi.WritePosition (start);
X	gi.WritePosition (beam_endpt);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X
}
X
X
/*
=================
fire_heat
X
Fires a single heat beam.  Zap.
=================
*/
void fire_heat (edict_t *self, vec3_t start, vec3_t aimdir, vec3_t offset, int damage, int kick, qboolean monster)
{
X	if (monster)
X		fire_beams (self, start, aimdir, offset, damage, kick, TE_MONSTER_HEATBEAM, TE_HEATBEAM_SPARKS, MOD_HEATBEAM);
X	else
X		fire_beams (self, start, aimdir, offset, damage, kick, TE_HEATBEAM, TE_HEATBEAM_SPARKS, MOD_HEATBEAM);
}
X
#endif
X
X
// *************************
//	BLASTER 2
// *************************
X
/*
=================
fire_blaster2
X
Fires a single green blaster bolt.  Used by monsters, generally.
=================
*/
void blaster2_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	int		mod;
X	int		damagestat;
X
X	if (other == self->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (self->owner && self->owner->client)
X		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
X
X	if (other->takedamage)
X	{
X		// the only time players will be firing blaster2 bolts will be from the 
X		// defender sphere.
X		if(self->owner->client)
X			mod = MOD_DEFENDER_SPHERE;
X		else
X			mod = MOD_BLASTER2;
X
X		if (self->owner)
X		{
X			damagestat = self->owner->takedamage;
X			self->owner->takedamage = DAMAGE_NO;
X			if (self->dmg >= 5)
X				T_RadiusDamage(self, self->owner, self->dmg*3, other, self->dmg_radius, 0);
X			T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal, self->dmg, 1, DAMAGE_ENERGY, mod);
X			self->owner->takedamage = damagestat;
X		}
X		else
X		{
X			if (self->dmg >= 5)
X				T_RadiusDamage(self, self->owner, self->dmg*3, other, self->dmg_radius, 0);
X			T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal, self->dmg, 1, DAMAGE_ENERGY, mod);
X		}
X	}
X	else
X	{
X		//PMM - yeowch this will get expensive
X		if (self->dmg >= 5)
X			T_RadiusDamage(self, self->owner, self->dmg*3, self->owner, self->dmg_radius, 0);
X
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_BLASTER2);
X		gi.WritePosition (self->s.origin);
X		if (!plane)
X			gi.WriteDir (vec3_origin);
X		else
X			gi.WriteDir (plane->normal);
X		gi.multicast (self->s.origin, MULTICAST_PVS);
X	}
X
X	G_FreeEdict (self);
}
X
void fire_blaster2 (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int effect, qboolean hyper)
{
X	edict_t	*bolt;
X	trace_t	tr;
X
X	VectorNormalize (dir);
X
X	bolt = G_Spawn();
X	VectorCopy (start, bolt->s.origin);
X	VectorCopy (start, bolt->s.old_origin);
X	vectoangles2 (dir, bolt->s.angles);
X	VectorScale (dir, speed, bolt->velocity);
X	bolt->movetype = MOVETYPE_FLYMISSILE;
X	bolt->clipmask = MASK_SHOT;
X	bolt->solid = SOLID_BBOX;
X	bolt->s.effects |= effect;
X	VectorClear (bolt->mins);
X	VectorClear (bolt->maxs);
X	
X		if (effect)
X			bolt->s.effects |= EF_TRACKER;
X		bolt->dmg_radius = 128;
X		bolt->s.modelindex = gi.modelindex ("models/proj/laser2/tris.md2");
X		bolt->touch = blaster2_touch;
X
X	bolt->owner = self;
X	bolt->nextthink = level.time + 2;
X	bolt->think = G_FreeEdict;
X	bolt->dmg = damage;
X	bolt->classname = "bolt";
X 	gi.linkentity (bolt);
X
X	if (self->client)
X		check_dodge (self, bolt->s.origin, dir, speed);
X
X	tr = gi.trace (self->s.origin, NULL, NULL, bolt->s.origin, bolt, MASK_SHOT);
X	if (tr.fraction < 1.0)
X	{
X		VectorMA (bolt->s.origin, -10, dir, bolt->s.origin);
X		bolt->touch (bolt, tr.ent, NULL, NULL);
X	}
}	
X
// *************************
// tracker
// *************************
X
/*
void tracker_boom_think (edict_t *self)
{
X	self->s.frame--;
X	if(self->s.frame < 0)
X		G_FreeEdict(self);
X	else
X		self->nextthink = level.time + 0.1;
}
X
void tracker_boom_spawn (vec3_t origin)
{
X	edict_t *boom;
X
X	boom = G_Spawn();
X	VectorCopy (origin, boom->s.origin);
X	boom->s.modelindex = gi.modelindex ("models/items/spawngro/tris.md2");
X	boom->s.skinnum = 1;
X	boom->s.frame = 2;
X	boom->classname = "tracker boom";
X	gi.linkentity (boom);
X
X	boom->think = tracker_boom_think;
X	boom->nextthink = level.time + 0.1;
X	//PMM
//	boom->s.renderfx |= RF_TRANSLUCENT;
X	boom->s.effects |= EF_SPHERETRANS;
X	//pmm
}
*/
X
#define TRACKER_DAMAGE_FLAGS	(DAMAGE_NO_POWER_ARMOR | DAMAGE_ENERGY | DAMAGE_NO_KNOCKBACK)
#define TRACKER_IMPACT_FLAGS	(DAMAGE_NO_POWER_ARMOR | DAMAGE_ENERGY)
X
#define TRACKER_DAMAGE_TIME		0.5		// seconds
X
void tracker_pain_daemon_think (edict_t *self)
{
X	static vec3_t	pain_normal = { 0, 0, 1 };
X	int				hurt;
X
X	if(!self->inuse)
X		return;
X
X	if((level.time - self->timestamp) > TRACKER_DAMAGE_TIME)
X	{
X		if(!self->enemy->client)
X			self->enemy->s.effects &= ~EF_TRACKERTRAIL;
X		G_FreeEdict (self);
X	}
X	else
X	{
X		if(self->enemy->health > 0)
X		{
//			gi.dprintf("ouch %x\n", self);
X			T_Damage (self->enemy, self, self->owner, vec3_origin, self->enemy->s.origin, pain_normal,
X						self->dmg, 0, TRACKER_DAMAGE_FLAGS, MOD_TRACKER);
X			
X			// if we kill the player, we'll be removed.
X			if(self->inuse)
X			{
X				// if we killed a monster, gib them.
X				if (self->enemy->health < 1)
X				{
X					if(self->enemy->gib_health)
X						hurt = - self->enemy->gib_health;
X					else
X						hurt = 500;
X
//					gi.dprintf("non-player killed. ensuring gib!  %d\n", hurt);
X					T_Damage (self->enemy, self, self->owner, vec3_origin, self->enemy->s.origin,
X								pain_normal, hurt, 0, TRACKER_DAMAGE_FLAGS, MOD_TRACKER);
X				}
X
X				if(self->enemy->client)
X					self->enemy->client->tracker_pain_framenum = level.framenum + 1;
X				else
X					self->enemy->s.effects |= EF_TRACKERTRAIL;
X				
X				self->nextthink = level.time + FRAMETIME;
X			}
X		}
X		else
X		{
X			if(!self->enemy->client)
X				self->enemy->s.effects &= ~EF_TRACKERTRAIL;
X			G_FreeEdict (self);
X		}
X	}
}
X
void tracker_pain_daemon_spawn (edict_t *owner, edict_t *enemy, int damage)
{
X	edict_t	 *daemon;
X
X	if(enemy == NULL)
X		return;
X
X	daemon = G_Spawn();
X	daemon->classname = "pain daemon";
X	daemon->think = tracker_pain_daemon_think;
X	daemon->nextthink = level.time + FRAMETIME;
X	daemon->timestamp = level.time;
X	daemon->owner = owner;
X	daemon->enemy = enemy;
X	daemon->dmg = damage;
}
X
void tracker_explode (edict_t *self, cplane_t *plane)
{
X	vec3_t	dir;
X
X	if(!plane)
X		VectorClear (dir);
X	else
X		VectorScale (plane->normal, 256, dir);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_TRACKER_EXPLOSION);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
//	gi.sound (self, CHAN_VOICE, gi.soundindex ("weapons/disrupthit.wav"), 1, ATTN_NORM, 0);
//	tracker_boom_spawn(self->s.origin);
X
X	G_FreeEdict (self);
}
X
void tracker_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	float	damagetime;
X
X	if (other == self->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (self->client)
X		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
X
X	if (other->takedamage)
X	{
X		if((other->svflags & SVF_MONSTER) || other->client)
X		{
X			if(other->health > 0)		// knockback only for living creatures
X			{
X				// PMM - kickback was times 4 .. reduced to 3
X				// now this does no damage, just knockback
X				T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal,
X							/* self->dmg */ 0, (self->dmg*3), TRACKER_IMPACT_FLAGS, MOD_TRACKER);
X				
X				if (!(other->flags & (FL_FLY|FL_SWIM)))
X					other->velocity[2] += 140;
X				
X				damagetime = ((float)self->dmg)*FRAMETIME;
X				damagetime = damagetime / TRACKER_DAMAGE_TIME;
//				gi.dprintf ("damage is %f\n", damagetime);
X
X				tracker_pain_daemon_spawn (self->owner, other, (int)damagetime);
X			}
X			else						// lots of damage (almost autogib) for dead bodies
X			{
X				T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal,
X							self->dmg*4, (self->dmg*3), TRACKER_IMPACT_FLAGS, MOD_TRACKER);
X			}
X		}
X		else	// full damage in one shot for inanimate objects
X		{
X			T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal,
X						self->dmg, (self->dmg*3), TRACKER_IMPACT_FLAGS, MOD_TRACKER);
X		}
X	}
X
X	tracker_explode (self, plane);
X	return;
}
X
void tracker_fly (edict_t *self)
{
X	vec3_t	dest;
X	vec3_t	dir;
X	vec3_t	center;
X
X	if ((!self->enemy) || (!self->enemy->inuse) || (self->enemy->health < 1))
X	{
X		tracker_explode (self, NULL);
X		return;
X	}
/*
X	VectorCopy (self->enemy->s.origin, dest);
X	if(self->enemy->client)
X		dest[2] += self->enemy->viewheight;
*/
X	// PMM - try to hunt for center of enemy, if possible and not client
X	if(self->enemy->client)
X	{
X		VectorCopy (self->enemy->s.origin, dest);
X		dest[2] += self->enemy->viewheight;
X	}
X	// paranoia
X	else if (VectorCompare(self->enemy->absmin, vec3_origin) || VectorCompare(self->enemy->absmax, vec3_origin))
X	{
X		VectorCopy (self->enemy->s.origin, dest);
X	}
X	else
X	{
X		VectorMA (vec3_origin, 0.5, self->enemy->absmin, center);
X		VectorMA (center, 0.5, self->enemy->absmax, center);
X		VectorCopy (center, dest);
X	}
X
X	VectorSubtract (dest, self->s.origin, dir);
X	VectorNormalize (dir);
X	vectoangles2 (dir, self->s.angles);
X	VectorScale (dir, self->speed, self->velocity);
X	VectorCopy(dest, self->monsterinfo.saved_goal);
X
X	self->nextthink = level.time + 0.1;
}
X
void fire_tracker (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, edict_t *enemy)
{
X	edict_t	*bolt;
X	trace_t	tr;
X
X	VectorNormalize (dir);
X
X	bolt = G_Spawn();
X	VectorCopy (start, bolt->s.origin);
X	VectorCopy (start, bolt->s.old_origin);
X	vectoangles2 (dir, bolt->s.angles);
X	VectorScale (dir, speed, bolt->velocity);
X	bolt->movetype = MOVETYPE_FLYMISSILE;
X	bolt->clipmask = MASK_SHOT;
X	bolt->solid = SOLID_BBOX;
X	bolt->speed = speed;
X	bolt->s.effects = EF_TRACKER;
X	bolt->s.sound = gi.soundindex ("weapons/disrupt.wav");
X	VectorClear (bolt->mins);
X	VectorClear (bolt->maxs);
X	
X	bolt->s.modelindex = gi.modelindex ("models/proj/disintegrator/tris.md2");
X	bolt->touch = tracker_touch;
X	bolt->enemy = enemy;
X	bolt->owner = self;
X	bolt->dmg = damage;
X	bolt->classname = "tracker";
X	gi.linkentity (bolt);
X
X	if(enemy)
X	{
X		bolt->nextthink = level.time + 0.1;
X		bolt->think = tracker_fly;
X	}
X	else
X	{
X		bolt->nextthink = level.time + 10;
X		bolt->think = G_FreeEdict;
X	}
X
X	if (self->client)
X		check_dodge (self, bolt->s.origin, dir, speed);
X
X	tr = gi.trace (self->s.origin, NULL, NULL, bolt->s.origin, bolt, MASK_SHOT);
X	if (tr.fraction < 1.0)
X	{
X		VectorMA (bolt->s.origin, -10, dir, bolt->s.origin);
X		bolt->touch (bolt, tr.ent, NULL, NULL);
X	}
}	
SHAR_EOF
  $shar_touch -am 1130175398 'g_newweap.c' &&
  chmod 0664 'g_newweap.c' ||
  $echo 'restore of' 'g_newweap.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_newweap.c:' 'MD5 check failed'
84a00b473a785f26f635ea8d5c5a5207  g_newweap.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_newweap.c'`"
    test 60131 -eq "$shar_count" ||
    $echo 'g_newweap.c:' 'original size' '60131,' 'current size' "$shar_count!"
  fi
fi
# ============= g_phys.c ==============
if test -f 'g_phys.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_phys.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_phys.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_phys.c' &&
// g_phys.c
X
#include "g_local.h"
X
/*
X
X
pushmove objects do not obey gravity, and do not interact with each other or trigger fields, but block normal movement and push normal objects when they move.
X
onground is set for toss objects when they come to a complete rest.  it is set for steping or walking objects 
X
doors, plats, etc are SOLID_BSP, and MOVETYPE_PUSH
bonus items are SOLID_TRIGGER touch, and MOVETYPE_TOSS
corpses are SOLID_NOT and MOVETYPE_TOSS
crates are SOLID_BBOX and MOVETYPE_TOSS
walking monsters are SOLID_SLIDEBOX and MOVETYPE_STEP
flying/floating monsters are SOLID_SLIDEBOX and MOVETYPE_FLY
X
solid_edge items only clip against bsp models.
X
*/
X
void SV_Physics_NewToss (edict_t *ent);			// PGM
X
X
/*
============
SV_TestEntityPosition
X
============
*/
edict_t	*SV_TestEntityPosition (edict_t *ent)
{
X	trace_t	trace;
X	int		mask;
X
X	if (ent->clipmask)
X		mask = ent->clipmask;
X	else
X		mask = MASK_SOLID;
X	trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, ent->s.origin, ent, mask);
X	
X	if (trace.startsolid)
X		return g_edicts;
X		
X	return NULL;
}
X
X
/*
================
SV_CheckVelocity
================
*/
void SV_CheckVelocity (edict_t *ent)
{
X	int		i;
X
//
// bound velocity
//
X	for (i=0 ; i<3 ; i++)
X	{
X		if (ent->velocity[i] > sv_maxvelocity->value)
X			ent->velocity[i] = sv_maxvelocity->value;
X		else if (ent->velocity[i] < -sv_maxvelocity->value)
X			ent->velocity[i] = -sv_maxvelocity->value;
X	}
}
X
/*
=============
SV_RunThink
X
Runs thinking code for this frame if necessary
=============
*/
qboolean SV_RunThink (edict_t *ent)
{
X	float	thinktime;
X
X	thinktime = ent->nextthink;
X	if (thinktime <= 0)
X		return true;
X	if (thinktime > level.time+0.001)
X		return true;
X	
X	ent->nextthink = 0;
X	if (!ent->think)
X		gi.error ("NULL ent->think");
X	ent->think (ent);
X
X	return false;
}
X
/*
==================
SV_Impact
X
Two entities have touched, so run their touch functions
==================
*/
void SV_Impact (edict_t *e1, trace_t *trace)
{
X	edict_t		*e2;
//	cplane_t	backplane;
X
X	e2 = trace->ent;
X
X	if (e1->touch && e1->solid != SOLID_NOT)
X		e1->touch (e1, e2, &trace->plane, trace->surface);
X	
X	if (e2->touch && e2->solid != SOLID_NOT)
X		e2->touch (e2, e1, NULL, NULL);
}
X
X
/*
==================
ClipVelocity
X
Slide off of the impacting object
returns the blocked flags (1 = floor, 2 = step / wall)
==================
*/
#define	STOP_EPSILON	0.1
X
int ClipVelocity (vec3_t in, vec3_t normal, vec3_t out, float overbounce)
{
X	float	backoff;
X	float	change;
X	int		i, blocked;
X	
X	blocked = 0;
X	if (normal[2] > 0)
X		blocked |= 1;		// floor
X	if (!normal[2])
X		blocked |= 2;		// step
X	
X	backoff = DotProduct (in, normal) * overbounce;
X
X	for (i=0 ; i<3 ; i++)
X	{
X		change = normal[i]*backoff;
X		out[i] = in[i] - change;
X		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
X			out[i] = 0;
X	}
X	
X	return blocked;
}
X
X
/*
============
SV_FlyMove
X
The basic solid body movement clip that slides along multiple planes
Returns the clipflags if the velocity was modified (hit something solid)
1 = floor
2 = wall / step
4 = dead stop
============
*/
#define	MAX_CLIP_PLANES	5
int SV_FlyMove (edict_t *ent, float time, int mask)
{
X	edict_t		*hit;
X	int			bumpcount, numbumps;
X	vec3_t		dir;
X	float		d;
X	int			numplanes;
X	vec3_t		planes[MAX_CLIP_PLANES];
X	vec3_t		primal_velocity, original_velocity, new_velocity;
X	int			i, j;
X	trace_t		trace;
X	vec3_t		end;
X	float		time_left;
X	int			blocked;
X	
X	numbumps = 4;
X	
X	blocked = 0;
X	VectorCopy (ent->velocity, original_velocity);
X	VectorCopy (ent->velocity, primal_velocity);
X	numplanes = 0;
X	
X	time_left = time;
X
X	ent->groundentity = NULL;
X	for (bumpcount=0 ; bumpcount<numbumps ; bumpcount++)
X	{
X		for (i=0 ; i<3 ; i++)
X			end[i] = ent->s.origin[i] + time_left * ent->velocity[i];
X
X		trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, end, ent, mask);
X
X		if (trace.allsolid)
X		{	// entity is trapped in another solid
X			VectorCopy (vec3_origin, ent->velocity);
X			return 3;
X		}
X
X		if (trace.fraction > 0)
X		{	// actually covered some distance
X			VectorCopy (trace.endpos, ent->s.origin);
X			VectorCopy (ent->velocity, original_velocity);
X			numplanes = 0;
X		}
X
X		if (trace.fraction == 1)
X			 break;		// moved the entire distance
X
X		hit = trace.ent;
X
X		if (trace.plane.normal[2] > 0.7)
X		{
X			blocked |= 1;		// floor
X			if ( hit->solid == SOLID_BSP)
X			{
X				ent->groundentity = hit;
X				ent->groundentity_linkcount = hit->linkcount;
X			}
X		}
X		if (!trace.plane.normal[2])
X		{
X			blocked |= 2;		// step
X		}
X
//
// run the impact function
//
X		SV_Impact (ent, &trace);
X		if (!ent->inuse)
X			break;		// removed by the impact function
X
X		
X		time_left -= time_left * trace.fraction;
X		
X	// cliped to another plane
X		if (numplanes >= MAX_CLIP_PLANES)
X		{	// this shouldn't really happen
X			VectorCopy (vec3_origin, ent->velocity);
X			return 3;
X		}
X
X		VectorCopy (trace.plane.normal, planes[numplanes]);
X		numplanes++;
X
//
// modify original_velocity so it parallels all of the clip planes
//
X		for (i=0 ; i<numplanes ; i++)
X		{
X			ClipVelocity (original_velocity, planes[i], new_velocity, 1);
X
X			for (j=0 ; j<numplanes ; j++)
X				if ((j != i) && !VectorCompare (planes[i], planes[j]))
X				{
X					if (DotProduct (new_velocity, planes[j]) < 0)
X						break;	// not ok
X				}
X			if (j == numplanes)
X				break;
X		}
X		
X		if (i != numplanes)
X		{	// go along this plane
X			VectorCopy (new_velocity, ent->velocity);
X		}
X		else
X		{	// go along the crease
X			if (numplanes != 2)
X			{
//				gi.dprintf ("clip velocity, numplanes == %i\n",numplanes);
X				VectorCopy (vec3_origin, ent->velocity);
X				return 7;
X			}
X			CrossProduct (planes[0], planes[1], dir);
X			d = DotProduct (dir, ent->velocity);
X			VectorScale (dir, d, ent->velocity);
X		}
X
//
// if original velocity is against the original velocity, stop dead
// to avoid tiny occilations in sloping corners
//
X		if (DotProduct (ent->velocity, primal_velocity) <= 0)
X		{
X			VectorCopy (vec3_origin, ent->velocity);
X			return blocked;
X		}
X	}
X
X	return blocked;
}
X
X
/*
============
SV_AddGravity
X
============
*/
void SV_AddGravity (edict_t *ent)
{
#ifdef ROGUE_GRAVITY
X	if(ent->gravityVector[2] > 0)
X	{
X		VectorMA(ent->velocity,
X				 ent->gravity * sv_gravity->value * FRAMETIME,
X				 ent->gravityVector,
X				 ent->velocity);
X	}
X	else
X		ent->velocity[2] -= ent->gravity * sv_gravity->value * FRAMETIME;
#else
X	ent->velocity[2] -= ent->gravity * sv_gravity->value * FRAMETIME;
#endif
}
X
/*
===============================================================================
X
PUSHMOVE
X
===============================================================================
*/
X
/*
============
SV_PushEntity
X
Does not change the entities velocity at all
============
*/
trace_t SV_PushEntity (edict_t *ent, vec3_t push)
{
X	trace_t	trace;
X	vec3_t	start;
X	vec3_t	end;
X	int		mask;
X
X	VectorCopy (ent->s.origin, start);
X	VectorAdd (start, push, end);
X
retry:
X	if (ent->clipmask)
X		mask = ent->clipmask;
X	else
X		mask = MASK_SOLID;
X
X	trace = gi.trace (start, ent->mins, ent->maxs, end, ent, mask);
X	
X	VectorCopy (trace.endpos, ent->s.origin);
X	gi.linkentity (ent);
X
X	if (trace.fraction != 1.0)
X	{
X		SV_Impact (ent, &trace);
X
X		// if the pushed entity went away and the pusher is still there
X		if (!trace.ent->inuse && ent->inuse)
X		{
X			// move the pusher back and try again
X			VectorCopy (start, ent->s.origin);
X			gi.linkentity (ent);
X			goto retry;
X		}
X	}
X
// ================
// PGM
X	// FIXME - is this needed?
X	ent->gravity = 1.0;
// PGM
// ================
X
X	if (ent->inuse)
X		G_TouchTriggers (ent);
X
X	return trace;
}					
X
X
typedef struct
{
X	edict_t	*ent;
X	vec3_t	origin;
X	vec3_t	angles;
X	float	deltayaw;
} pushed_t;
pushed_t	pushed[MAX_EDICTS], *pushed_p;
X
edict_t	*obstacle;
X
/*
============
SV_Push
X
Objects need to be moved back on a failed push,
otherwise riders would continue to slide.
============
*/
qboolean SV_Push (edict_t *pusher, vec3_t move, vec3_t amove)
{
X	int			i, e;
X	edict_t		*check, *block;
X	vec3_t		mins, maxs;
X	pushed_t	*p;
X	vec3_t		org, org2, move2, forward, right, up;
X
X	// clamp the move to 1/8 units, so the position will
X	// be accurate for client side prediction
X	for (i=0 ; i<3 ; i++)
X	{
X		float	temp;
X		temp = move[i]*8.0;
X		if (temp > 0.0)
X			temp += 0.5;
X		else
X			temp -= 0.5;
X		move[i] = 0.125 * (int)temp;
X	}
X
X	// find the bounding box
X	for (i=0 ; i<3 ; i++)
X	{
X		mins[i] = pusher->absmin[i] + move[i];
X		maxs[i] = pusher->absmax[i] + move[i];
X	}
X
// we need this for pushing things later
X	VectorSubtract (vec3_origin, amove, org);
X	AngleVectors (org, forward, right, up);
X
// save the pusher's original position
X	pushed_p->ent = pusher;
X	VectorCopy (pusher->s.origin, pushed_p->origin);
X	VectorCopy (pusher->s.angles, pushed_p->angles);
X	if (pusher->client)
X		pushed_p->deltayaw = pusher->client->ps.pmove.delta_angles[YAW];
X	pushed_p++;
X
// move the pusher to it's final position
X	VectorAdd (pusher->s.origin, move, pusher->s.origin);
X	VectorAdd (pusher->s.angles, amove, pusher->s.angles);
X	gi.linkentity (pusher);
X
// see if any solid entities are inside the final position
X	check = g_edicts+1;
X	for (e = 1; e < globals.num_edicts; e++, check++)
X	{
X		if (!check->inuse)
X			continue;
X		if (check->movetype == MOVETYPE_PUSH
X		|| check->movetype == MOVETYPE_STOP
X		|| check->movetype == MOVETYPE_NONE
X		|| check->movetype == MOVETYPE_NOCLIP)
X			continue;
X
X		if (!check->area.prev)
X			continue;		// not linked in anywhere
X
X	// if the entity is standing on the pusher, it will definitely be moved
X		if (check->groundentity != pusher)
X		{
X			// see if the ent needs to be tested
X			if ( check->absmin[0] >= maxs[0]
X			|| check->absmin[1] >= maxs[1]
X			|| check->absmin[2] >= maxs[2]
X			|| check->absmax[0] <= mins[0]
X			|| check->absmax[1] <= mins[1]
X			|| check->absmax[2] <= mins[2] )
X				continue;
X
X			// see if the ent's bbox is inside the pusher's final position
X			if (!SV_TestEntityPosition (check))
X				continue;
X		}
X
X		if ((pusher->movetype == MOVETYPE_PUSH) || (check->groundentity == pusher))
X		{
X			// move this entity
X			pushed_p->ent = check;
X			VectorCopy (check->s.origin, pushed_p->origin);
X			VectorCopy (check->s.angles, pushed_p->angles);
X			pushed_p++;
X
X			// try moving the contacted entity 
X			VectorAdd (check->s.origin, move, check->s.origin);
X			if (check->client)
X			{	// FIXME: doesn't rotate monsters?
X				check->client->ps.pmove.delta_angles[YAW] += amove[YAW];
X			}
X
X			// figure movement due to the pusher's amove
X			VectorSubtract (check->s.origin, pusher->s.origin, org);
X			org2[0] = DotProduct (org, forward);
X			org2[1] = -DotProduct (org, right);
X			org2[2] = DotProduct (org, up);
X			VectorSubtract (org2, org, move2);
X			VectorAdd (check->s.origin, move2, check->s.origin);
X
X			// may have pushed them off an edge
X			if (check->groundentity != pusher)
X				check->groundentity = NULL;
X
X			block = SV_TestEntityPosition (check);
X			if (!block)
X			{	// pushed ok
X				gi.linkentity (check);
X				// impact?
X				continue;
X			}
X
X			// if it is ok to leave in the old position, do it
X			// this is only relevent for riding entities, not pushed
X			// FIXME: this doesn't acount for rotation
X			VectorSubtract (check->s.origin, move, check->s.origin);
X			block = SV_TestEntityPosition (check);
X			if (!block)
X			{
X				pushed_p--;
X				continue;
X			}
X		}
X		
X		// save off the obstacle so we can call the block function
X		obstacle = check;
X
X		// move back any entities we already moved
X		// go backwards, so if the same entity was pushed
X		// twice, it goes back to the original position
X		for (p=pushed_p-1 ; p>=pushed ; p--)
X		{
X			VectorCopy (p->origin, p->ent->s.origin);
X			VectorCopy (p->angles, p->ent->s.angles);
X			if (p->ent->client)
X			{
X				p->ent->client->ps.pmove.delta_angles[YAW] = p->deltayaw;
X			}
X			gi.linkentity (p->ent);
X		}
X		return false;
X	}
X
//FIXME: is there a better way to handle this?
X	// see if anything we moved has touched a trigger
X	for (p=pushed_p-1 ; p>=pushed ; p--)
X		G_TouchTriggers (p->ent);
X
X	return true;
}
X
/*
================
SV_Physics_Pusher
X
Bmodel objects don't interact with each other, but
push all box objects
================
*/
void SV_Physics_Pusher (edict_t *ent)
{
X	vec3_t		move, amove;
X	edict_t		*part, *mv;
X
X	// if not a team captain, so movement will be handled elsewhere
X	if ( ent->flags & FL_TEAMSLAVE)
X		return;
X
X	// make sure all team slaves can move before commiting
X	// any moves or calling any think functions
X	// if the move is blocked, all moved objects will be backed out
//retry:
X	pushed_p = pushed;
X	for (part = ent ; part ; part=part->teamchain)
X	{
X		if (part->velocity[0] || part->velocity[1] || part->velocity[2] ||
X			part->avelocity[0] || part->avelocity[1] || part->avelocity[2]
X			)
X		{	// object is moving
X			VectorScale (part->velocity, FRAMETIME, move);
X			VectorScale (part->avelocity, FRAMETIME, amove);
X
X			if (!SV_Push (part, move, amove))
X				break;	// move was blocked
X		}
X	}
X	if (pushed_p > &pushed[MAX_EDICTS])
X		gi.error (ERR_FATAL, "pushed_p > &pushed[MAX_EDICTS], memory corrupted");
X
X	if (part)
X	{
X		// the move failed, bump all nextthink times and back out moves
X		for (mv = ent ; mv ; mv=mv->teamchain)
X		{
X			if (mv->nextthink > 0)
X				mv->nextthink += FRAMETIME;
X		}
X
X		// if the pusher has a "blocked" function, call it
X		// otherwise, just stay in place until the obstacle is gone
X		if (part->blocked)
X			part->blocked (part, obstacle);
#if 0
X		// if the pushed entity went away and the pusher is still there
X		if (!obstacle->inuse && part->inuse)
X			goto retry;
#endif
X	}
X	else
X	{
X		// the move succeeded, so call all think functions
X		for (part = ent ; part ; part=part->teamchain)
X		{
X			// prevent entities that are on trains that have gone away from thinking!
X			if (part->inuse)
X				SV_RunThink (part);
X		}
X	}
}
X
//==================================================================
X
/*
=============
SV_Physics_None
X
Non moving objects can only think
=============
*/
void SV_Physics_None (edict_t *ent)
{
// regular thinking
X	SV_RunThink (ent);
}
X
/*
=============
SV_Physics_Noclip
X
A moving object that doesn't obey physics
=============
*/
void SV_Physics_Noclip (edict_t *ent)
{
// regular thinking
X	if (!SV_RunThink (ent))
X		return;
X	
X	VectorMA (ent->s.angles, FRAMETIME, ent->avelocity, ent->s.angles);
X	VectorMA (ent->s.origin, FRAMETIME, ent->velocity, ent->s.origin);
X
X	gi.linkentity (ent);
}
X
/*
==============================================================================
X
TOSS / BOUNCE
X
==============================================================================
*/
X
/*
=============
SV_Physics_Toss
X
Toss, bounce, and fly movement.  When onground, do nothing.
=============
*/
void SV_Physics_Toss (edict_t *ent)
{
X	trace_t		trace;
X	vec3_t		move;
X	float		backoff;
X	edict_t		*slave;
X	qboolean	wasinwater;
X	qboolean	isinwater;
X	vec3_t		old_origin;
X
// regular thinking
X	SV_RunThink (ent);
X
X	// if not a team captain, so movement will be handled elsewhere
X	if ( ent->flags & FL_TEAMSLAVE)
X		return;
X
X	if (ent->velocity[2] > 0)
X		ent->groundentity = NULL;
X
// check for the groundentity going away
X	if (ent->groundentity)
X		if (!ent->groundentity->inuse)
X			ent->groundentity = NULL;
X
// if onground, return without moving
X	if ( ent->groundentity && ent->gravity > 0.0)		// PGM - gravity hack
X		return;
X
X	VectorCopy (ent->s.origin, old_origin);
X
X	SV_CheckVelocity (ent);
X
// add gravity
X	if (ent->movetype != MOVETYPE_FLY
X	&& ent->movetype != MOVETYPE_FLYMISSILE)
X		SV_AddGravity (ent);
X
// move angles
X	VectorMA (ent->s.angles, FRAMETIME, ent->avelocity, ent->s.angles);
X
// move origin
X	VectorScale (ent->velocity, FRAMETIME, move);
X	trace = SV_PushEntity (ent, move);
X	if (!ent->inuse)
X		return;
X
X	if (trace.fraction < 1)
X	{
X		if (ent->movetype == MOVETYPE_BOUNCE)
X			backoff = 1.5;
X		else
X			backoff = 1;
X
X		ClipVelocity (ent->velocity, trace.plane.normal, ent->velocity, backoff);
X
X	// stop if on ground
X		if (trace.plane.normal[2] > 0.7)
X		{		
X			if (ent->velocity[2] < 60 || ent->movetype != MOVETYPE_BOUNCE )
X			{
X				ent->groundentity = trace.ent;
X				ent->groundentity_linkcount = trace.ent->linkcount;
X				VectorCopy (vec3_origin, ent->velocity);
X				VectorCopy (vec3_origin, ent->avelocity);
X			}
X		}
X
//		if (ent->touch)
//			ent->touch (ent, trace.ent, &trace.plane, trace.surface);
X	}
X	
// check for water transition
X	wasinwater = (ent->watertype & MASK_WATER);
X	ent->watertype = gi.pointcontents (ent->s.origin);
X	isinwater = ent->watertype & MASK_WATER;
X
X	if (isinwater)
X		ent->waterlevel = 1;
X	else
X		ent->waterlevel = 0;
X
X	if (!wasinwater && isinwater)
X		gi.positioned_sound (old_origin, g_edicts, CHAN_AUTO, gi.soundindex("misc/h2ohit1.wav"), 1, 1, 0);
X	else if (wasinwater && !isinwater)
X		gi.positioned_sound (ent->s.origin, g_edicts, CHAN_AUTO, gi.soundindex("misc/h2ohit1.wav"), 1, 1, 0);
X
// move teamslaves
X	for (slave = ent->teamchain; slave; slave = slave->teamchain)
X	{
X		VectorCopy (ent->s.origin, slave->s.origin);
X		gi.linkentity (slave);
X	}
}
X
/*
===============================================================================
X
STEPPING MOVEMENT
X
===============================================================================
*/
X
/*
=============
SV_Physics_Step
X
Monsters freefall when they don't have a ground entity, otherwise
all movement is done with discrete steps.
X
This is also used for objects that have become still on the ground, but
will fall if the floor is pulled out from under them.
FIXME: is this true?
=============
*/
X
//FIXME: hacked in for E3 demo
//#define	sv_stopspeed		100
#define sv_friction			6
#define sv_waterfriction	1
X
void SV_AddRotationalFriction (edict_t *ent)
{
X	int		n;
X	float	adjustment;
X
X	VectorMA (ent->s.angles, FRAMETIME, ent->avelocity, ent->s.angles);
X	adjustment = FRAMETIME * sv_stopspeed->value * sv_friction;		//PGM now a cvar
X	for (n = 0; n < 3; n++)
X	{
X		if (ent->avelocity[n] > 0)
X		{
X			ent->avelocity[n] -= adjustment;
X			if (ent->avelocity[n] < 0)
X				ent->avelocity[n] = 0;
X		}
X		else
X		{
X			ent->avelocity[n] += adjustment;
X			if (ent->avelocity[n] > 0)
X				ent->avelocity[n] = 0;
X		}
X	}
}
X
void SV_Physics_Step (edict_t *ent)
{
X	qboolean	wasonground;
X	qboolean	hitsound = false;
X	float		*vel;
X	float		speed, newspeed, control;
X	float		friction;
X	edict_t		*groundentity;
X	int			mask;
X
X	// airborn monsters should always check for ground
X	if (!ent->groundentity)
X		M_CheckGround (ent);
X
X	groundentity = ent->groundentity;
X
X	SV_CheckVelocity (ent);
X
X	if (groundentity)
X		wasonground = true;
X	else
X		wasonground = false;
X		
X	if (ent->avelocity[0] || ent->avelocity[1] || ent->avelocity[2])
X		SV_AddRotationalFriction (ent);
X
X	// add gravity except:
X	//   flying monsters
X	//   swimming monsters who are in the water
X	if (! wasonground)
X		if (!(ent->flags & FL_FLY))
X			if (!((ent->flags & FL_SWIM) && (ent->waterlevel > 2)))
X			{
X				if (ent->velocity[2] < sv_gravity->value*-0.1)
X					hitsound = true;
X				if (ent->waterlevel == 0)
X					SV_AddGravity (ent);
X			}
X
X	// friction for flying monsters that have been given vertical velocity
X	if ((ent->flags & FL_FLY) && (ent->velocity[2] != 0))
X	{
X		speed = fabs(ent->velocity[2]);
X		control = speed < sv_stopspeed->value ? sv_stopspeed->value : speed;
X		friction = sv_friction/3;
X		newspeed = speed - (FRAMETIME * control * friction);
X		if (newspeed < 0)
X			newspeed = 0;
X		newspeed /= speed;
X		ent->velocity[2] *= newspeed;
X	}
X
X	// friction for flying monsters that have been given vertical velocity
X	if ((ent->flags & FL_SWIM) && (ent->velocity[2] != 0))
X	{
X		speed = fabs(ent->velocity[2]);
X		control = speed < sv_stopspeed->value ? sv_stopspeed->value : speed;
X		newspeed = speed - (FRAMETIME * control * sv_waterfriction * ent->waterlevel);
X		if (newspeed < 0)
X			newspeed = 0;
X		newspeed /= speed;
X		ent->velocity[2] *= newspeed;
X	}
X
X	if (ent->velocity[2] || ent->velocity[1] || ent->velocity[0])
X	{
X		// apply friction
X		// let dead monsters who aren't completely onground slide
X		if ((wasonground) || (ent->flags & (FL_SWIM|FL_FLY)))
X			if (!(ent->health <= 0.0 && !M_CheckBottom(ent)))
X			{
X				vel = ent->velocity;
X				speed = sqrt(vel[0]*vel[0] +vel[1]*vel[1]);
X				if (speed)
X				{
X					friction = sv_friction;
X
X					control = speed < sv_stopspeed->value ? sv_stopspeed->value : speed;
X					newspeed = speed - FRAMETIME*control*friction;
X
X					if (newspeed < 0)
X						newspeed = 0;
X					newspeed /= speed;
X
X					vel[0] *= newspeed;
X					vel[1] *= newspeed;
X				}
X			}
X
X		if (ent->svflags & SVF_MONSTER)
X			mask = MASK_MONSTERSOLID;
X		else
X			mask = MASK_SOLID;
X		SV_FlyMove (ent, FRAMETIME, mask);
X
X		gi.linkentity (ent);
X
// ========
// PGM - reset this every time they move. 
//       G_touchtriggers will set it back if appropriate
X		ent->gravity = 1.0;
// ========
X		
X		G_TouchTriggers (ent);
X		if (!ent->inuse)
X			return;
X
X		if (ent->groundentity)
X			if (!wasonground)
X				if (hitsound)
X					gi.sound (ent, 0, gi.soundindex("world/land.wav"), 1, 1, 0);
X	}
X
X	if(!ent->inuse)			// PGM g_touchtrigger free problem
X		return;
X
// regular thinking
X	SV_RunThink (ent);
}
X
//============================================================================
/*
================
G_RunEntity
X
================
*/
void G_RunEntity (edict_t *ent)
{
//PGM
X	trace_t	trace;
X	vec3_t	previous_origin;
X
X	if(ent->movetype == MOVETYPE_STEP)
X		VectorCopy(ent->s.origin, previous_origin);
//PGM
X
X	if (ent->prethink)
X		ent->prethink (ent);
X
X	switch ( (int)ent->movetype)
X	{
X		case MOVETYPE_PUSH:
X		case MOVETYPE_STOP:
X			SV_Physics_Pusher (ent);
X			break;
X		case MOVETYPE_NONE:
X			SV_Physics_None (ent);
X			break;
X		case MOVETYPE_NOCLIP:
X			SV_Physics_Noclip (ent);
X			break;
X		case MOVETYPE_STEP:
X			SV_Physics_Step (ent);
X			break;
X		case MOVETYPE_TOSS:
X		case MOVETYPE_BOUNCE:
X		case MOVETYPE_FLY:
X		case MOVETYPE_FLYMISSILE:
X			SV_Physics_Toss (ent);
X			break;
X		case MOVETYPE_NEWTOSS:
X			SV_Physics_NewToss (ent);
X			break;
X		default:
X			gi.error ("SV_Physics: bad movetype %i", (int)ent->movetype);			
X	}
X
//PGM
X	if(ent->movetype == MOVETYPE_STEP)
X	{
X		// if we moved, check and fix origin if needed
X		if (!VectorCompare(ent->s.origin, previous_origin))
X		{
X			trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, previous_origin, ent, MASK_MONSTERSOLID);
X			if(trace.allsolid || trace.startsolid)
X				VectorCopy (previous_origin, ent->s.origin);
X		}
X	}
//PGM
}
X
//============
//ROGUE
/*
=============
SV_Physics_NewToss
X
Toss, bounce, and fly movement. When on ground and no velocity, do nothing. With velocity,
slide.
=============
*/
void SV_Physics_NewToss (edict_t *ent)
{
X	trace_t		trace;
X	vec3_t		move;
//	float		backoff;
X	edict_t		*slave;
X	qboolean	wasinwater;
X	qboolean	isinwater;
X	qboolean	wasonground;
X	float		speed, newspeed;
X	vec3_t		old_origin;
//	float		firstmove;
//	int			mask;
X
X	// regular thinking
X	SV_RunThink (ent);
X
X	// if not a team captain, so movement will be handled elsewhere
X	if ( ent->flags & FL_TEAMSLAVE)
X		return;
X
X	if (ent->groundentity)
X		wasonground = true;
X	else
X		wasonground = false;
X	
X	wasinwater = ent->waterlevel;
X
X	// find out what we're sitting on.
X	VectorCopy (ent->s.origin, move);
X	move[2] -= 0.25;
X	trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, move, ent, ent->clipmask);
X	if(ent->groundentity && ent->groundentity->inuse)
X		ent->groundentity = trace.ent;
X	else
X		ent->groundentity = NULL;
X
X	// if we're sitting on something flat and have no velocity of our own, return.
X	if (ent->groundentity && (trace.plane.normal[2] == 1.0) && 
X		!ent->velocity[0] && !ent->velocity[1] && !ent->velocity[2])
X	{
X		return;
X	}
X
X	// store the old origin
X	VectorCopy (ent->s.origin, old_origin);
X
X	SV_CheckVelocity (ent);
X
X	// add gravity
X	SV_AddGravity (ent);
X
X	if (ent->avelocity[0] || ent->avelocity[1] || ent->avelocity[2])
X		SV_AddRotationalFriction (ent);
X
X	// add friction
X	speed = VectorLength(ent->velocity);
X	if(ent->waterlevel)				// friction for water movement
X	{
X		newspeed = speed - (sv_waterfriction * 6 * ent->waterlevel);
X		if (newspeed < 0)
X			newspeed = 0;
X		newspeed /= speed;
X		VectorScale (ent->velocity, newspeed, ent->velocity);
X	}
X	else if (!ent->groundentity)	// friction for air movement
X	{
X		newspeed = speed - ((sv_friction));
X		if (newspeed < 0)
X			newspeed = 0;
X		newspeed /= speed;
X		VectorScale (ent->velocity, newspeed, ent->velocity);
X	}
X	else	// use ground friction
X	{
X		newspeed = speed - (sv_friction * 6);
X		if (newspeed < 0)
X			newspeed = 0;
X		newspeed /= speed;
X		VectorScale (ent->velocity, newspeed, ent->velocity);
X	}
X
X	SV_FlyMove (ent, FRAMETIME, ent->clipmask);
X	gi.linkentity (ent);
X
X	G_TouchTriggers (ent);
X
// check for water transition
X	wasinwater = (ent->watertype & MASK_WATER);
X	ent->watertype = gi.pointcontents (ent->s.origin);
X	isinwater = ent->watertype & MASK_WATER;
X
X	if (isinwater)
X		ent->waterlevel = 1;
X	else
X		ent->waterlevel = 0;
X
X	if (!wasinwater && isinwater)
X		gi.positioned_sound (old_origin, g_edicts, CHAN_AUTO, gi.soundindex("misc/h2ohit1.wav"), 1, 1, 0);
X	else if (wasinwater && !isinwater)
X		gi.positioned_sound (ent->s.origin, g_edicts, CHAN_AUTO, gi.soundindex("misc/h2ohit1.wav"), 1, 1, 0);
X
// move teamslaves
X	for (slave = ent->teamchain; slave; slave = slave->teamchain)
X	{
X		VectorCopy (ent->s.origin, slave->s.origin);
X		gi.linkentity (slave);
X	}
}
X
//ROGUE
//============
SHAR_EOF
  $shar_touch -am 1130175398 'g_phys.c' &&
  chmod 0664 'g_phys.c' ||
  $echo 'restore of' 'g_phys.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_phys.c:' 'MD5 check failed'
82af26be6d74fe0101620c7f3c9a380c  g_phys.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_phys.c'`"
    test 25071 -eq "$shar_count" ||
    $echo 'g_phys.c:' 'original size' '25071,' 'current size' "$shar_count!"
  fi
fi
# ============= g_save.c ==============
if test -f 'g_save.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_save.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_save.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_save.c' &&
X
#include "g_local.h"
X
#define Function(f) {#f, f}
X
mmove_t mmove_reloc;
X
field_t fields[] = {
X	{"classname", FOFS(classname), F_LSTRING},
X	{"model", FOFS(model), F_LSTRING},
X	{"spawnflags", FOFS(spawnflags), F_INT},
X	{"speed", FOFS(speed), F_FLOAT},
X	{"accel", FOFS(accel), F_FLOAT},
X	{"decel", FOFS(decel), F_FLOAT},
X	{"target", FOFS(target), F_LSTRING},
X	{"targetname", FOFS(targetname), F_LSTRING},
X	{"pathtarget", FOFS(pathtarget), F_LSTRING},
X	{"deathtarget", FOFS(deathtarget), F_LSTRING},
X	{"killtarget", FOFS(killtarget), F_LSTRING},
X	{"combattarget", FOFS(combattarget), F_LSTRING},
X	{"message", FOFS(message), F_LSTRING},
X	{"team", FOFS(team), F_LSTRING},
X	{"wait", FOFS(wait), F_FLOAT},
X	{"delay", FOFS(delay), F_FLOAT},
X	{"random", FOFS(random), F_FLOAT},
X	{"move_origin", FOFS(move_origin), F_VECTOR},
X	{"move_angles", FOFS(move_angles), F_VECTOR},
X	{"style", FOFS(style), F_INT},
X	{"count", FOFS(count), F_INT},
X	{"health", FOFS(health), F_INT},
X	{"sounds", FOFS(sounds), F_INT},
X	{"light", 0, F_IGNORE},
X	{"dmg", FOFS(dmg), F_INT},
X	{"mass", FOFS(mass), F_INT},
X	{"volume", FOFS(volume), F_FLOAT},
X	{"attenuation", FOFS(attenuation), F_FLOAT},
X	{"map", FOFS(map), F_LSTRING},
X	{"origin", FOFS(s.origin), F_VECTOR},
X	{"angles", FOFS(s.angles), F_VECTOR},
X	{"angle", FOFS(s.angles), F_ANGLEHACK},
X
X	{"goalentity", FOFS(goalentity), F_EDICT, FFL_NOSPAWN},
X	{"movetarget", FOFS(movetarget), F_EDICT, FFL_NOSPAWN},
X	{"enemy", FOFS(enemy), F_EDICT, FFL_NOSPAWN},
X	{"oldenemy", FOFS(oldenemy), F_EDICT, FFL_NOSPAWN},
X	{"activator", FOFS(activator), F_EDICT, FFL_NOSPAWN},
X	{"groundentity", FOFS(groundentity), F_EDICT, FFL_NOSPAWN},
X	{"teamchain", FOFS(teamchain), F_EDICT, FFL_NOSPAWN},
X	{"teammaster", FOFS(teammaster), F_EDICT, FFL_NOSPAWN},
X	{"owner", FOFS(owner), F_EDICT, FFL_NOSPAWN},
X	{"mynoise", FOFS(mynoise), F_EDICT, FFL_NOSPAWN},
X	{"mynoise2", FOFS(mynoise2), F_EDICT, FFL_NOSPAWN},
X	{"target_ent", FOFS(target_ent), F_EDICT, FFL_NOSPAWN},
X	{"chain", FOFS(chain), F_EDICT, FFL_NOSPAWN},
X
X	{"prethink", FOFS(prethink), F_FUNCTION, FFL_NOSPAWN},
X	{"think", FOFS(think), F_FUNCTION, FFL_NOSPAWN},
X	{"blocked", FOFS(blocked), F_FUNCTION, FFL_NOSPAWN},
X	{"touch", FOFS(touch), F_FUNCTION, FFL_NOSPAWN},
X	{"use", FOFS(use), F_FUNCTION, FFL_NOSPAWN},
X	{"pain", FOFS(pain), F_FUNCTION, FFL_NOSPAWN},
X	{"die", FOFS(die), F_FUNCTION, FFL_NOSPAWN},
X
X	{"stand", FOFS(monsterinfo.stand), F_FUNCTION, FFL_NOSPAWN},
X	{"idle", FOFS(monsterinfo.idle), F_FUNCTION, FFL_NOSPAWN},
X	{"search", FOFS(monsterinfo.search), F_FUNCTION, FFL_NOSPAWN},
X	{"walk", FOFS(monsterinfo.walk), F_FUNCTION, FFL_NOSPAWN},
X	{"run", FOFS(monsterinfo.run), F_FUNCTION, FFL_NOSPAWN},
X	{"dodge", FOFS(monsterinfo.dodge), F_FUNCTION, FFL_NOSPAWN},
X	{"attack", FOFS(monsterinfo.attack), F_FUNCTION, FFL_NOSPAWN},
X	{"melee", FOFS(monsterinfo.melee), F_FUNCTION, FFL_NOSPAWN},
X	{"sight", FOFS(monsterinfo.sight), F_FUNCTION, FFL_NOSPAWN},
X	{"checkattack", FOFS(monsterinfo.checkattack), F_FUNCTION, FFL_NOSPAWN},
X	{"currentmove", FOFS(monsterinfo.currentmove), F_MMOVE, FFL_NOSPAWN},
X
X	{"endfunc", FOFS(moveinfo.endfunc), F_FUNCTION, FFL_NOSPAWN},
X
X	// temp spawn vars -- only valid when the spawn function is called
X	{"lip", STOFS(lip), F_INT, FFL_SPAWNTEMP},
X	{"distance", STOFS(distance), F_INT, FFL_SPAWNTEMP},
X	{"height", STOFS(height), F_INT, FFL_SPAWNTEMP},
X	{"noise", STOFS(noise), F_LSTRING, FFL_SPAWNTEMP},
X	{"pausetime", STOFS(pausetime), F_FLOAT, FFL_SPAWNTEMP},
X	{"item", STOFS(item), F_LSTRING, FFL_SPAWNTEMP},
X
//need for item field in edict struct, FFL_SPAWNTEMP item will be skipped on saves
X	{"item", FOFS(item), F_ITEM},
X
X	{"gravity", STOFS(gravity), F_LSTRING, FFL_SPAWNTEMP},
X	{"sky", STOFS(sky), F_LSTRING, FFL_SPAWNTEMP},
X	{"skyrotate", STOFS(skyrotate), F_FLOAT, FFL_SPAWNTEMP},
X	{"skyaxis", STOFS(skyaxis), F_VECTOR, FFL_SPAWNTEMP},
X	{"minyaw", STOFS(minyaw), F_FLOAT, FFL_SPAWNTEMP},
X	{"maxyaw", STOFS(maxyaw), F_FLOAT, FFL_SPAWNTEMP},
X	{"minpitch", STOFS(minpitch), F_FLOAT, FFL_SPAWNTEMP},
X	{"maxpitch", STOFS(maxpitch), F_FLOAT, FFL_SPAWNTEMP},
X	{"nextmap", STOFS(nextmap), F_LSTRING, FFL_SPAWNTEMP},
X
X	// ROGUE
X	{"bad_area", FOFS(bad_area), F_EDICT},
X	// while the hint_path stuff could be reassembled on the fly, no reason to be different
X	{"hint_chain", FOFS(hint_chain), F_EDICT},
X	{"monster_hint_chain", FOFS(monster_hint_chain), F_EDICT},
X	{"target_hint_chain", FOFS(target_hint_chain), F_EDICT},
X	//
X	{"goal_hint", FOFS(monsterinfo.goal_hint), F_EDICT},
X	{"badMedic1", FOFS(monsterinfo.badMedic1), F_EDICT},
X	{"badMedic2", FOFS(monsterinfo.badMedic2), F_EDICT},
X	{"last_player_enemy", FOFS(monsterinfo.last_player_enemy), F_EDICT},
X	{"commander", FOFS(monsterinfo.commander), F_EDICT},
X	{"blocked", FOFS(monsterinfo.blocked), F_MMOVE, FFL_NOSPAWN},
X	{"duck", FOFS(monsterinfo.duck), F_MMOVE, FFL_NOSPAWN},
X	{"unduck", FOFS(monsterinfo.unduck), F_MMOVE, FFL_NOSPAWN},
X	{"sidestep", FOFS(monsterinfo.sidestep), F_MMOVE, FFL_NOSPAWN},
X	// ROGUE	
X
X	{0, 0, 0, 0}
X
};
X
field_t		levelfields[] =
{
X	{"changemap", LLOFS(changemap), F_LSTRING},
X                   
X	{"sight_client", LLOFS(sight_client), F_EDICT},
X	{"sight_entity", LLOFS(sight_entity), F_EDICT},
X	{"sound_entity", LLOFS(sound_entity), F_EDICT},
X	{"sound2_entity", LLOFS(sound2_entity), F_EDICT},
X
X	// ROGUE
X	{"disguise_violator", LLOFS(disguise_violator), F_EDICT},
X	// ROGUE
X
X	{NULL, 0, F_INT}
};
X
field_t		clientfields[] =
{
X	{"pers.weapon", CLOFS(pers.weapon), F_ITEM},
X	{"pers.lastweapon", CLOFS(pers.lastweapon), F_ITEM},
X	{"newweapon", CLOFS(newweapon), F_ITEM},
X	// ROGUE
X	{"owned_sphere", CLOFS(owned_sphere), F_EDICT},
X	// ROGUE
X
X	{NULL, 0, F_INT}
};
X
/*
============
InitGame
X
This will be called when the dll is first loaded, which
only happens when a new game is started or a save game
is loaded.
============
*/
void InitGame (void)
{
X	gi.dprintf ("==== InitGame ====\n");
X
X	gun_x = gi.cvar ("gun_x", "0", 0);
X	gun_y = gi.cvar ("gun_y", "0", 0);
X	gun_z = gi.cvar ("gun_z", "0", 0);
X
X	//FIXME: sv_ prefix is wrong for these
X	sv_rollspeed = gi.cvar ("sv_rollspeed", "200", 0);
X	sv_rollangle = gi.cvar ("sv_rollangle", "2", 0);
X	sv_maxvelocity = gi.cvar ("sv_maxvelocity", "2000", 0);
X	sv_gravity = gi.cvar ("sv_gravity", "800", 0);
X
X	sv_stopspeed = gi.cvar ("sv_stopspeed", "100", 0);		// PGM - was #define in g_phys.c
X
//ROGUE
X	g_showlogic = gi.cvar ("g_showlogic", "0", 0);
X	huntercam = gi.cvar ("huntercam", "1", CVAR_SERVERINFO|CVAR_LATCH);
X	strong_mines = gi.cvar ("strong_mines", "0", 0);
X	randomrespawn = gi.cvar ("randomrespawn", "0", 0);
//ROGUE
X
X	// noset vars
X	dedicated = gi.cvar ("dedicated", "0", CVAR_NOSET);
X
X	// latched vars
X	sv_cheats = gi.cvar ("cheats", "0", CVAR_SERVERINFO|CVAR_LATCH);
X	gi.cvar ("gamename", GAMEVERSION , CVAR_SERVERINFO | CVAR_LATCH);
X	gi.cvar ("gamedate", __DATE__ , CVAR_SERVERINFO | CVAR_LATCH);
X
X	maxclients = gi.cvar ("maxclients", "4", CVAR_SERVERINFO | CVAR_LATCH);
X	maxspectators = gi.cvar ("maxspectators", "4", CVAR_SERVERINFO);
X	deathmatch = gi.cvar ("deathmatch", "0", CVAR_LATCH);
X	coop = gi.cvar ("coop", "0", CVAR_LATCH);
X	skill = gi.cvar ("skill", "1", CVAR_LATCH);
X	maxentities = gi.cvar ("maxentities", "1024", CVAR_LATCH);
X	gamerules = gi.cvar ("gamerules", "0", CVAR_LATCH);			//PGM
X
X	// change anytime vars
X	dmflags = gi.cvar ("dmflags", "0", CVAR_SERVERINFO);
X	fraglimit = gi.cvar ("fraglimit", "0", CVAR_SERVERINFO);
X	timelimit = gi.cvar ("timelimit", "0", CVAR_SERVERINFO);
X	password = gi.cvar ("password", "", CVAR_USERINFO);
X	spectator_password = gi.cvar ("spectator_password", "", CVAR_USERINFO);
X	filterban = gi.cvar ("filterban", "1", 0);
X
X	g_select_empty = gi.cvar ("g_select_empty", "0", CVAR_ARCHIVE);
X
X	run_pitch = gi.cvar ("run_pitch", "0.002", 0);
X	run_roll = gi.cvar ("run_roll", "0.005", 0);
X	bob_up  = gi.cvar ("bob_up", "0.005", 0);
X	bob_pitch = gi.cvar ("bob_pitch", "0.002", 0);
X	bob_roll = gi.cvar ("bob_roll", "0.002", 0);
X
X	// flood control
X	flood_msgs = gi.cvar ("flood_msgs", "4", 0);
X	flood_persecond = gi.cvar ("flood_persecond", "4", 0);
X	flood_waitdelay = gi.cvar ("flood_waitdelay", "10", 0);
X
X	// dm map list
X	sv_maplist = gi.cvar ("sv_maplist", "", 0);
X
X	// items
X	InitItems ();
X
X	Com_sprintf (game.helpmessage1, sizeof(game.helpmessage1), "");
X
X	Com_sprintf (game.helpmessage2, sizeof(game.helpmessage2), "");
X
X	// initialize all entities for this game
X	game.maxentities = maxentities->value;
X	g_edicts =  gi.TagMalloc (game.maxentities * sizeof(g_edicts[0]), TAG_GAME);
X	globals.edicts = g_edicts;
X	globals.max_edicts = game.maxentities;
X
X	// initialize all clients for this game
X	game.maxclients = maxclients->value;
X	game.clients = gi.TagMalloc (game.maxclients * sizeof(game.clients[0]), TAG_GAME);
X	globals.num_edicts = game.maxclients+1;
X
//======
//ROGUE
X	if(gamerules)
X	{
X		InitGameRules();	// if there are game rules to set up, do so now.
X	}
//ROGUE
//======
}
X
//=========================================================
X
void WriteField1 (FILE *f, field_t *field, byte *base)
{
X	void		*p;
X	int			len;
X	int			index;
X
X	if (field->flags & FFL_SPAWNTEMP)
X		return;
X
X	p = (void *)(base + field->ofs);
X	switch (field->type)
X	{
X	case F_INT:
X	case F_FLOAT:
X	case F_ANGLEHACK:
X	case F_VECTOR:
X	case F_IGNORE:
X		break;
X
X	case F_LSTRING:
X	case F_GSTRING:
X		if ( *(char **)p )
X			len = strlen(*(char **)p) + 1;
X		else
X			len = 0;
X		*(int *)p = len;
X		break;
X	case F_EDICT:
X		if ( *(edict_t **)p == NULL)
X			index = -1;
X		else
X			index = *(edict_t **)p - g_edicts;
X		*(int *)p = index;
X		break;
X	case F_CLIENT:
X		if ( *(gclient_t **)p == NULL)
X			index = -1;
X		else
X			index = *(gclient_t **)p - game.clients;
X		*(int *)p = index;
X		break;
X	case F_ITEM:
X		if ( *(edict_t **)p == NULL)
X			index = -1;
X		else
X			index = *(gitem_t **)p - itemlist;
X		*(int *)p = index;
X		break;
X
X	//relative to code segment
X	case F_FUNCTION:
X		if (*(byte **)p == NULL)
X			index = 0;
X		else
X			index = *(byte **)p - ((byte *)InitGame);
X		*(int *)p = index;
X		break;
X
X	//relative to data segment
X	case F_MMOVE:
X		if (*(byte **)p == NULL)
X			index = 0;
X		else
X			index = *(byte **)p - (byte *)&mmove_reloc;
X		*(int *)p = index;
X		break;
X
X	default:
X		gi.error ("WriteEdict: unknown field type");
X	}
}
X
X
void WriteField2 (FILE *f, field_t *field, byte *base)
{
X	int			len;
X	void		*p;
X
X	if (field->flags & FFL_SPAWNTEMP)
X		return;
X
X	p = (void *)(base + field->ofs);
X	switch (field->type)
X	{
X	case F_LSTRING:
X		if ( *(char **)p )
X		{
X			len = strlen(*(char **)p) + 1;
X			fwrite (*(char **)p, len, 1, f);
X		}
X		break;
X	}
}
X
void ReadField (FILE *f, field_t *field, byte *base)
{
X	void		*p;
X	int			len;
X	int			index;
X
X	if (field->flags & FFL_SPAWNTEMP)
X		return;
X
X	p = (void *)(base + field->ofs);
X	switch (field->type)
X	{
X	case F_INT:
X	case F_FLOAT:
X	case F_ANGLEHACK:
X	case F_VECTOR:
X	case F_IGNORE:
X		break;
X
X	case F_LSTRING:
X		len = *(int *)p;
X		if (!len)
X			*(char **)p = NULL;
X		else
X		{
X			*(char **)p = gi.TagMalloc (len, TAG_LEVEL);
X			fread (*(char **)p, len, 1, f);
X		}
X		break;
X	case F_EDICT:
X		index = *(int *)p;
X		if ( index == -1 )
X			*(edict_t **)p = NULL;
X		else
X			*(edict_t **)p = &g_edicts[index];
X		break;
X	case F_CLIENT:
X		index = *(int *)p;
X		if ( index == -1 )
X			*(gclient_t **)p = NULL;
X		else
X			*(gclient_t **)p = &game.clients[index];
X		break;
X	case F_ITEM:
X		index = *(int *)p;
X		if ( index == -1 )
X			*(gitem_t **)p = NULL;
X		else
X			*(gitem_t **)p = &itemlist[index];
X		break;
X
X	//relative to code segment
X	case F_FUNCTION:
X		index = *(int *)p;
X		if ( index == 0 )
X			*(byte **)p = NULL;
X		else
X			*(byte **)p = ((byte *)InitGame) + index;
X		break;
X
X	//relative to data segment
X	case F_MMOVE:
X		index = *(int *)p;
X		if (index == 0)
X			*(byte **)p = NULL;
X		else
X			*(byte **)p = (byte *)&mmove_reloc + index;
X		break;
X
X	default:
X		gi.error ("ReadEdict: unknown field type");
X	}
}
X
//=========================================================
X
/*
==============
WriteClient
X
All pointer variables (except function pointers) must be handled specially.
==============
*/
void WriteClient (FILE *f, gclient_t *client)
{
X	field_t		*field;
X	gclient_t	temp;
X	
X	// all of the ints, floats, and vectors stay as they are
X	temp = *client;
X
X	// change the pointers to lengths or indexes
X	for (field=clientfields ; field->name ; field++)
X	{
X		WriteField1 (f, field, (byte *)&temp);
X	}
X
X	// write the block
X	fwrite (&temp, sizeof(temp), 1, f);
X
X	// now write any allocated data following the edict
X	for (field=clientfields ; field->name ; field++)
X	{
X		WriteField2 (f, field, (byte *)client);
X	}
}
X
/*
==============
ReadClient
X
All pointer variables (except function pointers) must be handled specially.
==============
*/
void ReadClient (FILE *f, gclient_t *client)
{
X	field_t		*field;
X
X	fread (client, sizeof(*client), 1, f);
X
X	for (field=clientfields ; field->name ; field++)
X	{
X		ReadField (f, field, (byte *)client);
X	}
}
X
/*
============
WriteGame
X
This will be called whenever the game goes to a new level,
and when the user explicitly saves the game.
X
Game information include cross level data, like multi level
triggers, help computer info, and all client states.
X
A single player death will automatically restore from the
last save position.
============
*/
void WriteGame (char *filename, qboolean autosave)
{
X	FILE	*f;
X	int		i;
X	char	str[16];
X
X	if (!autosave)
X		SaveClientData ();
X
X	f = fopen (filename, "wb");
X	if (!f)
X		gi.error ("Couldn't open %s", filename);
X
X	memset (str, 0, sizeof(str));
X	strcpy (str, __DATE__);
X	fwrite (str, sizeof(str), 1, f);
X
X	game.autosaved = autosave;
X	fwrite (&game, sizeof(game), 1, f);
X	game.autosaved = false;
X
X	for (i=0 ; i<game.maxclients ; i++)
X		WriteClient (f, &game.clients[i]);
X
X	fclose (f);
}
X
void ReadGame (char *filename)
{
X	FILE	*f;
X	int		i;
X	char	str[16];
X
X	gi.FreeTags (TAG_GAME);
X
X	f = fopen (filename, "rb");
X	if (!f)
X		gi.error ("Couldn't open %s", filename);
X
X	fread (str, sizeof(str), 1, f);
X	if (strcmp (str, __DATE__))
X	{
X		fclose (f);
X		gi.error ("Savegame from an older version.\n");
X	}
X
X	g_edicts =  gi.TagMalloc (game.maxentities * sizeof(g_edicts[0]), TAG_GAME);
X	globals.edicts = g_edicts;
X
X	fread (&game, sizeof(game), 1, f);
X	game.clients = gi.TagMalloc (game.maxclients * sizeof(game.clients[0]), TAG_GAME);
X	for (i=0 ; i<game.maxclients ; i++)
X		ReadClient (f, &game.clients[i]);
X
X	fclose (f);
}
X
//==========================================================
X
X
/*
==============
WriteEdict
X
All pointer variables (except function pointers) must be handled specially.
==============
*/
void WriteEdict (FILE *f, edict_t *ent)
{
X	field_t		*field;
X	edict_t		temp;
X
X	// all of the ints, floats, and vectors stay as they are
X	temp = *ent;
X
X	// change the pointers to lengths or indexes
X	for (field=fields ; field->name ; field++)
X	{
X		WriteField1 (f, field, (byte *)&temp);
X	}
X
X	// write the block
X	fwrite (&temp, sizeof(temp), 1, f);
X
X	// now write any allocated data following the edict
X	for (field=fields ; field->name ; field++)
X	{
X		WriteField2 (f, field, (byte *)ent);
X	}
X
}
X
/*
==============
WriteLevelLocals
X
All pointer variables (except function pointers) must be handled specially.
==============
*/
void WriteLevelLocals (FILE *f)
{
X	field_t		*field;
X	level_locals_t		temp;
X
X	// all of the ints, floats, and vectors stay as they are
X	temp = level;
X
X	// change the pointers to lengths or indexes
X	for (field=levelfields ; field->name ; field++)
X	{
X		WriteField1 (f, field, (byte *)&temp);
X	}
X
X	// write the block
X	fwrite (&temp, sizeof(temp), 1, f);
X
X	// now write any allocated data following the edict
X	for (field=levelfields ; field->name ; field++)
X	{
X		WriteField2 (f, field, (byte *)&level);
X	}
}
X
X
/*
==============
ReadEdict
X
All pointer variables (except function pointers) must be handled specially.
==============
*/
void ReadEdict (FILE *f, edict_t *ent)
{
X	field_t		*field;
X
X	fread (ent, sizeof(*ent), 1, f);
X
X	for (field=fields ; field->name ; field++)
X	{
X		ReadField (f, field, (byte *)ent);
X	}
}
X
/*
==============
ReadLevelLocals
X
All pointer variables (except function pointers) must be handled specially.
==============
*/
void ReadLevelLocals (FILE *f)
{
X	field_t		*field;
X
X	fread (&level, sizeof(level), 1, f);
X
X	for (field=levelfields ; field->name ; field++)
X	{
X		ReadField (f, field, (byte *)&level);
X	}
}
X
/*
=================
WriteLevel
X
=================
*/
void WriteLevel (char *filename)
{
X	int		i;
X	edict_t	*ent;
X	FILE	*f;
X	void	*base;
X
X	f = fopen (filename, "wb");
X	if (!f)
X		gi.error ("Couldn't open %s", filename);
X
X	// write out edict size for checking
X	i = sizeof(edict_t);
X	fwrite (&i, sizeof(i), 1, f);
X
X	// write out a function pointer for checking
X	base = (void *)InitGame;
X	fwrite (&base, sizeof(base), 1, f);
X
X	// write out level_locals_t
X	WriteLevelLocals (f);
X
X	// write out all the entities
X	for (i=0 ; i<globals.num_edicts ; i++)
X	{
X		ent = &g_edicts[i];
X		if (!ent->inuse)
X			continue;
X		fwrite (&i, sizeof(i), 1, f);
X		WriteEdict (f, ent);
X	}
X	i = -1;
X	fwrite (&i, sizeof(i), 1, f);
X
X	fclose (f);
}
X
X
/*
=================
ReadLevel
X
SpawnEntities will already have been called on the
level the same way it was when the level was saved.
X
That is necessary to get the baselines
set up identically.
X
The server will have cleared all of the world links before
calling ReadLevel.
X
No clients are connected yet.
=================
*/
void ReadLevel (char *filename)
{
X	int		entnum;
X	FILE	*f;
X	int		i;
X	void	*base;
X	edict_t	*ent;
X
X	f = fopen (filename, "rb");
X	if (!f)
X		gi.error ("Couldn't open %s", filename);
X
X	// free any dynamic memory allocated by loading the level
X	// base state
X	gi.FreeTags (TAG_LEVEL);
X
X	// wipe all the entities
X	memset (g_edicts, 0, game.maxentities*sizeof(g_edicts[0]));
X	globals.num_edicts = maxclients->value+1;
X
X	// check edict size
X	fread (&i, sizeof(i), 1, f);
X	if (i != sizeof(edict_t))
X	{
X		fclose (f);
X		gi.error ("ReadLevel: mismatched edict size");
X	}
X
X	// check function pointer base address
X	fread (&base, sizeof(base), 1, f);
#ifdef _WIN32
X	if (base != (void *)InitGame)
X	{
X		fclose (f);
X		gi.error ("ReadLevel: function pointers have moved");
X	}
#else
X	gi.dprintf("Function offsets %d\n", ((byte *)base) - ((byte *)InitGame));
#endif
X
X	// load the level locals
X	ReadLevelLocals (f);
X
X	// load all the entities
X	while (1)
X	{
X		if (fread (&entnum, sizeof(entnum), 1, f) != 1)
X		{
X			fclose (f);
X			gi.error ("ReadLevel: failed to read entnum");
X		}
X		if (entnum == -1)
X			break;
X		if (entnum >= globals.num_edicts)
X			globals.num_edicts = entnum+1;
X
X		ent = &g_edicts[entnum];
X		ReadEdict (f, ent);
X
X		// let the server rebuild world links for this ent
X		memset (&ent->area, 0, sizeof(ent->area));
X		gi.linkentity (ent);
X	}
X
X	fclose (f);
X
X	// PMM - rebuild the hint path chains
//	InitHintPaths();
X	// pmm
X
X	// mark all clients as unconnected
X	for (i=0 ; i<maxclients->value ; i++)
X	{
X		ent = &g_edicts[i+1];
X		ent->client = game.clients + i;
X		ent->client->pers.connected = false;
X	}
X
X	// do any load time things at this point
X	for (i=0 ; i<globals.num_edicts ; i++)
X	{
X		ent = &g_edicts[i];
X
X		if (!ent->inuse)
X			continue;
X
X		// fire any cross-level triggers
X		if (ent->classname)
X			if (strcmp(ent->classname, "target_crosslevel_target") == 0)
X				ent->nextthink = level.time + ent->delay;
X	}
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_save.c' &&
  chmod 0664 'g_save.c' ||
  $echo 'restore of' 'g_save.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_save.c:' 'MD5 check failed'
94a8c5c4dd348af736210fa84283ba12  g_save.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_save.c'`"
    test 19126 -eq "$shar_count" ||
    $echo 'g_save.c:' 'original size' '19126,' 'current size' "$shar_count!"
  fi
fi
# ============= g_spawn.c ==============
if test -f 'g_spawn.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_spawn.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_spawn.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_spawn.c' &&
X
#include "g_local.h"
X
typedef struct
{
X	char	*name;
X	void	(*spawn)(edict_t *ent);
} spawn_t;
X
X
void SP_item_health (edict_t *self);
void SP_item_health_small (edict_t *self);
void SP_item_health_large (edict_t *self);
void SP_item_health_mega (edict_t *self);
X
void SP_info_player_start (edict_t *ent);
void SP_info_player_deathmatch (edict_t *ent);
void SP_info_player_coop (edict_t *ent);
void SP_info_player_intermission (edict_t *ent);
X
void SP_func_plat (edict_t *ent);
void SP_func_rotating (edict_t *ent);
void SP_func_button (edict_t *ent);
void SP_func_door (edict_t *ent);
void SP_func_door_secret (edict_t *ent);
void SP_func_door_rotating (edict_t *ent);
void SP_func_water (edict_t *ent);
void SP_func_train (edict_t *ent);
void SP_func_conveyor (edict_t *self);
void SP_func_wall (edict_t *self);
void SP_func_object (edict_t *self);
void SP_func_explosive (edict_t *self);
void SP_func_timer (edict_t *self);
void SP_func_areaportal (edict_t *ent);
void SP_func_clock (edict_t *ent);
void SP_func_killbox (edict_t *ent);
X
void SP_trigger_always (edict_t *ent);
void SP_trigger_once (edict_t *ent);
void SP_trigger_multiple (edict_t *ent);
void SP_trigger_relay (edict_t *ent);
void SP_trigger_push (edict_t *ent);
void SP_trigger_hurt (edict_t *ent);
void SP_trigger_key (edict_t *ent);
void SP_trigger_counter (edict_t *ent);
void SP_trigger_elevator (edict_t *ent);
void SP_trigger_gravity (edict_t *ent);
void SP_trigger_monsterjump (edict_t *ent);
X
void SP_target_temp_entity (edict_t *ent);
void SP_target_speaker (edict_t *ent);
void SP_target_explosion (edict_t *ent);
void SP_target_changelevel (edict_t *ent);
void SP_target_secret (edict_t *ent);
void SP_target_goal (edict_t *ent);
void SP_target_splash (edict_t *ent);
void SP_target_spawner (edict_t *ent);
void SP_target_blaster (edict_t *ent);
void SP_target_crosslevel_trigger (edict_t *ent);
void SP_target_crosslevel_target (edict_t *ent);
void SP_target_laser (edict_t *self);
void SP_target_help (edict_t *ent);
void SP_target_actor (edict_t *ent);
void SP_target_lightramp (edict_t *self);
void SP_target_earthquake (edict_t *ent);
void SP_target_character (edict_t *ent);
void SP_target_string (edict_t *ent);
X
void SP_worldspawn (edict_t *ent);
void SP_viewthing (edict_t *ent);
X
void SP_light (edict_t *self);
void SP_light_mine1 (edict_t *ent);
void SP_light_mine2 (edict_t *ent);
void SP_info_null (edict_t *self);
void SP_info_notnull (edict_t *self);
void SP_path_corner (edict_t *self);
void SP_point_combat (edict_t *self);
X
void SP_misc_explobox (edict_t *self);
void SP_misc_banner (edict_t *self);
void SP_misc_satellite_dish (edict_t *self);
void SP_misc_actor (edict_t *self);
void SP_misc_gib_arm (edict_t *self);
void SP_misc_gib_leg (edict_t *self);
void SP_misc_gib_head (edict_t *self);
void SP_misc_insane (edict_t *self);
void SP_misc_deadsoldier (edict_t *self);
void SP_misc_viper (edict_t *self);
void SP_misc_viper_bomb (edict_t *self);
void SP_misc_bigviper (edict_t *self);
void SP_misc_strogg_ship (edict_t *self);
void SP_misc_teleporter (edict_t *self);
void SP_misc_teleporter_dest (edict_t *self);
void SP_misc_blackhole (edict_t *self);
void SP_misc_eastertank (edict_t *self);
void SP_misc_easterchick (edict_t *self);
void SP_misc_easterchick2 (edict_t *self);
X
void SP_monster_berserk (edict_t *self);
void SP_monster_gladiator (edict_t *self);
void SP_monster_gunner (edict_t *self);
void SP_monster_infantry (edict_t *self);
void SP_monster_soldier_light (edict_t *self);
void SP_monster_soldier (edict_t *self);
void SP_monster_soldier_ss (edict_t *self);
void SP_monster_tank (edict_t *self);
void SP_monster_medic (edict_t *self);
void SP_monster_flipper (edict_t *self);
void SP_monster_chick (edict_t *self);
void SP_monster_parasite (edict_t *self);
void SP_monster_flyer (edict_t *self);
void SP_monster_brain (edict_t *self);
void SP_monster_floater (edict_t *self);
void SP_monster_hover (edict_t *self);
void SP_monster_mutant (edict_t *self);
void SP_monster_supertank (edict_t *self);
void SP_monster_boss2 (edict_t *self);
void SP_monster_jorg (edict_t *self);
void SP_monster_boss3_stand (edict_t *self);
X
void SP_monster_commander_body (edict_t *self);
X
void SP_turret_breach (edict_t *self);
void SP_turret_base (edict_t *self);
void SP_turret_driver (edict_t *self);
X
//===========
//ROGUE
void SP_func_plat2 (edict_t *ent);
void SP_func_door_secret2(edict_t *ent);
void SP_func_force_wall(edict_t *ent);
void SP_info_player_coop_lava (edict_t *self);
void SP_info_teleport_destination (edict_t *self);
void SP_trigger_teleport (edict_t *self);
void SP_trigger_disguise (edict_t *self);
void SP_monster_stalker (edict_t *self);
void SP_monster_turret (edict_t *self);
void SP_target_steam (edict_t *self);
void SP_target_anger (edict_t *self);
void SP_target_killplayers (edict_t *self);
// PMM - still experimental!
void SP_target_blacklight (edict_t *self);
void SP_target_orb (edict_t *self);
// pmm
//void SP_target_spawn (edict_t *self);
void SP_hint_path (edict_t *self);
void SP_monster_carrier (edict_t *self);
void SP_monster_widow (edict_t *self);
void SP_monster_widow2 (edict_t *self);
void SP_dm_tag_token (edict_t *self);
void SP_dm_dball_goal (edict_t *self);
void SP_dm_dball_ball (edict_t *self);
void SP_dm_dball_team1_start (edict_t *self);
void SP_dm_dball_team2_start (edict_t *self);
void SP_dm_dball_ball_start (edict_t *self);
void SP_dm_dball_speed_change (edict_t *self);
void SP_monster_kamikaze (edict_t *self);
//void SP_monster_chick2 (edict_t *self);
void SP_turret_invisible_brain (edict_t *self);
void SP_xatrix_item (edict_t *self);
void SP_misc_nuke_core (edict_t *self);
//ROGUE
//===========
X
spawn_t	spawns[] = {
X	{"item_health", SP_item_health},
X	{"item_health_small", SP_item_health_small},
X	{"item_health_large", SP_item_health_large},
X	{"item_health_mega", SP_item_health_mega},
X
X	{"info_player_start", SP_info_player_start},
X	{"info_player_deathmatch", SP_info_player_deathmatch},
X	{"info_player_coop", SP_info_player_coop},
X	{"info_player_intermission", SP_info_player_intermission},
X
X	{"func_plat", SP_func_plat},
X	{"func_button", SP_func_button},
X	{"func_door", SP_func_door},
X	{"func_door_secret", SP_func_door_secret},
X	{"func_door_rotating", SP_func_door_rotating},
X	{"func_rotating", SP_func_rotating},
X	{"func_train", SP_func_train},
X	{"func_water", SP_func_water},
X	{"func_conveyor", SP_func_conveyor},
X	{"func_areaportal", SP_func_areaportal},
X	{"func_clock", SP_func_clock},
X	{"func_wall", SP_func_wall},
X	{"func_object", SP_func_object},
X	{"func_timer", SP_func_timer},
X	{"func_explosive", SP_func_explosive},
X	{"func_killbox", SP_func_killbox},
X
X	{"trigger_always", SP_trigger_always},
X	{"trigger_once", SP_trigger_once},
X	{"trigger_multiple", SP_trigger_multiple},
X	{"trigger_relay", SP_trigger_relay},
X	{"trigger_push", SP_trigger_push},
X	{"trigger_hurt", SP_trigger_hurt},
X	{"trigger_key", SP_trigger_key},
X	{"trigger_counter", SP_trigger_counter},
X	{"trigger_elevator", SP_trigger_elevator},
X	{"trigger_gravity", SP_trigger_gravity},
X	{"trigger_monsterjump", SP_trigger_monsterjump},
X
X	{"target_temp_entity", SP_target_temp_entity},
X	{"target_speaker", SP_target_speaker},
X	{"target_explosion", SP_target_explosion},
X	{"target_changelevel", SP_target_changelevel},
X	{"target_secret", SP_target_secret},
X	{"target_goal", SP_target_goal},
X	{"target_splash", SP_target_splash},
X	{"target_spawner", SP_target_spawner},
X	{"target_blaster", SP_target_blaster},
X	{"target_crosslevel_trigger", SP_target_crosslevel_trigger},
X	{"target_crosslevel_target", SP_target_crosslevel_target},
X	{"target_laser", SP_target_laser},
X	{"target_help", SP_target_help},
X	{"target_actor", SP_target_actor},
X	{"target_lightramp", SP_target_lightramp},
X	{"target_earthquake", SP_target_earthquake},
X	{"target_character", SP_target_character},
X	{"target_string", SP_target_string},
X
X	{"worldspawn", SP_worldspawn},
X	{"viewthing", SP_viewthing},
X
X	{"light", SP_light},
X	{"light_mine1", SP_light_mine1},
X	{"light_mine2", SP_light_mine2},
X	{"info_null", SP_info_null},
X	{"func_group", SP_info_null},
X	{"info_notnull", SP_info_notnull},
X	{"path_corner", SP_path_corner},
X	{"point_combat", SP_point_combat},
X
X	{"misc_explobox", SP_misc_explobox},
X	{"misc_banner", SP_misc_banner},
X	{"misc_satellite_dish", SP_misc_satellite_dish},
X	{"misc_actor", SP_misc_actor},
X	{"misc_gib_arm", SP_misc_gib_arm},
X	{"misc_gib_leg", SP_misc_gib_leg},
X	{"misc_gib_head", SP_misc_gib_head},
X	{"misc_insane", SP_misc_insane},
X	{"misc_deadsoldier", SP_misc_deadsoldier},
X	{"misc_viper", SP_misc_viper},
X	{"misc_viper_bomb", SP_misc_viper_bomb},
X	{"misc_bigviper", SP_misc_bigviper},
X	{"misc_strogg_ship", SP_misc_strogg_ship},
X	{"misc_teleporter", SP_misc_teleporter},
X	{"misc_teleporter_dest", SP_misc_teleporter_dest},
X	{"misc_blackhole", SP_misc_blackhole},
X	{"misc_eastertank", SP_misc_eastertank},
X	{"misc_easterchick", SP_misc_easterchick},
X	{"misc_easterchick2", SP_misc_easterchick2},
X
X	{"monster_berserk", SP_monster_berserk},
X	{"monster_gladiator", SP_monster_gladiator},
X	{"monster_gunner", SP_monster_gunner},
X	{"monster_infantry", SP_monster_infantry},
X	{"monster_soldier_light", SP_monster_soldier_light},
X	{"monster_soldier", SP_monster_soldier},
X	{"monster_soldier_ss", SP_monster_soldier_ss},
X	{"monster_tank", SP_monster_tank},
X	{"monster_tank_commander", SP_monster_tank},
X	{"monster_medic", SP_monster_medic},
X	{"monster_flipper", SP_monster_flipper},
X	{"monster_chick", SP_monster_chick},
X	{"monster_parasite", SP_monster_parasite},
X	{"monster_flyer", SP_monster_flyer},
X	{"monster_brain", SP_monster_brain},
X	{"monster_floater", SP_monster_floater},
X	{"monster_hover", SP_monster_hover},
X	{"monster_mutant", SP_monster_mutant},
X	{"monster_supertank", SP_monster_supertank},
X	{"monster_boss2", SP_monster_boss2},
X	{"monster_boss3_stand", SP_monster_boss3_stand},
X	{"monster_jorg", SP_monster_jorg},
X
X	{"monster_commander_body", SP_monster_commander_body},
X
X	{"turret_breach", SP_turret_breach},
X	{"turret_base", SP_turret_base},
X	{"turret_driver", SP_turret_driver},
X
//==============
//ROGUE
X	{"func_plat2", SP_func_plat2},
X	{"func_door_secret2", SP_func_door_secret2},
X	{"func_force_wall", SP_func_force_wall},
X	{"trigger_teleport", SP_trigger_teleport},
X	{"trigger_disguise", SP_trigger_disguise},
X	{"info_teleport_destination", SP_info_teleport_destination},
X	{"info_player_coop_lava", SP_info_player_coop_lava},
X	{"monster_stalker", SP_monster_stalker},
X	{"monster_turret", SP_monster_turret},
X	{"target_steam", SP_target_steam},
X	{"target_anger", SP_target_anger},
//	{"target_spawn", SP_target_spawn},
X	{"target_killplayers", SP_target_killplayers},
X	// PMM - experiment
X	{"target_blacklight", SP_target_blacklight},
X	{"target_orb", SP_target_orb},
X	// pmm
X	{"monster_daedalus", SP_monster_hover},
X	{"hint_path", SP_hint_path},
X	{"monster_carrier", SP_monster_carrier},
X	{"monster_widow", SP_monster_widow},
X	{"monster_widow2", SP_monster_widow2},
X	{"monster_medic_commander", SP_monster_medic},
X	{"dm_tag_token", SP_dm_tag_token},
X	{"dm_dball_goal", SP_dm_dball_goal},
X	{"dm_dball_ball", SP_dm_dball_ball},
X	{"dm_dball_team1_start", SP_dm_dball_team1_start},
X	{"dm_dball_team2_start", SP_dm_dball_team2_start},
X	{"dm_dball_ball_start", SP_dm_dball_ball_start},
X	{"dm_dball_speed_change", SP_dm_dball_speed_change},
X	{"monster_kamikaze", SP_monster_kamikaze},
//	{"monster_chick2", SP_monster_chick2},
X	{"turret_invisible_brain", SP_turret_invisible_brain},
X	{"misc_nuke_core", SP_misc_nuke_core},
X
X	{"ammo_magslug", SP_xatrix_item},
X	{"ammo_trap", SP_xatrix_item},
X	{"item_quadfire", SP_xatrix_item},
X	{"weapon_boomer", SP_xatrix_item},
X	{"weapon_phalanx", SP_xatrix_item},
//ROGUE
//==============
X
X	{NULL, NULL}
};
X
/*
===============
ED_CallSpawn
X
Finds the spawn function for the entity and calls it
===============
*/
void ED_CallSpawn (edict_t *ent)
{
X	spawn_t	*s;
X	gitem_t	*item;
X	int		i;
X
X	if (!ent->classname)
X	{
X		gi.dprintf ("ED_CallSpawn: NULL classname\n");
X		return;
X	}
X
//PGM - do this before calling the spawn function so it can be overridden.
#ifdef ROGUE_GRAVITY
X	ent->gravityVector[0] =  0.0;
X	ent->gravityVector[1] =  0.0;
X	ent->gravityVector[2] = -1.0;
#endif
//PGM
X
X	// FIXME - PMM classnames hack
X	if (!strcmp(ent->classname, "weapon_nailgun"))
X		ent->classname = (FindItem("ETF Rifle"))->classname;
X	if (!strcmp(ent->classname, "ammo_nails"))
X		ent->classname = (FindItem("Flechettes"))->classname;
X	if (!strcmp(ent->classname, "weapon_heatbeam"))
X		ent->classname = (FindItem("Plasma Beam"))->classname;
X	// pmm
X
X	// check item spawn functions
X	for (i=0,item=itemlist ; i<game.num_items ; i++,item++)
X	{
X		if (!item->classname)
X			continue;
X		if (!strcmp(item->classname, ent->classname))
X		{	// found it
X			SpawnItem (ent, item);
X			return;
X		}
X	}
X
X	// check normal spawn functions
X	for (s=spawns ; s->name ; s++)
X	{
X		if (!strcmp(s->name, ent->classname))
X		{	// found it
X			s->spawn (ent);
X			return;
X		}
X	}
X	gi.dprintf ("%s doesn't have a spawn function\n", ent->classname);
}
X
/*
=============
ED_NewString
=============
*/
char *ED_NewString (char *string)
{
X	char	*newb, *new_p;
X	int		i,l;
X	
X	l = strlen(string) + 1;
X
X	newb = gi.TagMalloc (l, TAG_LEVEL);
X
X	new_p = newb;
X
X	for (i=0 ; i< l ; i++)
X	{
X		if (string[i] == '\\' && i < l-1)
X		{
X			i++;
X			if (string[i] == 'n')
X				*new_p++ = '\n';
X			else
X				*new_p++ = '\\';
X		}
X		else
X			*new_p++ = string[i];
X	}
X	
X	return newb;
}
X
X
X
X
/*
===============
ED_ParseField
X
Takes a key/value pair and sets the binary values
in an edict
===============
*/
void ED_ParseField (char *key, char *value, edict_t *ent)
{
X	field_t	*f;
X	byte	*b;
X	float	v;
X	vec3_t	vec;
X
X	for (f=fields ; f->name ; f++)
X	{
X		if (!(f->flags & FFL_NOSPAWN) && !Q_stricmp(f->name, key))
X		{	// found it
X			if (f->flags & FFL_SPAWNTEMP)
X				b = (byte *)&st;
X			else
X				b = (byte *)ent;
X
X			switch (f->type)
X			{
X			case F_LSTRING:
X				*(char **)(b+f->ofs) = ED_NewString (value);
X				break;
X			case F_VECTOR:
X				sscanf (value, "%f %f %f", &vec[0], &vec[1], &vec[2]);
X				((float *)(b+f->ofs))[0] = vec[0];
X				((float *)(b+f->ofs))[1] = vec[1];
X				((float *)(b+f->ofs))[2] = vec[2];
X				break;
X			case F_INT:
X				*(int *)(b+f->ofs) = atoi(value);
X				break;
X			case F_FLOAT:
X				*(float *)(b+f->ofs) = atof(value);
X				break;
X			case F_ANGLEHACK:
X				v = atof(value);
X				((float *)(b+f->ofs))[0] = 0;
X				((float *)(b+f->ofs))[1] = v;
X				((float *)(b+f->ofs))[2] = 0;
X				break;
X			case F_IGNORE:
X				break;
X			}
X			return;
X		}
X	}
X	gi.dprintf ("%s is not a field\n", key);
}
X
/*
====================
ED_ParseEdict
X
Parses an edict out of the given string, returning the new position
ed should be a properly initialized empty edict.
====================
*/
char *ED_ParseEdict (char *data, edict_t *ent)
{
X	qboolean	init;
X	char		keyname[256];
X	char		*com_token;
X
X	init = false;
X	memset (&st, 0, sizeof(st));
X
// go through all the dictionary pairs
X	while (1)
X	{	
X	// parse key
X		com_token = COM_Parse (&data);
X		if (com_token[0] == '}')
X			break;
X		if (!data)
X			gi.error ("ED_ParseEntity: EOF without closing brace");
X
X		strncpy (keyname, com_token, sizeof(keyname)-1);
X		
X	// parse value	
X		com_token = COM_Parse (&data);
X		if (!data)
X			gi.error ("ED_ParseEntity: EOF without closing brace");
X
X		if (com_token[0] == '}')
X			gi.error ("ED_ParseEntity: closing brace without data");
X
X		init = true;	
X
X	// keynames with a leading underscore are used for utility comments,
X	// and are immediately discarded by quake
X		if (keyname[0] == '_')
X			continue;
X
X		ED_ParseField (keyname, com_token, ent);
X	}
X
X	if (!init)
X		memset (ent, 0, sizeof(*ent));
X
X	return data;
}
X
X
/*
================
G_FindTeams
X
Chain together all entities with a matching team field.
X
All but the first will have the FL_TEAMSLAVE flag set.
All but the last will have the teamchain field set to the next one
================
*/
void G_FixTeams (void)
{
X	edict_t	*e, *e2, *chain;
X	int		i, j;
X	int		c, c2;
X
X	c = 0;
X	c2 = 0;
X	for (i=1, e=g_edicts+i ; i < globals.num_edicts ; i++,e++)
X	{
X		if (!e->inuse)
X			continue;
X		if (!e->team)
X			continue;
X		if (!strcmp(e->classname, "func_train"))
X		{
X			if(e->flags & FL_TEAMSLAVE)
X			{
X				chain = e;
X				e->teammaster = e;
X				e->teamchain = NULL;
X				e->flags &= ~FL_TEAMSLAVE;
X				c++;
X				c2++;
X				for (j=1, e2=g_edicts+j ; j < globals.num_edicts ; j++,e2++)
X				{
X					if (e2 == e)
X						continue;
X					if (!e2->inuse)
X						continue;
X					if (!e2->team)
X						continue;
X					if (!strcmp(e->team, e2->team))
X					{
X						c2++;
X						chain->teamchain = e2;
X						e2->teammaster = e;
X						e2->teamchain = NULL;
X						chain = e2;
X						e2->flags |= FL_TEAMSLAVE;
X						e2->movetype = MOVETYPE_PUSH;
X						e2->speed = e->speed;
X					}
X				}
X			}
X		}
X	}
X	gi.dprintf ("%i teams repaired\n", c);
}
X
void G_FindTeams (void)
{
X	edict_t	*e, *e2, *chain;
X	int		i, j;
X	int		c, c2;
X
X	c = 0;
X	c2 = 0;
X	for (i=1, e=g_edicts+i ; i < globals.num_edicts ; i++,e++)
X	{
X		if (!e->inuse)
X			continue;
X		if (!e->team)
X			continue;
X		if (e->flags & FL_TEAMSLAVE)
X			continue;
X		chain = e;
X		e->teammaster = e;
X		c++;
X		c2++;
X		for (j=i+1, e2=e+1 ; j < globals.num_edicts ; j++,e2++)
X		{
X			if (!e2->inuse)
X				continue;
X			if (!e2->team)
X				continue;
X			if (e2->flags & FL_TEAMSLAVE)
X				continue;
X			if (!strcmp(e->team, e2->team))
X			{
X				c2++;
X				chain->teamchain = e2;
X				e2->teammaster = e;
X				chain = e2;
X				e2->flags |= FL_TEAMSLAVE;
X			}
X		}
X	}
X
X	G_FixTeams();
X
X	gi.dprintf ("%i teams with %i entities\n", c, c2);
}
X
/*
==============
SpawnEntities
X
Creates a server's entity / program execution context by
parsing textual entity definitions out of an ent file.
==============
*/
void SpawnEntities (char *mapname, char *entities, char *spawnpoint)
{
X	edict_t		*ent;
X	int			inhibit;
X	char		*com_token;
X	int			i;
X	float		skill_level;
X
X	skill_level = floor (skill->value);
X	if (skill_level < 0)
X		skill_level = 0;
X	if (skill_level > 3)
X		skill_level = 3;
X	if (skill->value != skill_level)
X		gi.cvar_forceset("skill", va("%f", skill_level));
X
X	SaveClientData ();
X
X	gi.FreeTags (TAG_LEVEL);
X
X	memset (&level, 0, sizeof(level));
X	memset (g_edicts, 0, game.maxentities * sizeof (g_edicts[0]));
X
X	strncpy (level.mapname, mapname, sizeof(level.mapname)-1);
X	strncpy (game.spawnpoint, spawnpoint, sizeof(game.spawnpoint)-1);
X
X	// set client fields on player ents
X	for (i=0 ; i<game.maxclients ; i++)
X		g_edicts[i+1].client = game.clients + i;
X
X	ent = NULL;
X	inhibit = 0;
X
// parse ents
X	while (1)
X	{
X		// parse the opening brace	
X		com_token = COM_Parse (&entities);
X		if (!entities)
X			break;
X		if (com_token[0] != '{')
X			gi.error ("ED_LoadFromFile: found %s when expecting {",com_token);
X
X		if (!ent)
X			ent = g_edicts;
X		else
X			ent = G_Spawn ();
X		entities = ED_ParseEdict (entities, ent);
X
X		// yet another map hack
X		if (!Q_stricmp(level.mapname, "command") && !Q_stricmp(ent->classname, "trigger_once") && !Q_stricmp(ent->model, "*27"))
X			ent->spawnflags &= ~SPAWNFLAG_NOT_HARD;
X		
X		// ROGUE
X		//ahh, the joys of map hacks .. 
X		if (!Q_stricmp(level.mapname, "rhangar2") && !Q_stricmp(ent->classname, "func_door_rotating") && ent->targetname && !Q_stricmp(ent->targetname, "t265"))
X			ent->spawnflags &= ~SPAWNFLAG_NOT_COOP;
X		if (!Q_stricmp(level.mapname, "rhangar2") && !Q_stricmp(ent->classname, "trigger_always") && ent->target && !Q_stricmp(ent->target, "t265"))
X			ent->spawnflags |= SPAWNFLAG_NOT_COOP;
X		if (!Q_stricmp(level.mapname, "rhangar2") && !Q_stricmp(ent->classname, "func_wall") && !Q_stricmp(ent->model, "*15"))
X			ent->spawnflags |= SPAWNFLAG_NOT_COOP;
X		// rogue
X
X		// remove things (except the world) from different skill levels or deathmatch
X		if (ent != g_edicts)
X		{
X			if (deathmatch->value)
X			{
X				if ( ent->spawnflags & SPAWNFLAG_NOT_DEATHMATCH )
X				{
X					G_FreeEdict (ent);	
X					inhibit++;
X					continue;
X				}
X			}
X			else if(coop->value)
X			{
X				if (ent->spawnflags & SPAWNFLAG_NOT_COOP)
X				{
X					G_FreeEdict (ent);	
X					inhibit++;
X					continue;
X				}
X
X				// stuff marked !easy & !med & !hard are coop only, all levels
X				if(!((ent->spawnflags & SPAWNFLAG_NOT_EASY) &&
X					(ent->spawnflags & SPAWNFLAG_NOT_MEDIUM) &&
X					(ent->spawnflags & SPAWNFLAG_NOT_HARD)) )
X				{
X					if( ((skill->value == 0) && (ent->spawnflags & SPAWNFLAG_NOT_EASY)) ||
X						((skill->value == 1) && (ent->spawnflags & SPAWNFLAG_NOT_MEDIUM)) ||
X						(((skill->value == 2) || (skill->value == 3)) && (ent->spawnflags & SPAWNFLAG_NOT_HARD))
X					  )
X					{
X						G_FreeEdict (ent);	
X						inhibit++;
X						continue;
X					}
X				}
X			}
X			else
X			{
X				if ( /*((coop->value) && (ent->spawnflags & SPAWNFLAG_NOT_COOP)) || */ 
X					((skill->value == 0) && (ent->spawnflags & SPAWNFLAG_NOT_EASY)) ||
X					((skill->value == 1) && (ent->spawnflags & SPAWNFLAG_NOT_MEDIUM)) ||
X					(((skill->value == 2) || (skill->value == 3)) && (ent->spawnflags & SPAWNFLAG_NOT_HARD))
X					)
X					{
X						G_FreeEdict (ent);	
X						inhibit++;
X						continue;
X					}
X			}
X
X			ent->spawnflags &= ~(SPAWNFLAG_NOT_EASY|SPAWNFLAG_NOT_MEDIUM|SPAWNFLAG_NOT_HARD|SPAWNFLAG_NOT_COOP|SPAWNFLAG_NOT_DEATHMATCH);
X		}
X
//PGM - do this before calling the spawn function so it can be overridden.
#ifdef ROGUE_GRAVITY
X		ent->gravityVector[0] =  0.0;
X		ent->gravityVector[1] =  0.0;
X		ent->gravityVector[2] = -1.0;
#endif
//PGM
X		ED_CallSpawn (ent);
X
X		ent->s.renderfx |= RF_IR_VISIBLE;		//PGM
X	}	
X
X	gi.dprintf ("%i entities inhibited\n", inhibit);
X
#ifdef DEBUG
X	i = 1;
X	ent = EDICT_NUM(i);
X	while (i < globals.num_edicts) {
X		if (ent->inuse != 0 || ent->inuse != 1)
X			Com_DPrintf("Invalid entity %d\n", i);
X		i++, ent++;
X	}
#endif
X
X	G_FindTeams ();
X
X	PlayerTrail_Init ();
X
//ROGUE
X	if(deathmatch->value)
X	{
X		if(randomrespawn && randomrespawn->value)
X			PrecacheForRandomRespawn();
X	}
X	else
X	{
X		InitHintPaths();		// if there aren't hintpaths on this map, enable quick aborts
X	}
//ROGUE
X
// ROGUE	-- allow dm games to do init stuff right before game starts.
X	if(deathmatch->value && gamerules && gamerules->value)
X	{
X		if(DMGame.PostInitSetup)
X			DMGame.PostInitSetup ();
X	}
// ROGUE
}
X
X
//===================================================================
X
#if 0
X	// cursor positioning
X	xl <value>
X	xr <value>
X	yb <value>
X	yt <value>
X	xv <value>
X	yv <value>
X
X	// drawing
X	statpic <name>
X	pic <stat>
X	num <fieldwidth> <stat>
X	string <stat>
X
X	// control
X	if <stat>
X	ifeq <stat> <value>
X	ifbit <stat> <value>
X	endif
X
#endif
X
char *single_statusbar = 
"yb	-24 "
X
// health
"xv	0 "
"hnum "
"xv	50 "
"pic 0 "
X
// ammo
"if 2 "
"	xv	100 "
"	anum "
"	xv	150 "
"	pic 2 "
"endif "
X
// armor
"if 4 "
"	xv	200 "
"	rnum "
"	xv	250 "
"	pic 4 "
"endif "
X
// selected item
"if 6 "
"	xv	296 "
"	pic 6 "
"endif "
X
"yb	-50 "
X
// picked up item
"if 7 "
"	xv	0 "
"	pic 7 "
"	xv	26 "
"	yb	-42 "
"	stat_string 8 "
"	yb	-50 "
"endif "
X
// timer
"if 9 "
"	xv	262 "
"	num	2	10 "
"	xv	296 "
"	pic	9 "
"endif "
X
//  help / weapon icon 
"if 11 "
"	xv	148 "
"	pic	11 "
"endif "
;
X
char *dm_statusbar =
"yb	-24 "
X
// health
"xv	0 "
"hnum "
"xv	50 "
"pic 0 "
X
// ammo
"if 2 "
"	xv	100 "
"	anum "
"	xv	150 "
"	pic 2 "
"endif "
X
// armor
"if 4 "
"	xv	200 "
"	rnum "
"	xv	250 "
"	pic 4 "
"endif "
X
// selected item
"if 6 "
"	xv	296 "
"	pic 6 "
"endif "
X
"yb	-50 "
X
// picked up item
"if 7 "
"	xv	0 "
"	pic 7 "
"	xv	26 "
"	yb	-42 "
"	stat_string 8 "
"	yb	-50 "
"endif "
X
// timer
"if 9 "
"	xv	246 "
"	num	2	10 "
"	xv	296 "
"	pic	9 "
"endif "
X
//  help / weapon icon 
"if 11 "
"	xv	148 "
"	pic	11 "
"endif "
X
//  frags
"xr	-50 "
"yt 2 "
"num 3 14 "
X
// spectator
"if 17 "
X  "xv 0 "
X  "yb -58 "
X  "string2 \"SPECTATOR MODE\" "
"endif "
X
// chase camera
"if 16 "
X  "xv 0 "
X  "yb -68 "
X  "string \"Chasing\" "
X  "xv 64 "
X  "stat_string 16 "
"endif "
;
X
X
/*QUAKED worldspawn (0 0 0) ?
X
Only used for the world.
"sky"	environment map name
"skyaxis"	vector axis for rotating sky
"skyrotate"	speed of rotation in degrees/second
"sounds"	music cd track number
"gravity"	800 is default gravity
"message"	text to print at user logon
*/
void SP_worldspawn (edict_t *ent)
{
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_BSP;
X	ent->inuse = true;			// since the world doesn't use G_Spawn()
X	ent->s.modelindex = 1;		// world model is always index 1
X
X	//---------------
X
X	// reserve some spots for dead player bodies for coop / deathmatch
X	InitBodyQue ();
X
X	// set configstrings for items
X	SetItemNames ();
X
X	if (st.nextmap)
X		strcpy (level.nextmap, st.nextmap);
X
X	// make some data visible to the server
X
X	if (ent->message && ent->message[0])
X	{
X		gi.configstring (CS_NAME, ent->message);
X		strncpy (level.level_name, ent->message, sizeof(level.level_name));
X	}
X	else
X		strncpy (level.level_name, level.mapname, sizeof(level.level_name));
X
X	if (st.sky && st.sky[0])
X		gi.configstring (CS_SKY, st.sky);
X	else
X		gi.configstring (CS_SKY, "unit1_");
X
X	gi.configstring (CS_SKYROTATE, va("%f", st.skyrotate) );
X
X	gi.configstring (CS_SKYAXIS, va("%f %f %f",
X		st.skyaxis[0], st.skyaxis[1], st.skyaxis[2]) );
X
X	gi.configstring (CS_CDTRACK, va("%i", ent->sounds) );
X
X	gi.configstring (CS_MAXCLIENTS, va("%i", (int)(maxclients->value) ) );
X
X	// status bar program
X	if (deathmatch->value)
X		gi.configstring (CS_STATUSBAR, dm_statusbar);
X	else
X		gi.configstring (CS_STATUSBAR, single_statusbar);
X
X	//---------------
X
X
X	// help icon for statusbar
X	gi.imageindex ("i_help");
X	level.pic_health = gi.imageindex ("i_health");
X	gi.imageindex ("help");
X	gi.imageindex ("field_3");
X
X	if (!st.gravity)
X		gi.cvar_set("sv_gravity", "800");
X	else
X		gi.cvar_set("sv_gravity", st.gravity);
X
X	snd_fry = gi.soundindex ("player/fry.wav");	// standing in lava / slime
X
X	PrecacheItem (FindItem ("Blaster"));
X
X	gi.soundindex ("player/lava1.wav");
X	gi.soundindex ("player/lava2.wav");
X
X	gi.soundindex ("misc/pc_up.wav");
X	gi.soundindex ("misc/talk1.wav");
X
X	gi.soundindex ("misc/udeath.wav");
X
X	// gibs
X	gi.soundindex ("items/respawn1.wav");
X
X	// sexed sounds
X	gi.soundindex ("*death1.wav");
X	gi.soundindex ("*death2.wav");
X	gi.soundindex ("*death3.wav");
X	gi.soundindex ("*death4.wav");
X	gi.soundindex ("*fall1.wav");
X	gi.soundindex ("*fall2.wav");	
X	gi.soundindex ("*gurp1.wav");		// drowning damage
X	gi.soundindex ("*gurp2.wav");	
X	gi.soundindex ("*jump1.wav");		// player jump
X	gi.soundindex ("*pain25_1.wav");
X	gi.soundindex ("*pain25_2.wav");
X	gi.soundindex ("*pain50_1.wav");
X	gi.soundindex ("*pain50_2.wav");
X	gi.soundindex ("*pain75_1.wav");
X	gi.soundindex ("*pain75_2.wav");
X	gi.soundindex ("*pain100_1.wav");
X	gi.soundindex ("*pain100_2.wav");
X
X	// sexed models
X	// THIS ORDER MUST MATCH THE DEFINES IN g_local.h
X	// you can add more, max 19 (pete change)
X	// these models are only loaded in coop or deathmatch. not singleplayer.
X	if (coop->value || deathmatch->value)
X	{
X		gi.modelindex ("#w_blaster.md2");
X		gi.modelindex ("#w_shotgun.md2");
X		gi.modelindex ("#w_sshotgun.md2");
X		gi.modelindex ("#w_machinegun.md2");
X		gi.modelindex ("#w_chaingun.md2");
X		gi.modelindex ("#a_grenades.md2");
X		gi.modelindex ("#w_glauncher.md2");
X		gi.modelindex ("#w_rlauncher.md2");
X		gi.modelindex ("#w_hyperblaster.md2");
X		gi.modelindex ("#w_railgun.md2");
X		gi.modelindex ("#w_bfg.md2");
X
X		gi.modelindex ("#w_disrupt.md2");			// PGM
X		gi.modelindex ("#w_etfrifle.md2");			// PGM
X		gi.modelindex ("#w_plasma.md2");			// PGM
X		gi.modelindex ("#w_plauncher.md2");			// PGM
X		gi.modelindex ("#w_chainfist.md2");			// PGM
X	}
X
X	//-------------------
X
X	gi.soundindex ("player/gasp1.wav");		// gasping for air
X	gi.soundindex ("player/gasp2.wav");		// head breaking surface, not gasping
X
X	gi.soundindex ("player/watr_in.wav");	// feet hitting water
X	gi.soundindex ("player/watr_out.wav");	// feet leaving water
X
X	gi.soundindex ("player/watr_un.wav");	// head going underwater
X	
X	gi.soundindex ("player/u_breath1.wav");
X	gi.soundindex ("player/u_breath2.wav");
X
X	gi.soundindex ("items/pkup.wav");		// bonus item pickup
X	gi.soundindex ("world/land.wav");		// landing thud
X	gi.soundindex ("misc/h2ohit1.wav");		// landing splash
X
X	gi.soundindex ("items/damage.wav");
X	// ROGUE - double damage
X	gi.soundindex ("misc/ddamage1.wav");
X	// rogue
X	gi.soundindex ("items/protect.wav");
X	gi.soundindex ("items/protect4.wav");
X	gi.soundindex ("weapons/noammo.wav");
X
X	gi.soundindex ("infantry/inflies1.wav");
X
X	sm_meat_index = gi.modelindex ("models/objects/gibs/sm_meat/tris.md2");
X	gi.modelindex ("models/objects/gibs/arm/tris.md2");
X	gi.modelindex ("models/objects/gibs/bone/tris.md2");
X	gi.modelindex ("models/objects/gibs/bone2/tris.md2");
X	gi.modelindex ("models/objects/gibs/chest/tris.md2");
X	gi.modelindex ("models/objects/gibs/skull/tris.md2");
X	gi.modelindex ("models/objects/gibs/head2/tris.md2");
X
//
// Setup light animation tables. 'a' is total darkness, 'z' is doublebright.
//
X
X	// 0 normal
X	gi.configstring(CS_LIGHTS+0, "m");
X	
X	// 1 FLICKER (first variety)
X	gi.configstring(CS_LIGHTS+1, "mmnmmommommnonmmonqnmmo");
X	
X	// 2 SLOW STRONG PULSE
X	gi.configstring(CS_LIGHTS+2, "abcdefghijklmnopqrstuvwxyzyxwvutsrqponmlkjihgfedcba");
X	
X	// 3 CANDLE (first variety)
X	gi.configstring(CS_LIGHTS+3, "mmmmmaaaaammmmmaaaaaabcdefgabcdefg");
X	
X	// 4 FAST STROBE
X	gi.configstring(CS_LIGHTS+4, "mamamamamama");
X	
X	// 5 GENTLE PULSE 1
X	gi.configstring(CS_LIGHTS+5,"jklmnopqrstuvwxyzyxwvutsrqponmlkj");
X	
X	// 6 FLICKER (second variety)
X	gi.configstring(CS_LIGHTS+6, "nmonqnmomnmomomno");
X	
X	// 7 CANDLE (second variety)
X	gi.configstring(CS_LIGHTS+7, "mmmaaaabcdefgmmmmaaaammmaamm");
X	
X	// 8 CANDLE (third variety)
X	gi.configstring(CS_LIGHTS+8, "mmmaaammmaaammmabcdefaaaammmmabcdefmmmaaaa");
X	
X	// 9 SLOW STROBE (fourth variety)
X	gi.configstring(CS_LIGHTS+9, "aaaaaaaazzzzzzzz");
X	
X	// 10 FLUORESCENT FLICKER
X	gi.configstring(CS_LIGHTS+10, "mmamammmmammamamaaamammma");
X
X	// 11 SLOW PULSE NOT FADE TO BLACK
X	gi.configstring(CS_LIGHTS+11, "abcdefghijklmnopqrrqponmlkjihgfedcba");
X	
X	// styles 32-62 are assigned by the light program for switchable lights
X
X	// 63 testing
X	gi.configstring(CS_LIGHTS+63, "a");
}
X
//
//ROGUE
//
X
//
// Monster spawning code
//
// Used by the carrier, the medic_commander, and the black widow
//
// The sequence to create a flying monster is:
//
//  FindSpawnPoint - tries to find suitable spot to spawn the monster in
//  CreateFlyMonster  - this verifies the point as good and creates the monster
X
// To create a ground walking monster:
//
//  FindSpawnPoint - same thing
//  CreateGroundMonster - this checks the volume and makes sure the floor under the volume is suitable
//
X
// FIXME - for the black widow, if we want the stalkers coming in on the roof, we'll have to tweak some things
X
//
// CreateMonster
//
edict_t *CreateMonster(vec3_t origin, vec3_t angles, char *classname)
{
X	edict_t		*newEnt;
X
X	newEnt = G_Spawn();
X
X	VectorCopy(origin, newEnt->s.origin);
X	VectorCopy(angles, newEnt->s.angles);
X	newEnt->classname = ED_NewString (classname);
X	newEnt->monsterinfo.aiflags |= AI_DO_NOT_COUNT;
X	
X	VectorSet(newEnt->gravityVector, 0, 0, -1);
X	ED_CallSpawn(newEnt);
X	newEnt->s.renderfx |= RF_IR_VISIBLE;
X
X	return newEnt;
}
X
edict_t *CreateFlyMonster (vec3_t origin, vec3_t angles, vec3_t mins, vec3_t maxs, char *classname)
{
X	if (!mins || !maxs || VectorCompare (mins, vec3_origin) || VectorCompare (maxs, vec3_origin))
X	{
X		DetermineBBox (classname, mins, maxs);
X	}
X
X	if (!CheckSpawnPoint(origin, mins, maxs))
X		return NULL;
X
X	return (CreateMonster (origin, angles, classname));
}
X
// This is just a wrapper for CreateMonster that looks down height # of CMUs and sees if there
// are bad things down there or not
//
// this is from m_move.c
#define	STEPSIZE	18
X
edict_t *CreateGroundMonster (vec3_t origin, vec3_t angles, vec3_t entMins, vec3_t entMaxs, char *classname, int height)
{
//	trace_t		tr;
X	edict_t		*newEnt;
//	vec3_t		start, stop;
//	int			failure = 0;
//	vec3_t		mins, maxs;
//	int			x, y;	
//	float		mid, bottom;
X	vec3_t		mins, maxs;
X
X	// if they don't provide us a bounding box, figure it out
X	if (!entMins || !entMaxs || VectorCompare (entMins, vec3_origin) || VectorCompare (entMaxs, vec3_origin))
X	{
X		DetermineBBox (classname, mins, maxs);
X	}
X	else
X	{
X		VectorCopy (entMins, mins);
X		VectorCopy (entMaxs, maxs);
X	}
X
X	// check the ground to make sure it's there, it's relatively flat, and it's not toxic
X	if (!CheckGroundSpawnPoint(origin, mins, maxs, height, -1))
X		return NULL;
X
X	newEnt = CreateMonster (origin, angles, classname);
X	if (!newEnt)
X		return NULL;
X
X	return newEnt;
}
X
X
// FindSpawnPoint
// PMM - this is used by the medic commander (possibly by the carrier) to find a good spawn point
// if the startpoint is bad, try above the startpoint for a bit
X
qboolean FindSpawnPoint (vec3_t startpoint, vec3_t mins, vec3_t maxs, vec3_t spawnpoint, float maxMoveUp)
{
X	trace_t		tr;
X	float		height;
X	vec3_t		top;
X
X	height = maxs[2] - mins[2];
X
X	tr = gi.trace (startpoint, mins, maxs, startpoint, NULL, MASK_MONSTERSOLID|CONTENTS_PLAYERCLIP);
X	if((tr.startsolid || tr.allsolid) || (tr.ent != world))
X	{
//		if ( ((tr.ent->svflags & SVF_MONSTER) && (tr.ent->health <= 0)) ||
//			 (tr.ent->svflags & SVF_DAMAGEABLE) )
//		{
//			T_Damage (tr.ent, self, self, vec3_origin, self->enemy->s.origin,
//						pain_normal, hurt, 0, 0, MOD_UNKNOWN);
X
X		VectorCopy (startpoint, top);
X		top[2] += maxMoveUp;
/*
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_DEBUGTRAIL);
X		gi.WritePosition (top);
X		gi.WritePosition (startpoint);
X		gi.multicast (startpoint, MULTICAST_ALL);	
*/
X		tr = gi.trace (top, mins, maxs, startpoint, NULL, MASK_MONSTERSOLID);
X		if (tr.startsolid || tr.allsolid)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				if (tr.ent)
//					gi.dprintf("FindSpawnPoint: failed to find a point -- blocked by %s\n", tr.ent->classname);
//				else
//					gi.dprintf("FindSpawnPoint: failed to find a point\n");
X
X			return false;
X		} 
X		else
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("FindSpawnPoint: %s -> %s\n", vtos (startpoint), vtos (tr.endpos));
X			VectorCopy (tr.endpos, spawnpoint);
X			return true;
X		}
X	}
X	else
X	{
X		VectorCopy (startpoint, spawnpoint);
X		return true;
X	}
}
X
// FIXME - all of this needs to be tweaked to handle the new gravity rules
// if we ever want to spawn stuff on the roof
X
//
// CheckSpawnPoint
//
// PMM - checks volume to make sure we can spawn a monster there (is it solid?)
//
// This is all fliers should need
X
qboolean CheckSpawnPoint (vec3_t origin, vec3_t mins, vec3_t maxs)
{
X	trace_t	tr;
X
X	if (!mins || !maxs || VectorCompare(mins, vec3_origin) || VectorCompare (maxs, vec3_origin))
X	{
X		return false;
X	}
X
X	tr = gi.trace (origin, mins, maxs, origin, NULL, MASK_MONSTERSOLID);
X	if(tr.startsolid || tr.allsolid)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf("createmonster in wall. removing\n");
X		return false;
X	}
X	if (tr.ent != world)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf("createmonster in entity %s\n", tr.ent->classname);
X		return false;
X	}	
X	return true;
}
X
//
// CheckGroundSpawnPoint
//
// PMM - used for walking monsters
//  checks:
//		1)	is there a ground within the specified height of the origin?
//		2)	is the ground non-water?
//		3)	is the ground flat enough to walk on?
//
X
qboolean CheckGroundSpawnPoint (vec3_t origin, vec3_t entMins, vec3_t entMaxs, float height, float gravity)
{
X	trace_t		tr;
X	vec3_t		start, stop;
X	int			failure = 0;
X	vec3_t		mins, maxs;
X	int			x, y;	
X	float		mid, bottom;
X
X	if (!CheckSpawnPoint (origin, entMins, entMaxs))
X		return false;
X
X	// FIXME - this is too conservative about angled surfaces
X
X	VectorCopy (origin, stop);
X	// FIXME - gravity vector
X	stop[2] = origin[2] + entMins[2] - height;
X
X	/*
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_DEBUGTRAIL);
X	gi.WritePosition (origin);
X	gi.WritePosition (stop);
X	gi.multicast (start, MULTICAST_ALL);
X	*/
X
X	tr = gi.trace (origin, entMins, entMaxs, stop, NULL, MASK_MONSTERSOLID | MASK_WATER);
X	// it's not going to be all solid or start solid, since that's checked above
X
X	if ((tr.fraction < 1) && (tr.contents & MASK_MONSTERSOLID))
X	{
X		// we found a non-water surface down there somewhere.  now we need to check to make sure it's not too sloped
X		//
X		// algorithm straight out of m_move.c:M_CheckBottom()
X		//
X
X		// first, do the midpoint trace
X
X		VectorAdd (tr.endpos, entMins, mins);
X		VectorAdd (tr.endpos, entMaxs, maxs);
X
X
X		// first, do the easy flat check
X		//
#ifdef ROGUE_GRAVITY
X		// FIXME - this will only handle 0,0,1 and 0,0,-1 gravity vectors
X		if(gravity > 0)
X			start[2] = maxs[2] + 1;
X		else
X			start[2] = mins[2] - 1;
#else
X		start[2] = mins[2] - 1;
#endif
X		for	(x=0 ; x<=1 ; x++)
X		{
X			for	(y=0 ; y<=1 ; y++)
X			{
X				start[0] = x ? maxs[0] : mins[0];
X				start[1] = y ? maxs[1] : mins[1];
X				if (gi.pointcontents (start) != CONTENTS_SOLID)
X					goto realcheck;
X			}
X		}
X
X		// if it passed all four above checks, we're done
X		return true;
X
realcheck:
X
X		// check it for real
X
X		start[0] = stop[0] = (mins[0] + maxs[0])*0.5;
X		start[1] = stop[1] = (mins[1] + maxs[1])*0.5;
X		start[2] = mins[2];
X
X		tr = gi.trace (start, vec3_origin, vec3_origin, stop, NULL, MASK_MONSTERSOLID);
X
X		if (tr.fraction == 1.0)
X			return false;
X		mid = bottom = tr.endpos[2];
X
#ifdef ROGUE_GRAVITY
X		if(gravity < 0)
X		{
X			start[2] = mins[2];
X			stop[2] = start[2] - STEPSIZE - STEPSIZE;
X			mid = bottom = tr.endpos[2] + entMins[2];
X		}
X		else
X		{
X			start[2] = maxs[2];
X			stop[2] = start[2] + STEPSIZE + STEPSIZE;
X			mid = bottom = tr.endpos[2] - entMaxs[2];
X		}
#else
X		stop[2] = start[2] - 2*STEPSIZE;
X		mid = bottom = tr.endpos[2] + entMins[2];
#endif
X
X		for	(x=0 ; x<=1 ; x++)
X			for	(y=0 ; y<=1 ; y++)
X			{
X				start[0] = stop[0] = x ? maxs[0] : mins[0];
X				start[1] = stop[1] = y ? maxs[1] : mins[1];
X				
X				/*
X				gi.WriteByte (svc_temp_entity);
X				gi.WriteByte (TE_DEBUGTRAIL);
X				gi.WritePosition (start);
X				gi.WritePosition (stop);
X				gi.multicast (start, MULTICAST_ALL);	
X				*/
X				tr = gi.trace (start, vec3_origin, vec3_origin, stop, NULL, MASK_MONSTERSOLID);
X
//PGM
#ifdef ROGUE_GRAVITY
// FIXME - this will only handle 0,0,1 and 0,0,-1 gravity vectors
X				if(gravity > 0)
X				{
X					if (tr.fraction != 1.0 && tr.endpos[2] < bottom)
X						bottom = tr.endpos[2];
X					if (tr.fraction == 1.0 || tr.endpos[2] - mid > STEPSIZE)
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("spawn - rejecting due to uneven ground\n");
X						return false;
X					}
X				}
X				else
X				{
X					if (tr.fraction != 1.0 && tr.endpos[2] > bottom)
X						bottom = tr.endpos[2];
X					if (tr.fraction == 1.0 || mid - tr.endpos[2] > STEPSIZE)
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("spawn - rejecting due to uneven ground\n");
X						return false;
X					}
X				}
#else
X				if (tr.fraction != 1.0 && tr.endpos[2] > bottom)
X					bottom = tr.endpos[2];
X				if (tr.fraction == 1.0 || mid - tr.endpos[2] > STEPSIZE)
X					{
X						return false;
X					}
#endif
X			}
X
X		return true;		// we can land on it, it's ok
X	}
X
X	// otherwise, it's either water (bad) or not there (too far)
X	// if we're here, it's bad below
//	if ((g_showlogic) && (g_showlogic->value))
//	{
//		if (tr.fraction < 1)
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf("groundmonster would fall into water/slime/lava\n");
//		else
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf("groundmonster would fall too far\n");
//	}
X
X	return false;
}
X
void DetermineBBox (char *classname, vec3_t mins, vec3_t maxs)
{
X	// FIXME - cache this stuff
X	edict_t		*newEnt;
X
X	newEnt = G_Spawn();
X
X	VectorCopy(vec3_origin, newEnt->s.origin);
X	VectorCopy(vec3_origin, newEnt->s.angles);
X	newEnt->classname = ED_NewString (classname);
X	newEnt->monsterinfo.aiflags |= AI_DO_NOT_COUNT;
X	
X	ED_CallSpawn(newEnt);
X	
X	VectorCopy (newEnt->mins, mins);
X	VectorCopy (newEnt->maxs, maxs);
X
X	G_FreeEdict (newEnt);
}
X
// ****************************
// SPAWNGROW stuff
// ****************************
X
#define SPAWNGROW_LIFESPAN		0.3
X
void spawngrow_think (edict_t *self)
{
X	int i;
X
X	for (i=0; i<2; i++)
X	{
X			self->s.angles[0] = rand()%360;
X			self->s.angles[1] = rand()%360;
X			self->s.angles[2] = rand()%360;
X	}
X	if ((level.time < self->wait) && (self->s.frame < 2))
X		self->s.frame++;
X	if (level.time >= self->wait)
X	{
X		if (self->s.effects & EF_SPHERETRANS)
X		{
X			G_FreeEdict (self);
X			return;
X		}
X		else if (self->s.frame > 0)
X			self->s.frame--;
X		else
X		{
X			G_FreeEdict (self);
X			return;
X		}
X	}
X	self->nextthink += FRAMETIME;
}
X
void SpawnGrow_Spawn (vec3_t startpos, int size)
{
X	edict_t *ent;
X	int	i;
X	float	lifespan;
X
X	ent = G_Spawn();
X	VectorCopy(startpos, ent->s.origin);
X	for (i=0; i<2; i++)
X	{
X			ent->s.angles[0] = rand()%360;
X			ent->s.angles[1] = rand()%360;
X			ent->s.angles[2] = rand()%360;
X	}
X	ent->solid = SOLID_NOT;
//	ent->s.renderfx = RF_FULLBRIGHT | RF_IR_VISIBLE;
X	ent->s.renderfx = RF_IR_VISIBLE;
X	ent->movetype = MOVETYPE_NONE;
X	ent->classname = "spawngro";
X
X	if (size <= 1)
X	{
X		lifespan = SPAWNGROW_LIFESPAN;
X		ent->s.modelindex = gi.modelindex("models/items/spawngro2/tris.md2");
X	}
X	else if (size == 2)
X	{
X		ent->s.modelindex = gi.modelindex("models/items/spawngro3/tris.md2");
X		lifespan = 2;
X	}
X	else
X	{
X		ent->s.modelindex = gi.modelindex("models/items/spawngro/tris.md2");
X		lifespan = SPAWNGROW_LIFESPAN;
X	}
X
X	ent->think = spawngrow_think;
X
X	ent->wait = level.time + lifespan;
X	ent->nextthink = level.time + FRAMETIME;
X	if (size != 2)
X		ent->s.effects |= EF_SPHERETRANS;
X	gi.linkentity (ent);
}
X
X
// ****************************
// WidowLeg stuff
// ****************************
X
#define	MAX_LEGSFRAME	23
#define	LEG_WAIT_TIME	1
X
void ThrowMoreStuff (edict_t *self, vec3_t point);
void ThrowSmallStuff (edict_t *self, vec3_t point);
void ThrowWidowGibLoc (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, qboolean fade);
void ThrowWidowGibSized (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, int hitsound, qboolean fade);
X
void widowlegs_think (edict_t *self)
{
X	vec3_t	offset;
X	vec3_t	point;
X	vec3_t	f,r,u;
X
X	if (self->s.frame == 17)
X	{
X		VectorSet (offset, 11.77, -7.24, 23.31);
X		AngleVectors (self->s.angles, f, r, u);
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, point);
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_EXPLOSION1);
X		gi.WritePosition (point);
X		gi.multicast (point, MULTICAST_ALL);
X		ThrowSmallStuff (self, point);
X	}
X
X	if (self->s.frame < MAX_LEGSFRAME)
X	{
X		self->s.frame++;
X		self->nextthink = level.time + FRAMETIME;
X		return;
X	}
X	else if (self->wait == 0)
X	{
X		self->wait = level.time + LEG_WAIT_TIME;
X	}
X	if (level.time > self->wait)
X	{
X		AngleVectors (self->s.angles, f, r, u);
X
X		VectorSet (offset, -65.6, -8.44, 28.59);
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, point);
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_EXPLOSION1);
X		gi.WritePosition (point);
X		gi.multicast (point, MULTICAST_ALL);
X		ThrowSmallStuff (self, point);
X
X		ThrowWidowGibSized (self, "models/monsters/blackwidow/gib1/tris.md2", 80 + (int)(random()*20.0), GIB_METALLIC, point, 0, true);
X		ThrowWidowGibSized (self, "models/monsters/blackwidow/gib2/tris.md2", 80 + (int)(random()*20.0), GIB_METALLIC, point, 0, true);
X
X		VectorSet (offset, -1.04, -51.18, 7.04);
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, point);
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_EXPLOSION1);
X		gi.WritePosition (point);
X		gi.multicast (point, MULTICAST_ALL);
X		ThrowSmallStuff (self, point);
X
X		ThrowWidowGibSized (self, "models/monsters/blackwidow/gib1/tris.md2", 80 + (int)(random()*20.0), GIB_METALLIC, point, 0, true);
X		ThrowWidowGibSized (self, "models/monsters/blackwidow/gib2/tris.md2", 80 + (int)(random()*20.0), GIB_METALLIC, point, 0, true);
X		ThrowWidowGibSized (self, "models/monsters/blackwidow/gib3/tris.md2", 80 + (int)(random()*20.0), GIB_METALLIC, point, 0, true);
X
X		G_FreeEdict (self);
X		return;
X	}
X	if ((level.time > (self->wait - 0.5)) && (self->count == 0))
X	{
X		self->count = 1;
X		AngleVectors (self->s.angles, f, r, u);
X
X		VectorSet (offset, 31, -88.7, 10.96);
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, point);
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_EXPLOSION1);
X		gi.WritePosition (point);
X		gi.multicast (point, MULTICAST_ALL);
//		ThrowSmallStuff (self, point);
X
X		VectorSet (offset, -12.67, -4.39, 15.68);
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, point);
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_EXPLOSION1);
X		gi.WritePosition (point);
X		gi.multicast (point, MULTICAST_ALL);
//		ThrowSmallStuff (self, point);
X
X		self->nextthink = level.time + FRAMETIME;
X		return;
X	}
X	self->nextthink = level.time + FRAMETIME;
}
X
void Widowlegs_Spawn (vec3_t startpos, vec3_t angles)
{
X	edict_t *ent;
X
X	ent = G_Spawn();
X	VectorCopy(startpos, ent->s.origin);
X	VectorCopy(angles, ent->s.angles);
X	ent->solid = SOLID_NOT;
X	ent->s.renderfx = RF_IR_VISIBLE;
X	ent->movetype = MOVETYPE_NONE;
X	ent->classname = "widowlegs";
X
X	ent->s.modelindex = gi.modelindex("models/monsters/legs/tris.md2");
X	ent->think = widowlegs_think;
X
X	ent->nextthink = level.time + FRAMETIME;
X	gi.linkentity (ent);
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_spawn.c' &&
  chmod 0664 'g_spawn.c' ||
  $echo 'restore of' 'g_spawn.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_spawn.c:' 'MD5 check failed'
7c532e556b2128922d8fafbb597d39bd  g_spawn.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_spawn.c'`"
    test 44893 -eq "$shar_count" ||
    $echo 'g_spawn.c:' 'original size' '44893,' 'current size' "$shar_count!"
  fi
fi
# ============= g_sphere.c ==============
if test -f 'g_sphere.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_sphere.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_sphere.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_sphere.c' &&
// g_sphere.c
// pmack
// april 1998
X
// defender - actively finds and shoots at enemies
// hunter - waits until < 25% health and vore ball tracks person who hurt you
// vengeance - kills person who killed you.
X
#include "g_local.h"
X
#define DEFENDER_LIFESPAN	30
#define HUNTER_LIFESPAN		30
#define VENGEANCE_LIFESPAN	30
#define MINIMUM_FLY_TIME	15
//#define MINIMUM_FLY_TIME	30
X
// FIXME - do we need to be calling ED_NewString at all?
extern char *ED_NewString (char *string);
void LookAtKiller (edict_t *self, edict_t *inflictor, edict_t *attacker);
X
X
void defender_think (edict_t *self);
void hunter_think (edict_t *self);
void vengeance_think (edict_t *self);
void vengeance_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf);
void hunter_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf);
X
// *************************
// General Sphere Code
// *************************
X
// =================
// =================
void sphere_think_explode (edict_t *self)
{
X	if(self->owner && self->owner->client && !(self->spawnflags & SPHERE_DOPPLEGANGER))
X	{
X		self->owner->client->owned_sphere = NULL;
X	}
X	BecomeExplosion1 (self);
}
X
// =================
// sphere_explode
// =================
void sphere_explode (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
//	if(self->owner && self->owner->client)
//		gi.cprintf(self->owner, PRINT_HIGH, "Sphere timed out\n");
//	gi.dprintf("player died, blowing up\n");
X	sphere_think_explode (self);
}
X
// =================
// sphere_if_idle_die - if the sphere is not currently attacking, blow up.
// =================
void sphere_if_idle_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	if(!self->enemy)
X	{
//		gi.dprintf("player died, blowing up\n");
X		sphere_think_explode(self);
X	}
}
X
// *************************
// Sphere Movement
// *************************
X
// =================
// =================
void sphere_fly (edict_t *self)
{
X	vec3_t	dest;
X	vec3_t	dir;
X
X	if(level.time >= self->wait)
X	{
//		gi.dprintf("fly: timed out\n");
X		sphere_think_explode(self);
X		return;
X	}
X
X	VectorCopy (self->owner->s.origin, dest);
X	dest[2] = self->owner->absmax[2] + 4;
X
X	if(level.time == (float)(int)level.time)
X	{
X		if(!visible(self, self->owner))
X		{
X			VectorCopy(dest, self->s.origin);
X			gi.linkentity(self);
X			return;
X		}
X	}
X
X	VectorSubtract (dest, self->s.origin, dir);
X	VectorScale (dir, 5, self->velocity);
}
X
// =================
// =================
void sphere_chase (edict_t *self, int stupidChase)
{
X	vec3_t	dest;
X	vec3_t	dir;
X	float	dist;
X
X	if(level.time >= self->wait || (self->enemy && self->enemy->health < 1))
X	{
X		sphere_think_explode(self);
X		return;
X	}
X
X	VectorCopy (self->enemy->s.origin, dest);
X	if(self->enemy->client)
X		dest[2] += self->enemy->viewheight;
X
X	if(visible(self, self->enemy) || stupidChase)
X	{
X		// if moving, hunter sphere uses active sound
X		if(!stupidChase)
X			self->s.sound = gi.soundindex ("spheres/h_active.wav");
X
X		VectorSubtract (dest, self->s.origin, dir);
X		VectorNormalize (dir);
X		vectoangles2(dir, self->s.angles);
X		VectorScale (dir, 500, self->velocity);
X		VectorCopy(dest, self->monsterinfo.saved_goal);
X	}
X	else if (VectorCompare (self->monsterinfo.saved_goal, vec3_origin))
X	{
X		VectorSubtract(self->enemy->s.origin, self->s.origin, dir);
X		dist = VectorNormalize(dir);
X		vectoangles2(dir, self->s.angles);
X
X		// if lurking, hunter sphere uses lurking sound
X		self->s.sound = gi.soundindex ("spheres/h_lurk.wav");
X		VectorClear (self->velocity);
X	}
X	else
X	{
X		VectorSubtract(self->monsterinfo.saved_goal, self->s.origin, dir);
X		dist = VectorNormalize(dir);
X
X		if(dist > 1)
X		{
X			vectoangles2(dir, self->s.angles);
X
X			if(dist > 500)			
X				VectorScale(dir, 500, self->velocity);
X			else if (dist < 20)
X				VectorScale(dir, (dist / FRAMETIME), self->velocity);
X			else
X				VectorScale(dir, dist, self->velocity);
X
X			// if moving, hunter sphere uses active sound
X			if(!stupidChase)
X				self->s.sound = gi.soundindex ("spheres/h_active.wav");
X		}
X		else
X		{
X			VectorSubtract(self->enemy->s.origin, self->s.origin, dir);
X			dist = VectorNormalize(dir);
X			vectoangles2(dir, self->s.angles);
X
X			// if not moving, hunter sphere uses lurk sound
X			if(!stupidChase)
X				self->s.sound = gi.soundindex ("spheres/h_lurk.wav");
X
X			VectorClear(self->velocity);
X		}
X	}
}
X
// *************************
// Attack related stuff
// *************************
X
// =================
// =================
void sphere_fire (edict_t *self, edict_t *enemy)
{
X	vec3_t	dest;
X	vec3_t	dir;
X
X	if(level.time >= self->wait || !enemy)
X	{
X		sphere_think_explode(self);
X		return;
X	}
X
X	VectorCopy (enemy->s.origin, dest);
X	self->s.effects |= EF_ROCKET;
X
X	VectorSubtract (dest, self->s.origin, dir);
X	VectorNormalize (dir);
X	vectoangles2 ( dir, self->s.angles );
X	VectorScale (dir, 1000, self->velocity);
X
X	self->touch = vengeance_touch;
X	self->think = sphere_think_explode;
X	self->nextthink = self->wait;
}
X
// =================
// =================
void sphere_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf, int mod)
{
X	if(self->spawnflags & SPHERE_DOPPLEGANGER)
X	{
X		if (other == self->teammaster)
X			return;
X
X		self->takedamage = DAMAGE_NO;
X		self->owner = self->teammaster;
X		self->teammaster = NULL;
X	}
X	else
X	{
X		if (other == self->owner)
X			return;
X		// PMM - don't blow up on bodies
X		if (!strcmp(other->classname, "bodyque"))
X			return;
X	}
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (other->takedamage)
X	{
X		T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal,
X			10000, 1, DAMAGE_DESTROY_ARMOR, mod);
X	}
X	else
X	{
X		T_RadiusDamage (self, self->owner, 512, self->owner, 256, mod);
X	}
X
X	sphere_think_explode (self);
}
X
// =================
// =================
void vengeance_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if(self->spawnflags & SPHERE_DOPPLEGANGER)
X		sphere_touch (self, other, plane, surf, MOD_DOPPLE_VENGEANCE);
X	else
X		sphere_touch (self, other, plane, surf, MOD_VENGEANCE_SPHERE);
}
X
// =================
// =================
void hunter_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	edict_t	*owner;
X
X	// don't blow up if you hit the world.... sheesh.
X	if(other==world)
X		return;
X
X	if(self->owner)
X	{
X		// if owner is flying with us, make sure they stop too.
X		owner=self->owner;
X		if(owner->flags & FL_SAM_RAIMI)
X		{
X			VectorClear(owner->velocity);
X			owner->movetype = MOVETYPE_NONE;
X			gi.linkentity(owner);
X		}
X	}
X
X	if(self->spawnflags & SPHERE_DOPPLEGANGER)
X		sphere_touch (self, other, plane, surf, MOD_DOPPLE_HUNTER);
X	else
X		sphere_touch (self, other, plane, surf, MOD_HUNTER_SPHERE);
}
X
// =================
// =================
void defender_shoot (edict_t *self, edict_t *enemy)
{
X	vec3_t	dir;
X	vec3_t	start;
X
X	if(!(enemy->inuse) || enemy->health <= 0)
X		return;
X
X	if(enemy == self->owner)
X		return;
X
X	VectorSubtract (enemy->s.origin, self->s.origin, dir);
X	VectorNormalize (dir);
X
X	if(self->monsterinfo.attack_finished > level.time)
X		return;
X
X	if(!visible(self, self->enemy))
X		return;
X
X	VectorCopy(self->s.origin, start);
X	start[2] += 2;
X	fire_blaster2 (self->owner, start, dir, 10, 1000, EF_BLASTER, 0);
X
X	self->monsterinfo.attack_finished = level.time + 0.4;
}
X
// *************************
// Activation Related Stuff
// *************************
X
// =================
// =================
void body_gib (edict_t *self)
{
X	int		n;
X
X	gi.sound (self, CHAN_BODY, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X	for (n= 0; n < 4; n++)
X		ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", 50, GIB_ORGANIC);
X	ThrowGib (self, "models/objects/gibs/skull/tris.md2", 50, GIB_ORGANIC);
}
X
// =================
// =================
void hunter_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	edict_t	*owner;
X	float	dist;
X	vec3_t	dir;
X
X	if(self->enemy)
X		return;
X
X	owner = self->owner;
X
X	if(!(self->spawnflags & SPHERE_DOPPLEGANGER))
X	{
X		if(owner && (owner->health > 0))
X			return;
X
X		//PMM
X		if(other == owner)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("hunter: won't get mad at my owner!\n");
X			return;
X		}
X		//pmm
X	}
X	else
X	{
X		// if fired by a doppleganger, set it to 10 second timeout
X		self->wait = level.time + MINIMUM_FLY_TIME;
X	}
X
X	if((self->wait - level.time) < MINIMUM_FLY_TIME)
X		self->wait = level.time + MINIMUM_FLY_TIME;
X	self->s.effects |= EF_BLASTER | EF_TRACKER;
X	self->touch = hunter_touch;
X	self->enemy = other;
X
//	if(g_showlogic && g_showlogic->value)
//		gi.dprintf("hunter_pain: mad at %s\n", other->classname);
X
X	// if we're not owned by a player, no sam raimi
X	// if we're spawned by a doppleganger, no sam raimi
X	if((self->spawnflags & SPHERE_DOPPLEGANGER)  || !(owner && owner->client))		
X		return;
X
X	// sam raimi cam is disabled if FORCE_RESPAWN is set.
X	// sam raimi cam is also disabled if huntercam->value is 0.
X	if(!((int)dmflags->value & DF_FORCE_RESPAWN) &&	(huntercam && (huntercam->value)))
X	{
X		VectorSubtract(other->s.origin, self->s.origin, dir);
X		dist=VectorLength(dir);
X
X		if(owner && (dist >= 192))
X		{
X			// detach owner from body and send him flying
X			owner->movetype = MOVETYPE_FLYMISSILE;
X
X			// gib like we just died, even though we didn't, really.
X			body_gib(owner);
X
X			// move the sphere to the owner's current viewpoint.
X			// we know it's a valid spot (or will be momentarily)
X			VectorCopy(owner->s.origin, self->s.origin);
X			self->s.origin[2] += owner->viewheight;
X
X			// move the player's origin to the sphere's new origin
X			VectorCopy(self->s.origin, owner->s.origin);
X			VectorCopy(self->s.angles, owner->s.angles);
X			VectorCopy(self->s.angles, owner->client->v_angle);
X			VectorClear(owner->mins);
X			VectorClear(owner->maxs);
X			VectorSet(owner->mins, -5, -5, -5);
X			VectorSet(owner->maxs, 5, 5, 5);
X			owner->client->ps.fov = 140;
X			owner->s.modelindex = 0;
X			owner->s.modelindex2 = 0;
X			owner->viewheight = 8;
X			owner->solid = SOLID_NOT;
X			owner->flags |= FL_SAM_RAIMI;
X			gi.linkentity(owner);
X
X			// PMM - set bounding box so we don't clip out of world
//			VectorSet(self->mins, -5, -5, -5);
//			VectorSet(self->maxs, 5, 5, 5);
X			self->solid = SOLID_BBOX;
X			gi.linkentity (self);
X		}
//		else
//			gi.dprintf("too close for sam raimi cam\n");
X	}
}
X
// =================
// =================
void defender_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	//PMM
X	if(other == self->owner)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("defender: won't get mad at my owner!\n");
X		return;
X	}
X	//pmm
X	self->enemy = other;
}
X
// =================
// =================
void vengeance_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if(self->enemy)
X		return;
X
X	if(!(self->spawnflags & SPHERE_DOPPLEGANGER))
X	{
X		if(self->owner->health >= 25)
X			return;
X
X		//PMM
X		if(other == self->owner)
X		{
X	//		if ((g_showlogic) && (g_showlogic->value))
X	//			gi.dprintf ("vengeance: won't get mad at my owner!\n");
X			return;
X		}
X		//pmm
X	}
X	else
X	{
X		self->wait = level.time + MINIMUM_FLY_TIME;
X	}
X
X	if((self->wait - level.time) < MINIMUM_FLY_TIME)
X		self->wait = level.time + MINIMUM_FLY_TIME;
X	self->s.effects |= EF_ROCKET;
X	self->touch = vengeance_touch;
X	self->enemy = other;
}
X
// *************************
// Think Functions
// *************************
X
// ===================
// ===================
void defender_think (edict_t *self)
{
X	if(!self->owner)
X	{
//		gi.dprintf("think: no owner\n");
X		G_FreeEdict(self);
X		return;
X	}
X
X	// if we've exited the level, just remove ourselves.
X	if (level.intermissiontime)
X	{	
X		sphere_think_explode(self);
X		return;
X	}	
X
X	if(self->owner->health <=0)
X	{
X		sphere_think_explode(self);
X		return;
X	}
X
//	if(level.time - self->timestamp > 1)
//	{
//		gi.sound (self, CHAN_VOICE, gi.soundindex ("powerup/dsphere.wav"), 0.6, ATTN_NORM, 0);
//		self->timestamp = level.time;
//	}
X
X	self->s.frame++;
X	if(self->s.frame>19)
X		self->s.frame = 0;
X
X	if(self->enemy)
X	{
X		if(self->enemy->health > 0)
X		{
//			gi.dprintf( "shooting at %s\n", self->enemy->classname);
X			defender_shoot (self, self->enemy);
X		}
X		else
X			self->enemy = NULL;
X	}
//	else
//	{
//		self->ideal_yaw+=3;
//		M_ChangeYaw (self);
//	}
X
X	sphere_fly (self);
X
X	if(self->inuse)
X		self->nextthink = level.time + 0.1;
}
X
// =================
// =================
void hunter_think (edict_t *self)
{
X	edict_t *owner;
X	vec3_t	dir, ang;
X
X	// if we've exited the level, just remove ourselves.
X	if (level.intermissiontime)
X	{	
X		sphere_think_explode(self);
X		return;
X	}	
X
X	owner = self->owner;
X	if(!owner && !(self->spawnflags & SPHERE_DOPPLEGANGER))
X	{
//		gi.dprintf("think: no owner\n");
X		G_FreeEdict(self);
X		return;
X	}
X
X	if(owner)
X		self->ideal_yaw = owner->s.angles[YAW];
X	else if(self->enemy)		// fired by doppleganger
X	{
X		VectorSubtract(self->enemy->s.origin, self->s.origin, dir);
X		vectoangles2(dir, ang);
X		self->ideal_yaw = ang[YAW];
X	}
X
X	M_ChangeYaw(self);
X
//	if(level.time - self->timestamp > 1)
//	{
//		gi.sound (self, CHAN_VOICE, gi.soundindex ("powerup/hsphere.wav"), 0.5, ATTN_NORM, 0);
//		self->timestamp = level.time;
//	}
X
X	if(self->enemy)
X	{
X		sphere_chase (self, 0);
X
X		// deal with sam raimi cam
X		if(owner && (owner->flags & FL_SAM_RAIMI)) 
X		{
X			if(self->inuse)
X			{
X				owner->movetype = MOVETYPE_FLYMISSILE;
//				VectorCopy(self->s.angles, owner->s.angles);
//				VectorCopy(self->s.angles, owner->client->v_angle);
X				LookAtKiller (owner, self, self->enemy);
//				owner->viewheight = 22;
X
//				owner->client->v_angle[YAW]+=5;
X				// owner is flying with us, move him too
X				owner->movetype = MOVETYPE_FLYMISSILE;
X				owner->viewheight = self->s.origin[2] - owner->s.origin[2];
//				VectorCopy(self->s.angles, owner->s.angles);
//				VectorCopy(self->s.angles, owner->client->v_angle);
X				VectorCopy(self->s.origin, owner->s.origin);
X				VectorCopy(self->velocity, owner->velocity);
X				VectorClear(owner->mins);
X				VectorClear(owner->maxs);
X				gi.linkentity(owner);
X			}
X			else	// sphere timed out
X			{
X				VectorClear(owner->velocity);
X				owner->movetype = MOVETYPE_NONE;
X				gi.linkentity(owner);
X			}
X		}
X	}
X	else 
X	{
//		self->ideal_yaw+=3;
//		M_ChangeYaw (self);
X		sphere_fly (self);
X	}
X
X	if(self->inuse)
X		self->nextthink = level.time + 0.1;
}
X
// =================
// =================
void vengeance_think (edict_t *self)
{
X	// if we've exited the level, just remove ourselves.
X	if (level.intermissiontime)
X	{	
X		sphere_think_explode(self);
X		return;
X	}	
X
X	if(!(self->owner) && !(self->spawnflags & SPHERE_DOPPLEGANGER))
X	{
//		gi.dprintf("think: no owner\n");
X		G_FreeEdict(self);
X		return;
X	}
X
//	if(level.time - self->timestamp > 1)
//	{
//		gi.sound (self, CHAN_VOICE, gi.soundindex ("powerup/vsphere.wav"), 0.5, ATTN_NORM, 0);
//		self->timestamp = level.time;
//	}
X
X	if(self->enemy)
X	{
//		sphere_fire (self, self->owner->enemy);
X		sphere_chase (self, 1);
X	}
X	else
X		sphere_fly (self);
X
X	if(self->inuse)
X		self->nextthink = level.time + 0.1;
}
X
// *************************
// Spawning / Creation
// *************************
X
// monsterinfo_t
// =================
// =================
edict_t *Sphere_Spawn (edict_t *owner, int spawnflags)
{
X	edict_t *sphere;
X
X	sphere = G_Spawn();
X	VectorCopy(owner->s.origin, sphere->s.origin);
X	sphere->s.origin[2] = owner->absmax[2];
X	sphere->s.angles[YAW] = owner->s.angles[YAW];
X	sphere->solid = SOLID_BBOX;
X	sphere->clipmask = MASK_SHOT;
X	sphere->s.renderfx = RF_FULLBRIGHT | RF_IR_VISIBLE;
X	sphere->movetype = MOVETYPE_FLYMISSILE;
X
X	if(spawnflags & SPHERE_DOPPLEGANGER)
X		sphere->teammaster = owner->teammaster;
X	else
X		sphere->owner = owner;
X	
X	sphere->classname = "sphere";
X	sphere->yaw_speed = 40;
X	sphere->monsterinfo.attack_finished = 0;
X	sphere->spawnflags = spawnflags;		// need this for the HUD to recognize sphere
X	//PMM
X	sphere->takedamage = DAMAGE_NO;
X
X	switch(spawnflags & SPHERE_TYPE)
X	{
X		case SPHERE_DEFENDER:
X			sphere->s.modelindex = gi.modelindex("models/items/defender/tris.md2");
X			// PMM - this doesn't work, causes problems with other stuff
//			sphere->s.modelindex2 = gi.modelindex("models/items/shell/tris.md2") | 0x80;
X			sphere->s.modelindex2 = gi.modelindex("models/items/shell/tris.md2");
X			sphere->s.sound = gi.soundindex ("spheres/d_idle.wav");
X			sphere->pain = defender_pain;
X			sphere->wait = level.time + DEFENDER_LIFESPAN;
X			sphere->die = sphere_explode;
X			sphere->think = defender_think;
X			break;
X		case SPHERE_HUNTER:
X			sphere->s.modelindex = gi.modelindex("models/items/hunter/tris.md2");
X			sphere->s.sound = gi.soundindex ("spheres/h_idle.wav");
X			sphere->wait = level.time + HUNTER_LIFESPAN;
X			sphere->pain = hunter_pain;
X			sphere->die = sphere_if_idle_die;
X			sphere->think = hunter_think;
X			break;
X		case SPHERE_VENGEANCE:
X			sphere->s.modelindex = gi.modelindex("models/items/vengnce/tris.md2");
X			sphere->s.sound = gi.soundindex ("spheres/v_idle.wav");
X			sphere->wait = level.time + VENGEANCE_LIFESPAN;
X			sphere->pain = vengeance_pain;
X			sphere->die = sphere_if_idle_die;
X			sphere->think = vengeance_think;
X			VectorSet (sphere->avelocity, 30, 30, 0);
X			break;
X		default:
X			gi.dprintf("Tried to create an invalid sphere\n");
X			G_FreeEdict(sphere);
X			return NULL;
X	}
X	
X	sphere->nextthink = level.time + 0.1;
X
X	gi.linkentity (sphere);
X
X	return sphere;
}
X
// =================
// Own_Sphere - attach the sphere to the client so we can 
//		directly access it later
// =================
void Own_Sphere (edict_t *self, edict_t *sphere)
{
X	if(!sphere)
X		return;
X
X	// ownership only for players	
X	if(self->client)
X	{
X		// if they don't have one
X		if(!(self->client->owned_sphere))
X		{
X			self->client->owned_sphere = sphere;
X		}
X		// they already have one, take care of the old one
X		else
X		{
X			if(self->client->owned_sphere->inuse)
X			{
X				G_FreeEdict(self->client->owned_sphere);
X				self->client->owned_sphere = sphere;
X			}
X			else
X			{
X				self->client->owned_sphere = sphere;
X			}
X		}
X	}
}
X
// =================
// =================
void Defender_Launch (edict_t *self)
{
X	edict_t		*sphere;
X
X	sphere = Sphere_Spawn (self, SPHERE_DEFENDER);	
X	Own_Sphere (self, sphere);
}
X
// =================
// =================
void Hunter_Launch (edict_t *self)
{
X	edict_t		*sphere;
X
X	sphere = Sphere_Spawn (self, SPHERE_HUNTER);	
X	Own_Sphere (self, sphere);
}
X
// =================
// =================
void Vengeance_Launch (edict_t *self)
{
X	edict_t		*sphere;
X
X	sphere = Sphere_Spawn (self, SPHERE_VENGEANCE);	
X	Own_Sphere (self, sphere);
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_sphere.c' &&
  chmod 0664 'g_sphere.c' ||
  $echo 'restore of' 'g_sphere.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_sphere.c:' 'MD5 check failed'
05833bc3e9d92b73909772084369b4fa  g_sphere.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_sphere.c'`"
    test 18537 -eq "$shar_count" ||
    $echo 'g_sphere.c:' 'original size' '18537,' 'current size' "$shar_count!"
  fi
fi
# ============= g_svcmds.c ==============
if test -f 'g_svcmds.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_svcmds.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_svcmds.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_svcmds.c' &&
X
#include "g_local.h"
X
X
void	Svcmd_Test_f (void)
{
X	gi.cprintf (NULL, PRINT_HIGH, "Svcmd_Test_f()\n");
}
X
/*
==============================================================================
X
PACKET FILTERING
X 
X
You can add or remove addresses from the filter list with:
X
addip <ip>
removeip <ip>
X
The ip address is specified in dot format, and any unspecified digits will match any value, so you can specify an entire class C network with "addip 192.246.40".
X
Removeip will only remove an address specified exactly the same way.  You cannot addip a subnet, then removeip a single host.
X
listip
Prints the current list of filters.
X
writeip
Dumps "addip <ip>" commands to listip.cfg so it can be execed at a later date.  The filter lists are not saved and restored by default, because I beleive it would cause too much confusion.
X
filterban <0 or 1>
X
If 1 (the default), then ip addresses matching the current list will be prohibited from entering the game.  This is the default setting.
X
If 0, then only addresses matching the list will be allowed.  This lets you easily set up a private game, or a game that only allows players from your local network.
X
X
==============================================================================
*/
X
typedef struct
{
X	unsigned	mask;
X	unsigned	compare;
} ipfilter_t;
X
#define	MAX_IPFILTERS	1024
X
ipfilter_t	ipfilters[MAX_IPFILTERS];
int			numipfilters;
X
/*
=================
StringToFilter
=================
*/
static qboolean StringToFilter (char *s, ipfilter_t *f)
{
X	char	num[128];
X	int		i, j;
X	byte	b[4];
X	byte	m[4];
X	
X	for (i=0 ; i<4 ; i++)
X	{
X		b[i] = 0;
X		m[i] = 0;
X	}
X	
X	for (i=0 ; i<4 ; i++)
X	{
X		if (*s < '0' || *s > '9')
X		{
X			gi.cprintf(NULL, PRINT_HIGH, "Bad filter address: %s\n", s);
X			return false;
X		}
X		
X		j = 0;
X		while (*s >= '0' && *s <= '9')
X		{
X			num[j++] = *s++;
X		}
X		num[j] = 0;
X		b[i] = atoi(num);
X		if (b[i] != 0)
X			m[i] = 255;
X
X		if (!*s)
X			break;
X		s++;
X	}
X	
X	f->mask = *(unsigned *)m;
X	f->compare = *(unsigned *)b;
X	
X	return true;
}
X
/*
=================
SV_FilterPacket
=================
*/
qboolean SV_FilterPacket (char *from)
{
X	int		i;
X	unsigned	in;
X	byte m[4];
X	char *p;
X
X	i = 0;
X	p = from;
X	while (*p && i < 4) {
X		m[i] = 0;
X		while (*p >= '0' && *p <= '9') {
X			m[i] = m[i]*10 + (*p - '0');
X			p++;
X		}
X		if (!*p || *p == ':')
X			break;
X		i++, p++;
X	}
X	
X	in = *(unsigned *)m;
X
X	for (i=0 ; i<numipfilters ; i++)
X		if ( (in & ipfilters[i].mask) == ipfilters[i].compare)
X			return (int)filterban->value;
X
X	return (int)!filterban->value;
}
X
X
/*
=================
SV_AddIP_f
=================
*/
void SVCmd_AddIP_f (void)
{
X	int		i;
X	
X	if (gi.argc() < 3) {
X		gi.cprintf(NULL, PRINT_HIGH, "Usage:  addip <ip-mask>\n");
X		return;
X	}
X
X	for (i=0 ; i<numipfilters ; i++)
X		if (ipfilters[i].compare == 0xffffffff)
X			break;		// free spot
X	if (i == numipfilters)
X	{
X		if (numipfilters == MAX_IPFILTERS)
X		{
X			gi.cprintf (NULL, PRINT_HIGH, "IP filter list is full\n");
X			return;
X		}
X		numipfilters++;
X	}
X	
X	if (!StringToFilter (gi.argv(2), &ipfilters[i]))
X		ipfilters[i].compare = 0xffffffff;
}
X
/*
=================
SV_RemoveIP_f
=================
*/
void SVCmd_RemoveIP_f (void)
{
X	ipfilter_t	f;
X	int			i, j;
X
X	if (gi.argc() < 3) {
X		gi.cprintf(NULL, PRINT_HIGH, "Usage:  sv removeip <ip-mask>\n");
X		return;
X	}
X
X	if (!StringToFilter (gi.argv(2), &f))
X		return;
X
X	for (i=0 ; i<numipfilters ; i++)
X		if (ipfilters[i].mask == f.mask
X		&& ipfilters[i].compare == f.compare)
X		{
X			for (j=i+1 ; j<numipfilters ; j++)
X				ipfilters[j-1] = ipfilters[j];
X			numipfilters--;
X			gi.cprintf (NULL, PRINT_HIGH, "Removed.\n");
X			return;
X		}
X	gi.cprintf (NULL, PRINT_HIGH, "Didn't find %s.\n", gi.argv(2));
}
X
/*
=================
SV_ListIP_f
=================
*/
void SVCmd_ListIP_f (void)
{
X	int		i;
X	byte	b[4];
X
X	gi.cprintf (NULL, PRINT_HIGH, "Filter list:\n");
X	for (i=0 ; i<numipfilters ; i++)
X	{
X		*(unsigned *)b = ipfilters[i].compare;
X		gi.cprintf (NULL, PRINT_HIGH, "%3i.%3i.%3i.%3i\n", b[0], b[1], b[2], b[3]);
X	}
}
X
/*
=================
SV_WriteIP_f
=================
*/
void SVCmd_WriteIP_f (void)
{
X	FILE	*f;
X	char	name[MAX_OSPATH];
X	byte	b[4];
X	int		i;
X	cvar_t	*game;
X
X	game = gi.cvar("game", "", 0);
X
X	if (!*game->string)
X		sprintf (name, "%s/listip.cfg", GAMEVERSION);
X	else
X		sprintf (name, "%s/listip.cfg", game->string);
X
X	gi.cprintf (NULL, PRINT_HIGH, "Writing %s.\n", name);
X
X	f = fopen (name, "wb");
X	if (!f)
X	{
X		gi.cprintf (NULL, PRINT_HIGH, "Couldn't open %s\n", name);
X		return;
X	}
X	
X	fprintf(f, "set filterban %d\n", (int)filterban->value);
X
X	for (i=0 ; i<numipfilters ; i++)
X	{
X		*(unsigned *)b = ipfilters[i].compare;
X		fprintf (f, "sv addip %i.%i.%i.%i\n", b[0], b[1], b[2], b[3]);
X	}
X	
X	fclose (f);
}
X
/*
=================
ServerCommand
X
ServerCommand will be called when an "sv" command is issued.
The game can issue gi.argc() / gi.argv() commands to get the rest
of the parameters
=================
*/
void	ServerCommand (void)
{
X	char	*cmd;
X
X	cmd = gi.argv(1);
X	if (Q_stricmp (cmd, "test") == 0)
X		Svcmd_Test_f ();
X	else if (Q_stricmp (cmd, "addip") == 0)
X		SVCmd_AddIP_f ();
X	else if (Q_stricmp (cmd, "removeip") == 0)
X		SVCmd_RemoveIP_f ();
X	else if (Q_stricmp (cmd, "listip") == 0)
X		SVCmd_ListIP_f ();
X	else if (Q_stricmp (cmd, "writeip") == 0)
X		SVCmd_WriteIP_f ();
X	else
X		gi.cprintf (NULL, PRINT_HIGH, "Unknown server command \"%s\"\n", cmd);
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_svcmds.c' &&
  chmod 0664 'g_svcmds.c' ||
  $echo 'restore of' 'g_svcmds.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_svcmds.c:' 'MD5 check failed'
7cbfff31b7396dcef4a2a3a2a5894a7e  g_svcmds.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_svcmds.c'`"
    test 5345 -eq "$shar_count" ||
    $echo 'g_svcmds.c:' 'original size' '5345,' 'current size' "$shar_count!"
  fi
fi
# ============= g_target.c ==============
if test -f 'g_target.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_target.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_target.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_target.c' &&
#include "g_local.h"
X
/*QUAKED target_temp_entity (1 0 0) (-8 -8 -8) (8 8 8)
Fire an origin based temp entity event to the clients.
"style"		type byte
*/
void Use_Target_Tent (edict_t *ent, edict_t *other, edict_t *activator)
{
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (ent->style);
X	gi.WritePosition (ent->s.origin);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
}
X
void SP_target_temp_entity (edict_t *ent)
{
X	ent->use = Use_Target_Tent;
}
X
X
//==========================================================
X
//==========================================================
X
/*QUAKED target_speaker (1 0 0) (-8 -8 -8) (8 8 8) looped-on looped-off reliable
"noise"		wav file to play
"attenuation"
-1 = none, send to whole level
1 = normal fighting sounds
2 = idle sound level
3 = ambient sound level
"volume"	0.0 to 1.0
X
Normal sounds play each time the target is used.  The reliable flag can be set for crucial voiceovers.
X
Looped sounds are always atten 3 / vol 1, and the use function toggles it on/off.
Multiple identical looping sounds will just increase volume without any speed cost.
*/
void Use_Target_Speaker (edict_t *ent, edict_t *other, edict_t *activator)
{
X	int		chan;
X
X	if (ent->spawnflags & 3)
X	{	// looping sound toggles
X		if (ent->s.sound)
X			ent->s.sound = 0;	// turn it off
X		else
X			ent->s.sound = ent->noise_index;	// start it
X	}
X	else
X	{	// normal sound
X		if (ent->spawnflags & 4)
X			chan = CHAN_VOICE|CHAN_RELIABLE;
X		else
X			chan = CHAN_VOICE;
X		// use a positioned_sound, because this entity won't normally be
X		// sent to any clients because it is invisible
X		gi.positioned_sound (ent->s.origin, ent, chan, ent->noise_index, ent->volume, ent->attenuation, 0);
X	}
}
X
void SP_target_speaker (edict_t *ent)
{
X	char	buffer[MAX_QPATH];
X
X	if(!st.noise)
X	{
X		gi.dprintf("target_speaker with no noise set at %s\n", vtos(ent->s.origin));
X		return;
X	}
X	if (!strstr (st.noise, ".wav"))
X		Com_sprintf (buffer, sizeof(buffer), "%s.wav", st.noise);
X	else
X		strncpy (buffer, st.noise, sizeof(buffer));
X	ent->noise_index = gi.soundindex (buffer);
X
X	if (!ent->volume)
X		ent->volume = 1.0;
X
X	if (!ent->attenuation)
X		ent->attenuation = 1.0;
X	else if (ent->attenuation == -1)	// use -1 so 0 defaults to 1
X		ent->attenuation = 0;
X
X	// check for prestarted looping sound
X	if (ent->spawnflags & 1)
X		ent->s.sound = ent->noise_index;
X
X	ent->use = Use_Target_Speaker;
X
X	// must link the entity so we get areas and clusters so
X	// the server can determine who to send updates to
X	gi.linkentity (ent);
}
X
X
//==========================================================
X
void Use_Target_Help (edict_t *ent, edict_t *other, edict_t *activator)
{
X	if (ent->spawnflags & 1)
X		strncpy (game.helpmessage1, ent->message, sizeof(game.helpmessage2)-1);
X	else
X		strncpy (game.helpmessage2, ent->message, sizeof(game.helpmessage1)-1);
X
X	game.helpchanged++;
}
X
/*QUAKED target_help (1 0 1) (-16 -16 -24) (16 16 24) help1
When fired, the "message" key becomes the current personal computer string, and the message light will be set on all clients status bars.
*/
void SP_target_help(edict_t *ent)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (ent);
X		return;
X	}
X
X	if (!ent->message)
X	{
X		gi.dprintf ("%s with no message at %s\n", ent->classname, vtos(ent->s.origin));
X		G_FreeEdict (ent);
X		return;
X	}
X	ent->use = Use_Target_Help;
}
X
//==========================================================
X
/*QUAKED target_secret (1 0 1) (-8 -8 -8) (8 8 8)
Counts a secret found.
These are single use targets.
*/
void use_target_secret (edict_t *ent, edict_t *other, edict_t *activator)
{
X	gi.sound (ent, CHAN_VOICE, ent->noise_index, 1, ATTN_NORM, 0);
X
X	level.found_secrets++;
X
X	G_UseTargets (ent, activator);
X	G_FreeEdict (ent);
}
X
void SP_target_secret (edict_t *ent)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (ent);
X		return;
X	}
X
X	ent->use = use_target_secret;
X	if (!st.noise)
X		st.noise = "misc/secret.wav";
X	ent->noise_index = gi.soundindex (st.noise);
X	ent->svflags = SVF_NOCLIENT;
X	level.total_secrets++;
X	// map bug hack
X	if (!Q_stricmp(level.mapname, "mine3") && ent->s.origin[0] == 280 && ent->s.origin[1] == -2048 && ent->s.origin[2] == -624)
X		ent->message = "You have found a secret area.";
}
X
//==========================================================
X
/*QUAKED target_goal (1 0 1) (-8 -8 -8) (8 8 8)
Counts a goal completed.
These are single use targets.
*/
void use_target_goal (edict_t *ent, edict_t *other, edict_t *activator)
{
X	gi.sound (ent, CHAN_VOICE, ent->noise_index, 1, ATTN_NORM, 0);
X
X	level.found_goals++;
X
X	if (level.found_goals == level.total_goals)
X		gi.configstring (CS_CDTRACK, "0");
X
X	G_UseTargets (ent, activator);
X	G_FreeEdict (ent);
}
X
void SP_target_goal (edict_t *ent)
{
X	if (deathmatch->value)
X	{	// auto-remove for deathmatch
X		G_FreeEdict (ent);
X		return;
X	}
X
X	ent->use = use_target_goal;
X	if (!st.noise)
X		st.noise = "misc/secret.wav";
X	ent->noise_index = gi.soundindex (st.noise);
X	ent->svflags = SVF_NOCLIENT;
X	level.total_goals++;
}
X
//==========================================================
X
X
/*QUAKED target_explosion (1 0 0) (-8 -8 -8) (8 8 8)
Spawns an explosion temporary entity when used.
X
"delay"		wait this long before going off
"dmg"		how much radius damage should be done, defaults to 0
*/
void target_explosion_explode (edict_t *self)
{
X	float		save;
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PHS);
X
X	T_RadiusDamage (self, self->activator, self->dmg, NULL, self->dmg+40, MOD_EXPLOSIVE);
X
X	save = self->delay;
X	self->delay = 0;
X	G_UseTargets (self, self->activator);
X	self->delay = save;
}
X
void use_target_explosion (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->activator = activator;
X
X	if (!self->delay)
X	{
X		target_explosion_explode (self);
X		return;
X	}
X
X	self->think = target_explosion_explode;
X	self->nextthink = level.time + self->delay;
}
X
void SP_target_explosion (edict_t *ent)
{
X	ent->use = use_target_explosion;
X	ent->svflags = SVF_NOCLIENT;
}
X
X
//==========================================================
X
/*QUAKED target_changelevel (1 0 0) (-8 -8 -8) (8 8 8)
Changes level to "map" when fired
*/
void use_target_changelevel (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (level.intermissiontime)
X		return;		// already activated
X
X	if (!deathmatch->value && !coop->value)
X	{
X		if (g_edicts[1].health <= 0)
X			return;
X	}
X
X	// if noexit, do a ton of damage to other
X	if (deathmatch->value && !( (int)dmflags->value & DF_ALLOW_EXIT) && other != world)
X	{
X		T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, 10 * other->max_health, 1000, 0, MOD_EXIT);
X		return;
X	}
X
X	// if multiplayer, let everyone know who hit the exit
X	if (deathmatch->value)
X	{
X		if (activator && activator->client)
X			gi.bprintf (PRINT_HIGH, "%s exited the level.\n", activator->client->pers.netname);
X	}
X
X	// if going to a new unit, clear cross triggers
X	if (strstr(self->map, "*"))	
X		game.serverflags &= ~(SFL_CROSS_TRIGGER_MASK);
X
X	BeginIntermission (self);
}
X
void SP_target_changelevel (edict_t *ent)
{
X	if (!ent->map)
X	{
X		gi.dprintf("target_changelevel with no map at %s\n", vtos(ent->s.origin));
X		G_FreeEdict (ent);
X		return;
X	}
X
X	// ugly hack because *SOMEBODY* screwed up their map
X   if((Q_stricmp(level.mapname, "fact1") == 0) && (Q_stricmp(ent->map, "fact3") == 0))
X	   ent->map = "fact3$secret1";
X
X	ent->use = use_target_changelevel;
X	ent->svflags = SVF_NOCLIENT;
}
X
X
//==========================================================
X
/*QUAKED target_splash (1 0 0) (-8 -8 -8) (8 8 8)
Creates a particle splash effect when used.
X
Set "sounds" to one of the following:
X  1) sparks
X  2) blue water
X  3) brown water
X  4) slime
X  5) lava
X  6) blood
X
"count"	how many pixels in the splash
"dmg"	if set, does a radius damage at this location when it splashes
X		useful for lava/sparks
*/
X
void use_target_splash (edict_t *self, edict_t *other, edict_t *activator)
{
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_SPLASH);
X	gi.WriteByte (self->count);
X	gi.WritePosition (self->s.origin);
X	gi.WriteDir (self->movedir);
X	gi.WriteByte (self->sounds);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	if (self->dmg)
X		T_RadiusDamage (self, activator, self->dmg, NULL, self->dmg+40, MOD_SPLASH);
}
X
void SP_target_splash (edict_t *self)
{
X	self->use = use_target_splash;
X	G_SetMovedir (self->s.angles, self->movedir);
X
X	if (!self->count)
X		self->count = 32;
X
X	self->svflags = SVF_NOCLIENT;
}
X
X
//==========================================================
X
/*QUAKED target_spawner (1 0 0) (-8 -8 -8) (8 8 8)
Set target to the type of entity you want spawned.
Useful for spawning monsters and gibs in the factory levels.
X
For monsters:
X	Set direction to the facing you want it to have.
X
For gibs:
X	Set direction if you want it moving and
X	speed how fast it should be moving otherwise it
X	will just be dropped
*/
void ED_CallSpawn (edict_t *ent);
X
void use_target_spawner (edict_t *self, edict_t *other, edict_t *activator)
{
X	edict_t	*ent;
X
X	ent = G_Spawn();
X	ent->classname = self->target;
X	VectorCopy (self->s.origin, ent->s.origin);
X	VectorCopy (self->s.angles, ent->s.angles);
X	ED_CallSpawn (ent);
X	gi.unlinkentity (ent);
X	KillBox (ent);
X	gi.linkentity (ent);
X	if (self->speed)
X		VectorCopy (self->movedir, ent->velocity);
X
X	ent->s.renderfx |= RF_IR_VISIBLE;		//PGM
}
X
void SP_target_spawner (edict_t *self)
{
X	self->use = use_target_spawner;
X	self->svflags = SVF_NOCLIENT;
X	if (self->speed)
X	{
X		G_SetMovedir (self->s.angles, self->movedir);
X		VectorScale (self->movedir, self->speed, self->movedir);
X	}
}
X
//==========================================================
X
/*QUAKED target_blaster (1 0 0) (-8 -8 -8) (8 8 8) NOTRAIL NOEFFECTS
Fires a blaster bolt in the set direction when triggered.
X
dmg		default is 15
speed	default is 1000
*/
X
void use_target_blaster (edict_t *self, edict_t *other, edict_t *activator)
{
X	int effect;
X
X	if (self->spawnflags & 2)
X		effect = 0;
X	else if (self->spawnflags & 1)
X		effect = EF_HYPERBLASTER;
X	else
X		effect = EF_BLASTER;
X
X	fire_blaster (self, self->s.origin, self->movedir, self->dmg, self->speed, EF_BLASTER, MOD_TARGET_BLASTER);
X	gi.sound (self, CHAN_VOICE, self->noise_index, 1, ATTN_NORM, 0);
}
X
void SP_target_blaster (edict_t *self)
{
X	self->use = use_target_blaster;
X	G_SetMovedir (self->s.angles, self->movedir);
X	self->noise_index = gi.soundindex ("weapons/laser2.wav");
X
X	if (!self->dmg)
X		self->dmg = 15;
X	if (!self->speed)
X		self->speed = 1000;
X
X	self->svflags = SVF_NOCLIENT;
}
X
X
//==========================================================
X
/*QUAKED target_crosslevel_trigger (.5 .5 .5) (-8 -8 -8) (8 8 8) trigger1 trigger2 trigger3 trigger4 trigger5 trigger6 trigger7 trigger8
Once this trigger is touched/used, any trigger_crosslevel_target with the same trigger number is automatically used when a level is started within the same unit.  It is OK to check multiple triggers.  Message, delay, target, and killtarget also work.
*/
void trigger_crosslevel_trigger_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	game.serverflags |= self->spawnflags;
X	G_FreeEdict (self);
}
X
void SP_target_crosslevel_trigger (edict_t *self)
{
X	self->svflags = SVF_NOCLIENT;
X	self->use = trigger_crosslevel_trigger_use;
}
X
/*QUAKED target_crosslevel_target (.5 .5 .5) (-8 -8 -8) (8 8 8) trigger1 trigger2 trigger3 trigger4 trigger5 trigger6 trigger7 trigger8
Triggered by a trigger_crosslevel elsewhere within a unit.  If multiple triggers are checked, all must be true.  Delay, target and
killtarget also work.
X
"delay"		delay before using targets if the trigger has been activated (default 1)
*/
void target_crosslevel_target_think (edict_t *self)
{
X	if (self->spawnflags == (game.serverflags & SFL_CROSS_TRIGGER_MASK & self->spawnflags))
X	{
X		G_UseTargets (self, self);
X		G_FreeEdict (self);
X	}
}
X
void SP_target_crosslevel_target (edict_t *self)
{
X	if (! self->delay)
X		self->delay = 1;
X	self->svflags = SVF_NOCLIENT;
X
X	self->think = target_crosslevel_target_think;
X	self->nextthink = level.time + self->delay;
}
X
//==========================================================
X
/*QUAKED target_laser (0 .5 .8) (-8 -8 -8) (8 8 8) START_ON RED GREEN BLUE YELLOW ORANGE FAT WINDOWSTOP
When triggered, fires a laser.  You can either set a target
or a direction.
X
WINDOWSTOP - stops at CONTENTS_WINDOW
*/
X
//======
// PGM
#define LASER_ON			0x0001
#define LASER_RED			0x0002
#define LASER_GREEN			0x0004
#define LASER_BLUE			0x0008
#define LASER_YELLOW		0x0010
#define LASER_ORANGE		0x0020
#define LASER_FAT			0x0040
#define LASER_STOPWINDOW	0x0080
// PGM
//======
X
void target_laser_think (edict_t *self)
{
X	edict_t	*ignore;
X	vec3_t	start;
X	vec3_t	end;
X	trace_t	tr;
X	vec3_t	point;
X	vec3_t	last_movedir;
X	int		count;
X
X	if (self->spawnflags & 0x80000000)
X		count = 8;
X	else
X		count = 4;
X
X	if (self->enemy)
X	{
X		VectorCopy (self->movedir, last_movedir);
X		VectorMA (self->enemy->absmin, 0.5, self->enemy->size, point);
X		VectorSubtract (point, self->s.origin, self->movedir);
X		VectorNormalize (self->movedir);
X		if (!VectorCompare(self->movedir, last_movedir))
X			self->spawnflags |= 0x80000000;
X	}
X
X	ignore = self;
X	VectorCopy (self->s.origin, start);
X	VectorMA (start, 2048, self->movedir, end);
X	while(1)
X	{
//======
// PGM
X		if(self->spawnflags & LASER_STOPWINDOW)
X			tr = gi.trace (start, NULL, NULL, end, ignore, MASK_SHOT);
X		else
X			tr = gi.trace (start, NULL, NULL, end, ignore, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_DEADMONSTER);
// PGM
//======
X
X		if (!tr.ent)
X			break;
X
X		// hurt it if we can
X		if ((tr.ent->takedamage) && !(tr.ent->flags & FL_IMMUNE_LASER))
X			T_Damage (tr.ent, self, self->activator, self->movedir, tr.endpos, vec3_origin, self->dmg, 1, DAMAGE_ENERGY, MOD_TARGET_LASER);
X
X		// if we hit something that's not a monster or player or is immune to lasers, we're done
//		if (!(tr.ent->svflags & SVF_MONSTER) && (!tr.ent->client))
X		//PMM added SVF_DAMAGEABLE
X		if (!(tr.ent->svflags & SVF_MONSTER) && (!tr.ent->client) && !(tr.ent->svflags & SVF_DAMAGEABLE))
X		{
X			if (self->spawnflags & 0x80000000)
X			{
X				self->spawnflags &= ~0x80000000;
X				gi.WriteByte (svc_temp_entity);
X				gi.WriteByte (TE_LASER_SPARKS);
X				gi.WriteByte (count);
X				gi.WritePosition (tr.endpos);
X				gi.WriteDir (tr.plane.normal);
X				gi.WriteByte (self->s.skinnum);
X				gi.multicast (tr.endpos, MULTICAST_PVS);
X			}
X			break;
X		}
X
X		ignore = tr.ent;
X		VectorCopy (tr.endpos, start);
X	}
X
X	VectorCopy (tr.endpos, self->s.old_origin);
X
X	self->nextthink = level.time + FRAMETIME;
}
X
void target_laser_on (edict_t *self)
{
X	if (!self->activator)
X		self->activator = self;
X	self->spawnflags |= 0x80000001;
X	self->svflags &= ~SVF_NOCLIENT;
X	target_laser_think (self);
}
X
void target_laser_off (edict_t *self)
{
X	self->spawnflags &= ~1;
X	self->svflags |= SVF_NOCLIENT;
X	self->nextthink = 0;
}
X
void target_laser_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->activator = activator;
X	if (self->spawnflags & 1)
X		target_laser_off (self);
X	else
X		target_laser_on (self);
}
X
void target_laser_start (edict_t *self)
{
X	edict_t *ent;
X
X	self->movetype = MOVETYPE_NONE;
X	self->solid = SOLID_NOT;
X	self->s.renderfx |= RF_BEAM|RF_TRANSLUCENT;
X	self->s.modelindex = 1;			// must be non-zero
X
X	// set the beam diameter
X	if (self->spawnflags & 64)
X		self->s.frame = 16;
X	else
X		self->s.frame = 4;
X
X	// set the color
X	if (self->spawnflags & 2)
X		self->s.skinnum = 0xf2f2f0f0;
X	else if (self->spawnflags & 4)
X		self->s.skinnum = 0xd0d1d2d3;
X	else if (self->spawnflags & 8)
X		self->s.skinnum = 0xf3f3f1f1;
X	else if (self->spawnflags & 16)
X		self->s.skinnum = 0xdcdddedf;
X	else if (self->spawnflags & 32)
X		self->s.skinnum = 0xe0e1e2e3;
X
X	if (!self->enemy)
X	{
X		if (self->target)
X		{
X			ent = G_Find (NULL, FOFS(targetname), self->target);
X			if (!ent)
X				gi.dprintf ("%s at %s: %s is a bad target\n", self->classname, vtos(self->s.origin), self->target);
X			self->enemy = ent;
X		}
X		else
X		{
X			G_SetMovedir (self->s.angles, self->movedir);
X		}
X	}
X	self->use = target_laser_use;
X	self->think = target_laser_think;
X
X	if (!self->dmg)
X		self->dmg = 1;
X
X	VectorSet (self->mins, -8, -8, -8);
X	VectorSet (self->maxs, 8, 8, 8);
X	gi.linkentity (self);
X
X	if (self->spawnflags & 1)
X		target_laser_on (self);
X	else
X		target_laser_off (self);
}
X
void SP_target_laser (edict_t *self)
{
X	// let everything else get spawned before we start firing
X	self->think = target_laser_start;
X	self->nextthink = level.time + 1;
}
X
//==========================================================
X
/*QUAKED target_lightramp (0 .5 .8) (-8 -8 -8) (8 8 8) TOGGLE
speed		How many seconds the ramping will take
message		two letters; starting lightlevel and ending lightlevel
*/
X
void target_lightramp_think (edict_t *self)
{
X	char	style[2];
X
X	style[0] = 'a' + self->movedir[0] + (level.time - self->timestamp) / FRAMETIME * self->movedir[2];
X	style[1] = 0;
X	gi.configstring (CS_LIGHTS+self->enemy->style, style);
X
X	if ((level.time - self->timestamp) < self->speed)
X	{
X		self->nextthink = level.time + FRAMETIME;
X	}
X	else if (self->spawnflags & 1)
X	{
X		char	temp;
X
X		temp = self->movedir[0];
X		self->movedir[0] = self->movedir[1];
X		self->movedir[1] = temp;
X		self->movedir[2] *= -1;
X	}
}
X
void target_lightramp_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (!self->enemy)
X	{
X		edict_t		*e;
X
X		// check all the targets
X		e = NULL;
X		while (1)
X		{
X			e = G_Find (e, FOFS(targetname), self->target);
X			if (!e)
X				break;
X			if (strcmp(e->classname, "light") != 0)
X			{
X				gi.dprintf("%s at %s ", self->classname, vtos(self->s.origin));
X				gi.dprintf("target %s (%s at %s) is not a light\n", self->target, e->classname, vtos(e->s.origin));
X			}
X			else
X			{
X				self->enemy = e;
X			}
X		}
X
X		if (!self->enemy)
X		{
X			gi.dprintf("%s target %s not found at %s\n", self->classname, self->target, vtos(self->s.origin));
X			G_FreeEdict (self);
X			return;
X		}
X	}
X
X	self->timestamp = level.time;
X	target_lightramp_think (self);
}
X
void SP_target_lightramp (edict_t *self)
{
X	if (!self->message || strlen(self->message) != 2 || self->message[0] < 'a' || self->message[0] > 'z' || self->message[1] < 'a' || self->message[1] > 'z' || self->message[0] == self->message[1])
X	{
X		gi.dprintf("target_lightramp has bad ramp (%s) at %s\n", self->message, vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (!self->target)
X	{
X		gi.dprintf("%s with no target at %s\n", self->classname, vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->svflags |= SVF_NOCLIENT;
X	self->use = target_lightramp_use;
X	self->think = target_lightramp_think;
X
X	self->movedir[0] = self->message[0] - 'a';
X	self->movedir[1] = self->message[1] - 'a';
X	self->movedir[2] = (self->movedir[1] - self->movedir[0]) / (self->speed / FRAMETIME);
}
X
//==========================================================
X
/*QUAKED target_earthquake (1 0 0) (-8 -8 -8) (8 8 8) SILENT
When triggered, this initiates a level-wide earthquake.
All players and monsters are affected.
"speed"		severity of the quake (default:200)
"count"		duration of the quake (default:5)
*/
X
void target_earthquake_think (edict_t *self)
{
X	int		i;
X	edict_t	*e;
X
X	if(!(self->spawnflags & 1))					// PGM
X	{											// PGM
X		if (self->last_move_time < level.time)
X		{
X			gi.positioned_sound (self->s.origin, self, CHAN_AUTO, self->noise_index, 1.0, ATTN_NONE, 0);
X			self->last_move_time = level.time + 0.5;
X		}
X	}											// PGM
X
X	for (i=1, e=g_edicts+i; i < globals.num_edicts; i++,e++)
X	{
X		if (!e->inuse)
X			continue;
X		if (!e->client)
X			continue;
X		if (!e->groundentity)
X			continue;
X
X		e->groundentity = NULL;
X		e->velocity[0] += crandom()* 150;
X		e->velocity[1] += crandom()* 150;
X		e->velocity[2] = self->speed * (100.0 / e->mass);
X	}
X
X	if (level.time < self->timestamp)
X		self->nextthink = level.time + FRAMETIME;
}
X
void target_earthquake_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	// PGM
//	if(g_showlogic && g_showlogic->value)
//		gi.dprintf("earthquake: %0.1f\n", self->speed);
X	// PGM
X
X	self->timestamp = level.time + self->count;
X	self->nextthink = level.time + FRAMETIME;
X	self->activator = activator;
X	self->last_move_time = 0;
}
X
void SP_target_earthquake (edict_t *self)
{
X	if (!self->targetname)
X		gi.dprintf("untargeted %s at %s\n", self->classname, vtos(self->s.origin));
X
X	if (!self->count)
X		self->count = 5;
X
X	if (!self->speed)
X		self->speed = 200;
X
X	self->svflags |= SVF_NOCLIENT;
X	self->think = target_earthquake_think;
X	self->use = target_earthquake_use;
X
X	if(!(self->spawnflags & 1))									// PGM
X		self->noise_index = gi.soundindex ("world/quake.wav");
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_target.c' &&
  chmod 0664 'g_target.c' ||
  $echo 'restore of' 'g_target.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_target.c:' 'MD5 check failed'
e5cb0e5696056c63eb1e3a5762997208  g_target.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_target.c'`"
    test 20668 -eq "$shar_count" ||
    $echo 'g_target.c:' 'original size' '20668,' 'current size' "$shar_count!"
  fi
fi
# ============= g_trigger.c ==============
if test -f 'g_trigger.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_trigger.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_trigger.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_trigger.c' &&
#include "g_local.h"
X
//PGM - some of these are mine, some id's. I added the define's.
#define TRIGGER_MONSTER		0x01
#define TRIGGER_NOT_PLAYER	0x02
#define TRIGGER_TRIGGERED	0x04
#define TRIGGER_TOGGLE		0x08
//PGM
X
void InitTrigger (edict_t *self)
{
X	if (!VectorCompare (self->s.angles, vec3_origin))
X		G_SetMovedir (self->s.angles, self->movedir);
X
X	self->solid = SOLID_TRIGGER;
X	self->movetype = MOVETYPE_NONE;
X	gi.setmodel (self, self->model);
X	self->svflags = SVF_NOCLIENT;
}
X
X
// the wait time has passed, so set back up for another activation
void multi_wait (edict_t *ent)
{
X	ent->nextthink = 0;
}
X
X
// the trigger was just activated
// ent->activator should be set to the activator so it can be held through a delay
// so wait for the delay time before firing
void multi_trigger (edict_t *ent)
{
X	if (ent->nextthink)
X		return;		// already been triggered
X
X	G_UseTargets (ent, ent->activator);
X
X	if (ent->wait > 0)	
X	{
X		ent->think = multi_wait;
X		ent->nextthink = level.time + ent->wait;
X	}
X	else
X	{	// we can't just remove (self) here, because this is a touch function
X		// called while looping through area links...
X		ent->touch = NULL;
X		ent->nextthink = level.time + FRAMETIME;
X		ent->think = G_FreeEdict;
X	}
}
X
void Use_Multi (edict_t *ent, edict_t *other, edict_t *activator)
{
//PGM
X	if(ent->spawnflags & TRIGGER_TOGGLE)
X	{
X		if(ent->solid == SOLID_TRIGGER)
X			ent->solid = SOLID_NOT;
X		else
X			ent->solid = SOLID_TRIGGER;
X		gi.linkentity (ent);
X	}
X	else
X	{
X		ent->activator = activator;
X		multi_trigger (ent);
X	}
//PGM
}
X
void Touch_Multi (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if(other->client)
X	{
X		if (self->spawnflags & 2)
X			return;
X	}
X	else if (other->svflags & SVF_MONSTER)
X	{
X		if (!(self->spawnflags & 1))
X			return;
X	}
X	else
X		return;
X
X	if (!VectorCompare(self->movedir, vec3_origin))
X	{
X		vec3_t	forward;
X
X		AngleVectors(other->s.angles, forward, NULL, NULL);
X		if (_DotProduct(forward, self->movedir) < 0)
X			return;
X	}
X
X	self->activator = other;
X	multi_trigger (self);
}
X
/*QUAKED trigger_multiple (.5 .5 .5) ? MONSTER NOT_PLAYER TRIGGERED TOGGLE
Variable sized repeatable trigger.  Must be targeted at one or more entities.
If "delay" is set, the trigger waits some time after activating before firing.
"wait" : Seconds between triggerings. (.2 default)
X
TOGGLE - using this trigger will activate/deactivate it. trigger will begin inactive.
X
sounds
1)	secret
2)	beep beep
3)	large switch
4)
set "message" to text string
*/
void trigger_enable (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->solid = SOLID_TRIGGER;
X	self->use = Use_Multi;
X	gi.linkentity (self);
}
X
void SP_trigger_multiple (edict_t *ent)
{
X	if (ent->sounds == 1)
X		ent->noise_index = gi.soundindex ("misc/secret.wav");
X	else if (ent->sounds == 2)
X		ent->noise_index = gi.soundindex ("misc/talk.wav");
X	else if (ent->sounds == 3)
X		ent->noise_index = gi.soundindex ("misc/trigger1.wav");
X	
X	if (!ent->wait)
X		ent->wait = 0.2;
X	ent->touch = Touch_Multi;
X	ent->movetype = MOVETYPE_NONE;
X	ent->svflags |= SVF_NOCLIENT;
X
//PGM
X	if (ent->spawnflags & (TRIGGER_TRIGGERED | TRIGGER_TOGGLE))
X	{
X		ent->solid = SOLID_NOT;
X		ent->use = trigger_enable;
X	}
X	else
X	{
X		ent->solid = SOLID_TRIGGER;
X		ent->use = Use_Multi;
X	}
//PGM
X
X	if (!VectorCompare(ent->s.angles, vec3_origin))
X		G_SetMovedir (ent->s.angles, ent->movedir);
X
X	gi.setmodel (ent, ent->model);
X	gi.linkentity (ent);
}
X
X
/*QUAKED trigger_once (.5 .5 .5) ? x x TRIGGERED
Triggers once, then removes itself.
You must set the key "target" to the name of another object in the level that has a matching "targetname".
X
If TRIGGERED, this trigger must be triggered before it is live.
X
sounds
X 1)	secret
X 2)	beep beep
X 3)	large switch
X 4)
X
"message"	string to be displayed when triggered
*/
X
void SP_trigger_once(edict_t *ent)
{
X	// make old maps work because I messed up on flag assignments here
X	// triggered was on bit 1 when it should have been on bit 4
X	if (ent->spawnflags & 1)
X	{
X		vec3_t	v;
X
X		VectorMA (ent->mins, 0.5, ent->size, v);
X		ent->spawnflags &= ~1;
X		ent->spawnflags |= 4;
X		gi.dprintf("fixed TRIGGERED flag on %s at %s\n", ent->classname, vtos(v));
X	}
X
X	ent->wait = -1;
X	SP_trigger_multiple (ent);
}
X
/*QUAKED trigger_relay (.5 .5 .5) (-8 -8 -8) (8 8 8)
This fixed size trigger cannot be touched, it can only be fired by other events.
*/
void trigger_relay_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	G_UseTargets (self, activator);
}
X
void SP_trigger_relay (edict_t *self)
{
X	self->use = trigger_relay_use;
}
X
X
/*
==============================================================================
X
trigger_key
X
==============================================================================
*/
X
/*QUAKED trigger_key (.5 .5 .5) (-8 -8 -8) (8 8 8)
A relay trigger that only fires it's targets if player has the proper key.
Use "item" to specify the required key, for example "key_data_cd"
*/
void trigger_key_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	int			index;
X
X	if (!self->item)
X		return;
X	if (!activator->client)
X		return;
X
X	index = ITEM_INDEX(self->item);
X	if (!activator->client->pers.inventory[index])
X	{
X		if (level.time < self->touch_debounce_time)
X			return;
X		self->touch_debounce_time = level.time + 5.0;
X		gi.centerprintf (activator, "You need the %s", self->item->pickup_name);
X		gi.sound (activator, CHAN_AUTO, gi.soundindex ("misc/keytry.wav"), 1, ATTN_NORM, 0);
X		return;
X	}
X
X	gi.sound (activator, CHAN_AUTO, gi.soundindex ("misc/keyuse.wav"), 1, ATTN_NORM, 0);
X	if (coop->value)
X	{
X		int		player;
X		edict_t	*ent;
X
X		if (strcmp(self->item->classname, "key_power_cube") == 0)
X		{
X			int	cube;
X
X			for (cube = 0; cube < 8; cube++)
X				if (activator->client->pers.power_cubes & (1 << cube))
X					break;
X			for (player = 1; player <= game.maxclients; player++)
X			{
X				ent = &g_edicts[player];
X				if (!ent->inuse)
X					continue;
X				if (!ent->client)
X					continue;
X				if (ent->client->pers.power_cubes & (1 << cube))
X				{
X					ent->client->pers.inventory[index]--;
X					ent->client->pers.power_cubes &= ~(1 << cube);
X				}
X			}
X		}
X		else
X		{
X			for (player = 1; player <= game.maxclients; player++)
X			{
X				ent = &g_edicts[player];
X				if (!ent->inuse)
X					continue;
X				if (!ent->client)
X					continue;
X				ent->client->pers.inventory[index] = 0;
X			}
X		}
X	}
X	else
X	{
X		activator->client->pers.inventory[index]--;
X	}
X
X	G_UseTargets (self, activator);
X
X	self->use = NULL;
}
X
void SP_trigger_key (edict_t *self)
{
X	if (!st.item)
X	{
X		gi.dprintf("no key item for trigger_key at %s\n", vtos(self->s.origin));
X		return;
X	}
X	self->item = FindItemByClassname (st.item);
X
X	if (!self->item)
X	{
X		gi.dprintf("item %s not found for trigger_key at %s\n", st.item, vtos(self->s.origin));
X		return;
X	}
X
X	if (!self->target)
X	{
X		gi.dprintf("%s at %s has no target\n", self->classname, vtos(self->s.origin));
X		return;
X	}
X
X	gi.soundindex ("misc/keytry.wav");
X	gi.soundindex ("misc/keyuse.wav");
X
X	self->use = trigger_key_use;
}
X
X
/*
==============================================================================
X
trigger_counter
X
==============================================================================
*/
X
/*QUAKED trigger_counter (.5 .5 .5) ? nomessage
Acts as an intermediary for an action that takes multiple inputs.
X
If nomessage is not set, t will print "1 more.. " etc when triggered and "sequence complete" when finished.
X
After the counter has been triggered "count" times (default 2), it will fire all of it's targets and remove itself.
*/
X
void trigger_counter_use(edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->count == 0)
X		return;
X	
X	self->count--;
X
X	if (self->count)
X	{
X		if (! (self->spawnflags & 1))
X		{
X			gi.centerprintf(activator, "%i more to go...", self->count);
X			gi.sound (activator, CHAN_AUTO, gi.soundindex ("misc/talk1.wav"), 1, ATTN_NORM, 0);
X		}
X		return;
X	}
X	
X	if (! (self->spawnflags & 1))
X	{
X		gi.centerprintf(activator, "Sequence completed!");
X		gi.sound (activator, CHAN_AUTO, gi.soundindex ("misc/talk1.wav"), 1, ATTN_NORM, 0);
X	}
X	self->activator = activator;
X	multi_trigger (self);
}
X
void SP_trigger_counter (edict_t *self)
{
X	self->wait = -1;
X	if (!self->count)
X		self->count = 2;
X
X	self->use = trigger_counter_use;
}
X
X
/*
==============================================================================
X
trigger_always
X
==============================================================================
*/
X
/*QUAKED trigger_always (.5 .5 .5) (-8 -8 -8) (8 8 8)
This trigger will always fire.  It is activated by the world.
*/
void SP_trigger_always (edict_t *ent)
{
X	// we must have some delay to make sure our use targets are present
X	if (ent->delay < 0.2)
X		ent->delay = 0.2;
X	G_UseTargets(ent, ent);
}
X
X
/*
==============================================================================
X
trigger_push
X
==============================================================================
*/
X
// PGM
#define PUSH_ONCE		0x01
#define PUSH_START_OFF	0x02
#define PUSH_SILENT		0x04
// PGM
X
static int windsound;
X
void trigger_push_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (strcmp(other->classname, "grenade") == 0)
X	{
X		VectorScale (self->movedir, self->speed * 10, other->velocity);
X	}
X	else if (other->health > 0)
X	{
X		VectorScale (self->movedir, self->speed * 10, other->velocity);
X
X		if (other->client)
X		{
X			// don't take falling damage immediately from this
X			VectorCopy (other->velocity, other->client->oldvelocity);
X			if (!(self->spawnflags & PUSH_SILENT) && (other->fly_sound_debounce_time < level.time))
X			{
X				other->fly_sound_debounce_time = level.time + 1.5;
X				gi.sound (other, CHAN_AUTO, windsound, 1, ATTN_NORM, 0);
X			}
X		}
X	}
X	if (self->spawnflags & PUSH_ONCE)
X		G_FreeEdict (self);
}
X
//======
//PGM
void trigger_push_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->solid == SOLID_NOT)
X		self->solid = SOLID_TRIGGER;
X	else
X		self->solid = SOLID_NOT;
X	gi.linkentity (self);
}
//PGM
//======
X
/*QUAKED trigger_push (.5 .5 .5) ? PUSH_ONCE START_OFF SILENT
Pushes the player
"speed"		defaults to 1000
X                                     
If targeted, it will toggle on and off when used.
X
START_OFF - toggled trigger_push begins in off setting
SILENT - doesn't make wind noise
*/
void SP_trigger_push (edict_t *self)
{
X	InitTrigger (self);
X	windsound = gi.soundindex ("misc/windfly.wav");
X	self->touch = trigger_push_touch;
X	if (!self->speed)
X		self->speed = 1000;
X
//PGM
X	if(self->targetname)		// toggleable
X	{
X		self->use = trigger_push_use;
X		if(self->spawnflags & PUSH_START_OFF)
X			self->solid = SOLID_NOT;
X	}
X	else if(self->spawnflags & PUSH_START_OFF)
X	{
X		gi.dprintf ("trigger_push is START_OFF but not targeted.\n");
X		self->svflags = 0;
X		self->touch = NULL;
X		self->solid = SOLID_BSP;
X		self->movetype = MOVETYPE_PUSH;
X	}
//PGM
X
X	gi.linkentity (self);
}
X
X
/*
==============================================================================
X
trigger_hurt
X
==============================================================================
*/
X
/*QUAKED trigger_hurt (.5 .5 .5) ? START_OFF TOGGLE SILENT NO_PROTECTION SLOW
Any entity that touches this will be hurt.
X
It does dmg points of damage each server frame
X
SILENT			supresses playing the sound
SLOW			changes the damage rate to once per second
NO_PROTECTION	*nothing* stops the damage
X
"dmg"			default 5 (whole numbers only)
X
*/
void hurt_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->solid == SOLID_NOT)
X		self->solid = SOLID_TRIGGER;
X	else
X		self->solid = SOLID_NOT;
X	gi.linkentity (self);
X
X	if (!(self->spawnflags & 2))
X		self->use = NULL;
}
X
X
void hurt_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	int		dflags;
X
X	if (!other->takedamage)
X		return;
X
X	if (self->timestamp > level.time)
X		return;
X
X	if (self->spawnflags & 16)
X		self->timestamp = level.time + 1;
X	else
X		self->timestamp = level.time + FRAMETIME;
X
X	if (!(self->spawnflags & 4))
X	{
X		if ((level.framenum % 10) == 0)
X			gi.sound (other, CHAN_AUTO, self->noise_index, 1, ATTN_NORM, 0);
X	}
X
X	if (self->spawnflags & 8)
X		dflags = DAMAGE_NO_PROTECTION;
X	else
X		dflags = 0;
X	T_Damage (other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, self->dmg, dflags, MOD_TRIGGER_HURT);
}
X
void SP_trigger_hurt (edict_t *self)
{
X	InitTrigger (self);
X
X	self->noise_index = gi.soundindex ("world/electro.wav");
X	self->touch = hurt_touch;
X
X	if (!self->dmg)
X		self->dmg = 5;
X
X	if (self->spawnflags & 1)
X		self->solid = SOLID_NOT;
X	else
X		self->solid = SOLID_TRIGGER;
X
X	if (self->spawnflags & 2)
X		self->use = hurt_use;
X
X	gi.linkentity (self);
}
X
X
/*
==============================================================================
X
trigger_gravity
X
==============================================================================
*/
X
//PGM
void trigger_gravity_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (self->solid == SOLID_NOT)
X		self->solid = SOLID_TRIGGER;
X	else
X		self->solid = SOLID_NOT;
X	gi.linkentity (self);
}
//PGM
X
void trigger_gravity_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	other->gravity = self->gravity;
}
X
/*QUAKED trigger_gravity (.5 .5 .5) ? TOGGLE START_OFF
Changes the touching entites gravity to
the value of "gravity".  1.0 is standard
gravity for the level.
X
TOGGLE - trigger_gravity can be turned on and off
START_OFF - trigger_gravity starts turned off (implies TOGGLE)
*/
void SP_trigger_gravity (edict_t *self)
{
X	if (st.gravity == 0)
X	{
X		gi.dprintf("trigger_gravity without gravity set at %s\n", vtos(self->s.origin));
X		G_FreeEdict  (self);
X		return;
X	}
X
X	InitTrigger (self);
X
//PGM
//	self->gravity = atoi(st.gravity);
X	self->gravity = atof(st.gravity);
X
X	if(self->spawnflags & 1)				// TOGGLE
X		self->use = trigger_gravity_use;
X
X	if(self->spawnflags & 2)				// START_OFF
X	{
X		self->use = trigger_gravity_use;
X		self->solid = SOLID_NOT;
X	}
X
X	self->touch = trigger_gravity_touch;
//PGM
X
X	gi.linkentity (self);
}
X
X
/*
==============================================================================
X
trigger_monsterjump
X
==============================================================================
*/
X
/*QUAKED trigger_monsterjump (.5 .5 .5) ?
Walking monsters that touch this will jump in the direction of the trigger's angle
"speed" default to 200, the speed thrown forward
"height" default to 200, the speed thrown upwards
*/
X
void trigger_monsterjump_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other->flags & (FL_FLY | FL_SWIM) )
X		return;
X	if (other->svflags & SVF_DEADMONSTER)
X		return;
X	if ( !(other->svflags & SVF_MONSTER))
X		return;
X
// set XY even if not on ground, so the jump will clear lips
X	other->velocity[0] = self->movedir[0] * self->speed;
X	other->velocity[1] = self->movedir[1] * self->speed;
X	
X	if (!other->groundentity)
X		return;
X	
X	other->groundentity = NULL;
X	other->velocity[2] = self->movedir[2];
}
X
void SP_trigger_monsterjump (edict_t *self)
{
X	if (!self->speed)
X		self->speed = 200;
X	if (!st.height)
X		st.height = 200;
X	if (self->s.angles[YAW] == 0)
X		self->s.angles[YAW] = 360;
X	InitTrigger (self);
X	self->touch = trigger_monsterjump_touch;
X	self->movedir[2] = st.height;
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'g_trigger.c' &&
  chmod 0664 'g_trigger.c' ||
  $echo 'restore of' 'g_trigger.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_trigger.c:' 'MD5 check failed'
787c0a35a67b95f69b674eddc8d4520a  g_trigger.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_trigger.c'`"
    test 15164 -eq "$shar_count" ||
    $echo 'g_trigger.c:' 'original size' '15164,' 'current size' "$shar_count!"
  fi
fi
# ============= g_turret.c ==============
if test -f 'g_turret.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_turret.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_turret.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_turret.c' &&
// g_turret.c
X
#include "g_local.h"
X
void SpawnTargetingSystem (edict_t *turret);	// PGM
X
void AnglesNormalize(vec3_t vec)
{
X	while(vec[0] > 360)
X		vec[0] -= 360;
X	while(vec[0] < 0)
X		vec[0] += 360;
X	while(vec[1] > 360)
X		vec[1] -= 360;
X	while(vec[1] < 0)
X		vec[1] += 360;
}
X
float SnapToEights(float x)
{
X	x *= 8.0;
X	if (x > 0.0)
X		x += 0.5;
X	else
X		x -= 0.5;
X	return 0.125 * (int)x;
}
X
X
void turret_blocked(edict_t *self, edict_t *other)
{
X	edict_t	*attacker;
X
X	if (other->takedamage)
X	{
X		if (self->teammaster->owner)
X			attacker = self->teammaster->owner;
X		else
X			attacker = self->teammaster;
X		T_Damage (other, self, attacker, vec3_origin, other->s.origin, vec3_origin, self->teammaster->dmg, 10, 0, MOD_CRUSH);
X	}
}
X
/*QUAKED turret_breach (0 0 0) ?
This portion of the turret can change both pitch and yaw.
The model  should be made with a flat pitch.
It (and the associated base) need to be oriented towards 0.
Use "angle" to set the starting angle.
X
"speed"		default 50
"dmg"		default 10
"angle"		point this forward
"target"	point this at an info_notnull at the muzzle tip
"minpitch"	min acceptable pitch angle : default -30
"maxpitch"	max acceptable pitch angle : default 30
"minyaw"	min acceptable yaw angle   : default 0
"maxyaw"	max acceptable yaw angle   : default 360
*/
X
void turret_breach_fire (edict_t *self)
{
X	vec3_t	f, r, u;
X	vec3_t	start;
X	int		damage;
X	int		speed;
X
X	AngleVectors (self->s.angles, f, r, u);
X	VectorMA (self->s.origin, self->move_origin[0], f, start);
X	VectorMA (start, self->move_origin[1], r, start);
X	VectorMA (start, self->move_origin[2], u, start);
X
X	damage = 100 + random() * 50;
X	speed = 550 + 50 * skill->value;
X	fire_rocket (self->teammaster->owner, start, f, damage, speed, 150, damage);
X	gi.positioned_sound (start, self, CHAN_WEAPON, gi.soundindex("weapons/rocklf1a.wav"), 1, ATTN_NORM, 0);
}
X
void turret_breach_think (edict_t *self)
{
X	edict_t	*ent;
X	vec3_t	current_angles;
X	vec3_t	delta;
X
X	VectorCopy (self->s.angles, current_angles);
X	AnglesNormalize(current_angles);
X
X	AnglesNormalize(self->move_angles);
X	if (self->move_angles[PITCH] > 180)
X		self->move_angles[PITCH] -= 360;
X
X	// clamp angles to mins & maxs
X	if (self->move_angles[PITCH] > self->pos1[PITCH])
X		self->move_angles[PITCH] = self->pos1[PITCH];
X	else if (self->move_angles[PITCH] < self->pos2[PITCH])
X		self->move_angles[PITCH] = self->pos2[PITCH];
X
X	if ((self->move_angles[YAW] < self->pos1[YAW]) || (self->move_angles[YAW] > self->pos2[YAW]))
X	{
X		float	dmin, dmax;
X
X		dmin = fabs(self->pos1[YAW] - self->move_angles[YAW]);
X		if (dmin < -180)
X			dmin += 360;
X		else if (dmin > 180)
X			dmin -= 360;
X		dmax = fabs(self->pos2[YAW] - self->move_angles[YAW]);
X		if (dmax < -180)
X			dmax += 360;
X		else if (dmax > 180)
X			dmax -= 360;
X		if (fabs(dmin) < fabs(dmax))
X			self->move_angles[YAW] = self->pos1[YAW];
X		else
X			self->move_angles[YAW] = self->pos2[YAW];
X	}
X
X	VectorSubtract (self->move_angles, current_angles, delta);
X	if (delta[0] < -180)
X		delta[0] += 360;
X	else if (delta[0] > 180)
X		delta[0] -= 360;
X	if (delta[1] < -180)
X		delta[1] += 360;
X	else if (delta[1] > 180)
X		delta[1] -= 360;
X	delta[2] = 0;
X
X	if (delta[0] > self->speed * FRAMETIME)
X		delta[0] = self->speed * FRAMETIME;
X	if (delta[0] < -1 * self->speed * FRAMETIME)
X		delta[0] = -1 * self->speed * FRAMETIME;
X	if (delta[1] > self->speed * FRAMETIME)
X		delta[1] = self->speed * FRAMETIME;
X	if (delta[1] < -1 * self->speed * FRAMETIME)
X		delta[1] = -1 * self->speed * FRAMETIME;
X
X	VectorScale (delta, 1.0/FRAMETIME, self->avelocity);
X
X	self->nextthink = level.time + FRAMETIME;
X
X	for (ent = self->teammaster; ent; ent = ent->teamchain)
X		ent->avelocity[1] = self->avelocity[1];
X
X	// if we have adriver, adjust his velocities
X	if (self->owner)
X	{
X		float	angle;
X		float	target_z;
X		float	diff;
X		vec3_t	target;
X		vec3_t	dir;
X
X		// angular is easy, just copy ours
X		self->owner->avelocity[0] = self->avelocity[0];
X		self->owner->avelocity[1] = self->avelocity[1];
X
X		// x & y
X		angle = self->s.angles[1] + self->owner->move_origin[1];
X		angle *= (M_PI*2 / 360);
X		target[0] = SnapToEights(self->s.origin[0] + cos(angle) * self->owner->move_origin[0]);
X		target[1] = SnapToEights(self->s.origin[1] + sin(angle) * self->owner->move_origin[0]);
X		target[2] = self->owner->s.origin[2];
X
X		VectorSubtract (target, self->owner->s.origin, dir);
X		self->owner->velocity[0] = dir[0] * 1.0 / FRAMETIME;
X		self->owner->velocity[1] = dir[1] * 1.0 / FRAMETIME;
X
X		// z
X		angle = self->s.angles[PITCH] * (M_PI*2 / 360);
X		target_z = SnapToEights(self->s.origin[2] + self->owner->move_origin[0] * tan(angle) + self->owner->move_origin[2]);
X
X		diff = target_z - self->owner->s.origin[2];
X		self->owner->velocity[2] = diff * 1.0 / FRAMETIME;
X
X		if (self->spawnflags & 65536)
X		{
X			turret_breach_fire (self);
X			self->spawnflags &= ~65536;
X		}
X	}
}
X
void turret_breach_finish_init (edict_t *self)
{
X	// get and save info for muzzle location
X	if (!self->target)
X	{
X		gi.dprintf("%s at %s needs a target\n", self->classname, vtos(self->s.origin));
X	}
X	else
X	{
X		self->target_ent = G_PickTarget (self->target);
X		if(self->target_ent)
X		{
X			VectorSubtract (self->target_ent->s.origin, self->s.origin, self->move_origin);
X			G_FreeEdict(self->target_ent);
X		}
X		else
X			gi.dprintf("could not find target entity for %s at %s\n", self->classname, vtos(self->s.origin));
X	}
X
X	self->teammaster->dmg = self->dmg;
X	self->think = turret_breach_think;
X	self->think (self);
}
X
void SP_turret_breach (edict_t *self)
{
X	self->solid = SOLID_BSP;
X	self->movetype = MOVETYPE_PUSH;
X	gi.setmodel (self, self->model);
X
X	if (!self->speed)
X		self->speed = 50;
X	if (!self->dmg)
X		self->dmg = 10;
X
X	if (!st.minpitch)
X		st.minpitch = -30;
X	if (!st.maxpitch)
X		st.maxpitch = 30;
X	if (!st.maxyaw)
X		st.maxyaw = 360;
X
X	self->pos1[PITCH] = -1 * st.minpitch;
X	self->pos1[YAW]   = st.minyaw;
X	self->pos2[PITCH] = -1 * st.maxpitch;
X	self->pos2[YAW]   = st.maxyaw;
X
X	self->ideal_yaw = self->s.angles[YAW];
X	self->move_angles[YAW] = self->ideal_yaw;
X
X	self->blocked = turret_blocked;
X
X	self->think = turret_breach_finish_init;
X	self->nextthink = level.time + FRAMETIME;
X	gi.linkentity (self);
}
X
X
/*QUAKED turret_base (0 0 0) ?
This portion of the turret changes yaw only.
MUST be teamed with a turret_breach.
*/
X
void SP_turret_base (edict_t *self)
{
X	self->solid = SOLID_BSP;
X	self->movetype = MOVETYPE_PUSH;
X	gi.setmodel (self, self->model);
X	self->blocked = turret_blocked;
X	gi.linkentity (self);
}
X
X
/*QUAKED turret_driver (1 .5 0) (-16 -16 -24) (16 16 32)
Must NOT be on the team with the rest of the turret parts.
Instead it must target the turret_breach.
*/
X
void infantry_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage);
void infantry_stand (edict_t *self);
void monster_use (edict_t *self, edict_t *other, edict_t *activator);
X
void turret_driver_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	edict_t	*ent;
X
X	// level the gun
X	self->target_ent->move_angles[0] = 0;
X
X	// remove the driver from the end of them team chain
X	for (ent = self->target_ent->teammaster; ent->teamchain != self; ent = ent->teamchain)
X		;
X	ent->teamchain = NULL;
X	self->teammaster = NULL;
X	self->flags &= ~FL_TEAMSLAVE;
X
X	self->target_ent->owner = NULL;
X	self->target_ent->teammaster->owner = NULL;
X
X	infantry_die (self, inflictor, attacker, damage);
}
X
qboolean FindTarget (edict_t *self);
X
void turret_driver_think (edict_t *self)
{
X	vec3_t	target;
X	vec3_t	dir;
X	float	reaction_time;
X
X	self->nextthink = level.time + FRAMETIME;
X
X	if (self->enemy && (!self->enemy->inuse || self->enemy->health <= 0))
X		self->enemy = NULL;
X
X	if (!self->enemy)
X	{
X		if (!FindTarget (self))
X			return;
X		self->monsterinfo.trail_time = level.time;
X		self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X	}
X	else
X	{
X		if (visible (self, self->enemy))
X		{
X			if (self->monsterinfo.aiflags & AI_LOST_SIGHT)
X			{
X				self->monsterinfo.trail_time = level.time;
X				self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X			}
X		}
X		else
X		{
X			self->monsterinfo.aiflags |= AI_LOST_SIGHT;
X			return;
X		}
X	}
X
X	// let the turret know where we want it to aim
X	VectorCopy (self->enemy->s.origin, target);
X	target[2] += self->enemy->viewheight;
X	VectorSubtract (target, self->target_ent->s.origin, dir);
X	vectoangles (dir, self->target_ent->move_angles);
X
X	// decide if we should shoot
X	if (level.time < self->monsterinfo.attack_finished)
X		return;
X
X	reaction_time = (3 - skill->value) * 1.0;
X	if ((level.time - self->monsterinfo.trail_time) < reaction_time)
X		return;
X
X	self->monsterinfo.attack_finished = level.time + reaction_time + 1.0;
X	//FIXME how do we really want to pass this along?
X	self->target_ent->spawnflags |= 65536;
}
X
void turret_driver_link (edict_t *self)
{
X	vec3_t	vec;
X	edict_t	*ent;
X
X	self->think = turret_driver_think;
X	self->nextthink = level.time + FRAMETIME;
X
X	self->target_ent = G_PickTarget (self->target);
X	self->target_ent->owner = self;
X	self->target_ent->teammaster->owner = self;
X	VectorCopy (self->target_ent->s.angles, self->s.angles);
X
X	vec[0] = self->target_ent->s.origin[0] - self->s.origin[0];
X	vec[1] = self->target_ent->s.origin[1] - self->s.origin[1];
X	vec[2] = 0;
X	self->move_origin[0] = VectorLength(vec);
X
X	VectorSubtract (self->s.origin, self->target_ent->s.origin, vec);
X	vectoangles (vec, vec);
X	AnglesNormalize(vec);
X	self->move_origin[1] = vec[1];
X
X	self->move_origin[2] = self->s.origin[2] - self->target_ent->s.origin[2];
X
X	// add the driver to the end of them team chain
X	for (ent = self->target_ent->teammaster; ent->teamchain; ent = ent->teamchain)
X		;
X	ent->teamchain = self;
X	self->teammaster = self->target_ent->teammaster;
X	self->flags |= FL_TEAMSLAVE;
}
X
void SP_turret_driver (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->movetype = MOVETYPE_PUSH;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex("models/monsters/infantry/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X
X	self->health = 100;
X	self->gib_health = 0;
X	self->mass = 200;
X	self->viewheight = 24;
X
X	self->die = turret_driver_die;
X	self->monsterinfo.stand = infantry_stand;
X
X	self->flags |= FL_NO_KNOCKBACK;
X
X	level.total_monsters++;
X
X	self->svflags |= SVF_MONSTER;
X	self->s.renderfx |= RF_FRAMELERP;
X	self->takedamage = DAMAGE_AIM;
X	self->use = monster_use;
X	self->clipmask = MASK_MONSTERSOLID;
X	VectorCopy (self->s.origin, self->s.old_origin);
X	self->monsterinfo.aiflags |= AI_STAND_GROUND|AI_DUCKED;
X
X	if (st.item)
X	{
X		self->item = FindItemByClassname (st.item);
X		if (!self->item)
X			gi.dprintf("%s at %s has bad item: %s\n", self->classname, vtos(self->s.origin), st.item);
X	}
X
X	self->think = turret_driver_link;
X	self->nextthink = level.time + FRAMETIME;
X
X	gi.linkentity (self);
}
X
//============
// ROGUE
X
// invisible turret drivers so we can have unmanned turrets.
// originally designed to shoot at func_trains and such, so they
// fire at the center of the bounding box, rather than the entity's
// origin.
X
void turret_brain_think (edict_t *self)
{
X	vec3_t	target;
X	vec3_t	dir;
X	vec3_t	endpos;
X	float	reaction_time;
X	trace_t	trace;
X
X	self->nextthink = level.time + FRAMETIME;
X
X	if (self->enemy)
X	{
X		if(!self->enemy->inuse)
X			self->enemy = NULL;
X		else if(self->enemy->takedamage && self->enemy->health <= 0)
X			self->enemy = NULL;
X	}
X
X	if (!self->enemy)
X	{
X		if (!FindTarget (self))
X			return;
X		self->monsterinfo.trail_time = level.time;
X		self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X	}
X	else
X	{
X		VectorAdd (self->enemy->absmax, self->enemy->absmin, endpos);
X		VectorScale (endpos, 0.5, endpos);
X
X		trace = gi.trace (self->target_ent->s.origin, vec3_origin, vec3_origin, endpos, self->target_ent, MASK_SHOT);
X		if(trace.fraction == 1 || trace.ent == self->enemy)
X		{
X			if (self->monsterinfo.aiflags & AI_LOST_SIGHT)
X			{
X				self->monsterinfo.trail_time = level.time;
X				self->monsterinfo.aiflags &= ~AI_LOST_SIGHT;
X			}
X		}
X		else
X		{
X			self->monsterinfo.aiflags |= AI_LOST_SIGHT;
X			return;
X		}
X	}
X
X	// let the turret know where we want it to aim
X	VectorCopy (endpos, target);
X	VectorSubtract (target, self->target_ent->s.origin, dir);
X	vectoangles (dir, self->target_ent->move_angles);
X
X	// decide if we should shoot
X	if (level.time < self->monsterinfo.attack_finished)
X		return;
X
X	if(self->delay)
X		reaction_time = self->delay;
X	else
X		reaction_time = (3 - skill->value) * 1.0;
X	if ((level.time - self->monsterinfo.trail_time) < reaction_time)
X		return;
X
X	self->monsterinfo.attack_finished = level.time + reaction_time + 1.0;
X	//FIXME how do we really want to pass this along?
X	self->target_ent->spawnflags |= 65536;
}
X
// =================
// =================
void turret_brain_link (edict_t *self)
{
X	vec3_t	vec;
X	edict_t	*ent;
X
X	if (self->killtarget)
X	{
X		self->enemy = G_PickTarget (self->killtarget);
X	}
X
X	self->think = turret_brain_think;
X	self->nextthink = level.time + FRAMETIME;
X
X	self->target_ent = G_PickTarget (self->target);
X	self->target_ent->owner = self;
X	self->target_ent->teammaster->owner = self;
X	VectorCopy (self->target_ent->s.angles, self->s.angles);
X
X	vec[0] = self->target_ent->s.origin[0] - self->s.origin[0];
X	vec[1] = self->target_ent->s.origin[1] - self->s.origin[1];
X	vec[2] = 0;
X	self->move_origin[0] = VectorLength(vec);
X
X	VectorSubtract (self->s.origin, self->target_ent->s.origin, vec);
X	vectoangles (vec, vec);
X	AnglesNormalize(vec);
X	self->move_origin[1] = vec[1];
X
X	self->move_origin[2] = self->s.origin[2] - self->target_ent->s.origin[2];
X
X	// add the driver to the end of them team chain
X	for (ent = self->target_ent->teammaster; ent->teamchain; ent = ent->teamchain)
X		;
X	ent->teamchain = self;
X	self->teammaster = self->target_ent->teammaster;
X	self->flags |= FL_TEAMSLAVE;
}
X
// =================
// =================
void turret_brain_deactivate (edict_t *self, edict_t *other, edict_t *activator)
{
X	self->think = NULL;
X	self->nextthink = 0;
}
X
// =================
// =================
void turret_brain_activate (edict_t *self, edict_t *other, edict_t *activator)
{
X	if (!self->enemy)
X	{
X		self->enemy = activator;
X	}
X
X	// wait at least 3 seconds to fire.
X	self->monsterinfo.attack_finished = level.time + 3;
X	self->use = turret_brain_deactivate;
X
X	self->think = turret_brain_link;
X	self->nextthink = level.time + FRAMETIME;
}
X
/*QUAKED turret_invisible_brain (1 .5 0) (-16 -16 -16) (16 16 16)
Invisible brain to drive the turret.
X
Does not search for targets. If targeted, can only be turned on once
and then off once. After that they are completely disabled.
X
"delay" the delay between firing (default ramps for skill level)
"Target" the turret breach
"Killtarget" the item you want it to attack.
Target the brain if you want it activated later, instead of immediately. It will wait 3 seconds
before firing to acquire the target.
*/
void SP_turret_invisible_brain (edict_t *self)
{
X	if (!self->killtarget)
X	{
X		gi.dprintf("turret_invisible_brain with no killtarget!\n");
X		G_FreeEdict (self);
X		return;
X	}
X	if (!self->target)
X	{
X		gi.dprintf("turret_invisible_brain with no target!\n");
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (self->targetname)
X	{
X		self->use = turret_brain_activate;
X	}
X	else
X	{
X		self->think = turret_brain_link;
X		self->nextthink = level.time + FRAMETIME;
X	}
X
X	self->movetype = MOVETYPE_PUSH;
X	gi.linkentity (self);
}
X
// ROGUE
//============
SHAR_EOF
  $shar_touch -am 1130175398 'g_turret.c' &&
  chmod 0664 'g_turret.c' ||
  $echo 'restore of' 'g_turret.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_turret.c:' 'MD5 check failed'
3b1b018aa5782ecf4025bcf6dd31cc87  g_turret.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_turret.c'`"
    test 15291 -eq "$shar_count" ||
    $echo 'g_turret.c:' 'original size' '15291,' 'current size' "$shar_count!"
  fi
fi
# ============= g_utils.c ==============
if test -f 'g_utils.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_utils.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_utils.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_utils.c' &&
// g_utils.c -- misc utility functions for game module
X
#include "g_local.h"
X
X
void G_ProjectSource (vec3_t point, vec3_t distance, vec3_t forward, vec3_t right, vec3_t result)
{
X	result[0] = point[0] + forward[0] * distance[0] + right[0] * distance[1];
X	result[1] = point[1] + forward[1] * distance[0] + right[1] * distance[1];
X	result[2] = point[2] + forward[2] * distance[0] + right[2] * distance[1] + distance[2];
}
X
void G_ProjectSource2 (vec3_t point, vec3_t distance, vec3_t forward, vec3_t right, vec3_t up, vec3_t result)
{
X	result[0] = point[0] + forward[0] * distance[0] + right[0] * distance[1] + up[0] * distance[2];
X	result[1] = point[1] + forward[1] * distance[0] + right[1] * distance[1] + up[1] * distance[2];
X	result[2] = point[2] + forward[2] * distance[0] + right[2] * distance[1] + up[2] * distance[2];
}
X
/*
=============
G_Find
X
Searches all active entities for the next one that holds
the matching string at fieldofs (use the FOFS() macro) in the structure.
X
Searches beginning at the edict after from, or the beginning if NULL
NULL will be returned if the end of the list is reached.
X
=============
*/
edict_t *G_Find (edict_t *from, int fieldofs, char *match)
{
X	char	*s;
X
X	if (!from)
X		from = g_edicts;
X	else
X		from++;
X
X	for ( ; from < &g_edicts[globals.num_edicts] ; from++)
X	{
X		if (!from->inuse)
X			continue;
X		s = *(char **) ((byte *)from + fieldofs);
X		if (!s)
X			continue;
X		if (!Q_stricmp (s, match))
X			return from;
X	}
X
X	return NULL;
}
X
X
/*
=================
findradius
X
Returns entities that have origins within a spherical area
X
findradius (origin, radius)
=================
*/
edict_t *findradius (edict_t *from, vec3_t org, float rad)
{
X	vec3_t	eorg;
X	int		j;
X
X	if (!from)
X		from = g_edicts;
X	else
X		from++;
X	for ( ; from < &g_edicts[globals.num_edicts]; from++)
X	{
X		if (!from->inuse)
X			continue;
X		if (from->solid == SOLID_NOT)
X			continue;
X		for (j=0 ; j<3 ; j++)
X			eorg[j] = org[j] - (from->s.origin[j] + (from->mins[j] + from->maxs[j])*0.5);
X		if (VectorLength(eorg) > rad)
X			continue;
X		return from;
X	}
X
X	return NULL;
}
X
/*
=================
findradius2
X
Returns entities that have origins within a spherical area
X
ROGUE - tweaks for performance for tesla specific code
only returns entities that can be damaged
only returns entities that are SVF_DAMAGEABLE
X
findradius2 (origin, radius)
=================
*/
edict_t *findradius2 (edict_t *from, vec3_t org, float rad)
{
X	// rad must be positive
X	vec3_t	eorg;
X	int		j;
X
X	if (!from)
X		from = g_edicts;
X	else
X		from++;
X	for ( ; from < &g_edicts[globals.num_edicts]; from++)
X	{
X		if (!from->inuse)
X			continue;
X		if (from->solid == SOLID_NOT)
X			continue;
X		if (!from->takedamage)
X			continue;
X		if (!(from->svflags & SVF_DAMAGEABLE))
X			continue;
X		for (j=0 ; j<3 ; j++)
X			eorg[j] = org[j] - (from->s.origin[j] + (from->mins[j] + from->maxs[j])*0.5);
X		if (VectorLength(eorg) > rad)
X			continue;
X		return from;
X	}
X
X	return NULL;
}
X
X
/*
=============
G_PickTarget
X
Searches all active entities for the next one that holds
the matching string at fieldofs (use the FOFS() macro) in the structure.
X
Searches beginning at the edict after from, or the beginning if NULL
NULL will be returned if the end of the list is reached.
X
=============
*/
#define MAXCHOICES	8
X
edict_t *G_PickTarget (char *targetname)
{
X	edict_t	*ent = NULL;
X	int		num_choices = 0;
X	edict_t	*choice[MAXCHOICES];
X
X	if (!targetname)
X	{
X		gi.dprintf("G_PickTarget called with NULL targetname\n");
X		return NULL;
X	}
X
X	while(1)
X	{
X		ent = G_Find (ent, FOFS(targetname), targetname);
X		if (!ent)
X			break;
X		choice[num_choices++] = ent;
X		if (num_choices == MAXCHOICES)
X			break;
X	}
X
X	if (!num_choices)
X	{
X		gi.dprintf("G_PickTarget: target %s not found\n", targetname);
X		return NULL;
X	}
X
X	return choice[rand() % num_choices];
}
X
X
X
void Think_Delay (edict_t *ent)
{
X	G_UseTargets (ent, ent->activator);
X	G_FreeEdict (ent);
}
X
/*
==============================
G_UseTargets
X
the global "activator" should be set to the entity that initiated the firing.
X
If self.delay is set, a DelayedUse entity will be created that will actually
do the SUB_UseTargets after that many seconds have passed.
X
Centerprints any self.message to the activator.
X
Search for (string)targetname in all entities that
match (string)self.target and call their .use function
X
==============================
*/
void G_UseTargets (edict_t *ent, edict_t *activator)
{
X	edict_t		*t;
X	edict_t		*master;
X	qboolean	done = false;
X
//
// check for a delay
//
X	if (ent->delay)
X	{
X	// create a temp object to fire at a later time
X		t = G_Spawn();
X		t->classname = "DelayedUse";
X		t->nextthink = level.time + ent->delay;
X		t->think = Think_Delay;
X		t->activator = activator;
X		if (!activator)
X			gi.dprintf ("Think_Delay with no activator\n");
X		t->message = ent->message;
X		t->target = ent->target;
X		t->killtarget = ent->killtarget;
X		return;
X	}
X	
X	
//
// print the message
//
X	if ((ent->message) && !(activator->svflags & SVF_MONSTER))
X	{
X		gi.centerprintf (activator, "%s", ent->message);
X		if (ent->noise_index)
X			gi.sound (activator, CHAN_AUTO, ent->noise_index, 1, ATTN_NORM, 0);
X		else
X			gi.sound (activator, CHAN_AUTO, gi.soundindex ("misc/talk1.wav"), 1, ATTN_NORM, 0);
X	}
X
//
// kill killtargets
//
X	if (ent->killtarget)
X	{
X		t = NULL;
X		while ((t = G_Find (t, FOFS(targetname), ent->killtarget)))
X		{
X			// PMM - if this entity is part of a train, cleanly remove it
X			if (t->flags & FL_TEAMSLAVE)
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("Removing %s from train!\n", t->classname);
X
X				if (t->teammaster)
X				{
X					master = t->teammaster;
X					while (!done)
X					{
X						if (master->teamchain == t)
X						{
X							master->teamchain = t->teamchain;
X							done = true;
X						}
X						master = master->teamchain;
X						if (!master)
X						{
//							if ((g_showlogic) && (g_showlogic->value))
//								gi.dprintf ("Couldn't find myself in master's chain, ignoring!\n");
X						}
X					}
X				}
X				else
X				{
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("No master to free myself from, ignoring!\n");
X				}
X			}
X			// PMM
X			G_FreeEdict (t);
X			if (!ent->inuse)
X			{
X				gi.dprintf("entity was removed while using killtargets\n");
X				return;
X			}
X		}
X	}
X
//
// fire targets
//
X	if (ent->target)
X	{
X		t = NULL;
X		while ((t = G_Find (t, FOFS(targetname), ent->target)))
X		{
X			// doors fire area portals in a specific way
X			if (!Q_stricmp(t->classname, "func_areaportal") &&
X				(!Q_stricmp(ent->classname, "func_door") || !Q_stricmp(ent->classname, "func_door_rotating")))
X				continue;
X
X			if (t == ent)
X			{
X				gi.dprintf ("WARNING: Entity used itself.\n");
X			}
X			else
X			{
X				if (t->use)
X					t->use (t, ent, activator);
X			}
X			if (!ent->inuse)
X			{
X				gi.dprintf("entity was removed while using targets\n");
X				return;
X			}
X		}
X	}
}
X
X
/*
=============
TempVector
X
This is just a convenience function
for making temporary vectors for function calls
=============
*/
float	*tv (float x, float y, float z)
{
X	static	int		index;
X	static	vec3_t	vecs[8];
X	float	*v;
X
X	// use an array so that multiple tempvectors won't collide
X	// for a while
X	v = vecs[index];
X	index = (index + 1)&7;
X
X	v[0] = x;
X	v[1] = y;
X	v[2] = z;
X
X	return v;
}
X
X
/*
=============
VectorToString
X
This is just a convenience function
for printing vectors
=============
*/
char	*vtos (vec3_t v)
{
X	static	int		index;
X	static	char	str[8][32];
X	char	*s;
X
X	// use an array so that multiple vtos won't collide
X	s = str[index];
X	index = (index + 1)&7;
X
X	Com_sprintf (s, 32, "(%i %i %i)", (int)v[0], (int)v[1], (int)v[2]);
X
X	return s;
}
X
X
vec3_t VEC_UP		= {0, -1, 0};
vec3_t MOVEDIR_UP	= {0, 0, 1};
vec3_t VEC_DOWN		= {0, -2, 0};
vec3_t MOVEDIR_DOWN	= {0, 0, -1};
X
void G_SetMovedir (vec3_t angles, vec3_t movedir)
{
X	if (VectorCompare (angles, VEC_UP))
X	{
X		VectorCopy (MOVEDIR_UP, movedir);
X	}
X	else if (VectorCompare (angles, VEC_DOWN))
X	{
X		VectorCopy (MOVEDIR_DOWN, movedir);
X	}
X	else
X	{
X		AngleVectors (angles, movedir, NULL, NULL);
X	}
X
X	VectorClear (angles);
}
X
X
float vectoyaw (vec3_t vec)
{
X	float	yaw;
X	
X	// PMM - fixed to correct for pitch of 0
X	if (/*vec[YAW] == 0 &&*/ vec[PITCH] == 0)
X		if (vec[YAW] == 0)
X			yaw = 0;
X		else if (vec[YAW] > 0)
X			yaw = 90;
X		else
X			yaw = 270;
X	else
X	{
X		yaw = (int) (atan2(vec[YAW], vec[PITCH]) * 180 / M_PI);
X		if (yaw < 0)
X			yaw += 360;
X	}
X
X	return yaw;
}
X
float vectoyaw2 (vec3_t vec)
{
X	float	yaw;
X	
X	// PMM - fixed to correct for pitch of 0
X	if (/*vec[YAW] == 0 &&*/ vec[PITCH] == 0)
X		if (vec[YAW] == 0)
X			yaw = 0;
X		else if (vec[YAW] > 0)
X			yaw = 90;
X		else
X			yaw = 270;
X	else
X	{
X		yaw = (atan2(vec[YAW], vec[PITCH]) * 180 / M_PI);
X		if (yaw < 0)
X			yaw += 360;
X	}
X
X	return yaw;
}
X
X
void vectoangles (vec3_t value1, vec3_t angles)
{
X	float	forward;
X	float	yaw, pitch;
X	
X	if (value1[1] == 0 && value1[0] == 0)
X	{
X		yaw = 0;
X		if (value1[2] > 0)
X			pitch = 90;
X		else
X			pitch = 270;
X	}
X	else
X	{
X	// PMM - fixed to correct for pitch of 0
X		if (value1[0])
X			yaw = (int) (atan2(value1[1], value1[0]) * 180 / M_PI);
X		else if (value1[1] > 0)
X			yaw = 90;
X		else
X			yaw = 270;
X		if (yaw < 0)
X			yaw += 360;
X
X		forward = sqrt (value1[0]*value1[0] + value1[1]*value1[1]);
X		pitch = (int) (atan2(value1[2], forward) * 180 / M_PI);
X		if (pitch < 0)
X			pitch += 360;
X	}
X
X	angles[PITCH] = -pitch;
X	angles[YAW] = yaw;
X	angles[ROLL] = 0;
}
X
void vectoangles2 (vec3_t value1, vec3_t angles)
{
X	float	forward;
X	float	yaw, pitch;
X	
X	if (value1[1] == 0 && value1[0] == 0)
X	{
X		yaw = 0;
X		if (value1[2] > 0)
X			pitch = 90;
X		else
X			pitch = 270;
X	}
X	else
X	{
X	// PMM - fixed to correct for pitch of 0
X		if (value1[0])
X			yaw = (atan2(value1[1], value1[0]) * 180 / M_PI);
X		else if (value1[1] > 0)
X			yaw = 90;
X		else
X			yaw = 270;
X
X		if (yaw < 0)
X			yaw += 360;
X
X		forward = sqrt (value1[0]*value1[0] + value1[1]*value1[1]);
X		pitch = (atan2(value1[2], forward) * 180 / M_PI);
X		if (pitch < 0)
X			pitch += 360;
X	}
X
X	angles[PITCH] = -pitch;
X	angles[YAW] = yaw;
X	angles[ROLL] = 0;
}
X
char *G_CopyString (char *in)
{
X	char	*out;
X	
X	out = gi.TagMalloc (strlen(in)+1, TAG_LEVEL);
X	strcpy (out, in);
X	return out;
}
X
X
void G_InitEdict (edict_t *e)
{
X	// ROGUE
X	// FIXME -
X	//   this fixes a bug somewhere that is settling "nextthink" for an entity that has
X	//   already been released.  nextthink is being set to FRAMETIME after level.time, 
X	//   since freetime = nextthink - 0.1
X	if (e->nextthink)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("G_SPAWN:  Fixed bad nextthink time\n");
X		e->nextthink = 0;
X	}
X	// ROGUE
X
X	e->inuse = true;
X	e->classname = "noclass";
X	e->gravity = 1.0;
X	e->s.number = e - g_edicts;
X
//PGM - do this before calling the spawn function so it can be overridden.
#ifdef ROGUE_GRAVITY
X	e->gravityVector[0] =  0.0;
X	e->gravityVector[1] =  0.0;
X	e->gravityVector[2] = -1.0;
#endif
//PGM
}
X
/*
=================
G_Spawn
X
Either finds a free edict, or allocates a new one.
Try to avoid reusing an entity that was recently freed, because it
can cause the client to think the entity morphed into something else
instead of being removed and recreated, which can cause interpolated
angles and bad trails.
=================
*/
edict_t *G_Spawn (void)
{
X	int			i;
X	edict_t		*e;
X
X	e = &g_edicts[(int)maxclients->value+1];
X	for ( i=maxclients->value+1 ; i<globals.num_edicts ; i++, e++)
X	{
X		// the first couple seconds of server time can involve a lot of
X		// freeing and allocating, so relax the replacement policy
X		if (!e->inuse && ( e->freetime < 2 || level.time - e->freetime > 0.5 ) )
X		{
X			G_InitEdict (e);
X			return e;
X		}
X	}
X	
X	if (i == game.maxentities)
X		gi.error ("ED_Alloc: no free edicts");
X		
X	globals.num_edicts++;
X	G_InitEdict (e);
X	return e;
}
X
/*
=================
G_FreeEdict
X
Marks the edict as free
=================
*/
void G_FreeEdict (edict_t *ed)
{
X	gi.unlinkentity (ed);		// unlink from world
X
X	if ((ed - g_edicts) <= (maxclients->value + BODY_QUEUE_SIZE))
X	{
//		gi.dprintf("tried to free special edict\n");
X		return;
X	}
X
X	memset (ed, 0, sizeof(*ed));
X	ed->classname = "freed";
X	ed->freetime = level.time;
X	ed->inuse = false;
}
X
X
/*
============
G_TouchTriggers
X
============
*/
void	G_TouchTriggers (edict_t *ent)
{
X	int			i, num;
X	edict_t		*touch[MAX_EDICTS], *hit;
X
X	// dead things don't activate triggers!
X	if ((ent->client || (ent->svflags & SVF_MONSTER)) && (ent->health <= 0))
X		return;
X
X	num = gi.BoxEdicts (ent->absmin, ent->absmax, touch
X		, MAX_EDICTS, AREA_TRIGGERS);
X
X	// be careful, it is possible to have an entity in this
X	// list removed before we get to it (killtriggered)
X	for (i=0 ; i<num ; i++)
X	{
X		hit = touch[i];
X		if (!hit->inuse)
X			continue;
X		if (!hit->touch)
X			continue;
X		hit->touch (hit, ent, NULL, NULL);
X	}
}
X
/*
============
G_TouchSolids
X
Call after linking a new trigger in during gameplay
to force all entities it covers to immediately touch it
============
*/
void	G_TouchSolids (edict_t *ent)
{
X	int			i, num;
X	edict_t		*touch[MAX_EDICTS], *hit;
X
X	num = gi.BoxEdicts (ent->absmin, ent->absmax, touch
X		, MAX_EDICTS, AREA_SOLID);
X
X	// be careful, it is possible to have an entity in this
X	// list removed before we get to it (killtriggered)
X	for (i=0 ; i<num ; i++)
X	{
X		hit = touch[i];
X		if (!hit->inuse)
X			continue;
X		if (ent->touch)
X			ent->touch (hit, ent, NULL, NULL);
X		if (!ent->inuse)
X			break;
X	}
}
X
X
X
X
/*
==============================================================================
X
Kill box
X
==============================================================================
*/
X
/*
=================
KillBox
X
Kills all entities that would touch the proposed new positioning
of ent.  Ent should be unlinked before calling this!
=================
*/
qboolean KillBox (edict_t *ent)
{
X	trace_t		tr;
X
X	while (1)
X	{
X		tr = gi.trace (ent->s.origin, ent->mins, ent->maxs, ent->s.origin, NULL, MASK_PLAYERSOLID);
X		if (!tr.ent)
X			break;
X
X		// nail it
X		T_Damage (tr.ent, ent, ent, vec3_origin, ent->s.origin, vec3_origin, 100000, 0, DAMAGE_NO_PROTECTION, MOD_TELEFRAG);
X
X		// if we didn't kill it, fail
X		if (tr.ent->solid)
X			return false;
X	}
X
X	return true;		// all clear
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_utils.c' &&
  chmod 0664 'g_utils.c' ||
  $echo 'restore of' 'g_utils.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_utils.c:' 'MD5 check failed'
224d08cae8041669c2e5b2ea7596baea  g_utils.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_utils.c'`"
    test 14069 -eq "$shar_count" ||
    $echo 'g_utils.c:' 'original size' '14069,' 'current size' "$shar_count!"
  fi
fi
# ============= g_weapon.c ==============
if test -f 'g_weapon.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'g_weapon.c' '(file already exists)'
else
  $echo 'x -' extracting 'g_weapon.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'g_weapon.c' &&
#include "g_local.h"
X
X
/*
=================
check_dodge
X
This is a support routine used when a client is firing
a non-instant attack weapon.  It checks to see if a
monster's dodge function should be called.
=================
*/
//static void check_dodge (edict_t *self, vec3_t start, vec3_t dir, int speed)
void check_dodge (edict_t *self, vec3_t start, vec3_t dir, int speed)		//PGM
{
X	vec3_t	end;
X	vec3_t	v;
X	trace_t	tr;
X	float	eta;
X
X	// easy mode only ducks one quarter the time
X	if (skill->value == 0)
X	{
X		if (random() > 0.25)
X			return;
X	}
X	VectorMA (start, 8192, dir, end);
X	tr = gi.trace (start, NULL, NULL, end, self, MASK_SHOT);
X	if ((tr.ent) && (tr.ent->svflags & SVF_MONSTER) && (tr.ent->health > 0) && (tr.ent->monsterinfo.dodge) && infront(tr.ent, self))
X	{
X			VectorSubtract (tr.endpos, start, v);
X			eta = (VectorLength(v) - tr.ent->maxs[0]) / speed;
//			tr.ent->monsterinfo.dodge (tr.ent, self, eta);
X			tr.ent->monsterinfo.dodge (tr.ent, self, eta, &tr);
X	}
}
X
X
/*
=================
fire_hit
X
Used for all impact (hit/punch/slash) attacks
=================
*/
qboolean fire_hit (edict_t *self, vec3_t aim, int damage, int kick)
{
X	trace_t		tr;
X	vec3_t		forward, right, up;
X	vec3_t		v;
X	vec3_t		point;
X	float		range;
X	vec3_t		dir;
X
X	//see if enemy is in range
X	VectorSubtract (self->enemy->s.origin, self->s.origin, dir);
X	range = VectorLength(dir);
X	if (range > aim[0])
X		return false;
X
X	if (aim[1] > self->mins[0] && aim[1] < self->maxs[0])
X	{
X		// the hit is straight on so back the range up to the edge of their bbox
X		range -= self->enemy->maxs[0];
X	}
X	else
X	{
X		// this is a side hit so adjust the "right" value out to the edge of their bbox
X		if (aim[1] < 0)
X			aim[1] = self->enemy->mins[0];
X		else
X			aim[1] = self->enemy->maxs[0];
X	}
X
X	VectorMA (self->s.origin, range, dir, point);
X
X	tr = gi.trace (self->s.origin, NULL, NULL, point, self, MASK_SHOT);
X	if (tr.fraction < 1)
X	{
X		if (!tr.ent->takedamage)
X			return false;
X		// if it will hit any client/monster then hit the one we wanted to hit
X		if ((tr.ent->svflags & SVF_MONSTER) || (tr.ent->client))
X			tr.ent = self->enemy;
X	}
X
X	AngleVectors(self->s.angles, forward, right, up);
X	VectorMA (self->s.origin, range, forward, point);
X	VectorMA (point, aim[1], right, point);
X	VectorMA (point, aim[2], up, point);
X	VectorSubtract (point, self->enemy->s.origin, dir);
X
X	// do the damage
X	T_Damage (tr.ent, self, self, dir, point, vec3_origin, damage, kick/2, DAMAGE_NO_KNOCKBACK, MOD_HIT);
X
X	if (!(tr.ent->svflags & SVF_MONSTER) && (!tr.ent->client))
X		return false;
X
X	// do our special form of knockback here
X	VectorMA (self->enemy->absmin, 0.5, self->enemy->size, v);
X	VectorSubtract (v, point, v);
X	VectorNormalize (v);
X	VectorMA (self->enemy->velocity, kick, v, self->enemy->velocity);
X	if (self->enemy->velocity[2] > 0)
X		self->enemy->groundentity = NULL;
X	return true;
}
X
X
/*
=================
fire_lead
X
This is an internal support routine used for bullet/pellet based weapons.
=================
*/
static void fire_lead (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int te_impact, int hspread, int vspread, int mod)
{
X	trace_t		tr;
X	vec3_t		dir;
X	vec3_t		forward, right, up;
X	vec3_t		end;
X	float		r;
X	float		u;
X	vec3_t		water_start;
X	qboolean	water = false;
X	int			content_mask = MASK_SHOT | MASK_WATER;
X
X	tr = gi.trace (self->s.origin, NULL, NULL, start, self, MASK_SHOT);
X	if (!(tr.fraction < 1.0))
X	{
X		vectoangles (aimdir, dir);
X		AngleVectors (dir, forward, right, up);
X
X		r = crandom()*hspread;
X		u = crandom()*vspread;
X		VectorMA (start, 8192, forward, end);
X		VectorMA (end, r, right, end);
X		VectorMA (end, u, up, end);
X
X		if (gi.pointcontents (start) & MASK_WATER)
X		{
X			water = true;
X			VectorCopy (start, water_start);
X			content_mask &= ~MASK_WATER;
X		}
X
X		tr = gi.trace (start, NULL, NULL, end, self, content_mask);
X
X		// see if we hit water
X		if (tr.contents & MASK_WATER)
X		{
X			int		color;
X
X			water = true;
X			VectorCopy (tr.endpos, water_start);
X
X			if (!VectorCompare (start, tr.endpos))
X			{
X				if (tr.contents & CONTENTS_WATER)
X				{
X					if (strcmp(tr.surface->name, "*brwater") == 0)
X						color = SPLASH_BROWN_WATER;
X					else
X						color = SPLASH_BLUE_WATER;
X				}
X				else if (tr.contents & CONTENTS_SLIME)
X					color = SPLASH_SLIME;
X				else if (tr.contents & CONTENTS_LAVA)
X					color = SPLASH_LAVA;
X				else
X					color = SPLASH_UNKNOWN;
X
X				if (color != SPLASH_UNKNOWN)
X				{
X					gi.WriteByte (svc_temp_entity);
X					gi.WriteByte (TE_SPLASH);
X					gi.WriteByte (8);
X					gi.WritePosition (tr.endpos);
X					gi.WriteDir (tr.plane.normal);
X					gi.WriteByte (color);
X					gi.multicast (tr.endpos, MULTICAST_PVS);
X				}
X
X				// change bullet's course when it enters water
X				VectorSubtract (end, start, dir);
X				vectoangles (dir, dir);
X				AngleVectors (dir, forward, right, up);
X				r = crandom()*hspread*2;
X				u = crandom()*vspread*2;
X				VectorMA (water_start, 8192, forward, end);
X				VectorMA (end, r, right, end);
X				VectorMA (end, u, up, end);
X			}
X
X			// re-trace ignoring water this time
X			tr = gi.trace (water_start, NULL, NULL, end, self, MASK_SHOT);
X		}
X	}
X
X	// send gun puff / flash
X	if (!((tr.surface) && (tr.surface->flags & SURF_SKY)))
X	{
X		if (tr.fraction < 1.0)
X		{
X			if (tr.ent->takedamage)
X			{
X				T_Damage (tr.ent, self, self, aimdir, tr.endpos, tr.plane.normal, damage, kick, DAMAGE_BULLET, mod);
X			}
X			else
X			{
X				if (strncmp (tr.surface->name, "sky", 3) != 0)
X				{
X					gi.WriteByte (svc_temp_entity);
X					gi.WriteByte (te_impact);
X					gi.WritePosition (tr.endpos);
X					gi.WriteDir (tr.plane.normal);
X					gi.multicast (tr.endpos, MULTICAST_PVS);
X
X					if (self->client)
X						PlayerNoise(self, tr.endpos, PNOISE_IMPACT);
X				}
X			}
X		}
X	}
X
X	// if went through water, determine where the end and make a bubble trail
X	if (water)
X	{
X		vec3_t	pos;
X
X		VectorSubtract (tr.endpos, water_start, dir);
X		VectorNormalize (dir);
X		VectorMA (tr.endpos, -2, dir, pos);
X		if (gi.pointcontents (pos) & MASK_WATER)
X			VectorCopy (pos, tr.endpos);
X		else
X			tr = gi.trace (pos, NULL, NULL, water_start, tr.ent, MASK_WATER);
X
X		VectorAdd (water_start, tr.endpos, pos);
X		VectorScale (pos, 0.5, pos);
X
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_BUBBLETRAIL);
X		gi.WritePosition (water_start);
X		gi.WritePosition (tr.endpos);
X		gi.multicast (pos, MULTICAST_PVS);
X	}
}
X
X
/*
=================
fire_bullet
X
Fires a single round.  Used for machinegun and chaingun.  Would be fine for
pistols, rifles, etc....
=================
*/
void fire_bullet (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int hspread, int vspread, int mod)
{
X	fire_lead (self, start, aimdir, damage, kick, TE_GUNSHOT, hspread, vspread, mod);
}
X
X
/*
=================
fire_shotgun
X
Shoots shotgun pellets.  Used by shotgun and super shotgun.
=================
*/
void fire_shotgun (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick, int hspread, int vspread, int count, int mod)
{
X	int		i;
X
X	for (i = 0; i < count; i++)
X		fire_lead (self, start, aimdir, damage, kick, TE_SHOTGUN, hspread, vspread, mod);
}
X
X
/*
=================
fire_blaster
X
Fires a single blaster bolt.  Used by the blaster and hyper blaster.
=================
*/
void blaster_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	int		mod;
X
X	if (other == self->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	// PMM - crash prevention
X	if (self->owner && self->owner->client)
X		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
X
X	if (other->takedamage)
X	{
X		if (self->spawnflags & 1)
X			mod = MOD_HYPERBLASTER;
X		else
X			mod = MOD_BLASTER;
X		T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal, self->dmg, 1, DAMAGE_ENERGY, mod);
X	}
X	else
X	{
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_BLASTER);
X		gi.WritePosition (self->s.origin);
X		if (!plane)
X			gi.WriteDir (vec3_origin);
X		else
X			gi.WriteDir (plane->normal);
X		gi.multicast (self->s.origin, MULTICAST_PVS);
X	}
X
X	G_FreeEdict (self);
}
X
void fire_blaster (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, int effect, qboolean hyper)
{
X	edict_t	*bolt;
X	trace_t	tr;
X
X	VectorNormalize (dir);
X
X	bolt = G_Spawn();
X	bolt->svflags = SVF_DEADMONSTER;
X	// yes, I know it looks weird that projectiles are deadmonsters
X	// what this means is that when prediction is used against the object
X	// (blaster/hyperblaster shots), the player won't be solid clipped against
X	// the object.  Right now trying to run into a firing hyperblaster
X	// is very jerky since you are predicted 'against' the shots.
X	VectorCopy (start, bolt->s.origin);
X	VectorCopy (start, bolt->s.old_origin);
X	vectoangles (dir, bolt->s.angles);
X	VectorScale (dir, speed, bolt->velocity);
X	bolt->movetype = MOVETYPE_FLYMISSILE;
X	bolt->clipmask = MASK_SHOT;
X	bolt->solid = SOLID_BBOX;
X	bolt->s.effects |= effect;
X	VectorClear (bolt->mins);
X	VectorClear (bolt->maxs);
X	bolt->s.modelindex = gi.modelindex ("models/objects/laser/tris.md2");
X	bolt->s.sound = gi.soundindex ("misc/lasfly.wav");
X	bolt->owner = self;
X	bolt->touch = blaster_touch;
X	bolt->nextthink = level.time + 2;
X	bolt->think = G_FreeEdict;
X	bolt->dmg = damage;
X	bolt->classname = "bolt";
X	if (hyper)
X		bolt->spawnflags = 1;
X	gi.linkentity (bolt);
X
X	if (self->client)
X		check_dodge (self, bolt->s.origin, dir, speed);
X
X	tr = gi.trace (self->s.origin, NULL, NULL, bolt->s.origin, bolt, MASK_SHOT);
X	if (tr.fraction < 1.0)
X	{
X		VectorMA (bolt->s.origin, -10, dir, bolt->s.origin);
X		bolt->touch (bolt, tr.ent, NULL, NULL);
X	}
}	
X
X
/*
=================
fire_grenade
=================
*/
//static void Grenade_Explode (edict_t *ent)
void Grenade_Explode (edict_t *ent)
{
X	vec3_t		origin;
X	int			mod;
X
X	if (ent->owner->client)
X		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
X
X	//FIXME: if we are onground then raise our Z just a bit since we are a point?
X	if (ent->enemy)
X	{
X		float	points;
X		vec3_t	v;
X		vec3_t	dir;
X
X		VectorAdd (ent->enemy->mins, ent->enemy->maxs, v);
X		VectorMA (ent->enemy->s.origin, 0.5, v, v);
X		VectorSubtract (ent->s.origin, v, v);
X		points = ent->dmg - 0.5 * VectorLength (v);
X		VectorSubtract (ent->enemy->s.origin, ent->s.origin, dir);
X		if (ent->spawnflags & 1)
X			mod = MOD_HANDGRENADE;
X		else
X			mod = MOD_GRENADE;
X		T_Damage (ent->enemy, ent, ent->owner, dir, ent->s.origin, vec3_origin, (int)points, (int)points, DAMAGE_RADIUS, mod);
X	}
X
X	if (ent->spawnflags & 2)
X		mod = MOD_HELD_GRENADE;
X	else if (ent->spawnflags & 1)
X		mod = MOD_HG_SPLASH;
X	else
X		mod = MOD_G_SPLASH;
X	T_RadiusDamage(ent, ent->owner, ent->dmg, ent->enemy, ent->dmg_radius, mod);
X
X	VectorMA (ent->s.origin, -0.02, ent->velocity, origin);
X	gi.WriteByte (svc_temp_entity);
X	if (ent->waterlevel)
X	{
X		if (ent->groundentity)
X			gi.WriteByte (TE_GRENADE_EXPLOSION_WATER);
X		else
X			gi.WriteByte (TE_ROCKET_EXPLOSION_WATER);
X	}
X	else
X	{
X		if (ent->groundentity)
X			gi.WriteByte (TE_GRENADE_EXPLOSION);
X		else
X			gi.WriteByte (TE_ROCKET_EXPLOSION);
X	}
X	gi.WritePosition (origin);
X	gi.multicast (ent->s.origin, MULTICAST_PHS);
X
X	G_FreeEdict (ent);
}
X
static void Grenade_Touch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other == ent->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (ent);
X		return;
X	}
X
X	if (!other->takedamage)
X	{
X		if (ent->spawnflags & 1)
X		{
X			if (random() > 0.5)
X				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb1a.wav"), 1, ATTN_NORM, 0);
X			else
X				gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/hgrenb2a.wav"), 1, ATTN_NORM, 0);
X		}
X		else
X		{
X			gi.sound (ent, CHAN_VOICE, gi.soundindex ("weapons/grenlb1b.wav"), 1, ATTN_NORM, 0);
X		}
X		return;
X	}
X
X	ent->enemy = other;
X	Grenade_Explode (ent);
}
X
void fire_grenade (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, float timer, float damage_radius)
{
X	edict_t	*grenade;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X
X	vectoangles (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	grenade = G_Spawn();
X	VectorCopy (start, grenade->s.origin);
X	VectorScale (aimdir, speed, grenade->velocity);
X	VectorMA (grenade->velocity, 200 + crandom() * 10.0, up, grenade->velocity);
X	VectorMA (grenade->velocity, crandom() * 10.0, right, grenade->velocity);
X	VectorSet (grenade->avelocity, 300, 300, 300);
X	grenade->movetype = MOVETYPE_BOUNCE;
X	grenade->clipmask = MASK_SHOT;
X	grenade->solid = SOLID_BBOX;
X	grenade->s.effects |= EF_GRENADE;
X	VectorClear (grenade->mins);
X	VectorClear (grenade->maxs);
X	grenade->s.modelindex = gi.modelindex ("models/objects/grenade/tris.md2");
X	grenade->owner = self;
X	grenade->touch = Grenade_Touch;
X	grenade->nextthink = level.time + timer;
X	grenade->think = Grenade_Explode;
X	grenade->dmg = damage;
X	grenade->dmg_radius = damage_radius;
X	grenade->classname = "grenade";
X
X	gi.linkentity (grenade);
}
X
void fire_grenade2 (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, float timer, float damage_radius, qboolean held)
{
X	edict_t	*grenade;
X	vec3_t	dir;
X	vec3_t	forward, right, up;
X
X	vectoangles (aimdir, dir);
X	AngleVectors (dir, forward, right, up);
X
X	grenade = G_Spawn();
X	VectorCopy (start, grenade->s.origin);
X	VectorScale (aimdir, speed, grenade->velocity);
X	VectorMA (grenade->velocity, 200 + crandom() * 10.0, up, grenade->velocity);
X	VectorMA (grenade->velocity, crandom() * 10.0, right, grenade->velocity);
X	VectorSet (grenade->avelocity, 300, 300, 300);
X	grenade->movetype = MOVETYPE_BOUNCE;
X	grenade->clipmask = MASK_SHOT;
X	grenade->solid = SOLID_BBOX;
X	grenade->s.effects |= EF_GRENADE;
X	VectorClear (grenade->mins);
X	VectorClear (grenade->maxs);
X	grenade->s.modelindex = gi.modelindex ("models/objects/grenade2/tris.md2");
X	grenade->owner = self;
X	grenade->touch = Grenade_Touch;
X	grenade->nextthink = level.time + timer;
X	grenade->think = Grenade_Explode;
X	grenade->dmg = damage;
X	grenade->dmg_radius = damage_radius;
X	grenade->classname = "hgrenade";
X	if (held)
X		grenade->spawnflags = 3;
X	else
X		grenade->spawnflags = 1;
X	grenade->s.sound = gi.soundindex("weapons/hgrenc1b.wav");
X
X	if (timer <= 0.0)
X		Grenade_Explode (grenade);
X	else
X	{
X		gi.sound (self, CHAN_WEAPON, gi.soundindex ("weapons/hgrent1a.wav"), 1, ATTN_NORM, 0);
X		gi.linkentity (grenade);
X	}
}
X
X
/*
=================
fire_rocket
=================
*/
void rocket_touch (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	vec3_t		origin;
X	int			n;
X
X	if (other == ent->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (ent);
X		return;
X	}
X
X	if (ent->owner->client)
X		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
X
X	// calculate position for the explosion entity
X	VectorMA (ent->s.origin, -0.02, ent->velocity, origin);
X
X	if (other->takedamage)
X	{
X		T_Damage (other, ent, ent->owner, ent->velocity, ent->s.origin, plane->normal, ent->dmg, 0, 0, MOD_ROCKET);
X	}
X	else
X	{
X		// don't throw any debris in net games
X		if (!deathmatch->value && !coop->value)
X		{
X			if ((surf) && !(surf->flags & (SURF_WARP|SURF_TRANS33|SURF_TRANS66|SURF_FLOWING)))
X			{
X				n = rand() % 5;
X				while(n--)
X					ThrowDebris (ent, "models/objects/debris2/tris.md2", 2, ent->s.origin);
X			}
X		}
X	}
X
X	T_RadiusDamage(ent, ent->owner, ent->radius_dmg, other, ent->dmg_radius, MOD_R_SPLASH);
X
X	gi.WriteByte (svc_temp_entity);
X	if (ent->waterlevel)
X		gi.WriteByte (TE_ROCKET_EXPLOSION_WATER);
X	else
X		gi.WriteByte (TE_ROCKET_EXPLOSION);
X	gi.WritePosition (origin);
X	gi.multicast (ent->s.origin, MULTICAST_PHS);
X
X	G_FreeEdict (ent);
}
X
void fire_rocket (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, float damage_radius, int radius_damage)
{
X	edict_t	*rocket;
X
X	rocket = G_Spawn();
X	VectorCopy (start, rocket->s.origin);
X	VectorCopy (dir, rocket->movedir);
X	vectoangles (dir, rocket->s.angles);
X	VectorScale (dir, speed, rocket->velocity);
X	rocket->movetype = MOVETYPE_FLYMISSILE;
X	rocket->clipmask = MASK_SHOT;
X	rocket->solid = SOLID_BBOX;
X	rocket->s.effects |= EF_ROCKET;
X	VectorClear (rocket->mins);
X	VectorClear (rocket->maxs);
X	rocket->s.modelindex = gi.modelindex ("models/objects/rocket/tris.md2");
X	rocket->owner = self;
X	rocket->touch = rocket_touch;
X	rocket->nextthink = level.time + 8000/speed;
X	rocket->think = G_FreeEdict;
X	rocket->dmg = damage;
X	rocket->radius_dmg = radius_damage;
X	rocket->dmg_radius = damage_radius;
X	rocket->s.sound = gi.soundindex ("weapons/rockfly.wav");
X	rocket->classname = "rocket";
X
X	if (self->client)
X		check_dodge (self, rocket->s.origin, dir, speed);
X
X	gi.linkentity (rocket);
}
X
X
/*
=================
fire_rail
=================
*/
void fire_rail (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int kick)
{
X	vec3_t		from;
X	vec3_t		end;
X	trace_t		tr;
X	edict_t		*ignore;
X	int			mask;
X	qboolean	water;
X
X	VectorMA (start, 8192, aimdir, end);
X	VectorCopy (start, from);
X	ignore = self;
X	water = false;
X	mask = MASK_SHOT|CONTENTS_SLIME|CONTENTS_LAVA;
X	while (ignore)
X	{
X		tr = gi.trace (from, NULL, NULL, end, ignore, mask);
X
X		if (tr.contents & (CONTENTS_SLIME|CONTENTS_LAVA))
X		{
X			mask &= ~(CONTENTS_SLIME|CONTENTS_LAVA);
X			water = true;
X		}
X		else
X		{
X			//ZOID--added so rail goes through SOLID_BBOX entities (gibs, etc)
X			if ((tr.ent->svflags & SVF_MONSTER) || (tr.ent->client) ||
X				(tr.ent->svflags & SVF_DAMAGEABLE) ||
X				(tr.ent->solid == SOLID_BBOX))
X				ignore = tr.ent;
X			else
X				ignore = NULL;
X
X			if ((tr.ent != self) && (tr.ent->takedamage))
X				T_Damage (tr.ent, self, self, aimdir, tr.endpos, tr.plane.normal, damage, kick, 0, MOD_RAILGUN);
X		}
X
X		VectorCopy (tr.endpos, from);
X	}
X
X	// send gun puff / flash
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_RAILTRAIL);
X	gi.WritePosition (start);
X	gi.WritePosition (tr.endpos);
X	gi.multicast (self->s.origin, MULTICAST_PHS);
//	gi.multicast (start, MULTICAST_PHS);
X	if (water)
X	{
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_RAILTRAIL);
X		gi.WritePosition (start);
X		gi.WritePosition (tr.endpos);
X		gi.multicast (tr.endpos, MULTICAST_PHS);
X	}
X
X	if (self->client)
X		PlayerNoise(self, tr.endpos, PNOISE_IMPACT);
}
X
X
/*
=================
fire_bfg
=================
*/
void bfg_explode (edict_t *self)
{
X	edict_t	*ent;
X	float	points;
X	vec3_t	v;
X	float	dist;
X
X	if (self->s.frame == 0)
X	{
X		// the BFG effect
X		ent = NULL;
X		while ((ent = findradius(ent, self->s.origin, self->dmg_radius)) != NULL)
X		{
X			if (!ent->takedamage)
X				continue;
X			if (ent == self->owner)
X				continue;
X			if (!CanDamage (ent, self))
X				continue;
X			if (!CanDamage (ent, self->owner))
X				continue;
X
X			VectorAdd (ent->mins, ent->maxs, v);
X			VectorMA (ent->s.origin, 0.5, v, v);
X			VectorSubtract (self->s.origin, v, v);
X			dist = VectorLength(v);
X			points = self->radius_dmg * (1.0 - sqrt(dist/self->dmg_radius));
// PMM - happened to notice this copy/paste bug
//			if (ent == self->owner)
//				points = points * 0.5;
X
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_BFG_EXPLOSION);
X			gi.WritePosition (ent->s.origin);
X			gi.multicast (ent->s.origin, MULTICAST_PHS);
X			T_Damage (ent, self, self->owner, self->velocity, ent->s.origin, vec3_origin, (int)points, 0, DAMAGE_ENERGY, MOD_BFG_EFFECT);
X		}
X	}
X
X	self->nextthink = level.time + FRAMETIME;
X	self->s.frame++;
X	if (self->s.frame == 5)
X		self->think = G_FreeEdict;
}
X
void bfg_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (other == self->owner)
X		return;
X
X	if (surf && (surf->flags & SURF_SKY))
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (self->owner->client)
X		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
X
X	// core explosion - prevents firing it into the wall/floor
X	if (other->takedamage)
X		T_Damage (other, self, self->owner, self->velocity, self->s.origin, plane->normal, 200, 0, 0, MOD_BFG_BLAST);
X	T_RadiusDamage(self, self->owner, 200, other, 100, MOD_BFG_BLAST);
X
X	gi.sound (self, CHAN_VOICE, gi.soundindex ("weapons/bfg__x1b.wav"), 1, ATTN_NORM, 0);
X	self->solid = SOLID_NOT;
X	self->touch = NULL;
X	VectorMA (self->s.origin, -1 * FRAMETIME, self->velocity, self->s.origin);
X	VectorClear (self->velocity);
X	self->s.modelindex = gi.modelindex ("sprites/s_bfg3.sp2");
X	self->s.frame = 0;
X	self->s.sound = 0;
X	self->s.effects &= ~EF_ANIM_ALLFAST;
X	self->think = bfg_explode;
X	self->nextthink = level.time + FRAMETIME;
X	self->enemy = other;
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_BFG_BIGEXPLOSION);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
}
X
X
void bfg_think (edict_t *self)
{
X	edict_t	*ent;
X	edict_t	*ignore;
X	vec3_t	point;
X	vec3_t	dir;
X	vec3_t	start;
X	vec3_t	end;
X	int		dmg;
X	trace_t	tr;
X
X	if (deathmatch->value)
X		dmg = 5;
X	else
X		dmg = 10;
X
X	ent = NULL;
X	while ((ent = findradius(ent, self->s.origin, 256)) != NULL)
X	{
X		if (ent == self)
X			continue;
X
X		if (ent == self->owner)
X			continue;
X
X		if (!ent->takedamage)
X			continue;
X
X		//ROGUE - make tesla hurt by bfg
X		if (!(ent->svflags & SVF_MONSTER) && !(ent->svflags & SVF_DAMAGEABLE) && (!ent->client) && (strcmp(ent->classname, "misc_explobox") != 0))
//		if (!(ent->svflags & SVF_MONSTER) && (!ent->client) && (strcmp(ent->classname, "misc_explobox") != 0)
//			&& (strcmp(ent->classname, "tesla") != 0))
X			continue;
X
X		VectorMA (ent->absmin, 0.5, ent->size, point);
X
X		VectorSubtract (point, self->s.origin, dir);
X		VectorNormalize (dir);
X
X		ignore = self;
X		VectorCopy (self->s.origin, start);
X		VectorMA (start, 2048, dir, end);
X		while(1)
X		{
X			tr = gi.trace (start, NULL, NULL, end, ignore, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_DEADMONSTER);
X
X			if (!tr.ent)
X				break;
X
X			// hurt it if we can
X			if ((tr.ent->takedamage) && !(tr.ent->flags & FL_IMMUNE_LASER) && (tr.ent != self->owner))
X				T_Damage (tr.ent, self, self->owner, dir, tr.endpos, vec3_origin, dmg, 1, DAMAGE_ENERGY, MOD_BFG_LASER);
X
X			// if we hit something that's not a monster or player we're done
//			if (!(tr.ent->svflags & SVF_MONSTER) && (!tr.ent->client))
X			if (!(tr.ent->svflags & SVF_MONSTER) && !(tr.ent->svflags & SVF_DAMAGEABLE) && (!tr.ent->client))
X			{
X				gi.WriteByte (svc_temp_entity);
X				gi.WriteByte (TE_LASER_SPARKS);
X				gi.WriteByte (4);
X				gi.WritePosition (tr.endpos);
X				gi.WriteDir (tr.plane.normal);
X				gi.WriteByte (self->s.skinnum);
X				gi.multicast (tr.endpos, MULTICAST_PVS);
X				break;
X			}
X
X			ignore = tr.ent;
X			VectorCopy (tr.endpos, start);
X		}
X
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_BFG_LASER);
X		gi.WritePosition (self->s.origin);
X		gi.WritePosition (tr.endpos);
X		gi.multicast (self->s.origin, MULTICAST_PHS);
X	}
X
X	self->nextthink = level.time + FRAMETIME;
}
X
X
void fire_bfg (edict_t *self, vec3_t start, vec3_t dir, int damage, int speed, float damage_radius)
{
X	edict_t	*bfg;
X
X	bfg = G_Spawn();
X	VectorCopy (start, bfg->s.origin);
X	VectorCopy (dir, bfg->movedir);
X	vectoangles (dir, bfg->s.angles);
X	VectorScale (dir, speed, bfg->velocity);
X	bfg->movetype = MOVETYPE_FLYMISSILE;
X	bfg->clipmask = MASK_SHOT;
X	bfg->solid = SOLID_BBOX;
X	bfg->s.effects |= EF_BFG | EF_ANIM_ALLFAST;
X	VectorClear (bfg->mins);
X	VectorClear (bfg->maxs);
X	bfg->s.modelindex = gi.modelindex ("sprites/s_bfg1.sp2");
X	bfg->owner = self;
X	bfg->touch = bfg_touch;
X	bfg->nextthink = level.time + 8000/speed;
X	bfg->think = G_FreeEdict;
X	bfg->radius_dmg = damage;
X	bfg->dmg_radius = damage_radius;
X	bfg->classname = "bfg blast";
X	bfg->s.sound = gi.soundindex ("weapons/bfg__l1a.wav");
X
X	bfg->think = bfg_think;
X	bfg->nextthink = level.time + FRAMETIME;
X	bfg->teammaster = bfg;
X	bfg->teamchain = NULL;
X
X	if (self->client)
X		check_dodge (self, bfg->s.origin, dir, speed);
X
X	gi.linkentity (bfg);
}
SHAR_EOF
  $shar_touch -am 1130175398 'g_weapon.c' &&
  chmod 0664 'g_weapon.c' ||
  $echo 'restore of' 'g_weapon.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'g_weapon.c:' 'MD5 check failed'
af738fe9178c77809a30352fd73fb10e  g_weapon.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'g_weapon.c'`"
    test 23501 -eq "$shar_count" ||
    $echo 'g_weapon.c:' 'original size' '23501,' 'current size' "$shar_count!"
  fi
fi
# ============= game.h ==============
if test -f 'game.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'game.h' '(file already exists)'
else
  $echo 'x -' extracting 'game.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'game.h' &&
X
// game.h -- game dll information visible to server
X
#define	GAME_API_VERSION	3
X
// edict->svflags
X
#define	SVF_NOCLIENT			0x00000001	// don't send entity to clients, even if it has effects
#define	SVF_DEADMONSTER			0x00000002	// treat as CONTENTS_DEADMONSTER for collision
#define	SVF_MONSTER				0x00000004	// treat as CONTENTS_MONSTER for collision
//ROGUE -- added for things that are damageable, but not monsters
// right now, only the tesla has this
#define SVF_DAMAGEABLE			0x00000008
//ROGUE end
X
// edict->solid values
X
typedef enum
{
SOLID_NOT,			// no interaction with other objects
SOLID_TRIGGER,		// only touch when inside, after moving
SOLID_BBOX,			// touch on edge
SOLID_BSP			// bsp clip, touch on edge
} solid_t;
X
//===============================================================
X
// link_t is only used for entity area links now
typedef struct link_s
{
X	struct link_s	*prev, *next;
} link_t;
X
#define	MAX_ENT_CLUSTERS	16
X
X
typedef struct edict_s edict_t;
typedef struct gclient_s gclient_t;
X
X
#ifndef GAME_INCLUDE
X
struct gclient_s
{
X	player_state_t	ps;		// communicated by server to clients
X	int				ping;
X	// the game dll can add anything it wants after
X	// this point in the structure
};
X
X
struct edict_s
{
X	entity_state_t	s;
X	struct gclient_s	*client;
X	qboolean	inuse;
X	int			linkcount;
X
X	// FIXME: move these fields to a server private sv_entity_t
X	link_t		area;				// linked to a division node or leaf
X	
X	int			num_clusters;		// if -1, use headnode instead
X	int			clusternums[MAX_ENT_CLUSTERS];
X	int			headnode;			// unused if num_clusters != -1
X	int			areanum, areanum2;
X
X	//================================
X
X	int			svflags;			// SVF_NOCLIENT, SVF_DEADMONSTER, SVF_MONSTER, etc
X	vec3_t		mins, maxs;
X	vec3_t		absmin, absmax, size;
X	solid_t		solid;
X	int			clipmask;
X	edict_t		*owner;
X
X	// the game dll can add anything it wants after
X	// this point in the structure
};
X
#endif		// GAME_INCLUDE
X
//===============================================================
X
//
// functions provided by the main engine
//
typedef struct
{
X	// special messages
X	void	(*bprintf) (int printlevel, char *fmt, ...);
X	void	(*dprintf) (char *fmt, ...);
X	void	(*cprintf) (edict_t *ent, int printlevel, char *fmt, ...);
X	void	(*centerprintf) (edict_t *ent, char *fmt, ...);
X	void	(*sound) (edict_t *ent, int channel, int soundindex, float volume, float attenuation, float timeofs);
X	void	(*positioned_sound) (vec3_t origin, edict_t *ent, int channel, int soundinedex, float volume, float attenuation, float timeofs);
X
X	// config strings hold all the index strings, the lightstyles,
X	// and misc data like the sky definition and cdtrack.
X	// All of the current configstrings are sent to clients when
X	// they connect, and changes are sent to all connected clients.
X	void	(*configstring) (int num, char *string);
X
X	void	(*error) (char *fmt, ...);
X
X	// the *index functions create configstrings and some internal server state
X	int		(*modelindex) (char *name);
X	int		(*soundindex) (char *name);
X	int		(*imageindex) (char *name);
X
X	void	(*setmodel) (edict_t *ent, char *name);
X
X	// collision detection
X	trace_t	(*trace) (vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, edict_t *passent, int contentmask);
X	int		(*pointcontents) (vec3_t point);
X	qboolean	(*inPVS) (vec3_t p1, vec3_t p2);
X	qboolean	(*inPHS) (vec3_t p1, vec3_t p2);
X	void		(*SetAreaPortalState) (int portalnum, qboolean open);
X	qboolean	(*AreasConnected) (int area1, int area2);
X
X	// an entity will never be sent to a client or used for collision
X	// if it is not passed to linkentity.  If the size, position, or
X	// solidity changes, it must be relinked.
X	void	(*linkentity) (edict_t *ent);
X	void	(*unlinkentity) (edict_t *ent);		// call before removing an interactive edict
X	int		(*BoxEdicts) (vec3_t mins, vec3_t maxs, edict_t **list,	int maxcount, int areatype);
X	void	(*Pmove) (pmove_t *pmove);		// player movement code common with client prediction
X
X	// network messaging
X	void	(*multicast) (vec3_t origin, multicast_t to);
X	void	(*unicast) (edict_t *ent, qboolean reliable);
X	void	(*WriteChar) (int c);
X	void	(*WriteByte) (int c);
X	void	(*WriteShort) (int c);
X	void	(*WriteLong) (int c);
X	void	(*WriteFloat) (float f);
X	void	(*WriteString) (char *s);
X	void	(*WritePosition) (vec3_t pos);	// some fractional bits
X	void	(*WriteDir) (vec3_t pos);		// single byte encoded, very coarse
X	void	(*WriteAngle) (float f);
X
X	// managed memory allocation
X	void	*(*TagMalloc) (int size, int tag);
X	void	(*TagFree) (void *block);
X	void	(*FreeTags) (int tag);
X
X	// console variable interaction
X	cvar_t	*(*cvar) (char *var_name, char *value, int flags);
X	cvar_t	*(*cvar_set) (char *var_name, char *value);
X	cvar_t	*(*cvar_forceset) (char *var_name, char *value);
X
X	// ClientCommand and ServerCommand parameter access
X	int		(*argc) (void);
X	char	*(*argv) (int n);
X	char	*(*args) (void);	// concatenation of all argv >= 1
X
X	// add commands to the server console as if they were typed in
X	// for map changing, etc
X	void	(*AddCommandString) (char *text);
X
X	void	(*DebugGraph) (float value, int color);
} game_import_t;
X
//
// functions exported by the game subsystem
//
typedef struct
{
X	int			apiversion;
X
X	// the init function will only be called when a game starts,
X	// not each time a level is loaded.  Persistant data for clients
X	// and the server can be allocated in init
X	void		(*Init) (void);
X	void		(*Shutdown) (void);
X
X	// each new level entered will cause a call to SpawnEntities
X	void		(*SpawnEntities) (char *mapname, char *entstring, char *spawnpoint);
X
X	// Read/Write Game is for storing persistant cross level information
X	// about the world state and the clients.
X	// WriteGame is called every time a level is exited.
X	// ReadGame is called on a loadgame.
X	void		(*WriteGame) (char *filename, qboolean autosave);
X	void		(*ReadGame) (char *filename);
X
X	// ReadLevel is called after the default map information has been
X	// loaded with SpawnEntities
X	void		(*WriteLevel) (char *filename);
X	void		(*ReadLevel) (char *filename);
X
X	qboolean	(*ClientConnect) (edict_t *ent, char *userinfo);
X	void		(*ClientBegin) (edict_t *ent);
X	void		(*ClientUserinfoChanged) (edict_t *ent, char *userinfo);
X	void		(*ClientDisconnect) (edict_t *ent);
X	void		(*ClientCommand) (edict_t *ent);
X	void		(*ClientThink) (edict_t *ent, usercmd_t *cmd);
X
X	void		(*RunFrame) (void);
X
X	// ServerCommand will be called when an "sv <command>" command is issued on the
X	// server console.
X	// The game can issue gi.argc() / gi.argv() commands to get the rest
X	// of the parameters
X	void		(*ServerCommand) (void);
X
X	//
X	// global variables shared between game and server
X	//
X
X	// The edict array is allocated in the game dll so it
X	// can vary in size from one game to another.
X	// 
X	// The size will be fixed when ge->Init() is called
X	struct edict_s	*edicts;
X	int			edict_size;
X	int			num_edicts;		// current number, <= max_edicts
X	int			max_edicts;
} game_export_t;
X
game_export_t *GetGameApi (game_import_t *import);
SHAR_EOF
  $shar_touch -am 1130175398 'game.h' &&
  chmod 0664 'game.h' ||
  $echo 'restore of' 'game.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'game.h:' 'MD5 check failed'
6001d4101c5ad0cf7780da87c146eeb1  game.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'game.h'`"
    test 6954 -eq "$shar_count" ||
    $echo 'game.h:' 'original size' '6954,' 'current size' "$shar_count!"
  fi
fi
# ============= m_actor.c ==============
if test -f 'm_actor.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_actor.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_actor.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_actor.c' &&
// g_actor.c
X
#include "g_local.h"
#include "m_actor.h"
X
#define	MAX_ACTOR_NAMES		8
char *actor_names[MAX_ACTOR_NAMES] =
{
X	"Hellrot",
X	"Tokay",
X	"Killme",
X	"Disruptor",
X	"Adrianator",
X	"Rambear",
X	"Titus",
X	"Bitterman"
};
X
X
mframe_t actor_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t actor_move_stand = {FRAME_stand101, FRAME_stand140, actor_frames_stand, NULL};
X
void actor_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &actor_move_stand;
X
X	// randomize on startup
X	if (level.time < 1.0)
X		self->s.frame = self->monsterinfo.currentmove->firstframe + (rand() % (self->monsterinfo.currentmove->lastframe - self->monsterinfo.currentmove->firstframe + 1));
}
X
X
mframe_t actor_frames_walk [] =
{
X	ai_walk, 0,  NULL,
X	ai_walk, 6,  NULL,
X	ai_walk, 10, NULL,
X	ai_walk, 3,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 7,  NULL,
X	ai_walk, 10, NULL,
X	ai_walk, 1,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL
};
mmove_t actor_move_walk = {FRAME_walk01, FRAME_walk08, actor_frames_walk, NULL};
X
void actor_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &actor_move_walk;
}
X
X
mframe_t actor_frames_run [] =
{
X	ai_run, 4,  NULL,
X	ai_run, 15, NULL,
X	ai_run, 15, NULL,
X	ai_run, 8,  NULL,
X	ai_run, 20, NULL,
X	ai_run, 15, NULL,
X	ai_run, 8,  NULL,
X	ai_run, 17, NULL,
X	ai_run, 12, NULL,
X	ai_run, -2, NULL,
X	ai_run, -2, NULL,
X	ai_run, -1, NULL
};
mmove_t actor_move_run = {FRAME_run02, FRAME_run07, actor_frames_run, NULL};
X
void actor_run (edict_t *self)
{
X	if ((level.time < self->pain_debounce_time) && (!self->enemy))
X	{
X		if (self->movetarget)
X			actor_walk(self);
X		else
X			actor_stand(self);
X		return;
X	}
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		actor_stand(self);
X		return;
X	}
X
X	self->monsterinfo.currentmove = &actor_move_run;
}
X
X
mframe_t actor_frames_pain1 [] =
{
X	ai_move, -5, NULL,
X	ai_move, 4,  NULL,
X	ai_move, 1,  NULL
};
mmove_t actor_move_pain1 = {FRAME_pain101, FRAME_pain103, actor_frames_pain1, actor_run};
X
mframe_t actor_frames_pain2 [] =
{
X	ai_move, -4, NULL,
X	ai_move, 4,  NULL,
X	ai_move, 0,  NULL
};
mmove_t actor_move_pain2 = {FRAME_pain201, FRAME_pain203, actor_frames_pain2, actor_run};
X
mframe_t actor_frames_pain3 [] =
{
X	ai_move, -1, NULL,
X	ai_move, 1,  NULL,
X	ai_move, 0,  NULL
};
mmove_t actor_move_pain3 = {FRAME_pain301, FRAME_pain303, actor_frames_pain3, actor_run};
X
mframe_t actor_frames_flipoff [] =
{
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL
};
mmove_t actor_move_flipoff = {FRAME_flip01, FRAME_flip14, actor_frames_flipoff, actor_run};
X
mframe_t actor_frames_taunt [] =
{
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL,
X	ai_turn, 0,  NULL
};
mmove_t actor_move_taunt = {FRAME_taunt01, FRAME_taunt17, actor_frames_taunt, actor_run};
X
char *messages[] =
{
X	"Watch it",
X	"#$@*&",
X	"Idiot",
X	"Check your targets"
};
X
void actor_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	int		n;
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
//	gi.sound (self, CHAN_VOICE, actor.sound_pain, 1, ATTN_NORM, 0);
X
X	if ((other->client) && (random() < 0.4))
X	{
X		vec3_t	v;
X		char	*name;
X
X		VectorSubtract (other->s.origin, self->s.origin, v);
X		self->ideal_yaw = vectoyaw (v);
X		if (random() < 0.5)
X			self->monsterinfo.currentmove = &actor_move_flipoff;
X		else
X			self->monsterinfo.currentmove = &actor_move_taunt;
X		name = actor_names[(self - g_edicts)%MAX_ACTOR_NAMES];
X		gi.cprintf (other, PRINT_CHAT, "%s: %s!\n", name, messages[rand()%3]);
X		return;
X	}
X
X	n = rand() % 3;
X	if (n == 0)
X		self->monsterinfo.currentmove = &actor_move_pain1;
X	else if (n == 1)
X		self->monsterinfo.currentmove = &actor_move_pain2;
X	else
X		self->monsterinfo.currentmove = &actor_move_pain3;
}
X
X
void actorMachineGun (edict_t *self)
{
X	vec3_t	start, target;
X	vec3_t	forward, right;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1], forward, right, start);
X	if (self->enemy)
X	{
X		if (self->enemy->health > 0)
X		{
X			VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X			target[2] += self->enemy->viewheight;
X		}
X		else
X		{
X			VectorCopy (self->enemy->absmin, target);
X			target[2] += (self->enemy->size[2] / 2);
X		}
X		VectorSubtract (target, start, forward);
X		VectorNormalize (forward);
X	}
X	else
X	{
X		AngleVectors (self->s.angles, forward, NULL, NULL);
X	}
X	monster_fire_bullet (self, start, forward, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_ACTOR_MACHINEGUN_1);
}
X
X
void actor_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t actor_frames_death1 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -13, NULL,
X	ai_move, 14,  NULL,
X	ai_move, 3,   NULL,
X	ai_move, -2,  NULL,
X	ai_move, 1,   NULL
};
mmove_t actor_move_death1 = {FRAME_death101, FRAME_death107, actor_frames_death1, actor_dead};
X
mframe_t actor_frames_death2 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, 7,   NULL,
X	ai_move, -6,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, 1,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -1,  NULL,
X	ai_move, -2,  NULL,
X	ai_move, -1,  NULL,
X	ai_move, -9,  NULL,
X	ai_move, -13, NULL,
X	ai_move, -13, NULL,
X	ai_move, 0,   NULL
};
mmove_t actor_move_death2 = {FRAME_death201, FRAME_death213, actor_frames_death2, actor_dead};
X
void actor_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= -80)
X	{
//		gi.sound (self, CHAN_VOICE, actor.sound_gib, 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
//	gi.sound (self, CHAN_VOICE, actor.sound_die, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	n = rand() % 2;
X	if (n == 0)
X		self->monsterinfo.currentmove = &actor_move_death1;
X	else
X		self->monsterinfo.currentmove = &actor_move_death2;
}
X
X
void actor_fire (edict_t *self)
{
X	actorMachineGun (self);
X
X	if (level.time >= self->monsterinfo.pausetime)
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X	else
X		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
}
X
mframe_t actor_frames_attack [] =
{
X	ai_charge, -2,  actor_fire,
X	ai_charge, -2,  NULL,
X	ai_charge, 3,   NULL,
X	ai_charge, 2,   NULL
};
mmove_t actor_move_attack = {FRAME_attak01, FRAME_attak04, actor_frames_attack, actor_run};
X
void actor_attack(edict_t *self)
{
X	int		n;
X
X	self->monsterinfo.currentmove = &actor_move_attack;
X	n = (rand() & 15) + 3 + 7;
X	self->monsterinfo.pausetime = level.time + n * FRAMETIME;
}
X
X
void actor_use (edict_t *self, edict_t *other, edict_t *activator)
{
X	vec3_t		v;
X
X	self->goalentity = self->movetarget = G_PickTarget(self->target);
X	if ((!self->movetarget) || (strcmp(self->movetarget->classname, "target_actor") != 0))
X	{
X		gi.dprintf ("%s has bad target %s at %s\n", self->classname, self->target, vtos(self->s.origin));
X		self->target = NULL;
X		self->monsterinfo.pausetime = 100000000;
X		self->monsterinfo.stand (self);
X		return;
X	}
X
X	VectorSubtract (self->goalentity->s.origin, self->s.origin, v);
X	self->ideal_yaw = self->s.angles[YAW] = vectoyaw(v);
X	self->monsterinfo.walk (self);
X	self->target = NULL;
}
X
X
/*QUAKED misc_actor (1 .5 0) (-16 -16 -24) (16 16 32)
*/
X
void SP_misc_actor (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (!self->targetname)
X	{
X		gi.dprintf("untargeted %s at %s\n", self->classname, vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	if (!self->target)
X	{
X		gi.dprintf("%s with no target at %s\n", self->classname, vtos(self->s.origin));
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex("players/male/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X
X	if (!self->health)
X		self->health = 100;
X	self->mass = 200;
X
X	self->pain = actor_pain;
X	self->die = actor_die;
X
X	self->monsterinfo.stand = actor_stand;
X	self->monsterinfo.walk = actor_walk;
X	self->monsterinfo.run = actor_run;
X	self->monsterinfo.attack = actor_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = NULL;
X
X	self->monsterinfo.aiflags |= AI_GOOD_GUY;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &actor_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start (self);
X
X	// actors always start in a dormant state, they *must* be used to get going
X	self->use = actor_use;
}
X
X
/*QUAKED target_actor (.5 .3 0) (-8 -8 -8) (8 8 8) JUMP SHOOT ATTACK x HOLD BRUTAL
JUMP			jump in set direction upon reaching this target
SHOOT			take a single shot at the pathtarget
ATTACK			attack pathtarget until it or actor is dead 
X
"target"		next target_actor
"pathtarget"	target of any action to be taken at this point
"wait"			amount of time actor should pause at this point
"message"		actor will "say" this to the player
X
for JUMP only:
"speed"			speed thrown forward (default 200)
"height"		speed thrown upwards (default 200)
*/
X
void target_actor_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	vec3_t	v;
X
X	if (other->movetarget != self)
X		return;
X	
X	if (other->enemy)
X		return;
X
X	other->goalentity = other->movetarget = NULL;
X
X	if (self->message)
X	{
X		int		n;
X		edict_t	*ent;
X
X		for (n = 1; n <= game.maxclients; n++)
X		{
X			ent = &g_edicts[n];
X			if (!ent->inuse)
X				continue;
X			gi.cprintf (ent, PRINT_CHAT, "%s: %s\n", actor_names[(other - g_edicts)%MAX_ACTOR_NAMES], self->message);
X		}
X	}
X
X	if (self->spawnflags & 1)		//jump
X	{
X		other->velocity[0] = self->movedir[0] * self->speed;
X		other->velocity[1] = self->movedir[1] * self->speed;
X		
X		if (other->groundentity)
X		{
X			other->groundentity = NULL;
X			other->velocity[2] = self->movedir[2];
X			gi.sound(other, CHAN_VOICE, gi.soundindex("player/male/jump1.wav"), 1, ATTN_NORM, 0);
X		}
X	}
X
X	if (self->spawnflags & 2)	//shoot
X	{
X	}
X	else if (self->spawnflags & 4)	//attack
X	{
X		other->enemy = G_PickTarget(self->pathtarget);
X		if (other->enemy)
X		{
X			other->goalentity = other->enemy;
X			if (self->spawnflags & 32)
X				other->monsterinfo.aiflags |= AI_BRUTAL;
X			if (self->spawnflags & 16)
X			{
X				other->monsterinfo.aiflags |= AI_STAND_GROUND;
X				actor_stand (other);
X			}
X			else
X			{
X				actor_run (other);
X			}
X		}
X	}
X
X	if (!(self->spawnflags & 6) && (self->pathtarget))
X	{
X		char *savetarget;
X
X		savetarget = self->target;
X		self->target = self->pathtarget;
X		G_UseTargets (self, other);
X		self->target = savetarget;
X	}
X
X	other->movetarget = G_PickTarget(self->target);
X
X	if (!other->goalentity)
X		other->goalentity = other->movetarget;
X
X	if (!other->movetarget && !other->enemy)
X	{
X		other->monsterinfo.pausetime = level.time + 100000000;
X		other->monsterinfo.stand (other);
X	}
X	else if (other->movetarget == other->goalentity)
X	{
X		VectorSubtract (other->movetarget->s.origin, other->s.origin, v);
X		other->ideal_yaw = vectoyaw (v);
X	}
}
X
void SP_target_actor (edict_t *self)
{
X	if (!self->targetname)
X		gi.dprintf ("%s with no targetname at %s\n", self->classname, vtos(self->s.origin));
X
X	self->solid = SOLID_TRIGGER;
X	self->touch = target_actor_touch;
X	VectorSet (self->mins, -8, -8, -8);
X	VectorSet (self->maxs, 8, 8, 8);
X	self->svflags = SVF_NOCLIENT;
X
X	if (self->spawnflags & 1)
X	{
X		if (!self->speed)
X			self->speed = 200;
X		if (!st.height)
X			st.height = 200;
X		if (self->s.angles[YAW] == 0)
X			self->s.angles[YAW] = 360;
X		G_SetMovedir (self->s.angles, self->movedir);
X		self->movedir[2] = st.height;
X	}
X
X	gi.linkentity (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_actor.c' &&
  chmod 0664 'm_actor.c' ||
  $echo 'restore of' 'm_actor.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_actor.c:' 'MD5 check failed'
d3cad2227bdcba39c7723c20cc278dd7  m_actor.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_actor.c'`"
    test 13233 -eq "$shar_count" ||
    $echo 'm_actor.c:' 'original size' '13233,' 'current size' "$shar_count!"
  fi
fi
# ============= m_actor.h ==============
if test -f 'm_actor.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_actor.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_actor.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_actor.h' &&
// G:\quake2\baseq2\models/player_y
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_attak01         	0
#define FRAME_attak02         	1
#define FRAME_attak03         	2
#define FRAME_attak04         	3
#define FRAME_death101        	4
#define FRAME_death102        	5
#define FRAME_death103        	6
#define FRAME_death104        	7
#define FRAME_death105        	8
#define FRAME_death106        	9
#define FRAME_death107        	10
#define FRAME_death201        	11
#define FRAME_death202        	12
#define FRAME_death203        	13
#define FRAME_death204        	14
#define FRAME_death205        	15
#define FRAME_death206        	16
#define FRAME_death207        	17
#define FRAME_death208        	18
#define FRAME_death209        	19
#define FRAME_death210        	20
#define FRAME_death211        	21
#define FRAME_death212        	22
#define FRAME_death213        	23
#define FRAME_death301        	24
#define FRAME_death302        	25
#define FRAME_death303        	26
#define FRAME_death304        	27
#define FRAME_death305        	28
#define FRAME_death306        	29
#define FRAME_death307        	30
#define FRAME_death308        	31
#define FRAME_death309        	32
#define FRAME_death310        	33
#define FRAME_death311        	34
#define FRAME_death312        	35
#define FRAME_death313        	36
#define FRAME_death314        	37
#define FRAME_death315        	38
#define FRAME_flip01          	39
#define FRAME_flip02          	40
#define FRAME_flip03          	41
#define FRAME_flip04          	42
#define FRAME_flip05          	43
#define FRAME_flip06          	44
#define FRAME_flip07          	45
#define FRAME_flip08          	46
#define FRAME_flip09          	47
#define FRAME_flip10          	48
#define FRAME_flip11          	49
#define FRAME_flip12          	50
#define FRAME_flip13          	51
#define FRAME_flip14          	52
#define FRAME_grenad01        	53
#define FRAME_grenad02        	54
#define FRAME_grenad03        	55
#define FRAME_grenad04        	56
#define FRAME_grenad05        	57
#define FRAME_grenad06        	58
#define FRAME_grenad07        	59
#define FRAME_grenad08        	60
#define FRAME_grenad09        	61
#define FRAME_grenad10        	62
#define FRAME_grenad11        	63
#define FRAME_grenad12        	64
#define FRAME_grenad13        	65
#define FRAME_grenad14        	66
#define FRAME_grenad15        	67
#define FRAME_jump01          	68
#define FRAME_jump02          	69
#define FRAME_jump03          	70
#define FRAME_jump04          	71
#define FRAME_jump05          	72
#define FRAME_jump06          	73
#define FRAME_pain101         	74
#define FRAME_pain102         	75
#define FRAME_pain103         	76
#define FRAME_pain201         	77
#define FRAME_pain202         	78
#define FRAME_pain203         	79
#define FRAME_pain301         	80
#define FRAME_pain302         	81
#define FRAME_pain303         	82
#define FRAME_push01          	83
#define FRAME_push02          	84
#define FRAME_push03          	85
#define FRAME_push04          	86
#define FRAME_push05          	87
#define FRAME_push06          	88
#define FRAME_push07          	89
#define FRAME_push08          	90
#define FRAME_push09          	91
#define FRAME_run01           	92
#define FRAME_run02           	93
#define FRAME_run03           	94
#define FRAME_run04           	95
#define FRAME_run05           	96
#define FRAME_run06           	97
#define FRAME_run07           	98
#define FRAME_run08           	99
#define FRAME_run09           	100
#define FRAME_run10           	101
#define FRAME_run11           	102
#define FRAME_run12           	103
#define FRAME_runs01          	104
#define FRAME_runs02          	105
#define FRAME_runs03          	106
#define FRAME_runs04          	107
#define FRAME_runs05          	108
#define FRAME_runs06          	109
#define FRAME_runs07          	110
#define FRAME_runs08          	111
#define FRAME_runs09          	112
#define FRAME_runs10          	113
#define FRAME_runs11          	114
#define FRAME_runs12          	115
#define FRAME_salute01        	116
#define FRAME_salute02        	117
#define FRAME_salute03        	118
#define FRAME_salute04        	119
#define FRAME_salute05        	120
#define FRAME_salute06        	121
#define FRAME_salute07        	122
#define FRAME_salute08        	123
#define FRAME_salute09        	124
#define FRAME_salute10        	125
#define FRAME_salute11        	126
#define FRAME_salute12        	127
#define FRAME_stand101        	128
#define FRAME_stand102        	129
#define FRAME_stand103        	130
#define FRAME_stand104        	131
#define FRAME_stand105        	132
#define FRAME_stand106        	133
#define FRAME_stand107        	134
#define FRAME_stand108        	135
#define FRAME_stand109        	136
#define FRAME_stand110        	137
#define FRAME_stand111        	138
#define FRAME_stand112        	139
#define FRAME_stand113        	140
#define FRAME_stand114        	141
#define FRAME_stand115        	142
#define FRAME_stand116        	143
#define FRAME_stand117        	144
#define FRAME_stand118        	145
#define FRAME_stand119        	146
#define FRAME_stand120        	147
#define FRAME_stand121        	148
#define FRAME_stand122        	149
#define FRAME_stand123        	150
#define FRAME_stand124        	151
#define FRAME_stand125        	152
#define FRAME_stand126        	153
#define FRAME_stand127        	154
#define FRAME_stand128        	155
#define FRAME_stand129        	156
#define FRAME_stand130        	157
#define FRAME_stand131        	158
#define FRAME_stand132        	159
#define FRAME_stand133        	160
#define FRAME_stand134        	161
#define FRAME_stand135        	162
#define FRAME_stand136        	163
#define FRAME_stand137        	164
#define FRAME_stand138        	165
#define FRAME_stand139        	166
#define FRAME_stand140        	167
#define FRAME_stand201        	168
#define FRAME_stand202        	169
#define FRAME_stand203        	170
#define FRAME_stand204        	171
#define FRAME_stand205        	172
#define FRAME_stand206        	173
#define FRAME_stand207        	174
#define FRAME_stand208        	175
#define FRAME_stand209        	176
#define FRAME_stand210        	177
#define FRAME_stand211        	178
#define FRAME_stand212        	179
#define FRAME_stand213        	180
#define FRAME_stand214        	181
#define FRAME_stand215        	182
#define FRAME_stand216        	183
#define FRAME_stand217        	184
#define FRAME_stand218        	185
#define FRAME_stand219        	186
#define FRAME_stand220        	187
#define FRAME_stand221        	188
#define FRAME_stand222        	189
#define FRAME_stand223        	190
#define FRAME_swim01          	191
#define FRAME_swim02          	192
#define FRAME_swim03          	193
#define FRAME_swim04          	194
#define FRAME_swim05          	195
#define FRAME_swim06          	196
#define FRAME_swim07          	197
#define FRAME_swim08          	198
#define FRAME_swim09          	199
#define FRAME_swim10          	200
#define FRAME_swim11          	201
#define FRAME_swim12          	202
#define FRAME_sw_atk01        	203
#define FRAME_sw_atk02        	204
#define FRAME_sw_atk03        	205
#define FRAME_sw_atk04        	206
#define FRAME_sw_atk05        	207
#define FRAME_sw_atk06        	208
#define FRAME_sw_pan01        	209
#define FRAME_sw_pan02        	210
#define FRAME_sw_pan03        	211
#define FRAME_sw_pan04        	212
#define FRAME_sw_pan05        	213
#define FRAME_sw_std01        	214
#define FRAME_sw_std02        	215
#define FRAME_sw_std03        	216
#define FRAME_sw_std04        	217
#define FRAME_sw_std05        	218
#define FRAME_sw_std06        	219
#define FRAME_sw_std07        	220
#define FRAME_sw_std08        	221
#define FRAME_sw_std09        	222
#define FRAME_sw_std10        	223
#define FRAME_sw_std11        	224
#define FRAME_sw_std12        	225
#define FRAME_sw_std13        	226
#define FRAME_sw_std14        	227
#define FRAME_sw_std15        	228
#define FRAME_sw_std16        	229
#define FRAME_sw_std17        	230
#define FRAME_sw_std18        	231
#define FRAME_sw_std19        	232
#define FRAME_sw_std20        	233
#define FRAME_taunt01         	234
#define FRAME_taunt02         	235
#define FRAME_taunt03         	236
#define FRAME_taunt04         	237
#define FRAME_taunt05         	238
#define FRAME_taunt06         	239
#define FRAME_taunt07         	240
#define FRAME_taunt08         	241
#define FRAME_taunt09         	242
#define FRAME_taunt10         	243
#define FRAME_taunt11         	244
#define FRAME_taunt12         	245
#define FRAME_taunt13         	246
#define FRAME_taunt14         	247
#define FRAME_taunt15         	248
#define FRAME_taunt16         	249
#define FRAME_taunt17         	250
#define FRAME_walk01          	251
#define FRAME_walk02          	252
#define FRAME_walk03          	253
#define FRAME_walk04          	254
#define FRAME_walk05          	255
#define FRAME_walk06          	256
#define FRAME_walk07          	257
#define FRAME_walk08          	258
#define FRAME_walk09          	259
#define FRAME_walk10          	260
#define FRAME_walk11          	261
#define FRAME_wave01          	262
#define FRAME_wave02          	263
#define FRAME_wave03          	264
#define FRAME_wave04          	265
#define FRAME_wave05          	266
#define FRAME_wave06          	267
#define FRAME_wave07          	268
#define FRAME_wave08          	269
#define FRAME_wave09          	270
#define FRAME_wave10          	271
#define FRAME_wave11          	272
#define FRAME_wave12          	273
#define FRAME_wave13          	274
#define FRAME_wave14          	275
#define FRAME_wave15          	276
#define FRAME_wave16          	277
#define FRAME_wave17          	278
#define FRAME_wave18          	279
#define FRAME_wave19          	280
#define FRAME_wave20          	281
#define FRAME_wave21          	282
#define FRAME_bl_atk01        	283
#define FRAME_bl_atk02        	284
#define FRAME_bl_atk03        	285
#define FRAME_bl_atk04        	286
#define FRAME_bl_atk05        	287
#define FRAME_bl_atk06        	288
#define FRAME_bl_flp01        	289
#define FRAME_bl_flp02        	290
#define FRAME_bl_flp13        	291
#define FRAME_bl_flp14        	292
#define FRAME_bl_flp15        	293
#define FRAME_bl_jmp01        	294
#define FRAME_bl_jmp02        	295
#define FRAME_bl_jmp03        	296
#define FRAME_bl_jmp04        	297
#define FRAME_bl_jmp05        	298
#define FRAME_bl_jmp06        	299
#define FRAME_bl_pn101        	300
#define FRAME_bl_pn102        	301
#define FRAME_bl_pn103        	302
#define FRAME_bl_pn201        	303
#define FRAME_bl_pn202        	304
#define FRAME_bl_pn203        	305
#define FRAME_bl_pn301        	306
#define FRAME_bl_pn302        	307
#define FRAME_bl_pn303        	308
#define FRAME_bl_psh08        	309
#define FRAME_bl_psh09        	310
#define FRAME_bl_run01        	311
#define FRAME_bl_run02        	312
#define FRAME_bl_run03        	313
#define FRAME_bl_run04        	314
#define FRAME_bl_run05        	315
#define FRAME_bl_run06        	316
#define FRAME_bl_run07        	317
#define FRAME_bl_run08        	318
#define FRAME_bl_run09        	319
#define FRAME_bl_run10        	320
#define FRAME_bl_run11        	321
#define FRAME_bl_run12        	322
#define FRAME_bl_rns03        	323
#define FRAME_bl_rns04        	324
#define FRAME_bl_rns05        	325
#define FRAME_bl_rns06        	326
#define FRAME_bl_rns07        	327
#define FRAME_bl_rns08        	328
#define FRAME_bl_rns09        	329
#define FRAME_bl_sal10        	330
#define FRAME_bl_sal11        	331
#define FRAME_bl_sal12        	332
#define FRAME_bl_std01        	333
#define FRAME_bl_std02        	334
#define FRAME_bl_std03        	335
#define FRAME_bl_std04        	336
#define FRAME_bl_std05        	337
#define FRAME_bl_std06        	338
#define FRAME_bl_std07        	339
#define FRAME_bl_std08        	340
#define FRAME_bl_std09        	341
#define FRAME_bl_std10        	342
#define FRAME_bl_std11        	343
#define FRAME_bl_std12        	344
#define FRAME_bl_std13        	345
#define FRAME_bl_std14        	346
#define FRAME_bl_std15        	347
#define FRAME_bl_std16        	348
#define FRAME_bl_std17        	349
#define FRAME_bl_std18        	350
#define FRAME_bl_std19        	351
#define FRAME_bl_std20        	352
#define FRAME_bl_std21        	353
#define FRAME_bl_std22        	354
#define FRAME_bl_std23        	355
#define FRAME_bl_std24        	356
#define FRAME_bl_std25        	357
#define FRAME_bl_std26        	358
#define FRAME_bl_std27        	359
#define FRAME_bl_std28        	360
#define FRAME_bl_std29        	361
#define FRAME_bl_std30        	362
#define FRAME_bl_std31        	363
#define FRAME_bl_std32        	364
#define FRAME_bl_std33        	365
#define FRAME_bl_std34        	366
#define FRAME_bl_std35        	367
#define FRAME_bl_std36        	368
#define FRAME_bl_std37        	369
#define FRAME_bl_std38        	370
#define FRAME_bl_std39        	371
#define FRAME_bl_std40        	372
#define FRAME_bl_swm01        	373
#define FRAME_bl_swm02        	374
#define FRAME_bl_swm03        	375
#define FRAME_bl_swm04        	376
#define FRAME_bl_swm05        	377
#define FRAME_bl_swm06        	378
#define FRAME_bl_swm07        	379
#define FRAME_bl_swm08        	380
#define FRAME_bl_swm09        	381
#define FRAME_bl_swm10        	382
#define FRAME_bl_swm11        	383
#define FRAME_bl_swm12        	384
#define FRAME_bl_swk01        	385
#define FRAME_bl_swk02        	386
#define FRAME_bl_swk03        	387
#define FRAME_bl_swk04        	388
#define FRAME_bl_swk05        	389
#define FRAME_bl_swk06        	390
#define FRAME_bl_swp01        	391
#define FRAME_bl_swp02        	392
#define FRAME_bl_swp03        	393
#define FRAME_bl_swp04        	394
#define FRAME_bl_swp05        	395
#define FRAME_bl_sws01        	396
#define FRAME_bl_sws02        	397
#define FRAME_bl_sws03        	398
#define FRAME_bl_sws04        	399
#define FRAME_bl_sws05        	400
#define FRAME_bl_sws06        	401
#define FRAME_bl_sws07        	402
#define FRAME_bl_sws08        	403
#define FRAME_bl_sws09        	404
#define FRAME_bl_sws10        	405
#define FRAME_bl_sws11        	406
#define FRAME_bl_sws12        	407
#define FRAME_bl_sws13        	408
#define FRAME_bl_sws14        	409
#define FRAME_bl_tau14        	410
#define FRAME_bl_tau15        	411
#define FRAME_bl_tau16        	412
#define FRAME_bl_tau17        	413
#define FRAME_bl_wlk01        	414
#define FRAME_bl_wlk02        	415
#define FRAME_bl_wlk03        	416
#define FRAME_bl_wlk04        	417
#define FRAME_bl_wlk05        	418
#define FRAME_bl_wlk06        	419
#define FRAME_bl_wlk07        	420
#define FRAME_bl_wlk08        	421
#define FRAME_bl_wlk09        	422
#define FRAME_bl_wlk10        	423
#define FRAME_bl_wlk11        	424
#define FRAME_bl_wav19        	425
#define FRAME_bl_wav20        	426
#define FRAME_bl_wav21        	427
#define FRAME_cr_atk01        	428
#define FRAME_cr_atk02        	429
#define FRAME_cr_atk03        	430
#define FRAME_cr_atk04        	431
#define FRAME_cr_atk05        	432
#define FRAME_cr_atk06        	433
#define FRAME_cr_atk07        	434
#define FRAME_cr_atk08        	435
#define FRAME_cr_pan01        	436
#define FRAME_cr_pan02        	437
#define FRAME_cr_pan03        	438
#define FRAME_cr_pan04        	439
#define FRAME_cr_std01        	440
#define FRAME_cr_std02        	441
#define FRAME_cr_std03        	442
#define FRAME_cr_std04        	443
#define FRAME_cr_std05        	444
#define FRAME_cr_std06        	445
#define FRAME_cr_std07        	446
#define FRAME_cr_std08        	447
#define FRAME_cr_wlk01        	448
#define FRAME_cr_wlk02        	449
#define FRAME_cr_wlk03        	450
#define FRAME_cr_wlk04        	451
#define FRAME_cr_wlk05        	452
#define FRAME_cr_wlk06        	453
#define FRAME_cr_wlk07        	454
#define FRAME_crbl_a01        	455
#define FRAME_crbl_a02        	456
#define FRAME_crbl_a03        	457
#define FRAME_crbl_a04        	458
#define FRAME_crbl_a05        	459
#define FRAME_crbl_a06        	460
#define FRAME_crbl_a07        	461
#define FRAME_crbl_p01        	462
#define FRAME_crbl_p02        	463
#define FRAME_crbl_p03        	464
#define FRAME_crbl_p04        	465
#define FRAME_crbl_s01        	466
#define FRAME_crbl_s02        	467
#define FRAME_crbl_s03        	468
#define FRAME_crbl_s04        	469
#define FRAME_crbl_s05        	470
#define FRAME_crbl_s06        	471
#define FRAME_crbl_s07        	472
#define FRAME_crbl_s08        	473
#define FRAME_crbl_w01        	474
#define FRAME_crbl_w02        	475
#define FRAME_crbl_w03        	476
#define FRAME_crbl_w04        	477
#define FRAME_crbl_w05        	478
#define FRAME_crbl_w06        	479
#define FRAME_crbl_w07        	480
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_actor.h' &&
  chmod 0664 'm_actor.h' ||
  $echo 'restore of' 'm_actor.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_actor.h:' 'MD5 check failed'
818483ec282d8e6aa95e7e2514c98b0a  m_actor.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_actor.h'`"
    test 16845 -eq "$shar_count" ||
    $echo 'm_actor.h:' 'original size' '16845,' 'current size' "$shar_count!"
  fi
fi
# ============= m_berserk.c ==============
if test -f 'm_berserk.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_berserk.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_berserk.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_berserk.c' &&
/*
==============================================================================
X
BERSERK
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_berserk.h"
X
X
static int sound_pain;
static int sound_die;
static int sound_idle;
static int sound_punch;
static int sound_sight;
static int sound_search;
X
void berserk_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void berserk_search (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
}
X
X
void berserk_fidget (edict_t *self);
mframe_t berserk_frames_stand [] =
{
X	ai_stand, 0, berserk_fidget,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t berserk_move_stand = {FRAME_stand1, FRAME_stand5, berserk_frames_stand, NULL};
X
void berserk_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &berserk_move_stand;
}
X
mframe_t berserk_frames_stand_fidget [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t berserk_move_stand_fidget = {FRAME_standb1, FRAME_standb20, berserk_frames_stand_fidget, berserk_stand};
X
void berserk_fidget (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		return;
X	if (random() > 0.15)
X		return;
X
X	self->monsterinfo.currentmove = &berserk_move_stand_fidget;
X	gi.sound (self, CHAN_WEAPON, sound_idle, 1, ATTN_IDLE, 0);
}
X
X
mframe_t berserk_frames_walk [] =
{
X	ai_walk, 9.1, NULL,
X	ai_walk, 6.3, NULL,
X	ai_walk, 4.9, NULL,
X	ai_walk, 6.7, NULL,
X	ai_walk, 6.0, NULL,
X	ai_walk, 8.2, NULL,
X	ai_walk, 7.2, NULL,
X	ai_walk, 6.1, NULL,
X	ai_walk, 4.9, NULL,
X	ai_walk, 4.7, NULL,
X	ai_walk, 4.7, NULL,
X	ai_walk, 4.8, NULL
};
mmove_t berserk_move_walk = {FRAME_walkc1, FRAME_walkc11, berserk_frames_walk, NULL};
X
void berserk_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &berserk_move_walk;
}
X
/*
X
X  *****************************
X  SKIPPED THIS FOR NOW!
X  *****************************
X
X   Running -> Arm raised in air
X
void()	berserk_runb1	=[	$r_att1 ,	berserk_runb2	] {ai_run(21);};
void()	berserk_runb2	=[	$r_att2 ,	berserk_runb3	] {ai_run(11);};
void()	berserk_runb3	=[	$r_att3 ,	berserk_runb4	] {ai_run(21);};
void()	berserk_runb4	=[	$r_att4 ,	berserk_runb5	] {ai_run(25);};
void()	berserk_runb5	=[	$r_att5 ,	berserk_runb6	] {ai_run(18);};
void()	berserk_runb6	=[	$r_att6 ,	berserk_runb7	] {ai_run(19);};
// running with arm in air : start loop
void()	berserk_runb7	=[	$r_att7 ,	berserk_runb8	] {ai_run(21);};
void()	berserk_runb8	=[	$r_att8 ,	berserk_runb9	] {ai_run(11);};
void()	berserk_runb9	=[	$r_att9 ,	berserk_runb10	] {ai_run(21);};
void()	berserk_runb10	=[	$r_att10 ,	berserk_runb11	] {ai_run(25);};
void()	berserk_runb11	=[	$r_att11 ,	berserk_runb12	] {ai_run(18);};
void()	berserk_runb12	=[	$r_att12 ,	berserk_runb7	] {ai_run(19);};
// running with arm in air : end loop
*/
X
X
mframe_t berserk_frames_run1 [] =
{
X	ai_run, 21, NULL,
X	ai_run, 11, NULL,
X	ai_run, 21, NULL,
X	// PMM .. from NULL
X	ai_run, 25, monster_done_dodge,
X	ai_run, 18, NULL,
X	ai_run, 19, NULL
};
mmove_t berserk_move_run1 = {FRAME_run1, FRAME_run6, berserk_frames_run1, NULL};
X
void berserk_run (edict_t *self)
{
X	monster_done_dodge (self);
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &berserk_move_stand;
X	else
X		self->monsterinfo.currentmove = &berserk_move_run1;
}
X
X
void berserk_attack_spike (edict_t *self)
{
X	static	vec3_t	aim = {MELEE_DISTANCE, 0, -24};
X	fire_hit (self, aim, (15 + (rand() % 6)), 400);		//	Faster attack -- upwards and backwards
}
X
X
void berserk_swing (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_punch, 1, ATTN_NORM, 0);
}
X
mframe_t berserk_frames_attack_spike [] =
{
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, berserk_swing,
X		ai_charge, 0, berserk_attack_spike,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL
};
mmove_t berserk_move_attack_spike = {FRAME_att_c1, FRAME_att_c8, berserk_frames_attack_spike, berserk_run};
X
X
void berserk_attack_club (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->mins[0], -4);
X	fire_hit (self, aim, (5 + (rand() % 6)), 400);		// Slower attack
}
X
mframe_t berserk_frames_attack_club [] =
{	
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, berserk_swing,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, berserk_attack_club,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t berserk_move_attack_club = {FRAME_att_c9, FRAME_att_c20, berserk_frames_attack_club, berserk_run};
X
X
void berserk_strike (edict_t *self)
{
X	//FIXME play impact sound
}
X
X
mframe_t berserk_frames_attack_strike [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, berserk_swing,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, berserk_strike,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 9.7, NULL,
X	ai_move, 13.6, NULL
};
X	
mmove_t berserk_move_attack_strike = {FRAME_att_c21, FRAME_att_c34, berserk_frames_attack_strike, berserk_run};
X
X
void berserk_melee (edict_t *self)
{
X	monster_done_dodge (self);
X
X	if ((rand() % 2) == 0)
X		self->monsterinfo.currentmove = &berserk_move_attack_spike;
X	else
X		self->monsterinfo.currentmove = &berserk_move_attack_club;
}
X
X
/*
void() 	berserk_atke1	=[	$r_attb1,	berserk_atke2	] {ai_run(9);};
void() 	berserk_atke2	=[	$r_attb2,	berserk_atke3	] {ai_run(6);};
void() 	berserk_atke3	=[	$r_attb3,	berserk_atke4	] {ai_run(18.4);};
void() 	berserk_atke4	=[	$r_attb4,	berserk_atke5	] {ai_run(25);};
void() 	berserk_atke5	=[	$r_attb5,	berserk_atke6	] {ai_run(14);};
void() 	berserk_atke6	=[	$r_attb6,	berserk_atke7	] {ai_run(20);};
void() 	berserk_atke7	=[	$r_attb7,	berserk_atke8	] {ai_run(8.5);};
void() 	berserk_atke8	=[	$r_attb8,	berserk_atke9	] {ai_run(3);};
void() 	berserk_atke9	=[	$r_attb9,	berserk_atke10	] {ai_run(17.5);};
void() 	berserk_atke10	=[	$r_attb10,	berserk_atke11	] {ai_run(17);};
void() 	berserk_atke11	=[	$r_attb11,	berserk_atke12	] {ai_run(9);};
void() 	berserk_atke12	=[	$r_attb12,	berserk_atke13	] {ai_run(25);};
void() 	berserk_atke13	=[	$r_attb13,	berserk_atke14	] {ai_run(3.7);};
void() 	berserk_atke14	=[	$r_attb14,	berserk_atke15	] {ai_run(2.6);};
void() 	berserk_atke15	=[	$r_attb15,	berserk_atke16	] {ai_run(19);};
void() 	berserk_atke16	=[	$r_attb16,	berserk_atke17	] {ai_run(25);};
void() 	berserk_atke17	=[	$r_attb17,	berserk_atke18	] {ai_run(19.6);};
void() 	berserk_atke18	=[	$r_attb18,	berserk_run1	] {ai_run(7.8);};
*/
X
X
mframe_t berserk_frames_pain1 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t berserk_move_pain1 = {FRAME_painc1, FRAME_painc4, berserk_frames_pain1, berserk_run};
X
X
mframe_t berserk_frames_pain2 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t berserk_move_pain2 = {FRAME_painb1, FRAME_painb20, berserk_frames_pain2, berserk_run};
X
void berserk_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X	gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	monster_done_dodge (self);
X
X	if ((damage < 20) || (random() < 0.5))
X		self->monsterinfo.currentmove = &berserk_move_pain1;
X	else
X		self->monsterinfo.currentmove = &berserk_move_pain2;
}
X
X
void berserk_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
X
mframe_t berserk_frames_death1 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
X	
};
mmove_t berserk_move_death1 = {FRAME_death1, FRAME_death13, berserk_frames_death1, berserk_dead};
X
X
mframe_t berserk_frames_death2 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t berserk_move_death2 = {FRAME_deathc1, FRAME_deathc8, berserk_frames_death2, berserk_dead};
X
X
void berserk_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
X	gi.sound (self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	if (damage >= 50)
X		self->monsterinfo.currentmove = &berserk_move_death1;
X	else
X		self->monsterinfo.currentmove = &berserk_move_death2;
}
X
//===========
//PGM
void berserk_jump_now (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 100, forward, self->velocity);
X	VectorMA(self->velocity, 300, up, self->velocity);
}
X
void berserk_jump2_now (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 150, forward, self->velocity);
X	VectorMA(self->velocity, 400, up, self->velocity);
}
X
void berserk_jump_wait_land (edict_t *self)
{
X	if(self->groundentity == NULL)
X	{
X		self->monsterinfo.nextframe = self->s.frame;
X
X		if(monster_jump_finished (self))
X			self->monsterinfo.nextframe = self->s.frame + 1;
X	}
X	else 
X		self->monsterinfo.nextframe = self->s.frame + 1;
}
X
mframe_t berserk_frames_jump [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, berserk_jump_now,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, berserk_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t berserk_move_jump = { FRAME_jump1, FRAME_jump9, berserk_frames_jump, berserk_run };
X
mframe_t berserk_frames_jump2 [] =
{
X	ai_move, -8, NULL,
X	ai_move, -4, NULL,
X	ai_move, -4, NULL,
X	ai_move, 0, berserk_jump_now,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, berserk_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t berserk_move_jump2 = { FRAME_jump1, FRAME_jump9, berserk_frames_jump2, berserk_run };
X
void berserk_jump (edict_t *self)
{
X	if(!self->enemy)
X		return;
X
X	monster_done_dodge (self);
X
X	if(self->enemy->s.origin[2] > self->s.origin[2])
X		self->monsterinfo.currentmove = &berserk_move_jump2;
X	else
X		self->monsterinfo.currentmove = &berserk_move_jump;
}
X
qboolean berserk_blocked (edict_t *self, float dist)
{
X	if(blocked_checkjump (self, dist, 256, 40))
X	{
X		berserk_jump(self);
X		return true;
X	}
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
//PGM
//===========
X
void berserk_sidestep (edict_t *self)
{
X	// if we're jumping, don't dodge
X	if ((self->monsterinfo.currentmove == &berserk_move_jump) ||
X		(self->monsterinfo.currentmove == &berserk_move_jump2))
X	{
X		return;
X	}
X
X	// don't check for attack; the eta should suffice for melee monsters
X
X	if (self->monsterinfo.currentmove != &berserk_move_run1)
X		self->monsterinfo.currentmove = &berserk_move_run1;
}
X
X
/*QUAKED monster_berserk (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_berserk (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	// pre-caches
X	sound_pain  = gi.soundindex ("berserk/berpain2.wav");
X	sound_die   = gi.soundindex ("berserk/berdeth2.wav");
X	sound_idle  = gi.soundindex ("berserk/beridle1.wav");
X	sound_punch = gi.soundindex ("berserk/attack.wav");
X	sound_search = gi.soundindex ("berserk/bersrch1.wav");
X	sound_sight = gi.soundindex ("berserk/sight.wav");
X
X	self->s.modelindex = gi.modelindex("models/monsters/berserk/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X
X	self->health = 240;
X	self->gib_health = -60;
X	self->mass = 250;
X
X	self->pain = berserk_pain;
X	self->die = berserk_die;
X
X	self->monsterinfo.stand = berserk_stand;
X	self->monsterinfo.walk = berserk_walk;
X	self->monsterinfo.run = berserk_run;
X	// pmm
//	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.dodge = M_MonsterDodge;
X	self->monsterinfo.sidestep = berserk_sidestep;
X	// pmm
X	self->monsterinfo.attack = NULL;
X	self->monsterinfo.melee = berserk_melee;
X	self->monsterinfo.sight = berserk_sight;
X	self->monsterinfo.search = berserk_search;
X	self->monsterinfo.blocked = berserk_blocked;		//PGM
X
X	self->monsterinfo.currentmove = &berserk_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	gi.linkentity (self);
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_berserk.c' &&
  chmod 0664 'm_berserk.c' ||
  $echo 'restore of' 'm_berserk.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_berserk.c:' 'MD5 check failed'
adb59435d914acb4bf1ae21b2da51e32  m_berserk.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_berserk.c'`"
    test 13895 -eq "$shar_count" ||
    $echo 'm_berserk.c:' 'original size' '13895,' 'current size' "$shar_count!"
  fi
fi
# ============= m_berserk.h ==============
if test -f 'm_berserk.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_berserk.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_berserk.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_berserk.h' &&
// G:\quake2\baseq2\models/monsters/berserk
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_stand1          	0
#define FRAME_stand2          	1
#define FRAME_stand3          	2
#define FRAME_stand4          	3
#define FRAME_stand5          	4
#define FRAME_standb1         	5
#define FRAME_standb2         	6
#define FRAME_standb3         	7
#define FRAME_standb4         	8
#define FRAME_standb5         	9
#define FRAME_standb6         	10
#define FRAME_standb7         	11
#define FRAME_standb8         	12
#define FRAME_standb9         	13
#define FRAME_standb10        	14
#define FRAME_standb11        	15
#define FRAME_standb12        	16
#define FRAME_standb13        	17
#define FRAME_standb14        	18
#define FRAME_standb15        	19
#define FRAME_standb16        	20
#define FRAME_standb17        	21
#define FRAME_standb18        	22
#define FRAME_standb19        	23
#define FRAME_standb20        	24
#define FRAME_walkc1          	25
#define FRAME_walkc2          	26
#define FRAME_walkc3          	27
#define FRAME_walkc4          	28
#define FRAME_walkc5          	29
#define FRAME_walkc6          	30
#define FRAME_walkc7          	31
#define FRAME_walkc8          	32
#define FRAME_walkc9          	33
#define FRAME_walkc10         	34
#define FRAME_walkc11         	35
#define FRAME_run1            	36
#define FRAME_run2            	37
#define FRAME_run3            	38
#define FRAME_run4            	39
#define FRAME_run5            	40
#define FRAME_run6            	41
#define FRAME_att_a1          	42
#define FRAME_att_a2          	43
#define FRAME_att_a3          	44
#define FRAME_att_a4          	45
#define FRAME_att_a5          	46
#define FRAME_att_a6          	47
#define FRAME_att_a7          	48
#define FRAME_att_a8          	49
#define FRAME_att_a9          	50
#define FRAME_att_a10         	51
#define FRAME_att_a11         	52
#define FRAME_att_a12         	53
#define FRAME_att_a13         	54
#define FRAME_att_b1          	55
#define FRAME_att_b2          	56
#define FRAME_att_b3          	57
#define FRAME_att_b4          	58
#define FRAME_att_b5          	59
#define FRAME_att_b6          	60
#define FRAME_att_b7          	61
#define FRAME_att_b8          	62
#define FRAME_att_b9          	63
#define FRAME_att_b10         	64
#define FRAME_att_b11         	65
#define FRAME_att_b12         	66
#define FRAME_att_b13         	67
#define FRAME_att_b14         	68
#define FRAME_att_b15         	69
#define FRAME_att_b16         	70
#define FRAME_att_b17         	71
#define FRAME_att_b18         	72
#define FRAME_att_b19         	73
#define FRAME_att_b20         	74
#define FRAME_att_b21         	75
#define FRAME_att_c1          	76
#define FRAME_att_c2          	77
#define FRAME_att_c3          	78
#define FRAME_att_c4          	79
#define FRAME_att_c5          	80
#define FRAME_att_c6          	81
#define FRAME_att_c7          	82
#define FRAME_att_c8          	83
#define FRAME_att_c9          	84
#define FRAME_att_c10         	85
#define FRAME_att_c11         	86
#define FRAME_att_c12         	87
#define FRAME_att_c13         	88
#define FRAME_att_c14         	89
#define FRAME_att_c15         	90
#define FRAME_att_c16         	91
#define FRAME_att_c17         	92
#define FRAME_att_c18         	93
#define FRAME_att_c19         	94
#define FRAME_att_c20         	95
#define FRAME_att_c21         	96
#define FRAME_att_c22         	97
#define FRAME_att_c23         	98
#define FRAME_att_c24         	99
#define FRAME_att_c25         	100
#define FRAME_att_c26         	101
#define FRAME_att_c27         	102
#define FRAME_att_c28         	103
#define FRAME_att_c29         	104
#define FRAME_att_c30         	105
#define FRAME_att_c31         	106
#define FRAME_att_c32         	107
#define FRAME_att_c33         	108
#define FRAME_att_c34         	109
#define FRAME_r_att1          	110
#define FRAME_r_att2          	111
#define FRAME_r_att3          	112
#define FRAME_r_att4          	113
#define FRAME_r_att5          	114
#define FRAME_r_att6          	115
#define FRAME_r_att7          	116
#define FRAME_r_att8          	117
#define FRAME_r_att9          	118
#define FRAME_r_att10         	119
#define FRAME_r_att11         	120
#define FRAME_r_att12         	121
#define FRAME_r_att13         	122
#define FRAME_r_att14         	123
#define FRAME_r_att15         	124
#define FRAME_r_att16         	125
#define FRAME_r_att17         	126
#define FRAME_r_att18         	127
#define FRAME_r_attb1         	128
#define FRAME_r_attb2         	129
#define FRAME_r_attb3         	130
#define FRAME_r_attb4         	131
#define FRAME_r_attb5         	132
#define FRAME_r_attb6         	133
#define FRAME_r_attb7         	134
#define FRAME_r_attb8         	135
#define FRAME_r_attb9         	136
#define FRAME_r_attb10        	137
#define FRAME_r_attb11        	138
#define FRAME_r_attb12        	139
#define FRAME_r_attb13        	140
#define FRAME_r_attb14        	141
#define FRAME_r_attb15        	142
#define FRAME_r_attb16        	143
#define FRAME_r_attb17        	144
#define FRAME_r_attb18        	145
#define FRAME_slam1           	146
#define FRAME_slam2           	147
#define FRAME_slam3           	148
#define FRAME_slam4           	149
#define FRAME_slam5           	150
#define FRAME_slam6           	151
#define FRAME_slam7           	152
#define FRAME_slam8           	153
#define FRAME_slam9           	154
#define FRAME_slam10          	155
#define FRAME_slam11          	156
#define FRAME_slam12          	157
#define FRAME_slam13          	158
#define FRAME_slam14          	159
#define FRAME_slam15          	160
#define FRAME_slam16          	161
#define FRAME_slam17          	162
#define FRAME_slam18          	163
#define FRAME_slam19          	164
#define FRAME_slam20          	165
#define FRAME_slam21          	166
#define FRAME_slam22          	167
#define FRAME_slam23          	168
#define FRAME_duck1           	169
#define FRAME_duck2           	170
#define FRAME_duck3           	171
#define FRAME_duck4           	172
#define FRAME_duck5           	173
#define FRAME_duck6           	174
#define FRAME_duck7           	175
#define FRAME_duck8           	176
#define FRAME_duck9           	177
#define FRAME_duck10          	178
#define FRAME_fall1           	179
#define FRAME_fall2           	180
#define FRAME_fall3           	181
#define FRAME_fall4           	182
#define FRAME_fall5           	183
#define FRAME_fall6           	184
#define FRAME_fall7           	185
#define FRAME_fall8           	186
#define FRAME_fall9           	187
#define FRAME_fall10          	188
#define FRAME_fall11          	189
#define FRAME_fall12          	190
#define FRAME_fall13          	191
#define FRAME_fall14          	192
#define FRAME_fall15          	193
#define FRAME_fall16          	194
#define FRAME_fall17          	195
#define FRAME_fall18          	196
#define FRAME_fall19          	197
#define FRAME_fall20          	198
#define FRAME_painc1          	199
#define FRAME_painc2          	200
#define FRAME_painc3          	201
#define FRAME_painc4          	202
#define FRAME_painb1          	203
#define FRAME_painb2          	204
#define FRAME_painb3          	205
#define FRAME_painb4          	206
#define FRAME_painb5          	207
#define FRAME_painb6          	208
#define FRAME_painb7          	209
#define FRAME_painb8          	210
#define FRAME_painb9          	211
#define FRAME_painb10         	212
#define FRAME_painb11         	213
#define FRAME_painb12         	214
#define FRAME_painb13         	215
#define FRAME_painb14         	216
#define FRAME_painb15         	217
#define FRAME_painb16         	218
#define FRAME_painb17         	219
#define FRAME_painb18         	220
#define FRAME_painb19         	221
#define FRAME_painb20         	222
#define FRAME_death1          	223
#define FRAME_death2          	224
#define FRAME_death3          	225
#define FRAME_death4          	226
#define FRAME_death5          	227
#define FRAME_death6          	228
#define FRAME_death7          	229
#define FRAME_death8          	230
#define FRAME_death9          	231
#define FRAME_death10         	232
#define FRAME_death11         	233
#define FRAME_death12         	234
#define FRAME_death13         	235
#define FRAME_deathc1         	236
#define FRAME_deathc2         	237
#define FRAME_deathc3         	238
#define FRAME_deathc4         	239
#define FRAME_deathc5         	240
#define FRAME_deathc6         	241
#define FRAME_deathc7         	242
#define FRAME_deathc8         	243
X
//PGM
#define FRAME_jump1				244
#define FRAME_jump2				245
#define FRAME_jump3				246
#define FRAME_jump4				247
#define FRAME_jump5				248
#define FRAME_jump6				249
#define FRAME_jump7				250
#define FRAME_jump8				251
#define FRAME_jump9				252
//PGM
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_berserk.h' &&
  chmod 0664 'm_berserk.h' ||
  $echo 'restore of' 'm_berserk.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_berserk.h:' 'MD5 check failed'
38934b665a3fd3d770e6adde79c47d3f  m_berserk.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_berserk.h'`"
    test 8814 -eq "$shar_count" ||
    $echo 'm_berserk.h:' 'original size' '8814,' 'current size' "$shar_count!"
  fi
fi
# ============= m_boss2.c ==============
if test -f 'm_boss2.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_boss2.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_boss2.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_boss2.c' &&
/*
==============================================================================
X
boss2
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_boss2.h"
X
void BossExplode (edict_t *self);
X
qboolean infront (edict_t *self, edict_t *other);
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_pain3;
static int	sound_death;
static int	sound_search1;
X
void boss2_search (edict_t *self)
{
X	if (random() < 0.5)
X		gi.sound (self, CHAN_VOICE, sound_search1, 1, ATTN_NONE, 0);
}
X
void boss2_run (edict_t *self);
void boss2_stand (edict_t *self);
void boss2_dead (edict_t *self);
void boss2_attack (edict_t *self);
void boss2_attack_mg (edict_t *self);
void boss2_reattack_mg (edict_t *self);
void boss2_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
X
#define BOSS2_ROCKET_SPEED	750
X
void Boss2PredictiveRocket  (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X	float	time, dist;
X
gi.dprintf("predictive fire\n");
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X
//1
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_1], forward, right, start);
X		VectorSubtract(self->enemy->s.origin, start, dir);
//		dir[2] += self->enemy->viewheight;
X		dist = VectorLength(dir);
X		time = dist / BOSS2_ROCKET_SPEED;
X		VectorMA(self->enemy->s.origin, time-0.3, self->enemy->velocity, vec);
X
//	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, BOSS2_ROCKET_SPEED, MZ2_BOSS2_ROCKET_1);
X
//2
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_2], forward, right, start);
X		VectorSubtract(self->enemy->s.origin, start, dir);
//		dir[2] += self->enemy->viewheight;
X		dist = VectorLength(dir);
X		time = dist / BOSS2_ROCKET_SPEED;
X		VectorMA(self->enemy->s.origin, time-0.15, self->enemy->velocity, vec);
X
//	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, BOSS2_ROCKET_SPEED, MZ2_BOSS2_ROCKET_2);
X
//3
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_3], forward, right, start);
X		VectorSubtract(self->enemy->s.origin, start, dir);
//		dir[2] += self->enemy->viewheight;
X		dist = VectorLength(dir);
X		time = dist / BOSS2_ROCKET_SPEED;
X		VectorMA(self->enemy->s.origin, time, self->enemy->velocity, vec);
X
//	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, BOSS2_ROCKET_SPEED, MZ2_BOSS2_ROCKET_3);
X
//4
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_4], forward, right, start);
X		VectorSubtract(self->enemy->s.origin, start, dir);
//		dir[2] += self->enemy->viewheight;
X		dist = VectorLength(dir);
X		time = dist / BOSS2_ROCKET_SPEED;
X		VectorMA(self->enemy->s.origin, time+0.15, self->enemy->velocity, vec);
X
//	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, BOSS2_ROCKET_SPEED, MZ2_BOSS2_ROCKET_4);
}	
X
void Boss2Rocket (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X
X	if(self->enemy)
X	{
X		if(self->enemy->client && random() < 0.9)
X		{
X			Boss2PredictiveRocket(self);
X			return;
X		}
X	}
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X
//1
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_1], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	vec[2] -= 15;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, 0.4, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_BOSS2_ROCKET_1);
X
//2
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_2], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, 0.025, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_BOSS2_ROCKET_2);
X
//3
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_3], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, -0.025, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_BOSS2_ROCKET_3);
X
//4
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_4], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	vec[2] -= 15;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, -0.4, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_BOSS2_ROCKET_4);
X
//5
//	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_4], forward, right, start);
//	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
//	VectorSubtract (vec, start, dir);
//	VectorNormalize (dir);
//	monster_fire_rocket (self, start, dir, 50, 500, MZ2_BOSS2_ROCKET_2);
}	
X
void boss2_firebullet_right (edict_t *self)
{
X	vec3_t	forward, right, target;
X	vec3_t	start;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_MACHINEGUN_R1], forward, right, start);
X
//	VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X	VectorMA (self->enemy->s.origin, 0.2, self->enemy->velocity, target);
X	target[2] += self->enemy->viewheight;
X	VectorSubtract (target, start, forward);
X	VectorNormalize (forward);
X
X	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD*3, DEFAULT_BULLET_VSPREAD, MZ2_BOSS2_MACHINEGUN_R1);
//	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_BOSS2_MACHINEGUN_R1);
}	
X
void boss2_firebullet_left (edict_t *self)
{
X	vec3_t	forward, right, target;
X	vec3_t	start;
X	
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_MACHINEGUN_L1], forward, right, start);
X
//	VectorMA (self->enemy->s.origin, 0.2, self->enemy->velocity, target);
X	VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X
X	target[2] += self->enemy->viewheight;
X	VectorSubtract (target, start, forward);
X	VectorNormalize (forward);
X
X	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD*3, DEFAULT_BULLET_VSPREAD, MZ2_BOSS2_MACHINEGUN_L1);
//	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_BOSS2_MACHINEGUN_L1);
}	
X
void Boss2MachineGun (edict_t *self)
{
/*	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X	int		flash_number;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X
X	flash_number = MZ2_BOSS2_MACHINEGUN_1 + (self->s.frame - FRAME_attack10);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, vec);
X	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	monster_fire_bullet (self, start, dir, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
*/
X	boss2_firebullet_left(self);
X	boss2_firebullet_right(self);
}	
X
X
mframe_t boss2_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	boss2_move_stand = {FRAME_stand30, FRAME_stand50, boss2_frames_stand, NULL};
X
mframe_t boss2_frames_fidget [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t boss2_move_fidget = {FRAME_stand1, FRAME_stand30, boss2_frames_fidget, NULL};
X
mframe_t boss2_frames_walk [] =
{
X	/* PMM - normally, this is all 8's .. I upped it */
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL,
X	ai_walk,	10,	NULL
};
mmove_t boss2_move_walk = {FRAME_walk1, FRAME_walk20, boss2_frames_walk, NULL};
X
X
mframe_t boss2_frames_run [] =
{
X	/* PMM - normally, this is all 8's .. I upped it */
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL
};
mmove_t boss2_move_run = {FRAME_walk1, FRAME_walk20, boss2_frames_run, NULL};
X
mframe_t boss2_frames_attack_pre_mg [] =
{
X	/* used to be all 1's .. what a slow guy */
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	boss2_attack_mg
};
mmove_t boss2_move_attack_pre_mg = {FRAME_attack1, FRAME_attack9, boss2_frames_attack_pre_mg, NULL};
X
X
// Loop this
mframe_t boss2_frames_attack_mg [] =
{
X	/* used to be all 1's .. what a slow guy */
X	ai_charge,	2,	Boss2MachineGun,
X	ai_charge,	2,	Boss2MachineGun,
X	ai_charge,	2,	Boss2MachineGun,
X	ai_charge,	2,	Boss2MachineGun,
X	ai_charge,	2,	Boss2MachineGun,
X	ai_charge,	2,	boss2_reattack_mg
};
mmove_t boss2_move_attack_mg = {FRAME_attack10, FRAME_attack15, boss2_frames_attack_mg, NULL};
X
mframe_t boss2_frames_attack_post_mg [] =
{
X	/* used to be all 1's .. what a slow guy */
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL
};
mmove_t boss2_move_attack_post_mg = {FRAME_attack16, FRAME_attack19, boss2_frames_attack_post_mg, boss2_run};
X
mframe_t boss2_frames_attack_rocket [] =
{
X	/* used to be all 1's .. except the Boss2Rocket frame, which was -20(!) */
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_move,	-5,	Boss2Rocket,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	2,	NULL
};
mmove_t boss2_move_attack_rocket = {FRAME_attack20, FRAME_attack40, boss2_frames_attack_rocket, boss2_run};
X
mframe_t boss2_frames_pain_heavy [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t boss2_move_pain_heavy = {FRAME_pain2, FRAME_pain19, boss2_frames_pain_heavy, boss2_run};
X
mframe_t boss2_frames_pain_light [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t boss2_move_pain_light = {FRAME_pain20, FRAME_pain23, boss2_frames_pain_light, boss2_run};
X
mframe_t boss2_frames_death [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	BossExplode
};
mmove_t boss2_move_death = {FRAME_death2, FRAME_death50, boss2_frames_death, boss2_dead};
X
void boss2_stand (edict_t *self)
{
X		self->monsterinfo.currentmove = &boss2_move_stand;
}
X
void boss2_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &boss2_move_stand;
X	else
X		self->monsterinfo.currentmove = &boss2_move_run;
}
X
void boss2_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &boss2_move_walk;
}
X
void boss2_attack (edict_t *self)
{
X	vec3_t	vec;
X	float	range;
X
X	VectorSubtract (self->enemy->s.origin, self->s.origin, vec);
X	range = VectorLength (vec);
X	
X	if (range <= 125)
X	{
X		self->monsterinfo.currentmove = &boss2_move_attack_pre_mg;
X	}
X	else 
X	{
X		if (random() <= 0.6)
X			self->monsterinfo.currentmove = &boss2_move_attack_pre_mg;
X		else
X			self->monsterinfo.currentmove = &boss2_move_attack_rocket;
X	}
}
X
void boss2_attack_mg (edict_t *self)
{
X	self->monsterinfo.currentmove = &boss2_move_attack_mg;
}
X
void boss2_reattack_mg (edict_t *self)
{
X	if ( infront(self, self->enemy) )
X		if (random() <= 0.7)
X			self->monsterinfo.currentmove = &boss2_move_attack_mg;
X		else
X			self->monsterinfo.currentmove = &boss2_move_attack_post_mg;
X	else
X		self->monsterinfo.currentmove = &boss2_move_attack_post_mg;
}
X
X
void boss2_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
// American wanted these at no attenuation
X	if (damage < 10)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain3, 1, ATTN_NONE, 0);
X		self->monsterinfo.currentmove = &boss2_move_pain_light;
X	}
X	else if (damage < 30)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NONE, 0);
X		self->monsterinfo.currentmove = &boss2_move_pain_light;
X	}
X	else 
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NONE, 0);
X		self->monsterinfo.currentmove = &boss2_move_pain_heavy;
X	}
}
X
void boss2_dead (edict_t *self)
{
X	VectorSet (self->mins, -56, -56, 0);
X	VectorSet (self->maxs, 56, 56, 80);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
void boss2_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NONE, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_NO;
X	self->count = 0;
X	self->monsterinfo.currentmove = &boss2_move_death;
#if 0
X	int		n;
X
X	self->s.sound = 0;
X	// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->monsterinfo.currentmove = &boss2_move_death;
#endif
}
X
qboolean Boss2_CheckAttack (edict_t *self)
{
X	vec3_t	spot1, spot2;
X	vec3_t	temp;
X	float	chance;
X	trace_t	tr;
X	qboolean	enemy_infront;
X	int			enemy_range;
X	float		enemy_yaw;
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X		{	
X			// PGM - we want them to go ahead and shoot at info_notnulls if they can.
X			if(self->enemy->solid != SOLID_NOT || tr.fraction < 1.0)		//PGM
X				return false;
X		}
X	}
X	
X	enemy_infront = infront(self, self->enemy);
X	enemy_range = range(self, self->enemy);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw(temp);
X
X	self->ideal_yaw = enemy_yaw;
X
X
X	// melee attack
X	if (enemy_range == RANGE_MELEE)
X	{
X		if (self->monsterinfo.melee)
X			self->monsterinfo.attack_state = AS_MELEE;
X		else
X			self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X	
// missile attack
X	if (!self->monsterinfo.attack)
X		return false;
X		
X	if (level.time < self->monsterinfo.attack_finished)
X		return false;
X		
X	if (enemy_range == RANGE_FAR)
X		return false;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MELEE)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_NEAR)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_MID)
X	{
X		chance = 0.8;
X	}
X	else
X	{
X		return false;
X	}
X
X	// PGM - go ahead and shoot every time if it's a info_notnull
X	if ((random () < chance) || (self->enemy->solid == SOLID_NOT))
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
X		self->monsterinfo.attack_finished = level.time + 2*random();
X		return true;
X	}
X
X	if (self->flags & FL_FLY)
X	{
X		if (random() < 0.3)
X			self->monsterinfo.attack_state = AS_SLIDING;
X		else
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
X
X	return false;
}
X
X
X
/*QUAKED monster_boss2 (1 .5 0) (-56 -56 0) (56 56 80) Ambush Trigger_Spawn Sight
*/
void SP_monster_boss2 (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("bosshovr/bhvpain1.wav");
X	sound_pain2 = gi.soundindex ("bosshovr/bhvpain2.wav");
X	sound_pain3 = gi.soundindex ("bosshovr/bhvpain3.wav");
X	sound_death = gi.soundindex ("bosshovr/bhvdeth1.wav");
X	sound_search1 = gi.soundindex ("bosshovr/bhvunqv1.wav");
X
X	self->s.sound = gi.soundindex ("bosshovr/bhvengn1.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/boss2/tris.md2");
X	VectorSet (self->mins, -56, -56, 0);
X	VectorSet (self->maxs, 56, 56, 80);
X
X	self->health = 2000;
X	self->gib_health = -200;
X	self->mass = 1000;
X
X	self->yaw_speed = 50;
X
X	self->flags |= FL_IMMUNE_LASER;
X
X	self->pain = boss2_pain;
X	self->die = boss2_die;
X
X	self->monsterinfo.stand = boss2_stand;
X	self->monsterinfo.walk = boss2_walk;
X	self->monsterinfo.run = boss2_run;
X	self->monsterinfo.attack = boss2_attack;
X	self->monsterinfo.search = boss2_search;
X	self->monsterinfo.checkattack = Boss2_CheckAttack;
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &boss2_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	flymonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_boss2.c' &&
  chmod 0664 'm_boss2.c' ||
  $echo 'restore of' 'm_boss2.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_boss2.c:' 'MD5 check failed'
43db6d630b0b5ab5972837aa3d2a2220  m_boss2.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_boss2.c'`"
    test 20057 -eq "$shar_count" ||
    $echo 'm_boss2.c:' 'original size' '20057,' 'current size' "$shar_count!"
  fi
fi
# ============= m_boss2.h ==============
if test -f 'm_boss2.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_boss2.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_boss2.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_boss2.h' &&
// G:\quake2\baseq2\models/monsters/boss2
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_stand30         	0
#define FRAME_stand31         	1
#define FRAME_stand32         	2
#define FRAME_stand33         	3
#define FRAME_stand34         	4
#define FRAME_stand35         	5
#define FRAME_stand36         	6
#define FRAME_stand37         	7
#define FRAME_stand38         	8
#define FRAME_stand39         	9
#define FRAME_stand40         	10
#define FRAME_stand41         	11
#define FRAME_stand42         	12
#define FRAME_stand43         	13
#define FRAME_stand44         	14
#define FRAME_stand45         	15
#define FRAME_stand46         	16
#define FRAME_stand47         	17
#define FRAME_stand48         	18
#define FRAME_stand49         	19
#define FRAME_stand50         	20
#define FRAME_stand1          	21
#define FRAME_stand2          	22
#define FRAME_stand3          	23
#define FRAME_stand4          	24
#define FRAME_stand5          	25
#define FRAME_stand6          	26
#define FRAME_stand7          	27
#define FRAME_stand8          	28
#define FRAME_stand9          	29
#define FRAME_stand10         	30
#define FRAME_stand11         	31
#define FRAME_stand12         	32
#define FRAME_stand13         	33
#define FRAME_stand14         	34
#define FRAME_stand15         	35
#define FRAME_stand16         	36
#define FRAME_stand17         	37
#define FRAME_stand18         	38
#define FRAME_stand19         	39
#define FRAME_stand20         	40
#define FRAME_stand21         	41
#define FRAME_stand22         	42
#define FRAME_stand23         	43
#define FRAME_stand24         	44
#define FRAME_stand25         	45
#define FRAME_stand26         	46
#define FRAME_stand27         	47
#define FRAME_stand28         	48
#define FRAME_stand29         	49
#define FRAME_walk1           	50
#define FRAME_walk2           	51
#define FRAME_walk3           	52
#define FRAME_walk4           	53
#define FRAME_walk5           	54
#define FRAME_walk6           	55
#define FRAME_walk7           	56
#define FRAME_walk8           	57
#define FRAME_walk9           	58
#define FRAME_walk10          	59
#define FRAME_walk11          	60
#define FRAME_walk12          	61
#define FRAME_walk13          	62
#define FRAME_walk14          	63
#define FRAME_walk15          	64
#define FRAME_walk16          	65
#define FRAME_walk17          	66
#define FRAME_walk18          	67
#define FRAME_walk19          	68
#define FRAME_walk20          	69
#define FRAME_attack1         	70
#define FRAME_attack2         	71
#define FRAME_attack3         	72
#define FRAME_attack4         	73
#define FRAME_attack5         	74
#define FRAME_attack6         	75
#define FRAME_attack7         	76
#define FRAME_attack8         	77
#define FRAME_attack9         	78
#define FRAME_attack10        	79
#define FRAME_attack11        	80
#define FRAME_attack12        	81
#define FRAME_attack13        	82
#define FRAME_attack14        	83
#define FRAME_attack15        	84
#define FRAME_attack16        	85
#define FRAME_attack17        	86
#define FRAME_attack18        	87
#define FRAME_attack19        	88
#define FRAME_attack20        	89
#define FRAME_attack21        	90
#define FRAME_attack22        	91
#define FRAME_attack23        	92
#define FRAME_attack24        	93
#define FRAME_attack25        	94
#define FRAME_attack26        	95
#define FRAME_attack27        	96
#define FRAME_attack28        	97
#define FRAME_attack29        	98
#define FRAME_attack30        	99
#define FRAME_attack31        	100
#define FRAME_attack32        	101
#define FRAME_attack33        	102
#define FRAME_attack34        	103
#define FRAME_attack35        	104
#define FRAME_attack36        	105
#define FRAME_attack37        	106
#define FRAME_attack38        	107
#define FRAME_attack39        	108
#define FRAME_attack40        	109
#define FRAME_pain2           	110
#define FRAME_pain3           	111
#define FRAME_pain4           	112
#define FRAME_pain5           	113
#define FRAME_pain6           	114
#define FRAME_pain7           	115
#define FRAME_pain8           	116
#define FRAME_pain9           	117
#define FRAME_pain10          	118
#define FRAME_pain11          	119
#define FRAME_pain12          	120
#define FRAME_pain13          	121
#define FRAME_pain14          	122
#define FRAME_pain15          	123
#define FRAME_pain16          	124
#define FRAME_pain17          	125
#define FRAME_pain18          	126
#define FRAME_pain19          	127
#define FRAME_pain20          	128
#define FRAME_pain21          	129
#define FRAME_pain22          	130
#define FRAME_pain23          	131
#define FRAME_death2          	132
#define FRAME_death3          	133
#define FRAME_death4          	134
#define FRAME_death5          	135
#define FRAME_death6          	136
#define FRAME_death7          	137
#define FRAME_death8          	138
#define FRAME_death9          	139
#define FRAME_death10         	140
#define FRAME_death11         	141
#define FRAME_death12         	142
#define FRAME_death13         	143
#define FRAME_death14         	144
#define FRAME_death15         	145
#define FRAME_death16         	146
#define FRAME_death17         	147
#define FRAME_death18         	148
#define FRAME_death19         	149
#define FRAME_death20         	150
#define FRAME_death21         	151
#define FRAME_death22         	152
#define FRAME_death23         	153
#define FRAME_death24         	154
#define FRAME_death25         	155
#define FRAME_death26         	156
#define FRAME_death27         	157
#define FRAME_death28         	158
#define FRAME_death29         	159
#define FRAME_death30         	160
#define FRAME_death31         	161
#define FRAME_death32         	162
#define FRAME_death33         	163
#define FRAME_death34         	164
#define FRAME_death35         	165
#define FRAME_death36         	166
#define FRAME_death37         	167
#define FRAME_death38         	168
#define FRAME_death39         	169
#define FRAME_death40         	170
#define FRAME_death41         	171
#define FRAME_death42         	172
#define FRAME_death43         	173
#define FRAME_death44         	174
#define FRAME_death45         	175
#define FRAME_death46         	176
#define FRAME_death47         	177
#define FRAME_death48         	178
#define FRAME_death49         	179
#define FRAME_death50         	180
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_boss2.h' &&
  chmod 0664 'm_boss2.h' ||
  $echo 'restore of' 'm_boss2.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_boss2.h:' 'MD5 check failed'
ace391e182dd9417c9bcdade63b067cc  m_boss2.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_boss2.h'`"
    test 6351 -eq "$shar_count" ||
    $echo 'm_boss2.h:' 'original size' '6351,' 'current size' "$shar_count!"
  fi
fi
# ============= m_boss3.c ==============
if test -f 'm_boss3.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_boss3.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_boss3.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_boss3.c' &&
/*
==============================================================================
X
boss3
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_boss32.h"
X
void Use_Boss3 (edict_t *ent, edict_t *other, edict_t *activator)
{
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_BOSSTPORT);
X	gi.WritePosition (ent->s.origin);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X	G_FreeEdict (ent);
}
X
void Think_Boss3Stand (edict_t *ent)
{
X	if (ent->s.frame == FRAME_stand260)
X		ent->s.frame = FRAME_stand201;
X	else
X		ent->s.frame++;
X	ent->nextthink = level.time + FRAMETIME;
}
X
/*QUAKED monster_boss3_stand (1 .5 0) (-32 -32 0) (32 32 90)
X
Just stands and cycles in one place until targeted, then teleports away.
*/
void SP_monster_boss3_stand (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->model = "models/monsters/boss3/rider/tris.md2";
X	self->s.modelindex = gi.modelindex (self->model);
X	self->s.frame = FRAME_stand201;
X
X	gi.soundindex ("misc/bigtele.wav");
X
X	VectorSet (self->mins, -32, -32, 0);
X	VectorSet (self->maxs, 32, 32, 90);
X
X	self->use = Use_Boss3;
X	self->think = Think_Boss3Stand;
X	self->nextthink = level.time + FRAMETIME;
X	gi.linkentity (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_boss3.c' &&
  chmod 0664 'm_boss3.c' ||
  $echo 'restore of' 'm_boss3.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_boss3.c:' 'MD5 check failed'
6a6f74c9206a9a74bf0cd775ca0e6e70  m_boss3.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_boss3.c'`"
    test 1316 -eq "$shar_count" ||
    $echo 'm_boss3.c:' 'original size' '1316,' 'current size' "$shar_count!"
  fi
fi
# ============= m_boss31.c ==============
if test -f 'm_boss31.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_boss31.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_boss31.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_boss31.c' &&
/*
==============================================================================
X
jorg
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_boss31.h"
X
extern SP_monster_makron (edict_t *self);
qboolean visible (edict_t *self, edict_t *other);
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_pain3;
static int	sound_idle;
static int	sound_death;
static int	sound_search1;
static int	sound_search2;
static int	sound_search3;
static int	sound_attack1;
static int	sound_attack2;
static int	sound_firegun;
static int	sound_step_left;
static int	sound_step_right;
static int	sound_death_hit;
X
void BossExplode (edict_t *self);
void MakronToss (edict_t *self);
X
X
void jorg_search (edict_t *self)
{
X	float r;
X
X	r = random();
X
X	if (r <= 0.3)
X		gi.sound (self, CHAN_VOICE, sound_search1, 1, ATTN_NORM, 0);
X	else if (r <= 0.6)
X		gi.sound (self, CHAN_VOICE, sound_search2, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_search3, 1, ATTN_NORM, 0);
}
X
X
void jorg_dead (edict_t *self);
void jorgBFG (edict_t *self);
void jorgMachineGun (edict_t *self);
void jorg_firebullet (edict_t *self);
void jorg_reattack1(edict_t *self);
void jorg_attack1(edict_t *self);
void jorg_idle(edict_t *self);
void jorg_step_left(edict_t *self);
void jorg_step_right(edict_t *self);
void jorg_death_hit(edict_t *self);
X
//
// stand
//
X
mframe_t jorg_frames_stand []=
{
X	ai_stand, 0, jorg_idle,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 10
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 20
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 30
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 19, NULL,
X	ai_stand, 11, jorg_step_left,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 6, NULL,
X	ai_stand, 9, jorg_step_right,
X	ai_stand, 0, NULL,		// 40
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, -2, NULL,
X	ai_stand, -17, jorg_step_left,
X	ai_stand, 0, NULL,
X	ai_stand, -12, NULL,		// 50
X	ai_stand, -14, jorg_step_right	// 51
};
mmove_t	jorg_move_stand = {FRAME_stand01, FRAME_stand51, jorg_frames_stand, NULL};
X
void jorg_idle (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_NORM,0);
}
X
void jorg_death_hit (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_death_hit, 1, ATTN_NORM,0);
}
X
X
void jorg_step_left (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_step_left, 1, ATTN_NORM,0);
}
X
void jorg_step_right (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_step_right, 1, ATTN_NORM,0);
}
X
X
void jorg_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &jorg_move_stand;
}
X
mframe_t jorg_frames_run [] =
{
X	ai_run, 17,	jorg_step_left,
X	ai_run, 0,	NULL,
X	ai_run, 0,	NULL,
X	ai_run, 0,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 8,	NULL,
X	ai_run, 10,	NULL,
X	ai_run, 33,	jorg_step_right,
X	ai_run, 0,	NULL,
X	ai_run, 0,	NULL,
X	ai_run, 0,	NULL,
X	ai_run, 9,	NULL,
X	ai_run, 9,	NULL,
X	ai_run, 9,	NULL
};
mmove_t	jorg_move_run = {FRAME_walk06, FRAME_walk19, jorg_frames_run, NULL};
X
//
// walk
//
X
mframe_t jorg_frames_start_walk [] =
{
X	ai_walk,	5,	NULL,
X	ai_walk,	6,	NULL,
X	ai_walk,	7,	NULL,
X	ai_walk,	9,	NULL,
X	ai_walk,	15,	NULL
};
mmove_t jorg_move_start_walk = {FRAME_walk01, FRAME_walk05, jorg_frames_start_walk, NULL};
X
mframe_t jorg_frames_walk [] =
{
X	ai_walk, 17,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 12,	NULL,
X	ai_walk, 8,	NULL,
X	ai_walk, 10,	NULL,
X	ai_walk, 33,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 9,	NULL,
X	ai_walk, 9,	NULL,
X	ai_walk, 9,	NULL
};
mmove_t	jorg_move_walk = {FRAME_walk06, FRAME_walk19, jorg_frames_walk, NULL};
X
mframe_t jorg_frames_end_walk [] =
{
X	ai_walk,	11,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	8,	NULL,
X	ai_walk,	-8,	NULL
};
mmove_t jorg_move_end_walk = {FRAME_walk20, FRAME_walk25, jorg_frames_end_walk, NULL};
X
void jorg_walk (edict_t *self)
{
X		self->monsterinfo.currentmove = &jorg_move_walk;
}
X
void jorg_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &jorg_move_stand;
X	else
X		self->monsterinfo.currentmove = &jorg_move_run;
}
X
mframe_t jorg_frames_pain3 [] =
{
X	ai_move,	-28,	NULL,
X	ai_move,	-6,	NULL,
X	ai_move,	-3,	jorg_step_left,
X	ai_move,	-9,	NULL,
X	ai_move,	0,	jorg_step_right,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-7,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	-11,	NULL,
X	ai_move,	-4,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	10,	NULL,
X	ai_move,	11,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	10,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	10,	NULL,
X	ai_move,	7,	jorg_step_left,
X	ai_move,	17,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	jorg_step_right
};
mmove_t jorg_move_pain3 = {FRAME_pain301, FRAME_pain325, jorg_frames_pain3, jorg_run};
X
mframe_t jorg_frames_pain2 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t jorg_move_pain2 = {FRAME_pain201, FRAME_pain203, jorg_frames_pain2, jorg_run};
X
mframe_t jorg_frames_pain1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t jorg_move_pain1 = {FRAME_pain101, FRAME_pain103, jorg_frames_pain1, jorg_run};
X
mframe_t jorg_frames_death1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,		// 10
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,		// 20
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,		// 30
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,		// 40
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	MakronToss,
X	ai_move,	0,	BossExplode		// 50
};
mmove_t jorg_move_death = {FRAME_death01, FRAME_death50, jorg_frames_death1, jorg_dead};
X
mframe_t jorg_frames_attack2 []=
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	jorgBFG,		
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t jorg_move_attack2 = {FRAME_attak201, FRAME_attak213, jorg_frames_attack2, jorg_run};
X
mframe_t jorg_frames_start_attack1 [] =
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL
};
mmove_t jorg_move_start_attack1 = {FRAME_attak101, FRAME_attak108, jorg_frames_start_attack1, jorg_attack1};
X
mframe_t jorg_frames_attack1[]=
{
X	ai_charge,	0,	jorg_firebullet,
X	ai_charge,	0,	jorg_firebullet,
X	ai_charge,	0,	jorg_firebullet,
X	ai_charge,	0,	jorg_firebullet,
X	ai_charge,	0,	jorg_firebullet,
X	ai_charge,	0,	jorg_firebullet
};
mmove_t jorg_move_attack1 = {FRAME_attak109, FRAME_attak114, jorg_frames_attack1, jorg_reattack1};
X
mframe_t jorg_frames_end_attack1[]=
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t jorg_move_end_attack1 = {FRAME_attak115, FRAME_attak118, jorg_frames_end_attack1, jorg_run};
X
void jorg_reattack1(edict_t *self)
{
X	if (visible(self, self->enemy))
X		if (random() < 0.9)
X			self->monsterinfo.currentmove = &jorg_move_attack1;
X		else
X		{
X			self->s.sound = 0;
X			self->monsterinfo.currentmove = &jorg_move_end_attack1;	
X		}
X	else
X	{
X		self->s.sound = 0;
X		self->monsterinfo.currentmove = &jorg_move_end_attack1;	
X	}
}
X
void jorg_attack1(edict_t *self)
{
X	self->monsterinfo.currentmove = &jorg_move_attack1;
}
X
void jorg_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X
X	if (self->health < (self->max_health / 2))
X			self->s.skinnum = 1;
X	
X	self->s.sound = 0;
X
X	if (level.time < self->pain_debounce_time)
X			return;
X
X	// Lessen the chance of him going into his pain frames if he takes little damage
X	if (damage <= 40)
X		if (random()<=0.6)
X			return;
X
X	/* 
X	If he's entering his attack1 or using attack1, lessen the chance of him
X	going into pain
X	*/
X	
X	if ( (self->s.frame >= FRAME_attak101) && (self->s.frame <= FRAME_attak108) )
X		if (random() <= 0.005)
X			return;
X
X	if ( (self->s.frame >= FRAME_attak109) && (self->s.frame <= FRAME_attak114) )
X		if (random() <= 0.00005)
X			return;
X
X
X	if ( (self->s.frame >= FRAME_attak201) && (self->s.frame <= FRAME_attak208) )
X		if (random() <= 0.005)
X			return;
X
X
X	self->pain_debounce_time = level.time + 3;
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	if (damage <= 50)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM,0);
X		self->monsterinfo.currentmove = &jorg_move_pain1;
X	}
X	else if (damage <= 100)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM,0);
X		self->monsterinfo.currentmove = &jorg_move_pain2;
X	}
X	else
X	{
X		if (random() <= 0.3)
X		{
X			gi.sound (self, CHAN_VOICE, sound_pain3, 1, ATTN_NORM,0);
X			self->monsterinfo.currentmove = &jorg_move_pain3;
X		}
X	}
};
X
void jorgBFG (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_JORG_BFG_1], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, vec);
X	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	gi.sound (self, CHAN_VOICE, sound_attack2, 1, ATTN_NORM, 0);
X	/*void monster_fire_bfg (edict_t *self, 
X							 vec3_t start, 
X							 vec3_t aimdir, 
X							 int damage, 
X							 int speed, 
X							 int kick, 
X							 float damage_radius, 
X							 int flashtype)*/
X	monster_fire_bfg (self, start, dir, 50, 300, 100, 200, MZ2_JORG_BFG_1);
}	
X
void jorg_firebullet_right (edict_t *self)
{
X	vec3_t	forward, right, target;
X	vec3_t	start;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_JORG_MACHINEGUN_R1], forward, right, start);
X
X	VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X	target[2] += self->enemy->viewheight;
X	VectorSubtract (target, start, forward);
X	VectorNormalize (forward);
X
X	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_R1);
}	
X
void jorg_firebullet_left (edict_t *self)
{
X	vec3_t	forward, right, target;
X	vec3_t	start;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_JORG_MACHINEGUN_L1], forward, right, start);
X
X	VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X	target[2] += self->enemy->viewheight;
X	VectorSubtract (target, start, forward);
X	VectorNormalize (forward);
X
X	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_L1);
}	
X
void jorg_firebullet (edict_t *self)
{
X	jorg_firebullet_left(self);
X	jorg_firebullet_right(self);
};
X
void jorg_attack(edict_t *self)
{
X	vec3_t	vec;
X	float	range;
X	
X	VectorSubtract (self->enemy->s.origin, self->s.origin, vec);
X	range = VectorLength (vec);
X
X	if (random() <= 0.75)
X	{
X		gi.sound (self, CHAN_VOICE, sound_attack1, 1, ATTN_NORM,0);
X		self->s.sound = gi.soundindex ("boss3/w_loop.wav");
X		self->monsterinfo.currentmove = &jorg_move_start_attack1;
X	}
X	else
X	{
X		gi.sound (self, CHAN_VOICE, sound_attack2, 1, ATTN_NORM,0);
X		self->monsterinfo.currentmove = &jorg_move_attack2;
X	}
}
X
void jorg_dead (edict_t *self)
{
#if 0
X	edict_t	*tempent;
X	/*
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	*/
X	
X	// Jorg is on modelindex2. Do not clear him.
X	VectorSet (self->mins, -60, -60, 0);
X	VectorSet (self->maxs, 60, 60, 72);
X	self->movetype = MOVETYPE_TOSS;
X	self->nextthink = 0;
X	gi.linkentity (self);
X
X	tempent = G_Spawn();
X	VectorCopy (self->s.origin, tempent->s.origin);
X	VectorCopy (self->s.angles, tempent->s.angles);
X	tempent->killtarget = self->killtarget;
X	tempent->target = self->target;
X	tempent->activator = self->enemy;
X	self->killtarget = 0;
X	self->target = 0;
X	SP_monster_makron (tempent);
#endif
}
X
X
void jorg_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_NO;
X	self->s.sound = 0;
X	self->count = 0;
X	self->monsterinfo.currentmove = &jorg_move_death;
}
X
qboolean Jorg_CheckAttack (edict_t *self)
{
X	vec3_t	spot1, spot2;
X	vec3_t	temp;
X	float	chance;
X	trace_t	tr;
X	qboolean	enemy_infront;
X	int			enemy_range;
X	float		enemy_yaw;
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X			return false;
X	}
X	
X	enemy_infront = infront(self, self->enemy);
X	enemy_range = range(self, self->enemy);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw(temp);
X
X	self->ideal_yaw = enemy_yaw;
X
X
X	// melee attack
X	if (enemy_range == RANGE_MELEE)
X	{
X		if (self->monsterinfo.melee)
X			self->monsterinfo.attack_state = AS_MELEE;
X		else
X			self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X	
// missile attack
X	if (!self->monsterinfo.attack)
X		return false;
X		
X	if (level.time < self->monsterinfo.attack_finished)
X		return false;
X		
X	if (enemy_range == RANGE_FAR)
X		return false;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MELEE)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_NEAR)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MID)
X	{
X		chance = 0.2;
X	}
X	else
X	{
X		return false;
X	}
X
X	if (random () < chance)
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
X		self->monsterinfo.attack_finished = level.time + 2*random();
X		return true;
X	}
X
X	if (self->flags & FL_FLY)
X	{
X		if (random() < 0.3)
X			self->monsterinfo.attack_state = AS_SLIDING;
X		else
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
X
X	return false;
}
X
X
void MakronPrecache (void);
X
/*QUAKED monster_jorg (1 .5 0) (-80 -80 0) (90 90 140) Ambush Trigger_Spawn Sight
*/
void SP_monster_jorg (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("boss3/bs3pain1.wav");
X	sound_pain2 = gi.soundindex ("boss3/bs3pain2.wav");
X	sound_pain3 = gi.soundindex ("boss3/bs3pain3.wav");
X	sound_death = gi.soundindex ("boss3/bs3deth1.wav");
X	sound_attack1 = gi.soundindex ("boss3/bs3atck1.wav");
X	sound_attack2 = gi.soundindex ("boss3/bs3atck2.wav");
X	sound_search1 = gi.soundindex ("boss3/bs3srch1.wav");
X	sound_search2 = gi.soundindex ("boss3/bs3srch2.wav");
X	sound_search3 = gi.soundindex ("boss3/bs3srch3.wav");
X	sound_idle = gi.soundindex ("boss3/bs3idle1.wav");
X	sound_step_left = gi.soundindex ("boss3/step1.wav");
X	sound_step_right = gi.soundindex ("boss3/step2.wav");
X	sound_firegun = gi.soundindex ("boss3/xfire.wav");
X	sound_death_hit = gi.soundindex ("boss3/d_hit.wav");
X
X	MakronPrecache ();
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/boss3/rider/tris.md2");
X	self->s.modelindex2 = gi.modelindex ("models/monsters/boss3/jorg/tris.md2");
X	VectorSet (self->mins, -80, -80, 0);
X	VectorSet (self->maxs, 80, 80, 140);
X
X	self->health = 3000;
X	self->gib_health = -2000;
X	self->mass = 1000;
X
X	self->pain = jorg_pain;
X	self->die = jorg_die;
X	self->monsterinfo.stand = jorg_stand;
X	self->monsterinfo.walk = jorg_walk;
X	self->monsterinfo.run = jorg_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = jorg_attack;
X	self->monsterinfo.search = jorg_search;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = NULL;
X	self->monsterinfo.checkattack = Jorg_CheckAttack;
X	gi.linkentity (self);
X	
X	self->monsterinfo.currentmove = &jorg_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start(self);
X	//PMM
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X	//pmm
X
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_boss31.c' &&
  chmod 0664 'm_boss31.c' ||
  $echo 'restore of' 'm_boss31.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_boss31.c:' 'MD5 check failed'
981225fb122d3141d93989c8fd542f5a  m_boss31.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_boss31.c'`"
    test 17065 -eq "$shar_count" ||
    $echo 'm_boss31.c:' 'original size' '17065,' 'current size' "$shar_count!"
  fi
fi
# ============= m_boss31.h ==============
if test -f 'm_boss31.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_boss31.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_boss31.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_boss31.h' &&
// G:\quake2\baseq2\models/monsters/boss3/jorg
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_attak101        	0
#define FRAME_attak102        	1
#define FRAME_attak103        	2
#define FRAME_attak104        	3
#define FRAME_attak105        	4
#define FRAME_attak106        	5
#define FRAME_attak107        	6
#define FRAME_attak108        	7
#define FRAME_attak109        	8
#define FRAME_attak110        	9
#define FRAME_attak111        	10
#define FRAME_attak112        	11
#define FRAME_attak113        	12
#define FRAME_attak114        	13
#define FRAME_attak115        	14
#define FRAME_attak116        	15
#define FRAME_attak117        	16
#define FRAME_attak118        	17
#define FRAME_attak201        	18
#define FRAME_attak202        	19
#define FRAME_attak203        	20
#define FRAME_attak204        	21
#define FRAME_attak205        	22
#define FRAME_attak206        	23
#define FRAME_attak207        	24
#define FRAME_attak208        	25
#define FRAME_attak209        	26
#define FRAME_attak210        	27
#define FRAME_attak211        	28
#define FRAME_attak212        	29
#define FRAME_attak213        	30
#define FRAME_death01         	31
#define FRAME_death02         	32
#define FRAME_death03         	33
#define FRAME_death04         	34
#define FRAME_death05         	35
#define FRAME_death06         	36
#define FRAME_death07         	37
#define FRAME_death08         	38
#define FRAME_death09         	39
#define FRAME_death10         	40
#define FRAME_death11         	41
#define FRAME_death12         	42
#define FRAME_death13         	43
#define FRAME_death14         	44
#define FRAME_death15         	45
#define FRAME_death16         	46
#define FRAME_death17         	47
#define FRAME_death18         	48
#define FRAME_death19         	49
#define FRAME_death20         	50
#define FRAME_death21         	51
#define FRAME_death22         	52
#define FRAME_death23         	53
#define FRAME_death24         	54
#define FRAME_death25         	55
#define FRAME_death26         	56
#define FRAME_death27         	57
#define FRAME_death28         	58
#define FRAME_death29         	59
#define FRAME_death30         	60
#define FRAME_death31         	61
#define FRAME_death32         	62
#define FRAME_death33         	63
#define FRAME_death34         	64
#define FRAME_death35         	65
#define FRAME_death36         	66
#define FRAME_death37         	67
#define FRAME_death38         	68
#define FRAME_death39         	69
#define FRAME_death40         	70
#define FRAME_death41         	71
#define FRAME_death42         	72
#define FRAME_death43         	73
#define FRAME_death44         	74
#define FRAME_death45         	75
#define FRAME_death46         	76
#define FRAME_death47         	77
#define FRAME_death48         	78
#define FRAME_death49         	79
#define FRAME_death50         	80
#define FRAME_pain101         	81
#define FRAME_pain102         	82
#define FRAME_pain103         	83
#define FRAME_pain201         	84
#define FRAME_pain202         	85
#define FRAME_pain203         	86
#define FRAME_pain301         	87
#define FRAME_pain302         	88
#define FRAME_pain303         	89
#define FRAME_pain304         	90
#define FRAME_pain305         	91
#define FRAME_pain306         	92
#define FRAME_pain307         	93
#define FRAME_pain308         	94
#define FRAME_pain309         	95
#define FRAME_pain310         	96
#define FRAME_pain311         	97
#define FRAME_pain312         	98
#define FRAME_pain313         	99
#define FRAME_pain314         	100
#define FRAME_pain315         	101
#define FRAME_pain316         	102
#define FRAME_pain317         	103
#define FRAME_pain318         	104
#define FRAME_pain319         	105
#define FRAME_pain320         	106
#define FRAME_pain321         	107
#define FRAME_pain322         	108
#define FRAME_pain323         	109
#define FRAME_pain324         	110
#define FRAME_pain325         	111
#define FRAME_stand01         	112
#define FRAME_stand02         	113
#define FRAME_stand03         	114
#define FRAME_stand04         	115
#define FRAME_stand05         	116
#define FRAME_stand06         	117
#define FRAME_stand07         	118
#define FRAME_stand08         	119
#define FRAME_stand09         	120
#define FRAME_stand10         	121
#define FRAME_stand11         	122
#define FRAME_stand12         	123
#define FRAME_stand13         	124
#define FRAME_stand14         	125
#define FRAME_stand15         	126
#define FRAME_stand16         	127
#define FRAME_stand17         	128
#define FRAME_stand18         	129
#define FRAME_stand19         	130
#define FRAME_stand20         	131
#define FRAME_stand21         	132
#define FRAME_stand22         	133
#define FRAME_stand23         	134
#define FRAME_stand24         	135
#define FRAME_stand25         	136
#define FRAME_stand26         	137
#define FRAME_stand27         	138
#define FRAME_stand28         	139
#define FRAME_stand29         	140
#define FRAME_stand30         	141
#define FRAME_stand31         	142
#define FRAME_stand32         	143
#define FRAME_stand33         	144
#define FRAME_stand34         	145
#define FRAME_stand35         	146
#define FRAME_stand36         	147
#define FRAME_stand37         	148
#define FRAME_stand38         	149
#define FRAME_stand39         	150
#define FRAME_stand40         	151
#define FRAME_stand41         	152
#define FRAME_stand42         	153
#define FRAME_stand43         	154
#define FRAME_stand44         	155
#define FRAME_stand45         	156
#define FRAME_stand46         	157
#define FRAME_stand47         	158
#define FRAME_stand48         	159
#define FRAME_stand49         	160
#define FRAME_stand50         	161
#define FRAME_stand51         	162
#define FRAME_walk01          	163
#define FRAME_walk02          	164
#define FRAME_walk03          	165
#define FRAME_walk04          	166
#define FRAME_walk05          	167
#define FRAME_walk06          	168
#define FRAME_walk07          	169
#define FRAME_walk08          	170
#define FRAME_walk09          	171
#define FRAME_walk10          	172
#define FRAME_walk11          	173
#define FRAME_walk12          	174
#define FRAME_walk13          	175
#define FRAME_walk14          	176
#define FRAME_walk15          	177
#define FRAME_walk16          	178
#define FRAME_walk17          	179
#define FRAME_walk18          	180
#define FRAME_walk19          	181
#define FRAME_walk20          	182
#define FRAME_walk21          	183
#define FRAME_walk22          	184
#define FRAME_walk23          	185
#define FRAME_walk24          	186
#define FRAME_walk25          	187
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_boss31.h' &&
  chmod 0664 'm_boss31.h' ||
  $echo 'restore of' 'm_boss31.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_boss31.h:' 'MD5 check failed'
0e4c84bc97d88362d092c805063b0d65  m_boss31.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_boss31.h'`"
    test 6601 -eq "$shar_count" ||
    $echo 'm_boss31.h:' 'original size' '6601,' 'current size' "$shar_count!"
  fi
fi
# ============= m_boss32.c ==============
if test -f 'm_boss32.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_boss32.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_boss32.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_boss32.c' &&
/*
==============================================================================
X
Makron -- Final Boss
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_boss32.h"
X
qboolean visible (edict_t *self, edict_t *other);
X
void MakronRailgun (edict_t *self);
void MakronSaveloc (edict_t *self);
void MakronHyperblaster (edict_t *self);
void makron_step_left (edict_t *self);
void makron_step_right (edict_t *self);
void makronBFG (edict_t *self);
void makron_dead (edict_t *self);
X
static int	sound_pain4;
static int	sound_pain5;
static int	sound_pain6;
static int	sound_death;
static int	sound_step_left;
static int	sound_step_right;
static int	sound_attack_bfg;
static int	sound_brainsplorch;
static int	sound_prerailgun;
static int	sound_popup;
static int	sound_taunt1;
static int	sound_taunt2;
static int	sound_taunt3;
static int	sound_hit;
X
void makron_taunt (edict_t *self)
{
X	float r;
X
X	r=random();
X	if (r <= 0.3)
X		gi.sound (self, CHAN_AUTO, sound_taunt1, 1, ATTN_NONE, 0);
X	else if (r <= 0.6)
X		gi.sound (self, CHAN_AUTO, sound_taunt2, 1, ATTN_NONE, 0);
X	else
X		gi.sound (self, CHAN_AUTO, sound_taunt3, 1, ATTN_NONE, 0);
}
X
//
// stand
//
X
mframe_t makron_frames_stand []=
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 10
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 20
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 30
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 40
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 50
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL		// 60
};
mmove_t	makron_move_stand = {FRAME_stand201, FRAME_stand260, makron_frames_stand, NULL};
X	
void makron_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &makron_move_stand;
}
X
mframe_t makron_frames_run [] =
{
X	ai_run, 3,	makron_step_left,
X	ai_run, 12,	NULL,
X	ai_run, 8,	NULL,
X	ai_run, 8,	NULL,
X	ai_run, 8,	makron_step_right,
X	ai_run, 6,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 9,	NULL,
X	ai_run, 6,	NULL,
X	ai_run, 12,	NULL
};
mmove_t	makron_move_run = {FRAME_walk204, FRAME_walk213, makron_frames_run, NULL};
X
void makron_hit (edict_t *self)
{
X	gi.sound (self, CHAN_AUTO, sound_hit, 1, ATTN_NONE,0);
}
X
void makron_popup (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_popup, 1, ATTN_NONE,0);
}
X
void makron_step_left (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_step_left, 1, ATTN_NORM,0);
}
X
void makron_step_right (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_step_right, 1, ATTN_NORM,0);
}
X
void makron_brainsplorch (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_brainsplorch, 1, ATTN_NORM,0);
}
X
void makron_prerailgun (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_prerailgun, 1, ATTN_NORM,0);
}
X
X
mframe_t makron_frames_walk [] =
{
X	ai_walk, 3,	makron_step_left,
X	ai_walk, 12,	NULL,
X	ai_walk, 8,	NULL,
X	ai_walk, 8,	NULL,
X	ai_walk, 8,	makron_step_right,
X	ai_walk, 6,	NULL,
X	ai_walk, 12,	NULL,
X	ai_walk, 9,	NULL,
X	ai_walk, 6,	NULL,
X	ai_walk, 12,	NULL
};
mmove_t	makron_move_walk = {FRAME_walk204, FRAME_walk213, makron_frames_run, NULL};
X
void makron_walk (edict_t *self)
{
X		self->monsterinfo.currentmove = &makron_move_walk;
}
X
void makron_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &makron_move_stand;
X	else
X		self->monsterinfo.currentmove = &makron_move_run;
}
X
mframe_t makron_frames_pain6 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,		// 10
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	makron_popup,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,		// 20
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	makron_taunt,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_pain6 = {FRAME_pain601, FRAME_pain627, makron_frames_pain6, makron_run};
X
mframe_t makron_frames_pain5 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_pain5 = {FRAME_pain501, FRAME_pain504, makron_frames_pain5, makron_run};
X
mframe_t makron_frames_pain4 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_pain4 = {FRAME_pain401, FRAME_pain404, makron_frames_pain4, makron_run};
X
mframe_t makron_frames_death2 [] =
{
X	ai_move,	-15,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	-12,	NULL,
X	ai_move,	0,	makron_step_left,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			// 10
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	11,	NULL,
X	ai_move,	12,	NULL,
X	ai_move,	11,	makron_step_right,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			// 20
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			// 30
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	5,	NULL,
X	ai_move,	7,	NULL,
X	ai_move,	6,	makron_step_left,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-1,	NULL,
X	ai_move,	2,	NULL,			// 40
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,			// 50
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-6,	NULL,
X	ai_move,	-4,	NULL,
X	ai_move,	-6,	makron_step_right,
X	ai_move,	-4,	NULL,
X	ai_move,	-4,	makron_step_left,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			// 60
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	-2,	NULL,
X	ai_move,	-5,	NULL,
X	ai_move,	-3,	makron_step_right,
X	ai_move,	-8,	NULL,
X	ai_move,	-3,	makron_step_left,
X	ai_move,	-7,	NULL,
X	ai_move,	-4,	NULL,
X	ai_move,	-4,	makron_step_right,			// 70
X	ai_move,	-6,	NULL,			
X	ai_move,	-7,	NULL,
X	ai_move,	0,	makron_step_left,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,			// 80
X	ai_move,	0,	NULL,			
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-2,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	0,	NULL,			// 90
X	ai_move,	27,	makron_hit,			
X	ai_move,	26,	NULL,
X	ai_move,	0,	makron_brainsplorch,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL			// 95
};
mmove_t makron_move_death2 = {FRAME_death201, FRAME_death295, makron_frames_death2, makron_dead};
X
mframe_t makron_frames_death3 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_death3 = {FRAME_death301, FRAME_death320, makron_frames_death3, NULL};
X
mframe_t makron_frames_sight [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_sight= {FRAME_active01, FRAME_active13, makron_frames_sight, makron_run};
X
void makronBFG (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_MAKRON_BFG], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, vec);
X	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	gi.sound (self, CHAN_VOICE, sound_attack_bfg, 1, ATTN_NORM, 0);
X	monster_fire_bfg (self, start, dir, 50, 300, 100, 300, MZ2_MAKRON_BFG);
}	
X
X
mframe_t makron_frames_attack3 []=
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	makronBFG,		// FIXME: BFG Attack here
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_attack3 = {FRAME_attak301, FRAME_attak308, makron_frames_attack3, makron_run};
X
mframe_t makron_frames_attack4[]=
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	MakronHyperblaster,		// fire
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_attack4 = {FRAME_attak401, FRAME_attak426, makron_frames_attack4, makron_run};
X
mframe_t makron_frames_attack5[]=
{
X	ai_charge,	0,	makron_prerailgun,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	MakronSaveloc,
X	ai_move,	0,	MakronRailgun,		// Fire railgun
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t makron_move_attack5 = {FRAME_attak501, FRAME_attak516, makron_frames_attack5, makron_run};
X
void MakronSaveloc (edict_t *self)
{
X	VectorCopy (self->enemy->s.origin, self->pos1);	//save for aiming the shot
X	self->pos1[2] += self->enemy->viewheight;
};
X
// FIXME: He's not firing from the proper Z
void MakronRailgun (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	forward, right;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_MAKRON_RAILGUN_1], forward, right, start);
X	
X	// calc direction to where we targted
X	VectorSubtract (self->pos1, start, dir);
X	VectorNormalize (dir);
X
X	monster_fire_railgun (self, start, dir, 50, 100, MZ2_MAKRON_RAILGUN_1);
}
X
// FIXME: This is all wrong. He's not firing at the proper angles.
void MakronHyperblaster (edict_t *self)
{
X	vec3_t	dir;
X	vec3_t	vec;
X	vec3_t	start;
X	vec3_t	forward, right;
X	int		flash_number;
X
X	flash_number = MZ2_MAKRON_BLASTER_1 + (self->s.frame - FRAME_attak405);
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	if (self->enemy)
X	{
X		VectorCopy (self->enemy->s.origin, vec);
X		vec[2] += self->enemy->viewheight;
X		VectorSubtract (vec, start, vec);
X		vectoangles (vec, vec);
X		dir[0] = vec[0];
X	}
X	else
X	{
X		dir[0] = 0;
X	}
X	if (self->s.frame <= FRAME_attak413)
X		dir[1] = self->s.angles[1] - 10 * (self->s.frame - FRAME_attak413);
X	else
X		dir[1] = self->s.angles[1] + 10 * (self->s.frame - FRAME_attak421);
X	dir[2] = 0;
X
X	AngleVectors (dir, forward, NULL, NULL);
X
X	monster_fire_blaster (self, start, forward, 15, 1000, MZ2_MAKRON_BLASTER_1, EF_BLASTER);
}	
X
X
void makron_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X
X	if (self->health < (self->max_health / 2))
X			self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X			return;
X
X	// Lessen the chance of him going into his pain frames
X	if (damage <=25)
X		if (random()<0.2)
X			return;
X
X	self->pain_debounce_time = level.time + 3;
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X
X	if (damage <= 40)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain4, 1, ATTN_NONE,0);
X		self->monsterinfo.currentmove = &makron_move_pain4;
X	}
X	else if (damage <= 110)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain5, 1, ATTN_NONE,0);
X		self->monsterinfo.currentmove = &makron_move_pain5;
X	}
X	else
X	{
X		if (damage <= 150)
X			if (random() <= 0.45)
X			{
X				gi.sound (self, CHAN_VOICE, sound_pain6, 1, ATTN_NONE,0);
X				self->monsterinfo.currentmove = &makron_move_pain6;
X			}
X		else
X			if (random() <= 0.35)
X			{
X				gi.sound (self, CHAN_VOICE, sound_pain6, 1, ATTN_NONE,0);
X				self->monsterinfo.currentmove = &makron_move_pain6;
X			}
X	}
};
X
void makron_sight(edict_t *self, edict_t *other)
{
X	self->monsterinfo.currentmove = &makron_move_sight;
};
X
void makron_attack(edict_t *self)
{
X	vec3_t	vec;
X	float	range;
X	float	r;
X
X	r = random();
X
X	VectorSubtract (self->enemy->s.origin, self->s.origin, vec);
X	range = VectorLength (vec);
X
X
X	if (r <= 0.3)
X		self->monsterinfo.currentmove = &makron_move_attack3;
X	else if (r <= 0.6)
X		self->monsterinfo.currentmove = &makron_move_attack4;
X	else
X		self->monsterinfo.currentmove = &makron_move_attack5;
}
X
/*
---
Makron Torso. This needs to be spawned in
---
*/
X
void makron_torso_think (edict_t *self)
{
X	if (++self->s.frame < 365)
X		self->nextthink = level.time + FRAMETIME;
X	else
X	{		
X		self->s.frame = 346;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
void makron_torso (edict_t *ent)
{
X	ent->movetype = MOVETYPE_NONE;
X	ent->solid = SOLID_NOT;
X	VectorSet (ent->mins, -8, -8, 0);
X	VectorSet (ent->maxs, 8, 8, 8);
X	ent->s.frame = 346;
X	ent->s.modelindex = gi.modelindex ("models/monsters/boss3/rider/tris.md2");
X	ent->think = makron_torso_think;
X	ent->nextthink = level.time + 2 * FRAMETIME;
X	ent->s.sound = gi.soundindex ("makron/spine.wav");
X	gi.linkentity (ent);
}
X
X
//
// death
//
X
void makron_dead (edict_t *self)
{
X	VectorSet (self->mins, -60, -60, 0);
X	VectorSet (self->maxs, 60, 60, 72);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
X
void makron_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	edict_t *tempent;
X
X	int		n;
X
X	self->s.sound = 0;
X	// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 1 /*4*/; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_metal/tris.md2", damage, GIB_METALLIC);
X		ThrowHead (self, "models/objects/gibs/gear/tris.md2", damage, GIB_METALLIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NONE, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	tempent = G_Spawn();
X	VectorCopy (self->s.origin, tempent->s.origin);
X	VectorCopy (self->s.angles, tempent->s.angles);
X	tempent->s.origin[1] -= 84;
X	makron_torso (tempent);
X
X	self->monsterinfo.currentmove = &makron_move_death2;
X	
}
X
qboolean Makron_CheckAttack (edict_t *self)
{
X	vec3_t	spot1, spot2;
X	vec3_t	temp;
X	float	chance;
X	trace_t	tr;
X	qboolean	enemy_infront;
X	int			enemy_range;
X	float		enemy_yaw;
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X			return false;
X	}
X	
X	enemy_infront = infront(self, self->enemy);
X	enemy_range = range(self, self->enemy);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw(temp);
X
X	self->ideal_yaw = enemy_yaw;
X
X
X	// melee attack
X	if (enemy_range == RANGE_MELEE)
X	{
X		if (self->monsterinfo.melee)
X			self->monsterinfo.attack_state = AS_MELEE;
X		else
X			self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X	
// missile attack
X	if (!self->monsterinfo.attack)
X		return false;
X		
X	if (level.time < self->monsterinfo.attack_finished)
X		return false;
X		
X	if (enemy_range == RANGE_FAR)
X		return false;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MELEE)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_NEAR)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MID)
X	{
X		chance = 0.2;
X	}
X	else
X	{
X		return false;
X	}
X
X	if (random () < chance)
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
X		self->monsterinfo.attack_finished = level.time + 2*random();
X		return true;
X	}
X
X	if (self->flags & FL_FLY)
X	{
X		if (random() < 0.3)
X			self->monsterinfo.attack_state = AS_SLIDING;
X		else
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
X
X	return false;
}
X
X
//
// monster_makron
//
X
void MakronPrecache (void)
{
X	sound_pain4 = gi.soundindex ("makron/pain3.wav");
X	sound_pain5 = gi.soundindex ("makron/pain2.wav");
X	sound_pain6 = gi.soundindex ("makron/pain1.wav");
X	sound_death = gi.soundindex ("makron/death.wav");
X	sound_step_left = gi.soundindex ("makron/step1.wav");
X	sound_step_right = gi.soundindex ("makron/step2.wav");
X	sound_attack_bfg = gi.soundindex ("makron/bfg_fire.wav");
X	sound_brainsplorch = gi.soundindex ("makron/brain1.wav");
X	sound_prerailgun = gi.soundindex ("makron/rail_up.wav");
X	sound_popup = gi.soundindex ("makron/popup.wav");
X	sound_taunt1 = gi.soundindex ("makron/voice4.wav");
X	sound_taunt2 = gi.soundindex ("makron/voice3.wav");
X	sound_taunt3 = gi.soundindex ("makron/voice.wav");
X	sound_hit = gi.soundindex ("makron/bhit.wav");
X
X	gi.modelindex ("models/monsters/boss3/rider/tris.md2");
}
X
/*QUAKED monster_makron (1 .5 0) (-30 -30 0) (30 30 90) Ambush Trigger_Spawn Sight
*/
void SP_monster_makron (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	MakronPrecache ();
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/boss3/rider/tris.md2");
X	VectorSet (self->mins, -30, -30, 0);
X	VectorSet (self->maxs, 30, 30, 90);
X
X	self->health = 3000;
X	self->gib_health = -2000;
X	self->mass = 500;
X
X	self->pain = makron_pain;
X	self->die = makron_die;
X	self->monsterinfo.stand = makron_stand;
X	self->monsterinfo.walk = makron_walk;
X	self->monsterinfo.run = makron_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = makron_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = makron_sight;
X	self->monsterinfo.checkattack = Makron_CheckAttack;
X
X	gi.linkentity (self);
X	
//	self->monsterinfo.currentmove = &makron_move_stand;
X	self->monsterinfo.currentmove = &makron_move_sight;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start(self);
X
X	//PMM
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X	//pmm
}
X
X
/*
=================
MakronSpawn
X
=================
*/
void MakronSpawn (edict_t *self)
{
X	vec3_t		vec;
X	edict_t		*player;
X
X	SP_monster_makron (self);
X
X	// jump at player
X	player = level.sight_client;
X	if (!player)
X		return;
X
X	VectorSubtract (player->s.origin, self->s.origin, vec);
X	self->s.angles[YAW] = vectoyaw(vec);
X	VectorNormalize (vec);
X	VectorMA (vec3_origin, 400, vec, self->velocity);
X	self->velocity[2] = 200;
X	self->groundentity = NULL;
}
X
/*
=================
MakronToss
X
Jorg is just about dead, so set up to launch Makron out
=================
*/
void MakronToss (edict_t *self)
{
X	edict_t	*ent;
X
X	ent = G_Spawn ();
X	ent->nextthink = level.time + 0.8;
X	ent->think = MakronSpawn;
X	ent->target = self->target;
X	VectorCopy (self->s.origin, ent->s.origin);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_boss32.c' &&
  chmod 0664 'm_boss32.c' ||
  $echo 'restore of' 'm_boss32.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_boss32.c:' 'MD5 check failed'
650cb98b8dcc6c89b5028029c65b8654  m_boss32.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_boss32.c'`"
    test 20554 -eq "$shar_count" ||
    $echo 'm_boss32.c:' 'original size' '20554,' 'current size' "$shar_count!"
  fi
fi
# ============= m_boss32.h ==============
if test -f 'm_boss32.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_boss32.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_boss32.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_boss32.h' &&
// G:\quake2\baseq2\models/monsters/boss3/rider
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_attak101        	0
#define FRAME_attak102        	1
#define FRAME_attak103        	2
#define FRAME_attak104        	3
#define FRAME_attak105        	4
#define FRAME_attak106        	5
#define FRAME_attak107        	6
#define FRAME_attak108        	7
#define FRAME_attak109        	8
#define FRAME_attak110        	9
#define FRAME_attak111        	10
#define FRAME_attak112        	11
#define FRAME_attak113        	12
#define FRAME_attak114        	13
#define FRAME_attak115        	14
#define FRAME_attak116        	15
#define FRAME_attak117        	16
#define FRAME_attak118        	17
#define FRAME_attak201        	18
#define FRAME_attak202        	19
#define FRAME_attak203        	20
#define FRAME_attak204        	21
#define FRAME_attak205        	22
#define FRAME_attak206        	23
#define FRAME_attak207        	24
#define FRAME_attak208        	25
#define FRAME_attak209        	26
#define FRAME_attak210        	27
#define FRAME_attak211        	28
#define FRAME_attak212        	29
#define FRAME_attak213        	30
#define FRAME_death01         	31
#define FRAME_death02         	32
#define FRAME_death03         	33
#define FRAME_death04         	34
#define FRAME_death05         	35
#define FRAME_death06         	36
#define FRAME_death07         	37
#define FRAME_death08         	38
#define FRAME_death09         	39
#define FRAME_death10         	40
#define FRAME_death11         	41
#define FRAME_death12         	42
#define FRAME_death13         	43
#define FRAME_death14         	44
#define FRAME_death15         	45
#define FRAME_death16         	46
#define FRAME_death17         	47
#define FRAME_death18         	48
#define FRAME_death19         	49
#define FRAME_death20         	50
#define FRAME_death21         	51
#define FRAME_death22         	52
#define FRAME_death23         	53
#define FRAME_death24         	54
#define FRAME_death25         	55
#define FRAME_death26         	56
#define FRAME_death27         	57
#define FRAME_death28         	58
#define FRAME_death29         	59
#define FRAME_death30         	60
#define FRAME_death31         	61
#define FRAME_death32         	62
#define FRAME_death33         	63
#define FRAME_death34         	64
#define FRAME_death35         	65
#define FRAME_death36         	66
#define FRAME_death37         	67
#define FRAME_death38         	68
#define FRAME_death39         	69
#define FRAME_death40         	70
#define FRAME_death41         	71
#define FRAME_death42         	72
#define FRAME_death43         	73
#define FRAME_death44         	74
#define FRAME_death45         	75
#define FRAME_death46         	76
#define FRAME_death47         	77
#define FRAME_death48         	78
#define FRAME_death49         	79
#define FRAME_death50         	80
#define FRAME_pain101         	81
#define FRAME_pain102         	82
#define FRAME_pain103         	83
#define FRAME_pain201         	84
#define FRAME_pain202         	85
#define FRAME_pain203         	86
#define FRAME_pain301         	87
#define FRAME_pain302         	88
#define FRAME_pain303         	89
#define FRAME_pain304         	90
#define FRAME_pain305         	91
#define FRAME_pain306         	92
#define FRAME_pain307         	93
#define FRAME_pain308         	94
#define FRAME_pain309         	95
#define FRAME_pain310         	96
#define FRAME_pain311         	97
#define FRAME_pain312         	98
#define FRAME_pain313         	99
#define FRAME_pain314         	100
#define FRAME_pain315         	101
#define FRAME_pain316         	102
#define FRAME_pain317         	103
#define FRAME_pain318         	104
#define FRAME_pain319         	105
#define FRAME_pain320         	106
#define FRAME_pain321         	107
#define FRAME_pain322         	108
#define FRAME_pain323         	109
#define FRAME_pain324         	110
#define FRAME_pain325         	111
#define FRAME_stand01         	112
#define FRAME_stand02         	113
#define FRAME_stand03         	114
#define FRAME_stand04         	115
#define FRAME_stand05         	116
#define FRAME_stand06         	117
#define FRAME_stand07         	118
#define FRAME_stand08         	119
#define FRAME_stand09         	120
#define FRAME_stand10         	121
#define FRAME_stand11         	122
#define FRAME_stand12         	123
#define FRAME_stand13         	124
#define FRAME_stand14         	125
#define FRAME_stand15         	126
#define FRAME_stand16         	127
#define FRAME_stand17         	128
#define FRAME_stand18         	129
#define FRAME_stand19         	130
#define FRAME_stand20         	131
#define FRAME_stand21         	132
#define FRAME_stand22         	133
#define FRAME_stand23         	134
#define FRAME_stand24         	135
#define FRAME_stand25         	136
#define FRAME_stand26         	137
#define FRAME_stand27         	138
#define FRAME_stand28         	139
#define FRAME_stand29         	140
#define FRAME_stand30         	141
#define FRAME_stand31         	142
#define FRAME_stand32         	143
#define FRAME_stand33         	144
#define FRAME_stand34         	145
#define FRAME_stand35         	146
#define FRAME_stand36         	147
#define FRAME_stand37         	148
#define FRAME_stand38         	149
#define FRAME_stand39         	150
#define FRAME_stand40         	151
#define FRAME_stand41         	152
#define FRAME_stand42         	153
#define FRAME_stand43         	154
#define FRAME_stand44         	155
#define FRAME_stand45         	156
#define FRAME_stand46         	157
#define FRAME_stand47         	158
#define FRAME_stand48         	159
#define FRAME_stand49         	160
#define FRAME_stand50         	161
#define FRAME_stand51         	162
#define FRAME_walk01          	163
#define FRAME_walk02          	164
#define FRAME_walk03          	165
#define FRAME_walk04          	166
#define FRAME_walk05          	167
#define FRAME_walk06          	168
#define FRAME_walk07          	169
#define FRAME_walk08          	170
#define FRAME_walk09          	171
#define FRAME_walk10          	172
#define FRAME_walk11          	173
#define FRAME_walk12          	174
#define FRAME_walk13          	175
#define FRAME_walk14          	176
#define FRAME_walk15          	177
#define FRAME_walk16          	178
#define FRAME_walk17          	179
#define FRAME_walk18          	180
#define FRAME_walk19          	181
#define FRAME_walk20          	182
#define FRAME_walk21          	183
#define FRAME_walk22          	184
#define FRAME_walk23          	185
#define FRAME_walk24          	186
#define FRAME_walk25          	187
#define FRAME_active01        	188
#define FRAME_active02        	189
#define FRAME_active03        	190
#define FRAME_active04        	191
#define FRAME_active05        	192
#define FRAME_active06        	193
#define FRAME_active07        	194
#define FRAME_active08        	195
#define FRAME_active09        	196
#define FRAME_active10        	197
#define FRAME_active11        	198
#define FRAME_active12        	199
#define FRAME_active13        	200
#define FRAME_attak301        	201
#define FRAME_attak302        	202
#define FRAME_attak303        	203
#define FRAME_attak304        	204
#define FRAME_attak305        	205
#define FRAME_attak306        	206
#define FRAME_attak307        	207
#define FRAME_attak308        	208
#define FRAME_attak401        	209
#define FRAME_attak402        	210
#define FRAME_attak403        	211
#define FRAME_attak404        	212
#define FRAME_attak405        	213
#define FRAME_attak406        	214
#define FRAME_attak407        	215
#define FRAME_attak408        	216
#define FRAME_attak409        	217
#define FRAME_attak410        	218
#define FRAME_attak411        	219
#define FRAME_attak412        	220
#define FRAME_attak413        	221
#define FRAME_attak414        	222
#define FRAME_attak415        	223
#define FRAME_attak416        	224
#define FRAME_attak417        	225
#define FRAME_attak418        	226
#define FRAME_attak419        	227
#define FRAME_attak420        	228
#define FRAME_attak421        	229
#define FRAME_attak422        	230
#define FRAME_attak423        	231
#define FRAME_attak424        	232
#define FRAME_attak425        	233
#define FRAME_attak426        	234
#define FRAME_attak501        	235
#define FRAME_attak502        	236
#define FRAME_attak503        	237
#define FRAME_attak504        	238
#define FRAME_attak505        	239
#define FRAME_attak506        	240
#define FRAME_attak507        	241
#define FRAME_attak508        	242
#define FRAME_attak509        	243
#define FRAME_attak510        	244
#define FRAME_attak511        	245
#define FRAME_attak512        	246
#define FRAME_attak513        	247
#define FRAME_attak514        	248
#define FRAME_attak515        	249
#define FRAME_attak516        	250
#define FRAME_death201        	251
#define FRAME_death202        	252
#define FRAME_death203        	253
#define FRAME_death204        	254
#define FRAME_death205        	255
#define FRAME_death206        	256
#define FRAME_death207        	257
#define FRAME_death208        	258
#define FRAME_death209        	259
#define FRAME_death210        	260
#define FRAME_death211        	261
#define FRAME_death212        	262
#define FRAME_death213        	263
#define FRAME_death214        	264
#define FRAME_death215        	265
#define FRAME_death216        	266
#define FRAME_death217        	267
#define FRAME_death218        	268
#define FRAME_death219        	269
#define FRAME_death220        	270
#define FRAME_death221        	271
#define FRAME_death222        	272
#define FRAME_death223        	273
#define FRAME_death224        	274
#define FRAME_death225        	275
#define FRAME_death226        	276
#define FRAME_death227        	277
#define FRAME_death228        	278
#define FRAME_death229        	279
#define FRAME_death230        	280
#define FRAME_death231        	281
#define FRAME_death232        	282
#define FRAME_death233        	283
#define FRAME_death234        	284
#define FRAME_death235        	285
#define FRAME_death236        	286
#define FRAME_death237        	287
#define FRAME_death238        	288
#define FRAME_death239        	289
#define FRAME_death240        	290
#define FRAME_death241        	291
#define FRAME_death242        	292
#define FRAME_death243        	293
#define FRAME_death244        	294
#define FRAME_death245        	295
#define FRAME_death246        	296
#define FRAME_death247        	297
#define FRAME_death248        	298
#define FRAME_death249        	299
#define FRAME_death250        	300
#define FRAME_death251        	301
#define FRAME_death252        	302
#define FRAME_death253        	303
#define FRAME_death254        	304
#define FRAME_death255        	305
#define FRAME_death256        	306
#define FRAME_death257        	307
#define FRAME_death258        	308
#define FRAME_death259        	309
#define FRAME_death260        	310
#define FRAME_death261        	311
#define FRAME_death262        	312
#define FRAME_death263        	313
#define FRAME_death264        	314
#define FRAME_death265        	315
#define FRAME_death266        	316
#define FRAME_death267        	317
#define FRAME_death268        	318
#define FRAME_death269        	319
#define FRAME_death270        	320
#define FRAME_death271        	321
#define FRAME_death272        	322
#define FRAME_death273        	323
#define FRAME_death274        	324
#define FRAME_death275        	325
#define FRAME_death276        	326
#define FRAME_death277        	327
#define FRAME_death278        	328
#define FRAME_death279        	329
#define FRAME_death280        	330
#define FRAME_death281        	331
#define FRAME_death282        	332
#define FRAME_death283        	333
#define FRAME_death284        	334
#define FRAME_death285        	335
#define FRAME_death286        	336
#define FRAME_death287        	337
#define FRAME_death288        	338
#define FRAME_death289        	339
#define FRAME_death290        	340
#define FRAME_death291        	341
#define FRAME_death292        	342
#define FRAME_death293        	343
#define FRAME_death294        	344
#define FRAME_death295        	345
#define FRAME_death301        	346
#define FRAME_death302        	347
#define FRAME_death303        	348
#define FRAME_death304        	349
#define FRAME_death305        	350
#define FRAME_death306        	351
#define FRAME_death307        	352
#define FRAME_death308        	353
#define FRAME_death309        	354
#define FRAME_death310        	355
#define FRAME_death311        	356
#define FRAME_death312        	357
#define FRAME_death313        	358
#define FRAME_death314        	359
#define FRAME_death315        	360
#define FRAME_death316        	361
#define FRAME_death317        	362
#define FRAME_death318        	363
#define FRAME_death319        	364
#define FRAME_death320        	365
#define FRAME_jump01          	366
#define FRAME_jump02          	367
#define FRAME_jump03          	368
#define FRAME_jump04          	369
#define FRAME_jump05          	370
#define FRAME_jump06          	371
#define FRAME_jump07          	372
#define FRAME_jump08          	373
#define FRAME_jump09          	374
#define FRAME_jump10          	375
#define FRAME_jump11          	376
#define FRAME_jump12          	377
#define FRAME_jump13          	378
#define FRAME_pain401         	379
#define FRAME_pain402         	380
#define FRAME_pain403         	381
#define FRAME_pain404         	382
#define FRAME_pain501         	383
#define FRAME_pain502         	384
#define FRAME_pain503         	385
#define FRAME_pain504         	386
#define FRAME_pain601         	387
#define FRAME_pain602         	388
#define FRAME_pain603         	389
#define FRAME_pain604         	390
#define FRAME_pain605         	391
#define FRAME_pain606         	392
#define FRAME_pain607         	393
#define FRAME_pain608         	394
#define FRAME_pain609         	395
#define FRAME_pain610         	396
#define FRAME_pain611         	397
#define FRAME_pain612         	398
#define FRAME_pain613         	399
#define FRAME_pain614         	400
#define FRAME_pain615         	401
#define FRAME_pain616         	402
#define FRAME_pain617         	403
#define FRAME_pain618         	404
#define FRAME_pain619         	405
#define FRAME_pain620         	406
#define FRAME_pain621         	407
#define FRAME_pain622         	408
#define FRAME_pain623         	409
#define FRAME_pain624         	410
#define FRAME_pain625         	411
#define FRAME_pain626         	412
#define FRAME_pain627         	413
#define FRAME_stand201        	414
#define FRAME_stand202        	415
#define FRAME_stand203        	416
#define FRAME_stand204        	417
#define FRAME_stand205        	418
#define FRAME_stand206        	419
#define FRAME_stand207        	420
#define FRAME_stand208        	421
#define FRAME_stand209        	422
#define FRAME_stand210        	423
#define FRAME_stand211        	424
#define FRAME_stand212        	425
#define FRAME_stand213        	426
#define FRAME_stand214        	427
#define FRAME_stand215        	428
#define FRAME_stand216        	429
#define FRAME_stand217        	430
#define FRAME_stand218        	431
#define FRAME_stand219        	432
#define FRAME_stand220        	433
#define FRAME_stand221        	434
#define FRAME_stand222        	435
#define FRAME_stand223        	436
#define FRAME_stand224        	437
#define FRAME_stand225        	438
#define FRAME_stand226        	439
#define FRAME_stand227        	440
#define FRAME_stand228        	441
#define FRAME_stand229        	442
#define FRAME_stand230        	443
#define FRAME_stand231        	444
#define FRAME_stand232        	445
#define FRAME_stand233        	446
#define FRAME_stand234        	447
#define FRAME_stand235        	448
#define FRAME_stand236        	449
#define FRAME_stand237        	450
#define FRAME_stand238        	451
#define FRAME_stand239        	452
#define FRAME_stand240        	453
#define FRAME_stand241        	454
#define FRAME_stand242        	455
#define FRAME_stand243        	456
#define FRAME_stand244        	457
#define FRAME_stand245        	458
#define FRAME_stand246        	459
#define FRAME_stand247        	460
#define FRAME_stand248        	461
#define FRAME_stand249        	462
#define FRAME_stand250        	463
#define FRAME_stand251        	464
#define FRAME_stand252        	465
#define FRAME_stand253        	466
#define FRAME_stand254        	467
#define FRAME_stand255        	468
#define FRAME_stand256        	469
#define FRAME_stand257        	470
#define FRAME_stand258        	471
#define FRAME_stand259        	472
#define FRAME_stand260        	473
#define FRAME_walk201         	474
#define FRAME_walk202         	475
#define FRAME_walk203         	476
#define FRAME_walk204         	477
#define FRAME_walk205         	478
#define FRAME_walk206         	479
#define FRAME_walk207         	480
#define FRAME_walk208         	481
#define FRAME_walk209         	482
#define FRAME_walk210         	483
#define FRAME_walk211         	484
#define FRAME_walk212         	485
#define FRAME_walk213         	486
#define FRAME_walk214         	487
#define FRAME_walk215         	488
#define FRAME_walk216         	489
#define FRAME_walk217         	490
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_boss32.h' &&
  chmod 0664 'm_boss32.h' ||
  $echo 'restore of' 'm_boss32.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_boss32.h:' 'MD5 check failed'
f92293faae681282470a7b3225b81645  m_boss32.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_boss32.h'`"
    test 17207 -eq "$shar_count" ||
    $echo 'm_boss32.h:' 'original size' '17207,' 'current size' "$shar_count!"
  fi
fi
# ============= m_brain.c ==============
if test -f 'm_brain.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_brain.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_brain.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_brain.c' &&
/*
==============================================================================
X
brain
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_brain.h"
X
X
static int	sound_chest_open;
static int	sound_tentacles_extend;
static int	sound_tentacles_retract;
static int	sound_death;
static int	sound_idle1;
static int	sound_idle2;
static int	sound_idle3;
static int	sound_pain1;
static int	sound_pain2;
static int	sound_sight;
static int	sound_search;
static int	sound_melee1;
static int	sound_melee2;
static int	sound_melee3;
X
X
void brain_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void brain_search (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
}
X
X
void brain_run (edict_t *self);
void brain_dead (edict_t *self);
X
X
//
// STAND
//
X
mframe_t brain_frames_stand [] =
{
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL
};
mmove_t brain_move_stand = {FRAME_stand01, FRAME_stand30, brain_frames_stand, NULL};
X
void brain_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &brain_move_stand;
}
X
X
//
// IDLE
//
X
mframe_t brain_frames_idle [] =
{
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL
};
mmove_t brain_move_idle = {FRAME_stand31, FRAME_stand60, brain_frames_idle, brain_stand};
X
void brain_idle (edict_t *self)
{
X	gi.sound (self, CHAN_AUTO, sound_idle3, 1, ATTN_IDLE, 0);
X	self->monsterinfo.currentmove = &brain_move_idle;
}
X
X
//
// WALK
//
mframe_t brain_frames_walk1 [] =
{
X	ai_walk,	7,	NULL,
X	ai_walk,	2,	NULL,
X	ai_walk,	3,	NULL,
X	ai_walk,	3,	NULL,
X	ai_walk,	1,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	9,	NULL,
X	ai_walk,	-4,	NULL,
X	ai_walk,	-1,	NULL,
X	ai_walk,	2,	NULL
};
mmove_t brain_move_walk1 = {FRAME_walk101, FRAME_walk111, brain_frames_walk1, NULL};
X
// walk2 is FUBAR, do not use
#if 0
void brain_walk2_cycle (edict_t *self)
{
X	if (random() > 0.1)
X		self->monsterinfo.nextframe = FRAME_walk220;
}
X
mframe_t brain_frames_walk2 [] =
{
X	ai_walk,	3,	NULL,
X	ai_walk,	-2,	NULL,
X	ai_walk,	-4,	NULL,
X	ai_walk,	-3,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	1,	NULL,
X	ai_walk,	12,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	-3,	NULL,
X	ai_walk,	0,	NULL,
X
X	ai_walk,	-2,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	1,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	10,	NULL,		// Cycle Start
X
X	ai_walk,	-1,	NULL,
X	ai_walk,	7,	NULL,
X	ai_walk,	0,	NULL,
X	ai_walk,	3,	NULL,
X	ai_walk,	-3,	NULL,
X	ai_walk,	2,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	-3,	NULL,
X	ai_walk,	2,	NULL,
X	ai_walk,	0,	NULL,
X
X	ai_walk,	4,	brain_walk2_cycle,
X	ai_walk,	-1,	NULL,
X	ai_walk,	-1,	NULL,
X	ai_walk,	-8,	NULL,		
X	ai_walk,	0,	NULL,
X	ai_walk,	1,	NULL,
X	ai_walk,	5,	NULL,
X	ai_walk,	2,	NULL,
X	ai_walk,	-1,	NULL,
X	ai_walk,	-5,	NULL
};
mmove_t brain_move_walk2 = {FRAME_walk201, FRAME_walk240, brain_frames_walk2, NULL};
#endif
X
void brain_walk (edict_t *self)
{
//	if (random() <= 0.5)
X		self->monsterinfo.currentmove = &brain_move_walk1;
//	else
//		self->monsterinfo.currentmove = &brain_move_walk2;
}
X
X
X
mframe_t brain_frames_defense [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t brain_move_defense = {FRAME_defens01, FRAME_defens08, brain_frames_defense, NULL};
X
mframe_t brain_frames_pain3 [] =
{
X	ai_move,	-2,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-4,	NULL
};
mmove_t brain_move_pain3 = {FRAME_pain301, FRAME_pain306, brain_frames_pain3, brain_run};
X
mframe_t brain_frames_pain2 [] =
{
X	ai_move,	-2,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	-2,	NULL
};
mmove_t brain_move_pain2 = {FRAME_pain201, FRAME_pain208, brain_frames_pain2, brain_run};
X
mframe_t brain_frames_pain1 [] =
{
X	ai_move,	-6,	NULL,
X	ai_move,	-2,	NULL,
X	ai_move,	-6,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	7,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	-1,	NULL
};
mmove_t brain_move_pain1 = {FRAME_pain101, FRAME_pain121, brain_frames_pain1, brain_run};
X
mframe_t brain_frames_duck [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	-2,	monster_duck_down,
X	ai_move,	17,	monster_duck_hold,
X	ai_move,	-3,	NULL,
X	ai_move,	-1,	monster_duck_up,
X	ai_move,	-5,	NULL,
X	ai_move,	-6,	NULL,
X	ai_move,	-6,	NULL
};
mmove_t brain_move_duck = {FRAME_duck01, FRAME_duck08, brain_frames_duck, brain_run};
X
/*
void brain_dodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
X	//========
X	//PMM - new dodge code
X	float	r;
X	float	height;
X
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget (self);
X	}
X
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X		return;
X
X	r = random();
X	if (r > (0.25*((skill->value)+1)))
X		return;
X
X	if (self->monsterinfo.aiflags & AI_DODGING)
X	{
X		height = self->absmax[2];
X	}
X	else
X	{
X		height = self->absmax[2]-32-1;  // the -1 is because the absmax is s.origin + maxs + 1
X	}
X
X	// check to see if it makes sense to duck
X	if (tr->endpos[2] <= height)
X	{
X		// if it doesn't sense to duck, try to strafe and shoot
X		// FIXME - this guy is so slow, it's not worth it
X
X		//vec3_t forward,right,up,diff;
X
X		monster_done_dodge (self);
X		return;
X	}
X
X	if (skill->value == 0)
X	{
X		self->monsterinfo.currentmove = &brain_move_duck;
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		self->monsterinfo.aiflags |= AI_DODGING;
X		return;
X	}
X
X	self->monsterinfo.currentmove = &brain_move_duck;
X	self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X	self->monsterinfo.aiflags |= AI_DODGING;
X	return;
X	//============
X	//PMM
}
*/
X
mframe_t brain_frames_death2 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	9,	NULL,
X	ai_move,	0,	NULL
};
mmove_t brain_move_death2 = {FRAME_death201, FRAME_death205, brain_frames_death2, brain_dead};
X
mframe_t brain_frames_death1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-2,	NULL,
X	ai_move,	9,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t brain_move_death1 = {FRAME_death101, FRAME_death118, brain_frames_death1, brain_dead};
X
X
//
// MELEE
//
X
void brain_swing_right (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_melee1, 1, ATTN_NORM, 0);
}
X
void brain_hit_right (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->maxs[0], 8);
X	if (fire_hit (self, aim, (15 + (rand() %5)), 40))
X		gi.sound (self, CHAN_WEAPON, sound_melee3, 1, ATTN_NORM, 0);
}
X
void brain_swing_left (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_melee2, 1, ATTN_NORM, 0);
}
X
void brain_hit_left (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->mins[0], 8);
X	if (fire_hit (self, aim, (15 + (rand() %5)), 40))
X		gi.sound (self, CHAN_WEAPON, sound_melee3, 1, ATTN_NORM, 0);
}
X
mframe_t brain_frames_attack1 [] =
{
X	ai_charge,	8,	NULL,
X	ai_charge,	3,	NULL,
X	ai_charge,	5,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	-3,	brain_swing_right,
X	ai_charge,	0,	NULL,
X	ai_charge,	-5,	NULL,
X	ai_charge,	-7,	brain_hit_right,
X	ai_charge,	0,	NULL,
X	ai_charge,	6,	brain_swing_left,
X	ai_charge,	1,	NULL,
X	ai_charge,	2,	brain_hit_left,
X	ai_charge,	-3,	NULL,
X	ai_charge,	6,	NULL,
X	ai_charge,	-1,	NULL,
X	ai_charge,	-3,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	-11,NULL
};
mmove_t brain_move_attack1 = {FRAME_attak101, FRAME_attak118, brain_frames_attack1, brain_run};
X
void brain_chest_open (edict_t *self)
{
X	self->spawnflags &= ~65536;
X	self->monsterinfo.power_armor_type = POWER_ARMOR_NONE;
X	gi.sound (self, CHAN_BODY, sound_chest_open, 1, ATTN_NORM, 0);
}
X
void brain_tentacle_attack (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, 0, 8);
X	if (fire_hit (self, aim, (10 + (rand() %5)), -600) && skill->value > 0)
X		self->spawnflags |= 65536;
X	gi.sound (self, CHAN_WEAPON, sound_tentacles_retract, 1, ATTN_NORM, 0);
}
X
void brain_chest_closed (edict_t *self)
{
X	self->monsterinfo.power_armor_type = POWER_ARMOR_SCREEN;
X	if (self->spawnflags & 65536)
X	{
X		self->spawnflags &= ~65536;
X		self->monsterinfo.currentmove = &brain_move_attack1;
X	}
}
X
mframe_t brain_frames_attack2 [] =
{
X	ai_charge,	5,	NULL,
X	ai_charge,	-4,	NULL,
X	ai_charge,	-4,	NULL,
X	ai_charge,	-3,	NULL,
X	ai_charge,	0,	brain_chest_open,
X	ai_charge,	0,	NULL,
X	ai_charge,	13,	brain_tentacle_attack,
X	ai_charge,	0,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	-9,	brain_chest_closed,
X	ai_charge,	0,	NULL,
X	ai_charge,	4,	NULL,
X	ai_charge,	3,	NULL,
X	ai_charge,	2,	NULL,
X	ai_charge,	-3,	NULL,
X	ai_charge,	-6,	NULL
};
mmove_t brain_move_attack2 = {FRAME_attak201, FRAME_attak217, brain_frames_attack2, brain_run};
X
void brain_melee(edict_t *self)
{
X	if (random() <= 0.5)
X		self->monsterinfo.currentmove = &brain_move_attack1;
X	else
X		self->monsterinfo.currentmove = &brain_move_attack2;
}
X
X
//
// RUN
//
X
mframe_t brain_frames_run [] =
{
X	ai_run,	9,	NULL,
X	ai_run,	2,	NULL,
X	ai_run,	3,	NULL,
X	ai_run,	3,	NULL,
X	ai_run,	1,	NULL,
X	ai_run,	0,	NULL,
X	ai_run,	0,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	-4,	NULL,
X	ai_run,	-1,	NULL,
X	ai_run,	2,	NULL
};
mmove_t brain_move_run = {FRAME_walk101, FRAME_walk111, brain_frames_run, NULL};
X
void brain_run (edict_t *self)
{
X	self->monsterinfo.power_armor_type = POWER_ARMOR_SCREEN;
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &brain_move_stand;
X	else
X		self->monsterinfo.currentmove = &brain_move_run;
}
X
X
void brain_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	float	r;
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	r = random();
X	if (r < 0.33)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &brain_move_pain1;
X	}
X	else if (r < 0.66)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &brain_move_pain2;
X	}
X	else
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &brain_move_pain3;
X	}
X	// PMM - clear duck flag
X	if (self->monsterinfo.aiflags & AI_DUCKED)
X		monster_duck_up(self);
}
X
void brain_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
X
X
void brain_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
X	self->s.effects = 0;
X	self->monsterinfo.power_armor_type = POWER_ARMOR_NONE;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	if (random() <= 0.5)
X		self->monsterinfo.currentmove = &brain_move_death1;
X	else
X		self->monsterinfo.currentmove = &brain_move_death2;
}
X
void brain_duck (edict_t *self, float eta)
{
X	// has to be done immediately otherwise he can get stuck
X	monster_duck_down(self);
X
X	if (skill->value == 0)
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X	else
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X
X	self->monsterinfo.currentmove = &brain_move_duck;
X	self->monsterinfo.nextframe = FRAME_duck01;
X	return;
}
X
X
/*QUAKED monster_brain (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_brain (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_chest_open = gi.soundindex ("brain/brnatck1.wav");
X	sound_tentacles_extend = gi.soundindex ("brain/brnatck2.wav");
X	sound_tentacles_retract = gi.soundindex ("brain/brnatck3.wav");
X	sound_death = gi.soundindex ("brain/brndeth1.wav");
X	sound_idle1 = gi.soundindex ("brain/brnidle1.wav");
X	sound_idle2 = gi.soundindex ("brain/brnidle2.wav");
X	sound_idle3 = gi.soundindex ("brain/brnlens1.wav");
X	sound_pain1 = gi.soundindex ("brain/brnpain1.wav");
X	sound_pain2 = gi.soundindex ("brain/brnpain2.wav");
X	sound_sight = gi.soundindex ("brain/brnsght1.wav");
X	sound_search = gi.soundindex ("brain/brnsrch1.wav");
X	sound_melee1 = gi.soundindex ("brain/melee1.wav");
X	sound_melee2 = gi.soundindex ("brain/melee2.wav");
X	sound_melee3 = gi.soundindex ("brain/melee3.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/brain/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X
X	self->health = 300;
X	self->gib_health = -150;
X	self->mass = 400;
X
X	self->pain = brain_pain;
X	self->die = brain_die;
X
X	self->monsterinfo.stand = brain_stand;
X	self->monsterinfo.walk = brain_walk;
X	self->monsterinfo.run = brain_run;
// PMM
X	self->monsterinfo.dodge = M_MonsterDodge;
X	self->monsterinfo.duck = brain_duck;
X	self->monsterinfo.unduck = monster_duck_up;
//	self->monsterinfo.dodge = brain_dodge;
// pmm
//	self->monsterinfo.attack = brain_attack;
X	self->monsterinfo.melee = brain_melee;
X	self->monsterinfo.sight = brain_sight;
X	self->monsterinfo.search = brain_search;
X	self->monsterinfo.idle = brain_idle;
X
X	self->monsterinfo.power_armor_type = POWER_ARMOR_SCREEN;
X	self->monsterinfo.power_armor_power = 100;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &brain_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_brain.c' &&
  chmod 0664 'm_brain.c' ||
  $echo 'restore of' 'm_brain.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_brain.c:' 'MD5 check failed'
b924027ddbd2f2a6fd95736039f78913  m_brain.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_brain.c'`"
    test 15671 -eq "$shar_count" ||
    $echo 'm_brain.c:' 'original size' '15671,' 'current size' "$shar_count!"
  fi
fi
# ============= m_brain.h ==============
if test -f 'm_brain.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_brain.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_brain.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_brain.h' &&
// G:\quake2\baseq2\models/monsters/brain
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_walk101         	0
#define FRAME_walk102         	1
#define FRAME_walk103         	2
#define FRAME_walk104         	3
#define FRAME_walk105         	4
#define FRAME_walk106         	5
#define FRAME_walk107         	6
#define FRAME_walk108         	7
#define FRAME_walk109         	8
#define FRAME_walk110         	9
#define FRAME_walk111         	10
#define FRAME_walk112         	11
#define FRAME_walk113         	12
#define FRAME_walk201         	13
#define FRAME_walk202         	14
#define FRAME_walk203         	15
#define FRAME_walk204         	16
#define FRAME_walk205         	17
#define FRAME_walk206         	18
#define FRAME_walk207         	19
#define FRAME_walk208         	20
#define FRAME_walk209         	21
#define FRAME_walk210         	22
#define FRAME_walk211         	23
#define FRAME_walk212         	24
#define FRAME_walk213         	25
#define FRAME_walk214         	26
#define FRAME_walk215         	27
#define FRAME_walk216         	28
#define FRAME_walk217         	29
#define FRAME_walk218         	30
#define FRAME_walk219         	31
#define FRAME_walk220         	32
#define FRAME_walk221         	33
#define FRAME_walk222         	34
#define FRAME_walk223         	35
#define FRAME_walk224         	36
#define FRAME_walk225         	37
#define FRAME_walk226         	38
#define FRAME_walk227         	39
#define FRAME_walk228         	40
#define FRAME_walk229         	41
#define FRAME_walk230         	42
#define FRAME_walk231         	43
#define FRAME_walk232         	44
#define FRAME_walk233         	45
#define FRAME_walk234         	46
#define FRAME_walk235         	47
#define FRAME_walk236         	48
#define FRAME_walk237         	49
#define FRAME_walk238         	50
#define FRAME_walk239         	51
#define FRAME_walk240         	52
#define FRAME_attak101        	53
#define FRAME_attak102        	54
#define FRAME_attak103        	55
#define FRAME_attak104        	56
#define FRAME_attak105        	57
#define FRAME_attak106        	58
#define FRAME_attak107        	59
#define FRAME_attak108        	60
#define FRAME_attak109        	61
#define FRAME_attak110        	62
#define FRAME_attak111        	63
#define FRAME_attak112        	64
#define FRAME_attak113        	65
#define FRAME_attak114        	66
#define FRAME_attak115        	67
#define FRAME_attak116        	68
#define FRAME_attak117        	69
#define FRAME_attak118        	70
#define FRAME_attak201        	71
#define FRAME_attak202        	72
#define FRAME_attak203        	73
#define FRAME_attak204        	74
#define FRAME_attak205        	75
#define FRAME_attak206        	76
#define FRAME_attak207        	77
#define FRAME_attak208        	78
#define FRAME_attak209        	79
#define FRAME_attak210        	80
#define FRAME_attak211        	81
#define FRAME_attak212        	82
#define FRAME_attak213        	83
#define FRAME_attak214        	84
#define FRAME_attak215        	85
#define FRAME_attak216        	86
#define FRAME_attak217        	87
#define FRAME_pain101         	88
#define FRAME_pain102         	89
#define FRAME_pain103         	90
#define FRAME_pain104         	91
#define FRAME_pain105         	92
#define FRAME_pain106         	93
#define FRAME_pain107         	94
#define FRAME_pain108         	95
#define FRAME_pain109         	96
#define FRAME_pain110         	97
#define FRAME_pain111         	98
#define FRAME_pain112         	99
#define FRAME_pain113         	100
#define FRAME_pain114         	101
#define FRAME_pain115         	102
#define FRAME_pain116         	103
#define FRAME_pain117         	104
#define FRAME_pain118         	105
#define FRAME_pain119         	106
#define FRAME_pain120         	107
#define FRAME_pain121         	108
#define FRAME_pain201         	109
#define FRAME_pain202         	110
#define FRAME_pain203         	111
#define FRAME_pain204         	112
#define FRAME_pain205         	113
#define FRAME_pain206         	114
#define FRAME_pain207         	115
#define FRAME_pain208         	116
#define FRAME_pain301         	117
#define FRAME_pain302         	118
#define FRAME_pain303         	119
#define FRAME_pain304         	120
#define FRAME_pain305         	121
#define FRAME_pain306         	122
#define FRAME_death101        	123
#define FRAME_death102        	124
#define FRAME_death103        	125
#define FRAME_death104        	126
#define FRAME_death105        	127
#define FRAME_death106        	128
#define FRAME_death107        	129
#define FRAME_death108        	130
#define FRAME_death109        	131
#define FRAME_death110        	132
#define FRAME_death111        	133
#define FRAME_death112        	134
#define FRAME_death113        	135
#define FRAME_death114        	136
#define FRAME_death115        	137
#define FRAME_death116        	138
#define FRAME_death117        	139
#define FRAME_death118        	140
#define FRAME_death201        	141
#define FRAME_death202        	142
#define FRAME_death203        	143
#define FRAME_death204        	144
#define FRAME_death205        	145
#define FRAME_duck01          	146
#define FRAME_duck02          	147
#define FRAME_duck03          	148
#define FRAME_duck04          	149
#define FRAME_duck05          	150
#define FRAME_duck06          	151
#define FRAME_duck07          	152
#define FRAME_duck08          	153
#define FRAME_defens01        	154
#define FRAME_defens02        	155
#define FRAME_defens03        	156
#define FRAME_defens04        	157
#define FRAME_defens05        	158
#define FRAME_defens06        	159
#define FRAME_defens07        	160
#define FRAME_defens08        	161
#define FRAME_stand01         	162
#define FRAME_stand02         	163
#define FRAME_stand03         	164
#define FRAME_stand04         	165
#define FRAME_stand05         	166
#define FRAME_stand06         	167
#define FRAME_stand07         	168
#define FRAME_stand08         	169
#define FRAME_stand09         	170
#define FRAME_stand10         	171
#define FRAME_stand11         	172
#define FRAME_stand12         	173
#define FRAME_stand13         	174
#define FRAME_stand14         	175
#define FRAME_stand15         	176
#define FRAME_stand16         	177
#define FRAME_stand17         	178
#define FRAME_stand18         	179
#define FRAME_stand19         	180
#define FRAME_stand20         	181
#define FRAME_stand21         	182
#define FRAME_stand22         	183
#define FRAME_stand23         	184
#define FRAME_stand24         	185
#define FRAME_stand25         	186
#define FRAME_stand26         	187
#define FRAME_stand27         	188
#define FRAME_stand28         	189
#define FRAME_stand29         	190
#define FRAME_stand30         	191
#define FRAME_stand31         	192
#define FRAME_stand32         	193
#define FRAME_stand33         	194
#define FRAME_stand34         	195
#define FRAME_stand35         	196
#define FRAME_stand36         	197
#define FRAME_stand37         	198
#define FRAME_stand38         	199
#define FRAME_stand39         	200
#define FRAME_stand40         	201
#define FRAME_stand41         	202
#define FRAME_stand42         	203
#define FRAME_stand43         	204
#define FRAME_stand44         	205
#define FRAME_stand45         	206
#define FRAME_stand46         	207
#define FRAME_stand47         	208
#define FRAME_stand48         	209
#define FRAME_stand49         	210
#define FRAME_stand50         	211
#define FRAME_stand51         	212
#define FRAME_stand52         	213
#define FRAME_stand53         	214
#define FRAME_stand54         	215
#define FRAME_stand55         	216
#define FRAME_stand56         	217
#define FRAME_stand57         	218
#define FRAME_stand58         	219
#define FRAME_stand59         	220
#define FRAME_stand60         	221
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_brain.h' &&
  chmod 0664 'm_brain.h' ||
  $echo 'restore of' 'm_brain.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_brain.h:' 'MD5 check failed'
ada95c425789852f61b39e56e4aaa3fd  m_brain.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_brain.h'`"
    test 7786 -eq "$shar_count" ||
    $echo 'm_brain.h:' 'original size' '7786,' 'current size' "$shar_count!"
  fi
fi
# ============= m_carrier.c ==============
if test -f 'm_carrier.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_carrier.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_carrier.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_carrier.c' &&
/*
==============================================================================
X
carrier
X
==============================================================================
*/
X
// self->timestamp used for frame calculations in grenade & spawn code
// self->wait used to prevent rapid refire of rocket launcher
X
#include "g_local.h"
#include "m_carrier.h"
X
#define	CARRIER_ROCKET_TIME		2		// number of seconds between rocket shots
#define CARRIER_ROCKET_SPEED	750
#define	NUM_FLYERS_SPAWNED		6		// max # of flyers he can spawn
X
#define	RAIL_FIRE_TIME			3
X
void BossExplode (edict_t *self);
void Grenade_Explode (edict_t *ent);
X
qboolean infront (edict_t *self, edict_t *other);
qboolean inback (edict_t *self, edict_t *other);
qboolean below (edict_t *self, edict_t *other);
void drawbbox (edict_t *self);
X
//char *ED_NewString (char *string);
void ED_CallSpawn (edict_t *ent);
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_pain3;
static int	sound_death;
//static int	sound_search1;
static int	sound_sight;
static int	sound_rail;
static int	sound_spawn;
X
float	orig_yaw_speed;
X
vec3_t flyer_mins = {-16, -16, -24};
vec3_t flyer_maxs = {16, 16, 16};
X
extern mmove_t flyer_move_attack2, flyer_move_attack3, flyer_move_kamikaze;
X
X
void carrier_run (edict_t *self);
void carrier_stand (edict_t *self);
void carrier_dead (edict_t *self);
void carrier_attack (edict_t *self);
void carrier_attack_mg (edict_t *self);
void carrier_reattack_mg (edict_t *self);
void carrier_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
X
void carrier_attack_gren (edict_t *self);
void carrier_reattack_gren (edict_t *self);
X
void carrier_start_spawn (edict_t *self);
void carrier_spawn_check (edict_t *self);
void carrier_prep_spawn (edict_t *self);
X
void CarrierMachineGunHold (edict_t *self);
void CarrierRocket (edict_t *self);
X
X
void carrier_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
// code starts here
//void carrier_search (edict_t *self)
//{
//	if (random() < 0.5)
//		gi.sound (self, CHAN_VOICE, sound_search1, 1, ATTN_NONE, 0);
//}
X
//
// this is the smarts for the rocket launcher in coop
//
// if there is a player behind/below the carrier, and we can shoot, and we can trace a LOS to them ..
// pick one of the group, and let it rip
void CarrierCoopCheck (edict_t *self)
{
X	// no more than 4 players in coop, so..
X	edict_t *targets[4];
X	int		num_targets = 0, target, player;
X	edict_t *ent;
X	trace_t	tr;
X
X	// if we're not in coop, this is a noop
X	if (!coop || !coop->value)
X		return;
X	// if we are, and we have recently fired, bail
X	if (self->wait > level.time)
X		return;
X
X	memset (targets, 0, 4*sizeof(edict_t *));
X
X	// cycle through players
X	for (player = 1; player <= game.maxclients; player++)
X	{
X		ent = &g_edicts[player];
X		if (!ent->inuse)
X			continue;
X		if (!ent->client)
X			continue;
X		if (inback(self, ent) || below(self, ent))
X		{
X			tr = gi.trace (self->s.origin, NULL, NULL, ent->s.origin, self, MASK_SOLID);
X			if (tr.fraction == 1.0)
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("Carrier: found a player who I can shoot\n");
X				targets[num_targets++] = ent;
X			}
X		}
X	}
X
X	if (!num_targets)
X		return;
X
X	// get a number from 0 to (num_targets-1)
X	target = random() * num_targets;
X	
X	// just in case we got a 1.0 from random
X	if (target == num_targets)
X		target--;
X
X	// make sure to prevent rapid fire rockets
X	self->wait = level.time + CARRIER_ROCKET_TIME;
X
X	// save off the real enemy
X	ent = self->enemy;
X	// set the new guy as temporary enemy
X	self->enemy = targets[target];
X	CarrierRocket (self);
X	// put the real enemy back
X	self->enemy = ent;
X
X	// we're done
X	return;
}
X
void CarrierGrenade (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	forward, right, up;
X	vec3_t	aim;
X	int		flash_number;
X	float	direction;		// from lower left to upper right, or lower right to upper left
X	float	spreadR, spreadU;
X	int		mytime;
X
X	CarrierCoopCheck(self);
X
X	if (!self->enemy)
X		return;
X
X	if (random() < 0.5)
X		direction = -1.0;
X	else
X		direction = 1.0;
X
X	mytime = (int)((level.time - self->timestamp)/0.4);
X
X	if (mytime == 0)
X	{
X		spreadR = 0.15 * direction;
//		spreadU = 0.1 * direction;
X		spreadU = 0.1 - 0.1 * direction;
X	}
X	else if (mytime == 1)
X	{
X		spreadR = 0;
//		spreadU = 0;
X		spreadU = 0.1;
X	}
X	else if (mytime == 2)
X	{
X		spreadR = -0.15 * direction;
//		spreadU = -0.1 * direction;
X		spreadU = 0.1 - -0.1 * direction;
X	}
X	else if (mytime == 3)
X	{
X		spreadR = 0;
//		spreadU = 0;
X		spreadU = 0.1;
X	}
X	else
X	{
X		// error, shoot straight
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("CarrierGrenade: bad time  %2.2f   %2.2f\n", level.time, self->timestamp);
X		spreadR = 0;
X		spreadU = 0;
X	}
X
X	AngleVectors (self->s.angles, forward, right, up);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_GRENADE], forward, right, start);
X
X	VectorSubtract (self->enemy->s.origin, start, aim);
X	VectorNormalize (aim);
X
X	VectorMA (aim, spreadR, right, aim);
X	VectorMA (aim, spreadU, up, aim);
X
X	if(aim[2] > 0.15)
X		aim[2] = 0.15;
X	else if(aim[2] < -0.5)
X		aim[2] = -0.5;
X
X	flash_number = MZ2_GUNNER_GRENADE_1;
X	monster_fire_grenade (self, start, aim, 50, 600, flash_number);
}
X
void CarrierPredictiveRocket  (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf("predictive fire\n");
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X
//1
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_1], forward, right, start);
X	PredictAim (self->enemy, start, CARRIER_ROCKET_SPEED, false, -0.3, dir, NULL);
X	monster_fire_rocket (self, start, dir, 50, CARRIER_ROCKET_SPEED, MZ2_CARRIER_ROCKET_1);
X
//2
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_2], forward, right, start);
X	PredictAim (self->enemy, start, CARRIER_ROCKET_SPEED, false, -0.15, dir, NULL);
X	monster_fire_rocket (self, start, dir, 50, CARRIER_ROCKET_SPEED, MZ2_CARRIER_ROCKET_2);
X
//3
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_3], forward, right, start);
X	PredictAim (self->enemy, start, CARRIER_ROCKET_SPEED, false, 0, dir, NULL);
X	monster_fire_rocket (self, start, dir, 50, CARRIER_ROCKET_SPEED, MZ2_CARRIER_ROCKET_3);
X
//4
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_4], forward, right, start);
X	PredictAim (self->enemy, start, CARRIER_ROCKET_SPEED, false, 0.15, dir, NULL);
X	monster_fire_rocket (self, start, dir, 50, CARRIER_ROCKET_SPEED, MZ2_CARRIER_ROCKET_4);
}	
X
void CarrierRocket (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X
X	if(self->enemy)
X	{
X		if(self->enemy->client && random() < 0.5)
X		{
X			CarrierPredictiveRocket(self);
X			return;
X		}
X	}
X	else
X		return;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X
//1
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_1], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	vec[2] -= 15;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, 0.4, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_CARRIER_ROCKET_1);
X
//2
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_2], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, 0.025, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_CARRIER_ROCKET_2);
X
//3
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_3], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, -0.025, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_CARRIER_ROCKET_3);
X
//4
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_ROCKET_4], forward, right, start);
X	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
X	vec[2] -= 15;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X	VectorMA (dir, -0.4, right, dir);
X	VectorNormalize (dir);
X	monster_fire_rocket (self, start, dir, 50, 500, MZ2_CARRIER_ROCKET_4);
X
//5
//	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_BOSS2_ROCKET_4], forward, right, start);
//	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
//	VectorSubtract (vec, start, dir);
//	VectorNormalize (dir);
//	monster_fire_rocket (self, start, dir, 50, 500, MZ2_BOSS2_ROCKET_2);
}	
X
void carrier_firebullet_right (edict_t *self)
{
X	vec3_t	forward, right, target;
X	vec3_t	start;
X	int		flashnum;
X
X	// if we're in manual steering mode, it means we're leaning down .. use the lower shot
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X		flashnum = MZ2_CARRIER_MACHINEGUN_R2;
X	else
X		flashnum = MZ2_CARRIER_MACHINEGUN_R1;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flashnum], forward, right, start);
X
//	VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X	VectorMA (self->enemy->s.origin, 0.2, self->enemy->velocity, target);
X	target[2] += self->enemy->viewheight;
/*
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_DEBUGTRAIL);
X			gi.WritePosition (start);
X			gi.WritePosition (target);
X			gi.multicast (start, MULTICAST_ALL);	
*/
X	VectorSubtract (target, start, forward);
X	VectorNormalize (forward);
X
X	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD*3, DEFAULT_BULLET_VSPREAD, flashnum);
}	
X
void carrier_firebullet_left (edict_t *self)
{
X	vec3_t	forward, right, target;
X	vec3_t	start;
X	int		flashnum;
X
X	// if we're in manual steering mode, it means we're leaning down .. use the lower shot
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X		flashnum = MZ2_CARRIER_MACHINEGUN_L2;
X	else
X		flashnum = MZ2_CARRIER_MACHINEGUN_L1;
X	
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flashnum], forward, right, start);
X
//	VectorMA (self->enemy->s.origin, 0.2, self->enemy->velocity, target);
X	VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X
X	target[2] += self->enemy->viewheight;
X	VectorSubtract (target, start, forward);
/*
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_DEBUGTRAIL);
X			gi.WritePosition (start);
X			gi.WritePosition (target);
X			gi.multicast (start, MULTICAST_ALL);	
*/
X	VectorNormalize (forward);
X
X	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD*3, DEFAULT_BULLET_VSPREAD, flashnum);
}	
X
void CarrierMachineGun (edict_t *self)
{
X	CarrierCoopCheck(self);
X	if (self->enemy)
X		carrier_firebullet_left(self);
X	if (self->enemy)
X		carrier_firebullet_right(self);
}	
X
void CarrierSpawn (edict_t *self)
{
X	vec3_t	f, r, offset, startpoint, spawnpoint;
X	edict_t	*ent;
X	int		mytime;
X
//	VectorSet (offset, 105, 0, -30); // real distance needed is (sqrt (56*56*2) + sqrt(16*16*2)) or 101.8
X	VectorSet (offset, 105, 0, -58); // real distance needed is (sqrt (56*56*2) + sqrt(16*16*2)) or 101.8
X	AngleVectors (self->s.angles, f, r, NULL);
X
X	G_ProjectSource (self->s.origin, offset, f, r, startpoint);
X
X	// the +0.1 is because level.time is sometimes a little low
X	mytime = (int)((level.time + 0.1 - self->timestamp)/0.5);
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("mytime = %d, (%2.2f)\n", mytime, level.time - self->timestamp);
X
X	if (FindSpawnPoint (startpoint, flyer_mins, flyer_maxs, spawnpoint, 32))
X	{
X		// the second flier should be a kamikaze flyer
X		if (mytime != 2)
X			ent = CreateMonster (spawnpoint, self->s.angles, "monster_flyer");
X		else
X			ent = CreateMonster (spawnpoint, self->s.angles, "monster_kamikaze");
X
X		if (!ent)
X			return;
X
X		gi.sound (self, CHAN_BODY, sound_spawn, 1, ATTN_NONE, 0);
X
X		self->monsterinfo.monster_slots--;
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("carrier: post-spawn : %d slots left\n", self->monsterinfo.monster_slots);
X
X		ent->nextthink = level.time;
X		ent->think (ent);
X		
X		ent->monsterinfo.aiflags |= AI_SPAWNED_CARRIER|AI_DO_NOT_COUNT|AI_IGNORE_SHOTS;
X		ent->monsterinfo.commander = self;
X
X		if ((self->enemy->inuse) && (self->enemy->health > 0))
X		{
X			ent->enemy = self->enemy;
X			FoundTarget (ent);
X			if (mytime == 1)
X			{
X				ent->monsterinfo.lefty = 0;
X				ent->monsterinfo.attack_state = AS_SLIDING;
X				ent->monsterinfo.currentmove = &flyer_move_attack3;
X			}
X			else if (mytime == 2)
X			{
X				ent->monsterinfo.lefty = 0;
X				ent->monsterinfo.attack_state = AS_STRAIGHT;
X				ent->monsterinfo.currentmove = &flyer_move_kamikaze;
X				ent->mass = 100;
X				ent->monsterinfo.aiflags |= AI_CHARGING;
X			}
X			else if (mytime == 3)
X			{
X				ent->monsterinfo.lefty = 1;
X				ent->monsterinfo.attack_state = AS_SLIDING;
X				ent->monsterinfo.currentmove = &flyer_move_attack3;
X			}
//			else if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("carrier:  unexpected time %d!\n", mytime);
X		}
X	}
}
X
void carrier_prep_spawn (edict_t *self)
{
X	CarrierCoopCheck(self);
X	self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X	self->timestamp = level.time;
X	self->yaw_speed = 10;
X	CarrierMachineGun(self);
}
X
void carrier_spawn_check (edict_t *self)
{
//	gi.dprintf ("times - %2.2f %2.2f\n", level.time, self->timestamp);
X	CarrierCoopCheck(self);
X	CarrierMachineGun(self);
X	CarrierSpawn (self);
X
X	if (level.time > (self->timestamp + 1.1))  // 0.5 seconds per flyer.  this gets three
X	{
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		self->yaw_speed = orig_yaw_speed;
X		return;
X	}
X	else
X		self->monsterinfo.nextframe = FRAME_spawn08;
}
X
void carrier_ready_spawn (edict_t *self)
{
X	float	current_yaw;
X	vec3_t	offset, f, r, startpoint, spawnpoint;
X
X	CarrierCoopCheck(self);
X	CarrierMachineGun(self);
X
X	current_yaw = anglemod(self->s.angles[YAW]);
X
//	gi.dprintf ("yaws = %2.2f %2.2f\n", current_yaw, self->ideal_yaw);
X
X	if (fabs(current_yaw - self->ideal_yaw) > 0.1)
X	{
X		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
X		self->timestamp += FRAMETIME;
X		return;
X	}
X
X	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X
X	VectorSet (offset, 105,0,-58);
X	AngleVectors (self->s.angles, f, r, NULL);
X	G_ProjectSource (self->s.origin, offset, f, r, startpoint);
X	if (FindSpawnPoint (startpoint, flyer_mins, flyer_maxs, spawnpoint, 32))
X	{
X		SpawnGrow_Spawn (spawnpoint, 0);
X	}
}
X
void carrier_start_spawn (edict_t *self)
{
X	int		mytime;
X	float	enemy_yaw;
X	vec3_t	temp;
//	vec3_t	offset, f, r, startpoint;
X
X	CarrierCoopCheck(self);
X	if (!orig_yaw_speed)
X		orig_yaw_speed = self->yaw_speed;
X
X	if (!self->enemy)
X		return;
X
X	mytime = (int)((level.time - self->timestamp)/0.5);
X
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw2(temp);
X
X	// note that the offsets are based on a forward of 105 from the end angle
X	if (mytime == 0)
X	{
X		self->ideal_yaw = anglemod(enemy_yaw - 30);
//		VectorSet (offset, 90.9, 52.5, 0);
X	}
X	else if (mytime == 1)
X	{
X		self->ideal_yaw = anglemod(enemy_yaw);
//		VectorSet (offset, 90.9, -52.5, 0);
X	}
X	else if (mytime == 2)
X	{
X		self->ideal_yaw = anglemod(enemy_yaw + 30);
//		VectorSet (offset, 90.9, -52.5, 0);
X	}
//	else if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("carrier: bad spawntime\n");
X
X	CarrierMachineGun (self);
}
X
mframe_t carrier_frames_stand [] =
{
//	ai_stand, 0, drawbbox,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	carrier_move_stand = {FRAME_search01, FRAME_search13, carrier_frames_stand, NULL};
X
mframe_t carrier_frames_walk [] =
{
//	ai_walk,	12,	drawbbox,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL
};
mmove_t carrier_move_walk = {FRAME_search01, FRAME_search13, carrier_frames_walk, NULL};
X
X
mframe_t carrier_frames_run [] =
{
//	ai_run,	12,	drawbbox,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck,
X	ai_run,	6,	CarrierCoopCheck
};
mmove_t carrier_move_run = {FRAME_search01, FRAME_search13, carrier_frames_run, NULL};
X
mframe_t carrier_frames_attack_pre_mg [] =
{
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	carrier_attack_mg
};
mmove_t carrier_move_attack_pre_mg = {FRAME_firea01, FRAME_firea08, carrier_frames_attack_pre_mg, NULL};
X
X
// Loop this
mframe_t carrier_frames_attack_mg [] =
{
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	carrier_reattack_mg
/*
X	ai_charge,	0,	CarrierMachineGunHold,
//	ai_charge,	0,	CarrierMachineGun,
X	ai_charge,	0,	CarrierMachineGun,
X	ai_charge,	0,	carrier_reattack_mg
*/
};
mmove_t carrier_move_attack_mg = {FRAME_firea09, FRAME_firea11, carrier_frames_attack_mg, NULL};
X
mframe_t carrier_frames_attack_post_mg [] =
{
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck,
X	ai_charge,	4,	CarrierCoopCheck
};
mmove_t carrier_move_attack_post_mg = {FRAME_firea12, FRAME_firea15, carrier_frames_attack_post_mg, carrier_run};
X
mframe_t carrier_frames_attack_pre_gren [] =
{
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, carrier_attack_gren
};
mmove_t carrier_move_attack_pre_gren = {FRAME_fireb01, FRAME_fireb06, carrier_frames_attack_pre_gren, NULL};
X
mframe_t carrier_frames_attack_gren [] =
{
X	ai_charge, -15, CarrierGrenade,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, carrier_reattack_gren
};
mmove_t carrier_move_attack_gren = {FRAME_fireb07, FRAME_fireb10, carrier_frames_attack_gren, NULL};
X
mframe_t carrier_frames_attack_post_gren [] =
{
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck,
X	ai_charge, 4, CarrierCoopCheck
};
mmove_t carrier_move_attack_post_gren = {FRAME_fireb11, FRAME_fireb16, carrier_frames_attack_post_gren, carrier_run};
X
mframe_t carrier_frames_attack_rocket [] =
{
X	ai_charge,	15,	CarrierRocket
};
mmove_t carrier_move_attack_rocket = {FRAME_fireb01, FRAME_fireb01, carrier_frames_attack_rocket, carrier_run};
X
void CarrierRail (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	forward, right;
X
X	CarrierCoopCheck(self);
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CARRIER_RAILGUN], forward, right, start);
X
X	// calc direction to where we targeted
X	VectorSubtract (self->pos1, start, dir);
X	VectorNormalize (dir);
X
X	monster_fire_railgun (self, start, dir, 50, 100, MZ2_CARRIER_RAILGUN);
X	self->monsterinfo.attack_finished = level.time + RAIL_FIRE_TIME;
}
X
void CarrierSaveLoc (edict_t *self)
{
X	CarrierCoopCheck(self);
X	VectorCopy (self->enemy->s.origin, self->pos1);	//save for aiming the shot
X	self->pos1[2] += self->enemy->viewheight;
};
X
mframe_t carrier_frames_attack_rail [] =
{
X	ai_charge, 2, CarrierCoopCheck,
X	ai_charge, 2, CarrierSaveLoc,
X	ai_charge, 2, CarrierCoopCheck,
X	ai_charge, -20, CarrierRail,
X	ai_charge, 2, CarrierCoopCheck,
X	ai_charge, 2, CarrierCoopCheck,
X	ai_charge, 2, CarrierCoopCheck,
X	ai_charge, 2, CarrierCoopCheck,
X	ai_charge, 2, CarrierCoopCheck
};
mmove_t carrier_move_attack_rail = {FRAME_search01, FRAME_search09, carrier_frames_attack_rail, carrier_run};
X
mframe_t carrier_frames_spawn [] =
{
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	carrier_prep_spawn,		// 7 - end of wind down
X	ai_charge,	-2,	carrier_start_spawn,		// 8 - start of spawn
X	ai_charge,	-2,	carrier_ready_spawn,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-10, carrier_spawn_check,		//12 - actual spawn
X	ai_charge,	-2,	CarrierMachineGun,		//13 - begin of wind down
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	CarrierMachineGun,
X	ai_charge,	-2,	carrier_reattack_mg		//18 - end of wind down
};
mmove_t carrier_move_spawn = {FRAME_spawn01, FRAME_spawn18, carrier_frames_spawn, NULL};
X
mframe_t carrier_frames_pain_heavy [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t carrier_move_pain_heavy = {FRAME_death01, FRAME_death10, carrier_frames_pain_heavy, carrier_run};
X
mframe_t carrier_frames_pain_light [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t carrier_move_pain_light = {FRAME_spawn01, FRAME_spawn04, carrier_frames_pain_light, carrier_run};
X
mframe_t carrier_frames_death [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	BossExplode
};
mmove_t carrier_move_death = {FRAME_death01, FRAME_death16, carrier_frames_death, carrier_dead};
X
void carrier_stand (edict_t *self)
{
//	gi.dprintf ("carrier stand\n");
X	self->monsterinfo.currentmove = &carrier_move_stand;
}
X
void carrier_run (edict_t *self)
{
X
//	gi.dprintf ("carrier run - %2.2f - %s \n", level.time, self->enemy->classname);
X	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &carrier_move_stand;
X	else
X		self->monsterinfo.currentmove = &carrier_move_run;
}
X
void carrier_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &carrier_move_walk;
}
X
void CarrierMachineGunHold (edict_t *self)
{
//	self->monsterinfo.aiflags |= AI_HOLD_FRAME;
//	self->yaw_speed = 0;
//	self->monsterinfo.currentmove = &carrier_move_attack_mg;
X	CarrierMachineGun (self);
}
X
void carrier_attack (edict_t *self)
{
X	vec3_t	vec;
X	float	range, luck;
X	qboolean	enemy_inback, enemy_infront, enemy_below;
X
//	gi.dprintf ("carrier attack\n");
X	
X	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X
X	if ((!self->enemy) || (!self->enemy->inuse))
X		return;
X
X	enemy_inback = inback(self, self->enemy);
X	enemy_infront = infront (self, self->enemy);
X	enemy_below = below (self, self->enemy);
X
X	if (self->bad_area)
X	{
X		if ((enemy_inback) || (enemy_below))
X			self->monsterinfo.currentmove = &carrier_move_attack_rocket;
X		else if ((random() < 0.1) || (level.time < self->monsterinfo.attack_finished))
X			self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X		else
X		{
X			gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &carrier_move_attack_rail;
X		}
X		return;
X	}
X
X	if (self->monsterinfo.attack_state == AS_BLIND)
X	{
X		self->monsterinfo.currentmove = &carrier_move_spawn;
X		return;
X	}
X
X	if (!enemy_inback && !enemy_infront && !enemy_below) // to side and not under
X	{
X		if ((random() < 0.1) || (level.time < self->monsterinfo.attack_finished)) 
X			self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X		else
X		{
X			gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &carrier_move_attack_rail;
X		}
X		return;
X	}
X
/*	if ((g_showlogic) && (g_showlogic->value))
X	{
X		gi.dprintf ("checking enemy ..");
X		if (enemy_inback)
X			gi.dprintf (" in back\n");
X		else if (enemy_infront)
X			gi.dprintf (" in front\n");
X		else
X			gi.dprintf (" inaccessible\n");
X	}
*/	
X	if (enemy_infront)
X	{
X		VectorSubtract (self->enemy->s.origin, self->s.origin, vec);
X		range = VectorLength (vec);
X		if (range <= 125)
X		{
X			if ((random() < 0.8) || (level.time < self->monsterinfo.attack_finished))
X				self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X			else
X			{
X				gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &carrier_move_attack_rail;
X			}
X		}
X		else if (range < 600)
X		{
X			luck = random();
X			if (self->monsterinfo.monster_slots > 2)
X			{
X				if (luck <= 0.20)
X					self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X				else if (luck <= 0.40)
X					self->monsterinfo.currentmove = &carrier_move_attack_pre_gren;
X				else if ((luck <= 0.7) && !(level.time < self->monsterinfo.attack_finished))
X				{
X					gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X					self->monsterinfo.currentmove = &carrier_move_attack_rail;
X				}
X				else
X					self->monsterinfo.currentmove = &carrier_move_spawn;
X			}
X			else
X			{
X				if (luck <= 0.30)
X					self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X				else if (luck <= 0.65)
X					self->monsterinfo.currentmove = &carrier_move_attack_pre_gren;
X				else if (level.time >= self->monsterinfo.attack_finished)
X				{
X					gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X					self->monsterinfo.currentmove = &carrier_move_attack_rail;
X				}
X				else
X					self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X			}
X		}
X		else // won't use grenades at this range
X		{
X			luck = random();
X			if (self->monsterinfo.monster_slots > 2)
X			{
X				if (luck < 0.3)
X					self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X				else if ((luck < 0.65) && !(level.time < self->monsterinfo.attack_finished))
X				{
X					gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X					VectorCopy (self->enemy->s.origin, self->pos1);	//save for aiming the shot
X					self->pos1[2] += self->enemy->viewheight;
X					self->monsterinfo.currentmove = &carrier_move_attack_rail;
X				}
X				else
X					self->monsterinfo.currentmove = &carrier_move_spawn;
X			}
X			else
X			{
X				if ((luck < 0.45) || (level.time < self->monsterinfo.attack_finished))
X					self->monsterinfo.currentmove = &carrier_move_attack_pre_mg;
X				else
X				{
X					gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X					self->monsterinfo.currentmove = &carrier_move_attack_rail;
X				}
X			}
X		}
X	}
X	else if ((enemy_below) || (enemy_inback))
X	{
X		self->monsterinfo.currentmove = &carrier_move_attack_rocket;
X	}
}
X
void carrier_attack_mg (edict_t *self)
{
X	CarrierCoopCheck(self);
X	self->monsterinfo.currentmove = &carrier_move_attack_mg;
}
X
void carrier_reattack_mg (edict_t *self)
{
X	CarrierCoopCheck(self);
X	if ( infront(self, self->enemy) )
X		if (random() <= 0.5)
X			if ((random() < 0.7) || (self->monsterinfo.monster_slots <= 2))
X				self->monsterinfo.currentmove = &carrier_move_attack_mg;
X			else
X				self->monsterinfo.currentmove = &carrier_move_spawn;
X		else
X			self->monsterinfo.currentmove = &carrier_move_attack_post_mg;
X	else
X		self->monsterinfo.currentmove = &carrier_move_attack_post_mg;
}
X
X
void carrier_attack_gren (edict_t *self)
{
//	gi.dprintf ("carrier_attack_gren - %2.2f\n",level.time);
X	CarrierCoopCheck(self);
X	self->timestamp = level.time;
X	self->monsterinfo.currentmove = &carrier_move_attack_gren;
}
X
void carrier_reattack_gren (edict_t *self)
{
X	CarrierCoopCheck(self);
//	gi.dprintf ("carrier_reattack - %2.2f", level.time);
X	if ( infront(self, self->enemy) )
X		if (self->timestamp + 1.3 > level.time ) // four grenades
X		{
//			gi.dprintf (" attacking\n");
X			self->monsterinfo.currentmove = &carrier_move_attack_gren;
X			return;
X		}
//	gi.dprintf ("not attacking\n");
X	self->monsterinfo.currentmove = &carrier_move_attack_post_gren;
}
X
X
void carrier_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	qboolean changed = false;
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	//	gi.dprintf ("carrier pain\n");
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 5;
X
X	if (damage < 10)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain3, 1, ATTN_NONE, 0);
X	}
X	else if (damage < 30)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NONE, 0);
X		if (random() < 0.5)
X		{
X			changed = true;
X			self->monsterinfo.currentmove = &carrier_move_pain_light;
X		}
X	}
X	else 
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NONE, 0);
X		self->monsterinfo.currentmove = &carrier_move_pain_heavy;
X		changed = true;
X	}
X
X	// if we changed frames, clean up our little messes
X	if (changed)
X	{
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		self->yaw_speed = orig_yaw_speed;
X	}
}
X
void carrier_dead (edict_t *self)
{
X	VectorSet (self->mins, -56, -56, 0);
X	VectorSet (self->maxs, 56, 56, 80);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
void carrier_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NONE, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_NO;
X	self->count = 0;
X	self->monsterinfo.currentmove = &carrier_move_death;
}
X
qboolean Carrier_CheckAttack (edict_t *self)
{
X	vec3_t	spot1, spot2;
X	vec3_t	temp;
X	float	chance;
X	trace_t	tr;
X	qboolean	enemy_infront, enemy_inback, enemy_below;
X	int			enemy_range;
X	float		enemy_yaw;
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X		{	
X			// go ahead and spawn stuff if we're mad a a client
X			if (self->enemy->client && self->monsterinfo.monster_slots > 2)
X			{
X				self->monsterinfo.attack_state = AS_BLIND;
X				return true;
X			}
X				
X			// PGM - we want them to go ahead and shoot at info_notnulls if they can.
X			if(self->enemy->solid != SOLID_NOT || tr.fraction < 1.0)		//PGM
X				return false;
X		}
X	}
X	
X	enemy_infront = infront(self, self->enemy);
X	enemy_inback = inback(self, self->enemy);
X	enemy_below = below (self, self->enemy);
X
X	enemy_range = range(self, self->enemy);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw2(temp);
X
X	self->ideal_yaw = enemy_yaw;
X
X	// PMM - shoot out the back if appropriate
X	if ((enemy_inback) || (!enemy_infront && enemy_below))
X	{
X		// this is using wait because the attack is supposed to be independent
X		if (level.time >= self->wait)
X		{
X			self->wait = level.time + CARRIER_ROCKET_TIME;
X			self->monsterinfo.attack(self);
X			if (random() < 0.6)
X				self->monsterinfo.attack_state = AS_SLIDING;
X			else
X				self->monsterinfo.attack_state = AS_STRAIGHT;
X			return true;
X		}
X	}
X
X	// melee attack
X	if (enemy_range == RANGE_MELEE)
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X	
//	if (level.time < self->monsterinfo.attack_finished)
//		return false;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MELEE)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_NEAR)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_MID)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_FAR)
X	{
X		chance = 0.5;
X	}
X
X	// PGM - go ahead and shoot every time if it's a info_notnull
X	if ((random () < chance) || (self->enemy->solid == SOLID_NOT))
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
//		self->monsterinfo.attack_finished = level.time + 2*random();
X		return true;
X	}
X
X	if (self->flags & FL_FLY)
X	{
X		if (random() < 0.6)
X			self->monsterinfo.attack_state = AS_SLIDING;
X		else
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
X
X	return false;
}
X
void CarrierPrecache ()
{
X	gi.soundindex ("flyer/flysght1.wav");
X	gi.soundindex ("flyer/flysrch1.wav");
X	gi.soundindex ("flyer/flypain1.wav");
X	gi.soundindex ("flyer/flypain2.wav");
X	gi.soundindex ("flyer/flyatck2.wav");
X	gi.soundindex ("flyer/flyatck1.wav");
X	gi.soundindex ("flyer/flydeth1.wav");
X	gi.soundindex ("flyer/flyatck3.wav");
X	gi.soundindex ("flyer/flyidle1.wav");
X	gi.soundindex ("weapons/rockfly.wav");
X	gi.soundindex ("infantry/infatck1.wav");
X	gi.soundindex ("gunner/gunatck3.wav");
X	gi.soundindex ("weapons/grenlb1b.wav");
X	gi.soundindex ("tank/rocket.wav");
X
X	gi.modelindex ("models/monsters/flyer/tris.md2");
X	gi.modelindex ("models/objects/rocket/tris.md2");
X	gi.modelindex ("models/objects/debris2/tris.md2");
X	gi.modelindex ("models/objects/grenade/tris.md2");
X	gi.modelindex("models/items/spawngro/tris.md2");
X	gi.modelindex("models/items/spawngro2/tris.md2");
X	gi.modelindex ("models/objects/gibs/sm_metal/tris.md2");
X	gi.modelindex ("models/objects/gibs/gear/tris.md2");
}
X
X
/*QUAKED monster_carrier (1 .5 0) (-56 -56 -44) (56 56 44) Ambush Trigger_Spawn Sight
*/
void SP_monster_carrier (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("carrier/pain_md.wav");
X	sound_pain2 = gi.soundindex ("carrier/pain_lg.wav");
X	sound_pain3 = gi.soundindex ("carrier/pain_sm.wav");
X	sound_death = gi.soundindex ("carrier/death.wav");
//	sound_search1 = gi.soundindex ("bosshovr/bhvunqv1.wav");
X	sound_rail = gi.soundindex ("gladiator/railgun.wav");
X	sound_sight = gi.soundindex ("carrier/sight.wav");
X	sound_spawn = gi.soundindex ("medic_commander/monsterspawn1.wav");
X
X	self->s.sound = gi.soundindex ("bosshovr/bhvengn1.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/carrier/tris.md2");
X	VectorSet (self->mins, -56, -56, -44);
X	VectorSet (self->maxs, 56, 56, 44);
X
X	// 2000 - 4000 health
X	self->health = max (2000, 2000 + 1000*((skill->value)-1));
X	// add health in coop (500 * skill)
X	if (coop->value)
X		self->health += 500*(skill->value);	
X
X	self->gib_health = -200;
X	self->mass = 1000;
X
X	self->yaw_speed = 15;
X	orig_yaw_speed = self->yaw_speed;
//	self->yaw_speed = 1;
X	
X	self->flags |= FL_IMMUNE_LASER;
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X
X	self->pain = carrier_pain;
X	self->die = carrier_die;
X
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.stand = carrier_stand;
X	self->monsterinfo.walk = carrier_walk;
X	self->monsterinfo.run = carrier_run;
X	self->monsterinfo.attack = carrier_attack;
//	self->monsterinfo.search = carrier_search;
X	self->monsterinfo.sight = carrier_sight;
X	self->monsterinfo.checkattack = Carrier_CheckAttack;
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &carrier_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	CarrierPrecache();
X
X	flymonster_start (self);
X
X	self->monsterinfo.attack_finished = 0;
X	switch ((int)skill->value)
X	{
X	case 0:
X		self->monsterinfo.monster_slots = 3;
X		break;
X	case 1:
X	case 2:
X		self->monsterinfo.monster_slots = 6;
X		break;
X	case 3:
X		self->monsterinfo.monster_slots = 9;
X		break;
X	default:
X		self->monsterinfo.monster_slots = 6;
X		break;
X	}
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'm_carrier.c' &&
  chmod 0664 'm_carrier.c' ||
  $echo 'restore of' 'm_carrier.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_carrier.c:' 'MD5 check failed'
d31c3d75ae0a7f45bca50f0c8833c8be  m_carrier.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_carrier.c'`"
    test 35741 -eq "$shar_count" ||
    $echo 'm_carrier.c:' 'original size' '35741,' 'current size' "$shar_count!"
  fi
fi
# ============= m_carrier.h ==============
if test -f 'm_carrier.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_carrier.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_carrier.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_carrier.h' &&
// G:\quake2\xpack\models/monsters/carrier
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_search01        	0
#define FRAME_search02        	1
#define FRAME_search03        	2
#define FRAME_search04        	3
#define FRAME_search05        	4
#define FRAME_search06        	5
#define FRAME_search07        	6
#define FRAME_search08        	7
#define FRAME_search09        	8
#define FRAME_search10        	9
#define FRAME_search11        	10
#define FRAME_search12        	11
#define FRAME_search13        	12
#define FRAME_firea01         	13
#define FRAME_firea02         	14
#define FRAME_firea03         	15
#define FRAME_firea04         	16
#define FRAME_firea05         	17
#define FRAME_firea06         	18
#define FRAME_firea07         	19
#define FRAME_firea08         	20
#define FRAME_firea09         	21
#define FRAME_firea10         	22
#define FRAME_firea11         	23
#define FRAME_firea12         	24
#define FRAME_firea13         	25
#define FRAME_firea14         	26
#define FRAME_firea15         	27
#define FRAME_fireb01         	28
#define FRAME_fireb02         	29
#define FRAME_fireb03         	30
#define FRAME_fireb04         	31
#define FRAME_fireb05         	32
#define FRAME_fireb06         	33
#define FRAME_fireb07         	34
#define FRAME_fireb08         	35
#define FRAME_fireb09         	36
#define FRAME_fireb10         	37
#define FRAME_fireb11         	38
#define FRAME_fireb12         	39
#define FRAME_fireb13         	40
#define FRAME_fireb14         	41
#define FRAME_fireb15         	42
#define FRAME_fireb16         	43
#define FRAME_spawn01         	44
#define FRAME_spawn02         	45
#define FRAME_spawn03         	46
#define FRAME_spawn04         	47
#define FRAME_spawn05         	48
#define FRAME_spawn06         	49
#define FRAME_spawn07         	50
#define FRAME_spawn08         	51
#define FRAME_spawn09         	52
#define FRAME_spawn10         	53
#define FRAME_spawn11         	54
#define FRAME_spawn12         	55
#define FRAME_spawn13         	56
#define FRAME_spawn14         	57
#define FRAME_spawn15         	58
#define FRAME_spawn16         	59
#define FRAME_spawn17         	60
#define FRAME_spawn18         	61
#define FRAME_death01         	62
#define FRAME_death02         	63
#define FRAME_death03         	64
#define FRAME_death04         	65
#define FRAME_death05         	66
#define FRAME_death06         	67
#define FRAME_death07         	68
#define FRAME_death08         	69
#define FRAME_death09         	70
#define FRAME_death10         	71
#define FRAME_death11         	72
#define FRAME_death12         	73
#define FRAME_death13         	74
#define FRAME_death14         	75
#define FRAME_death15         	76
#define FRAME_death16         	77
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_carrier.h' &&
  chmod 0664 'm_carrier.h' ||
  $echo 'restore of' 'm_carrier.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_carrier.h:' 'MD5 check failed'
d0e6b2cc10d9acf62fce14f02752a0f3  m_carrier.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_carrier.h'`"
    test 2766 -eq "$shar_count" ||
    $echo 'm_carrier.h:' 'original size' '2766,' 'current size' "$shar_count!"
  fi
fi
# ============= m_chick.c ==============
if test -f 'm_chick.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_chick.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_chick.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_chick.c' &&
/*
==============================================================================
X
chick
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_chick.h"
X
// ROGUE
#define LEAD_TARGET		1
// ROGUE
X
qboolean visible (edict_t *self, edict_t *other);
X
void chick_stand (edict_t *self);
void chick_run (edict_t *self);
void chick_reslash(edict_t *self);
void chick_rerocket(edict_t *self);
void chick_attack1(edict_t *self);
X
static int	sound_missile_prelaunch;
static int	sound_missile_launch;
static int	sound_melee_swing;
static int	sound_melee_hit;
static int	sound_missile_reload;
static int	sound_death1;
static int	sound_death2;
static int	sound_fall_down;
static int	sound_idle1;
static int	sound_idle2;
static int	sound_pain1;
static int	sound_pain2;
static int	sound_pain3;
static int	sound_sight;
static int	sound_search;
X
void ChickMoan (edict_t *self)
{
X	if (random() < 0.5)
X		gi.sound (self, CHAN_VOICE, sound_idle1, 1, ATTN_IDLE, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_idle2, 1, ATTN_IDLE, 0);
}
X
mframe_t chick_frames_fidget [] =
{
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  ChickMoan,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL
};
mmove_t chick_move_fidget = {FRAME_stand201, FRAME_stand230, chick_frames_fidget, chick_stand};
X
void chick_fidget (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		return;
X	if (random() <= 0.3)
X		self->monsterinfo.currentmove = &chick_move_fidget;
}
X
mframe_t chick_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, chick_fidget,
X
};
mmove_t chick_move_stand = {FRAME_stand101, FRAME_stand130, chick_frames_stand, NULL};
X
void chick_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &chick_move_stand;
}
X
mframe_t chick_frames_start_run [] =
{
X	ai_run, 1,  NULL,
X	ai_run, 0,  NULL,
X	ai_run, 0,	 NULL,
X	ai_run, -1, NULL, 
X	ai_run, -1, NULL, 
X	ai_run, 0,  NULL,
X	ai_run, 1,  NULL,
X	ai_run, 3,  NULL,
X	ai_run, 6,	 NULL,
X	ai_run, 3,	 NULL
};
mmove_t chick_move_start_run = {FRAME_walk01, FRAME_walk10, chick_frames_start_run, chick_run};
X
mframe_t chick_frames_run [] =
{
X	ai_run, 6,	NULL,
X	ai_run, 8,  NULL,
X	ai_run, 13, NULL,
X	ai_run, 5,  monster_done_dodge,  // make sure to clear dodge bit
X	ai_run, 7,  NULL,
X	ai_run, 4,  NULL,
X	ai_run, 11, NULL,
X	ai_run, 5,  NULL,
X	ai_run, 9,  NULL,
X	ai_run, 7,  NULL
};
X
mmove_t chick_move_run = {FRAME_walk11, FRAME_walk20, chick_frames_run, NULL};
X
mframe_t chick_frames_walk [] =
{
X	ai_walk, 6,	 NULL,
X	ai_walk, 8,  NULL,
X	ai_walk, 13, NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 7,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 11, NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 9,  NULL,
X	ai_walk, 7,  NULL
};
X
mmove_t chick_move_walk = {FRAME_walk11, FRAME_walk20, chick_frames_walk, NULL};
X
void chick_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &chick_move_walk;
}
X
void chick_run (edict_t *self)
{
X	monster_done_dodge (self);
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		self->monsterinfo.currentmove = &chick_move_stand;
X		return;
X	}
X
X	if (self->monsterinfo.currentmove == &chick_move_walk ||
X		self->monsterinfo.currentmove == &chick_move_start_run)
X	{
X		self->monsterinfo.currentmove = &chick_move_run;
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &chick_move_start_run;
X	}
}
X
mframe_t chick_frames_pain1 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t chick_move_pain1 = {FRAME_pain101, FRAME_pain105, chick_frames_pain1, chick_run};
X
mframe_t chick_frames_pain2 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t chick_move_pain2 = {FRAME_pain201, FRAME_pain205, chick_frames_pain2, chick_run};
X
mframe_t chick_frames_pain3 [] =
{
X	ai_move, 0,		NULL,
X	ai_move, 0,		NULL,
X	ai_move, -6,	NULL,
X	ai_move, 3,		NULL,
X	ai_move, 11,	NULL,
X	ai_move, 3,		NULL,
X	ai_move, 0,		NULL,
X	ai_move, 0,		NULL,
X	ai_move, 4,		NULL,
X	ai_move, 1,		NULL,
X	ai_move, 0,		NULL,
X	ai_move, -3,	NULL,
X	ai_move, -4,	NULL,
X	ai_move, 5,		NULL,
X	ai_move, 7,		NULL,
X	ai_move, -2,	NULL,
X	ai_move, 3,		NULL,
X	ai_move, -5,	NULL,
X	ai_move, -2,	NULL,
X	ai_move, -8,	NULL,
X	ai_move, 2,		NULL
};
mmove_t chick_move_pain3 = {FRAME_pain301, FRAME_pain321, chick_frames_pain3, chick_run};
X
void chick_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	float	r;
X
X	monster_done_dodge(self);
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	r = random();
X	if (r < 0.33)
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X	else if (r < 0.66)
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_pain3, 1, ATTN_NORM, 0);
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	// PMM - clear this from blindfire
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X
X	if (damage <= 10)
X		self->monsterinfo.currentmove = &chick_move_pain1;
X	else if (damage <= 25)
X		self->monsterinfo.currentmove = &chick_move_pain2;
X	else
X		self->monsterinfo.currentmove = &chick_move_pain3;
X
X	// PMM - clear duck flag
X	if (self->monsterinfo.aiflags & AI_DUCKED)
X		monster_duck_up(self);
}
X
void chick_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, 0);
X	VectorSet (self->maxs, 16, 16, 16);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t chick_frames_death2 [] =
{
X	ai_move, -6, NULL,
X	ai_move, 0,  NULL,
X	ai_move, -1,  NULL,
X	ai_move, -5, NULL,
X	ai_move, 0, NULL,
X	ai_move, -1,  NULL,
X	ai_move, -2,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, 10, NULL,
X	ai_move, 2,  NULL,
X	ai_move, 3,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, 2, NULL,
X	ai_move, 0,  NULL,
X	ai_move, 3,  NULL,
X	ai_move, 3,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, -3,  NULL,
X	ai_move, -5, NULL,
X	ai_move, 4, NULL,
X	ai_move, 15, NULL,
X	ai_move, 14, NULL,
X	ai_move, 1, NULL
};
mmove_t chick_move_death2 = {FRAME_death201, FRAME_death223, chick_frames_death2, chick_dead};
X
mframe_t chick_frames_death1 [] =
{
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, -7, NULL,
X	ai_move, 4,  NULL,
X	ai_move, 11, NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL
X	
};
mmove_t chick_move_death1 = {FRAME_death101, FRAME_death112, chick_frames_death1, chick_dead};
X
void chick_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	n = rand() % 2;
X	if (n == 0)
X	{
X		self->monsterinfo.currentmove = &chick_move_death1;
X		gi.sound (self, CHAN_VOICE, sound_death1, 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &chick_move_death2;
X		gi.sound (self, CHAN_VOICE, sound_death2, 1, ATTN_NORM, 0);
X	}
}
X
// PMM - changes to duck code for new dodge
X
mframe_t chick_frames_duck [] =
{
X	ai_move, 0, monster_duck_down,
X	ai_move, 1, NULL,
X	ai_move, 4, monster_duck_hold,
X	ai_move, -4,  NULL,
X	ai_move, -5,  monster_duck_up,
X	ai_move, 3, NULL,
X	ai_move, 1,  NULL
};
mmove_t chick_move_duck = {FRAME_duck01, FRAME_duck07, chick_frames_duck, chick_run};
X
/*
void chick_dodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
// begin orig code
X	if (random() > 0.25)
X		return;
X
X	if (!self->enemy)
X		self->enemy = attacker;
X
X	self->monsterinfo.currentmove = &chick_move_duck;
// end
X
X	float	r;
X	float	height;
X	int		shooting = 0;
X
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget (self);
X	}
X
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X		return;
X
X	r = random();
X	if (r > (0.25*((skill->value)+1)))
X		return;
X
X	if ((self->monsterinfo.currentmove == &chick_move_start_attack1) ||
X		(self->monsterinfo.currentmove == &chick_move_attack1))
X	{
X		shooting = 1;
X	}
X	if (self->monsterinfo.aiflags & AI_DODGING)
X	{
X		height = self->absmax[2];
X	}
X	else
X	{
X		height = self->absmax[2]-32-1;  // the -1 is because the absmax is s.origin + maxs + 1
X	}
X
X	// check to see if it makes sense to duck
X	if (tr->endpos[2] <= height)
X	{
X		vec3_t right, diff;
X		if (shooting)
X		{
X			self->monsterinfo.attack_state = AS_SLIDING;
X			return;
X		}
X		AngleVectors (self->s.angles, NULL, right, NULL);
X		VectorSubtract (tr->endpos, self->s.origin, diff);
X		if (DotProduct (right, diff) < 0)
X		{
X			self->monsterinfo.lefty = 1;
X		}
X		// if it doesn't sense to duck, try to strafe away
X		monster_done_dodge (self);
X		self->monsterinfo.currentmove = &chick_move_run;
X		self->monsterinfo.attack_state = AS_SLIDING;
X		return;
X	}
X
X	if (skill->value == 0)
X	{
X		self->monsterinfo.currentmove = &chick_move_duck;
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		self->monsterinfo.aiflags |= AI_DODGING;
X		return;
X	}
X
X	if (!shooting)
X	{
X		self->monsterinfo.currentmove = &chick_move_duck;
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X		self->monsterinfo.aiflags |= AI_DODGING;
X	}
X	return;
X
}
*/
void ChickSlash (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->mins[0], 10);
X	gi.sound (self, CHAN_WEAPON, sound_melee_swing, 1, ATTN_NORM, 0);
X	fire_hit (self, aim, (10 + (rand() %6)), 100);
}
X
X
void ChickRocket (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X	trace_t	trace;	// PMM - check target
X	int		rocketSpeed;
X	float	dist;
X	// pmm - blindfire
X	vec3_t	target;
X	qboolean blindfire = false;
X
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X		blindfire = true;
X	else
X		blindfire = false;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_CHICK_ROCKET_1], forward, right, start);
X
X	rocketSpeed = 500 + (100 * skill->value);	// PGM rock & roll.... :)
X
X	// put a debug trail from start to endpoint, confirm that the start point is
X	// correct for the trace
X
X	// PMM
X	if (blindfire)
X		VectorCopy (self->monsterinfo.blind_fire_target, target);
X	else
X		VectorCopy (self->enemy->s.origin, target);
X	// pmm
//PGM
X	// PMM - blindfire shooting
X	if (blindfire)
X	{
X		VectorCopy (target, vec);
X		VectorSubtract (vec, start, dir);
X	}
X	// pmm
X	// don't shoot at feet if they're above where i'm shooting from.
X	else if(random() < 0.33 || (start[2] < self->enemy->absmin[2]))
X	{
//		gi.dprintf("normal shot\n");
X		VectorCopy (target, vec);
X		vec[2] += self->enemy->viewheight;
X		VectorSubtract (vec, start, dir);
X	}
X	else
X	{
//		gi.dprintf("shooting at feet!\n");
X		VectorCopy (target, vec);
X		vec[2] = self->enemy->absmin[2];
X		VectorSubtract (vec, start, dir);
X	}
//PGM
X
//======
//PMM - lead target  (not when blindfiring)
X	// 20, 35, 50, 65 chance of leading
X	if((!blindfire) && ((random() < (0.2 + ((3 - skill->value) * 0.15)))))
X	{
X		float	time;
X
//		gi.dprintf ("leading target\n");
X		dist = VectorLength (dir);
X		time = dist/rocketSpeed;
X		VectorMA(vec, time, self->enemy->velocity, vec);
X		VectorSubtract(vec, start, dir);
X	}
//PMM - lead target
//======
X
X	VectorNormalize (dir);
X
X	// pmm blindfire doesn't check target (done in checkattack)
X	// paranoia, make sure we're not shooting a target right next to us
X	trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X	if (blindfire)
X	{
X		// blindfire has different fail criteria for the trace
X		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5)))
X			monster_fire_rocket (self, start, dir, 50, rocketSpeed, MZ2_CHICK_ROCKET_1);
X		else 
X		{
X			// geez, this is bad.  she's avoiding about 80% of her blindfires due to hitting things.
X			// hunt around for a good shot
X			// try shifting the target to the left a little (to help counter her large offset)
X			VectorCopy (target, vec);
X			VectorMA (vec, -10, right, vec);
X			VectorSubtract(vec, start, dir);
X			VectorNormalize (dir);
X			trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5)))
X				monster_fire_rocket (self, start, dir, 50, rocketSpeed, MZ2_CHICK_ROCKET_1);
X			else 
X			{
X				// ok, that failed.  try to the right
X				VectorCopy (target, vec);
X				VectorMA (vec, 10, right, vec);
X				VectorSubtract(vec, start, dir);
X				VectorNormalize (dir);
X				trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5)))
X					monster_fire_rocket (self, start, dir, 50, rocketSpeed, MZ2_CHICK_ROCKET_1);
//				else if ((g_showlogic) && (g_showlogic->value))
//					// ok, I give up
//					gi.dprintf ("chick avoiding blindfire shot\n");
X			}
X		}
X	}
X	else
X	{
X		trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X		if(trace.ent == self->enemy || trace.ent == world)
X		{
X			if(trace.fraction > 0.5 || (trace.ent && trace.ent->client))
X				monster_fire_rocket (self, start, dir, 50, rocketSpeed, MZ2_CHICK_ROCKET_1);
X	//		else
X	//			gi.dprintf("didn't make it halfway to target...aborting\n");
X		}
X	}
}	
X
void Chick_PreAttack1 (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_missile_prelaunch, 1, ATTN_NORM, 0);
}
X
void ChickReload (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_missile_reload, 1, ATTN_NORM, 0);
}
X
X
mframe_t chick_frames_start_attack1 [] =
{
X	ai_charge, 0,	Chick_PreAttack1,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 4,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, -3,  NULL,
X	ai_charge, 3,	NULL,
X	ai_charge, 5,	NULL,
X	ai_charge, 7,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	chick_attack1
};
mmove_t chick_move_start_attack1 = {FRAME_attak101, FRAME_attak113, chick_frames_start_attack1, NULL};
X
X
mframe_t chick_frames_attack1 [] =
{
X	ai_charge, 19,	ChickRocket,
X	ai_charge, -6,	NULL,
X	ai_charge, -5,	NULL,
X	ai_charge, -2,	NULL,
X	ai_charge, -7,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 1,	NULL,
X	ai_charge, 10,	ChickReload,
X	ai_charge, 4,	NULL,
X	ai_charge, 5,	NULL,
X	ai_charge, 6,	NULL,
X	ai_charge, 6,	NULL,
X	ai_charge, 4,	NULL,
X	ai_charge, 3,	chick_rerocket
X
};
mmove_t chick_move_attack1 = {FRAME_attak114, FRAME_attak127, chick_frames_attack1, NULL};
X
mframe_t chick_frames_end_attack1 [] =
{
X	ai_charge, -3,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, -6,	NULL,
X	ai_charge, -4,	NULL,
X	ai_charge, -2,  NULL
};
mmove_t chick_move_end_attack1 = {FRAME_attak128, FRAME_attak132, chick_frames_end_attack1, chick_run};
X
void chick_rerocket(edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X	{
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		self->monsterinfo.currentmove = &chick_move_end_attack1;
X		return;
X	}
X	if (self->enemy->health > 0)
X	{
X		if (range (self, self->enemy) > RANGE_MELEE)
X			if ( visible (self, self->enemy) )
X				if (random() <= (0.6 + (0.05*((float)skill->value))))
X				{
X					self->monsterinfo.currentmove = &chick_move_attack1;
X					return;
X				}
X	}	
X	self->monsterinfo.currentmove = &chick_move_end_attack1;
}
X
void chick_attack1(edict_t *self)
{
X	self->monsterinfo.currentmove = &chick_move_attack1;
}
X
mframe_t chick_frames_slash [] =
{
X	ai_charge, 1,	NULL,
X	ai_charge, 7,	ChickSlash,
X	ai_charge, -7,	NULL,
X	ai_charge, 1,	NULL,
X	ai_charge, -1,	NULL,
X	ai_charge, 1,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 1,	NULL,
X	ai_charge, -2,	chick_reslash
};
mmove_t chick_move_slash = {FRAME_attak204, FRAME_attak212, chick_frames_slash, NULL};
X
mframe_t chick_frames_end_slash [] =
{
X	ai_charge, -6,	NULL,
X	ai_charge, -1,	NULL,
X	ai_charge, -6,	NULL,
X	ai_charge, 0,	NULL
};
mmove_t chick_move_end_slash = {FRAME_attak213, FRAME_attak216, chick_frames_end_slash, chick_run};
X
X
void chick_reslash(edict_t *self)
{
X	if (self->enemy->health > 0)
X	{
X		if (range (self, self->enemy) == RANGE_MELEE)
X			if (random() <= 0.9)
X			{				
X				self->monsterinfo.currentmove = &chick_move_slash;
X				return;
X			}
X			else
X			{
X				self->monsterinfo.currentmove = &chick_move_end_slash;
X				return;
X			}
X	}
X	self->monsterinfo.currentmove = &chick_move_end_slash;
}
X
void chick_slash(edict_t *self)
{
X	self->monsterinfo.currentmove = &chick_move_slash;
}
X
X
mframe_t chick_frames_start_slash [] =
{	
X	ai_charge, 1,	NULL,
X	ai_charge, 8,	NULL,
X	ai_charge, 3,	NULL
};
mmove_t chick_move_start_slash = {FRAME_attak201, FRAME_attak203, chick_frames_start_slash, chick_slash};
X
X
X
void chick_melee(edict_t *self)
{
X	self->monsterinfo.currentmove = &chick_move_start_slash;
}
X
X
void chick_attack(edict_t *self)
{
X	float r, chance;
X
X	monster_done_dodge (self);
X
X	// PMM 
X	if (self->monsterinfo.attack_state == AS_BLIND)
X	{
X		// setup shot probabilities
X		if (self->monsterinfo.blind_fire_delay < 1.0)
X			chance = 1.0;
X		else if (self->monsterinfo.blind_fire_delay < 7.5)
X			chance = 0.4;
X		else
X			chance = 0.1;
X
X		r = random();
X
X		// minimum of 2 seconds, plus 0-3, after the shots are done
X		self->monsterinfo.blind_fire_delay += 4.0 + 1.5 + random();
X
X		// don't shoot at the origin
X		if (VectorCompare (self->monsterinfo.blind_fire_target, vec3_origin))
X			return;
X
X		// don't shoot if the dice say not to
X		if (r > chance)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("blindfire - NO SHOT\n");
X			return;
X		}
X
X		// turn on manual steering to signal both manual steering and blindfire
X		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X		self->monsterinfo.currentmove = &chick_move_start_attack1;
X		self->monsterinfo.attack_finished = level.time + 2*random();
X		return;
X	}
X	// pmm
X
X	self->monsterinfo.currentmove = &chick_move_start_attack1;
}
X
void chick_sight(edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
//===========
//PGM
qboolean chick_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
//PGM
//===========
X
void chick_duck (edict_t *self, float eta)
{
X	if ((self->monsterinfo.currentmove == &chick_move_start_attack1) ||
X		(self->monsterinfo.currentmove == &chick_move_attack1))
X	{
X		// if we're shooting, and not on easy, don't dodge
X		if (skill->value)
X		{
X			self->monsterinfo.aiflags &= ~AI_DUCKED;
X			return;
X		}
X	}
X
X	if (skill->value == 0)
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X	else
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X
X	// has to be done immediately otherwise she can get stuck
X	monster_duck_down(self);
X
X	self->monsterinfo.nextframe = FRAME_duck01;
X	self->monsterinfo.currentmove = &chick_move_duck;
X	return;
}
X
void chick_sidestep (edict_t *self)
{
X	if ((self->monsterinfo.currentmove == &chick_move_start_attack1) ||
X		(self->monsterinfo.currentmove == &chick_move_attack1))
X	{
X		// if we're shooting, and not on easy, don't dodge
X		if (skill->value)
X		{
X			self->monsterinfo.aiflags &= ~AI_DODGING;
X			return;
X		}
X	}
X
X	if (self->monsterinfo.currentmove != &chick_move_run)
X		self->monsterinfo.currentmove = &chick_move_run;
}
X
/*QUAKED monster_chick (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_chick (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_missile_prelaunch	= gi.soundindex ("chick/chkatck1.wav");	
X	sound_missile_launch	= gi.soundindex ("chick/chkatck2.wav");	
X	sound_melee_swing		= gi.soundindex ("chick/chkatck3.wav");	
X	sound_melee_hit			= gi.soundindex ("chick/chkatck4.wav");	
X	sound_missile_reload	= gi.soundindex ("chick/chkatck5.wav");	
X	sound_death1			= gi.soundindex ("chick/chkdeth1.wav");	
X	sound_death2			= gi.soundindex ("chick/chkdeth2.wav");	
X	sound_fall_down			= gi.soundindex ("chick/chkfall1.wav");	
X	sound_idle1				= gi.soundindex ("chick/chkidle1.wav");	
X	sound_idle2				= gi.soundindex ("chick/chkidle2.wav");	
X	sound_pain1				= gi.soundindex ("chick/chkpain1.wav");	
X	sound_pain2				= gi.soundindex ("chick/chkpain2.wav");	
X	sound_pain3				= gi.soundindex ("chick/chkpain3.wav");	
X	sound_sight				= gi.soundindex ("chick/chksght1.wav");	
X	sound_search			= gi.soundindex ("chick/chksrch1.wav");	
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/bitch2/tris.md2");
X	VectorSet (self->mins, -16, -16, 0);
X	VectorSet (self->maxs, 16, 16, 56);
X
X	self->health = 175;
X	self->gib_health = -70;
X	self->mass = 200;
X
X	self->pain = chick_pain;
X	self->die = chick_die;
X
X	self->monsterinfo.stand = chick_stand;
X	self->monsterinfo.walk = chick_walk;
X	self->monsterinfo.run = chick_run;
X	// pmm
X	self->monsterinfo.dodge = M_MonsterDodge;
X	self->monsterinfo.duck = chick_duck;
X	self->monsterinfo.unduck = monster_duck_up;
X	self->monsterinfo.sidestep = chick_sidestep;
//	self->monsterinfo.dodge = chick_dodge;
X	// pmm
X	self->monsterinfo.attack = chick_attack;
X	self->monsterinfo.melee = chick_melee;
X	self->monsterinfo.sight = chick_sight;
X	self->monsterinfo.blocked = chick_blocked;		// PGM
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &chick_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	// PMM
X	self->monsterinfo.blindfire = true;
X	// pmm
X	walkmonster_start (self);
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'm_chick.c' &&
  chmod 0664 'm_chick.c' ||
  $echo 'restore of' 'm_chick.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_chick.c:' 'MD5 check failed'
3384fedf8fe13abc0a39da539ad2d853  m_chick.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_chick.c'`"
    test 22848 -eq "$shar_count" ||
    $echo 'm_chick.c:' 'original size' '22848,' 'current size' "$shar_count!"
  fi
fi
# ============= m_chick.h ==============
if test -f 'm_chick.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_chick.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_chick.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_chick.h' &&
// G:\quake2\baseq2\models/monsters/bitch
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_attak101        	0
#define FRAME_attak102        	1
#define FRAME_attak103        	2
#define FRAME_attak104        	3
#define FRAME_attak105        	4
#define FRAME_attak106        	5
#define FRAME_attak107        	6
#define FRAME_attak108        	7
#define FRAME_attak109        	8
#define FRAME_attak110        	9
#define FRAME_attak111        	10
#define FRAME_attak112        	11
#define FRAME_attak113        	12
#define FRAME_attak114        	13
#define FRAME_attak115        	14
#define FRAME_attak116        	15
#define FRAME_attak117        	16
#define FRAME_attak118        	17
#define FRAME_attak119        	18
#define FRAME_attak120        	19
#define FRAME_attak121        	20
#define FRAME_attak122        	21
#define FRAME_attak123        	22
#define FRAME_attak124        	23
#define FRAME_attak125        	24
#define FRAME_attak126        	25
#define FRAME_attak127        	26
#define FRAME_attak128        	27
#define FRAME_attak129        	28
#define FRAME_attak130        	29
#define FRAME_attak131        	30
#define FRAME_attak132        	31
#define FRAME_attak201        	32
#define FRAME_attak202        	33
#define FRAME_attak203        	34
#define FRAME_attak204        	35
#define FRAME_attak205        	36
#define FRAME_attak206        	37
#define FRAME_attak207        	38
#define FRAME_attak208        	39
#define FRAME_attak209        	40
#define FRAME_attak210        	41
#define FRAME_attak211        	42
#define FRAME_attak212        	43
#define FRAME_attak213        	44
#define FRAME_attak214        	45
#define FRAME_attak215        	46
#define FRAME_attak216        	47
#define FRAME_death101        	48
#define FRAME_death102        	49
#define FRAME_death103        	50
#define FRAME_death104        	51
#define FRAME_death105        	52
#define FRAME_death106        	53
#define FRAME_death107        	54
#define FRAME_death108        	55
#define FRAME_death109        	56
#define FRAME_death110        	57
#define FRAME_death111        	58
#define FRAME_death112        	59
#define FRAME_death201        	60
#define FRAME_death202        	61
#define FRAME_death203        	62
#define FRAME_death204        	63
#define FRAME_death205        	64
#define FRAME_death206        	65
#define FRAME_death207        	66
#define FRAME_death208        	67
#define FRAME_death209        	68
#define FRAME_death210        	69
#define FRAME_death211        	70
#define FRAME_death212        	71
#define FRAME_death213        	72
#define FRAME_death214        	73
#define FRAME_death215        	74
#define FRAME_death216        	75
#define FRAME_death217        	76
#define FRAME_death218        	77
#define FRAME_death219        	78
#define FRAME_death220        	79
#define FRAME_death221        	80
#define FRAME_death222        	81
#define FRAME_death223        	82
#define FRAME_duck01          	83
#define FRAME_duck02          	84
#define FRAME_duck03          	85
#define FRAME_duck04          	86
#define FRAME_duck05          	87
#define FRAME_duck06          	88
#define FRAME_duck07          	89
#define FRAME_pain101         	90
#define FRAME_pain102         	91
#define FRAME_pain103         	92
#define FRAME_pain104         	93
#define FRAME_pain105         	94
#define FRAME_pain201         	95
#define FRAME_pain202         	96
#define FRAME_pain203         	97
#define FRAME_pain204         	98
#define FRAME_pain205         	99
#define FRAME_pain301         	100
#define FRAME_pain302         	101
#define FRAME_pain303         	102
#define FRAME_pain304         	103
#define FRAME_pain305         	104
#define FRAME_pain306         	105
#define FRAME_pain307         	106
#define FRAME_pain308         	107
#define FRAME_pain309         	108
#define FRAME_pain310         	109
#define FRAME_pain311         	110
#define FRAME_pain312         	111
#define FRAME_pain313         	112
#define FRAME_pain314         	113
#define FRAME_pain315         	114
#define FRAME_pain316         	115
#define FRAME_pain317         	116
#define FRAME_pain318         	117
#define FRAME_pain319         	118
#define FRAME_pain320         	119
#define FRAME_pain321         	120
#define FRAME_stand101        	121
#define FRAME_stand102        	122
#define FRAME_stand103        	123
#define FRAME_stand104        	124
#define FRAME_stand105        	125
#define FRAME_stand106        	126
#define FRAME_stand107        	127
#define FRAME_stand108        	128
#define FRAME_stand109        	129
#define FRAME_stand110        	130
#define FRAME_stand111        	131
#define FRAME_stand112        	132
#define FRAME_stand113        	133
#define FRAME_stand114        	134
#define FRAME_stand115        	135
#define FRAME_stand116        	136
#define FRAME_stand117        	137
#define FRAME_stand118        	138
#define FRAME_stand119        	139
#define FRAME_stand120        	140
#define FRAME_stand121        	141
#define FRAME_stand122        	142
#define FRAME_stand123        	143
#define FRAME_stand124        	144
#define FRAME_stand125        	145
#define FRAME_stand126        	146
#define FRAME_stand127        	147
#define FRAME_stand128        	148
#define FRAME_stand129        	149
#define FRAME_stand130        	150
#define FRAME_stand201        	151
#define FRAME_stand202        	152
#define FRAME_stand203        	153
#define FRAME_stand204        	154
#define FRAME_stand205        	155
#define FRAME_stand206        	156
#define FRAME_stand207        	157
#define FRAME_stand208        	158
#define FRAME_stand209        	159
#define FRAME_stand210        	160
#define FRAME_stand211        	161
#define FRAME_stand212        	162
#define FRAME_stand213        	163
#define FRAME_stand214        	164
#define FRAME_stand215        	165
#define FRAME_stand216        	166
#define FRAME_stand217        	167
#define FRAME_stand218        	168
#define FRAME_stand219        	169
#define FRAME_stand220        	170
#define FRAME_stand221        	171
#define FRAME_stand222        	172
#define FRAME_stand223        	173
#define FRAME_stand224        	174
#define FRAME_stand225        	175
#define FRAME_stand226        	176
#define FRAME_stand227        	177
#define FRAME_stand228        	178
#define FRAME_stand229        	179
#define FRAME_stand230        	180
#define FRAME_walk01          	181
#define FRAME_walk02          	182
#define FRAME_walk03          	183
#define FRAME_walk04          	184
#define FRAME_walk05          	185
#define FRAME_walk06          	186
#define FRAME_walk07          	187
#define FRAME_walk08          	188
#define FRAME_walk09          	189
#define FRAME_walk10          	190
#define FRAME_walk11          	191
#define FRAME_walk12          	192
#define FRAME_walk13          	193
#define FRAME_walk14          	194
#define FRAME_walk15          	195
#define FRAME_walk16          	196
#define FRAME_walk17          	197
#define FRAME_walk18          	198
#define FRAME_walk19          	199
#define FRAME_walk20          	200
#define FRAME_walk21          	201
#define FRAME_walk22          	202
#define FRAME_walk23          	203
#define FRAME_walk24          	204
#define FRAME_walk25          	205
#define FRAME_walk26          	206
#define FRAME_walk27          	207
#define FRAME_recln201        	208
#define FRAME_recln202        	209
#define FRAME_recln203        	210
#define FRAME_recln204        	211
#define FRAME_recln205        	212
#define FRAME_recln206        	213
#define FRAME_recln207        	214
#define FRAME_recln208        	215
#define FRAME_recln209        	216
#define FRAME_recln210        	217
#define FRAME_recln211        	218
#define FRAME_recln212        	219
#define FRAME_recln213        	220
#define FRAME_recln214        	221
#define FRAME_recln215        	222
#define FRAME_recln216        	223
#define FRAME_recln217        	224
#define FRAME_recln218        	225
#define FRAME_recln219        	226
#define FRAME_recln220        	227
#define FRAME_recln221        	228
#define FRAME_recln222        	229
#define FRAME_recln223        	230
#define FRAME_recln224        	231
#define FRAME_recln225        	232
#define FRAME_recln226        	233
#define FRAME_recln227        	234
#define FRAME_recln228        	235
#define FRAME_recln229        	236
#define FRAME_recln230        	237
#define FRAME_recln231        	238
#define FRAME_recln232        	239
#define FRAME_recln233        	240
#define FRAME_recln234        	241
#define FRAME_recln235        	242
#define FRAME_recln236        	243
#define FRAME_recln237        	244
#define FRAME_recln238        	245
#define FRAME_recln239        	246
#define FRAME_recln240        	247
#define FRAME_recln101        	248
#define FRAME_recln102        	249
#define FRAME_recln103        	250
#define FRAME_recln104        	251
#define FRAME_recln105        	252
#define FRAME_recln106        	253
#define FRAME_recln107        	254
#define FRAME_recln108        	255
#define FRAME_recln109        	256
#define FRAME_recln110        	257
#define FRAME_recln111        	258
#define FRAME_recln112        	259
#define FRAME_recln113        	260
#define FRAME_recln114        	261
#define FRAME_recln115        	262
#define FRAME_recln116        	263
#define FRAME_recln117        	264
#define FRAME_recln118        	265
#define FRAME_recln119        	266
#define FRAME_recln120        	267
#define FRAME_recln121        	268
#define FRAME_recln122        	269
#define FRAME_recln123        	270
#define FRAME_recln124        	271
#define FRAME_recln125        	272
#define FRAME_recln126        	273
#define FRAME_recln127        	274
#define FRAME_recln128        	275
#define FRAME_recln129        	276
#define FRAME_recln130        	277
#define FRAME_recln131        	278
#define FRAME_recln132        	279
#define FRAME_recln133        	280
#define FRAME_recln134        	281
#define FRAME_recln135        	282
#define FRAME_recln136        	283
#define FRAME_recln137        	284
#define FRAME_recln138        	285
#define FRAME_recln139        	286
#define FRAME_recln140        	287
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_chick.h' &&
  chmod 0664 'm_chick.h' ||
  $echo 'restore of' 'm_chick.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_chick.h:' 'MD5 check failed'
834f66c2a7ac5f6790ae3f71e52ed58e  m_chick.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_chick.h'`"
    test 10093 -eq "$shar_count" ||
    $echo 'm_chick.h:' 'original size' '10093,' 'current size' "$shar_count!"
  fi
fi
# ============= m_flash.c ==============
if test -f 'm_flash.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_flash.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_flash.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_flash.c' &&
// m_flash.c
X
#include "q_shared.h"
X
// this file is included in both the game dll and quake2,
// the game needs it to source shot locations, the client
// needs it to position muzzle flashes
vec3_t monster_flash_offset [] =
{
// flash 0 is not used
X	0.0, 0.0, 0.0,
X
// MZ2_TANK_BLASTER_1				1
X	20.7, -18.5, 28.7,
// MZ2_TANK_BLASTER_2				2
X	16.6, -21.5, 30.1,
// MZ2_TANK_BLASTER_3				3
X	11.8, -23.9, 32.1,
// MZ2_TANK_MACHINEGUN_1			4
X	22.9, -0.7, 25.3,
// MZ2_TANK_MACHINEGUN_2			5
X	22.2, 6.2, 22.3,
// MZ2_TANK_MACHINEGUN_3			6
X	19.4, 13.1, 18.6,
// MZ2_TANK_MACHINEGUN_4			7
X	19.4, 18.8, 18.6,
// MZ2_TANK_MACHINEGUN_5			8
X	17.9, 25.0, 18.6,
// MZ2_TANK_MACHINEGUN_6			9
X	14.1, 30.5, 20.6,
// MZ2_TANK_MACHINEGUN_7			10
X	9.3, 35.3, 22.1,
// MZ2_TANK_MACHINEGUN_8			11
X	4.7, 38.4, 22.1,
// MZ2_TANK_MACHINEGUN_9			12
X	-1.1, 40.4, 24.1,
// MZ2_TANK_MACHINEGUN_10			13
X	-6.5, 41.2, 24.1,
// MZ2_TANK_MACHINEGUN_11			14
X	3.2, 40.1, 24.7,
// MZ2_TANK_MACHINEGUN_12			15
X	11.7, 36.7, 26.0,
// MZ2_TANK_MACHINEGUN_13			16
X	18.9, 31.3, 26.0,
// MZ2_TANK_MACHINEGUN_14			17
X	24.4, 24.4, 26.4,
// MZ2_TANK_MACHINEGUN_15			18
X	27.1, 17.1, 27.2,
// MZ2_TANK_MACHINEGUN_16			19
X	28.5, 9.1, 28.0,
// MZ2_TANK_MACHINEGUN_17			20
X	27.1, 2.2, 28.0,
// MZ2_TANK_MACHINEGUN_18			21
X	24.9, -2.8, 28.0,
// MZ2_TANK_MACHINEGUN_19			22
X	21.6, -7.0, 26.4,
// MZ2_TANK_ROCKET_1				23
X	6.2, 29.1, 49.1,
// MZ2_TANK_ROCKET_2				24
X	6.9, 23.8, 49.1,
// MZ2_TANK_ROCKET_3				25
X	8.3, 17.8, 49.5,
X
// MZ2_INFANTRY_MACHINEGUN_1		26
X	26.6, 7.1, 13.1,
// MZ2_INFANTRY_MACHINEGUN_2		27
X	18.2, 7.5, 15.4,
// MZ2_INFANTRY_MACHINEGUN_3		28
X	17.2, 10.3, 17.9,
// MZ2_INFANTRY_MACHINEGUN_4		29
X	17.0, 12.8, 20.1,
// MZ2_INFANTRY_MACHINEGUN_5		30
X	15.1, 14.1, 21.8,
// MZ2_INFANTRY_MACHINEGUN_6		31
X	11.8, 17.2, 23.1,
// MZ2_INFANTRY_MACHINEGUN_7		32
X	11.4, 20.2, 21.0,
// MZ2_INFANTRY_MACHINEGUN_8		33
X	9.0, 23.0, 18.9,
// MZ2_INFANTRY_MACHINEGUN_9		34
X	13.9, 18.6, 17.7,
// MZ2_INFANTRY_MACHINEGUN_10		35
X	15.4, 15.6, 15.8,
// MZ2_INFANTRY_MACHINEGUN_11		36
X	10.2, 15.2, 25.1,
// MZ2_INFANTRY_MACHINEGUN_12		37
X	-1.9, 15.1, 28.2,
// MZ2_INFANTRY_MACHINEGUN_13		38
X	-12.4, 13.0, 20.2,
X
// MZ2_SOLDIER_BLASTER_1			39
X	10.6 * 1.2, 7.7 * 1.2, 7.8 * 1.2,
// MZ2_SOLDIER_BLASTER_2			40
X	21.1 * 1.2, 3.6 * 1.2, 19.0 * 1.2,
// MZ2_SOLDIER_SHOTGUN_1			41
X	10.6 * 1.2, 7.7 * 1.2, 7.8 * 1.2,
// MZ2_SOLDIER_SHOTGUN_2			42
X	21.1 * 1.2, 3.6 * 1.2, 19.0 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_1			43
X	10.6 * 1.2, 7.7 * 1.2, 7.8 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_2			44
X	21.1 * 1.2, 3.6 * 1.2, 19.0 * 1.2,
X
// MZ2_GUNNER_MACHINEGUN_1			45
X	30.1 * 1.15, 3.9 * 1.15, 19.6 * 1.15,
// MZ2_GUNNER_MACHINEGUN_2			46
X	29.1 * 1.15, 2.5 * 1.15, 20.7 * 1.15,
// MZ2_GUNNER_MACHINEGUN_3			47
X	28.2 * 1.15, 2.5 * 1.15, 22.2 * 1.15,
// MZ2_GUNNER_MACHINEGUN_4			48
X	28.2 * 1.15, 3.6 * 1.15, 22.0 * 1.15,
// MZ2_GUNNER_MACHINEGUN_5			49
X	26.9 * 1.15, 2.0 * 1.15, 23.4 * 1.15,
// MZ2_GUNNER_MACHINEGUN_6			50
X	26.5 * 1.15, 0.6 * 1.15, 20.8 * 1.15,
// MZ2_GUNNER_MACHINEGUN_7			51
X	26.9 * 1.15, 0.5 * 1.15, 21.5 * 1.15,
// MZ2_GUNNER_MACHINEGUN_8			52
X	29.0 * 1.15, 2.4 * 1.15, 19.5 * 1.15,
// MZ2_GUNNER_GRENADE_1				53
X	4.6 * 1.15, -16.8 * 1.15, 7.3 * 1.15,
// MZ2_GUNNER_GRENADE_2				54
X	4.6 * 1.15, -16.8 * 1.15, 7.3 * 1.15,
// MZ2_GUNNER_GRENADE_3				55
X	4.6 * 1.15, -16.8 * 1.15, 7.3 * 1.15,
// MZ2_GUNNER_GRENADE_4				56
X	4.6 * 1.15, -16.8 * 1.15, 7.3 * 1.15,
X
// MZ2_CHICK_ROCKET_1				57
//	-24.8, -9.0, 39.0,
X	24.8, -9.0, 39.0,			// PGM - this was incorrect in Q2
X
// MZ2_FLYER_BLASTER_1				58
X	12.1, 13.4, -14.5,
// MZ2_FLYER_BLASTER_2				59
X	12.1, -7.4, -14.5,
X
// MZ2_MEDIC_BLASTER_1				60
X	12.1, 5.4, 16.5,
X
// MZ2_GLADIATOR_RAILGUN_1			61
X	30.0, 18.0, 28.0,
X
// MZ2_HOVER_BLASTER_1				62
X	32.5, -0.8, 10.0,
X
// MZ2_ACTOR_MACHINEGUN_1			63
X	18.4, 7.4, 9.6,
X
// MZ2_SUPERTANK_MACHINEGUN_1		64
X	30.0, 30.0, 88.5,
// MZ2_SUPERTANK_MACHINEGUN_2		65
X	30.0, 30.0, 88.5,
// MZ2_SUPERTANK_MACHINEGUN_3		66
X	30.0, 30.0, 88.5,
// MZ2_SUPERTANK_MACHINEGUN_4		67
X	30.0, 30.0, 88.5,
// MZ2_SUPERTANK_MACHINEGUN_5		68
X	30.0, 30.0, 88.5,
// MZ2_SUPERTANK_MACHINEGUN_6		69
X	30.0, 30.0, 88.5,
// MZ2_SUPERTANK_ROCKET_1			70
X	16.0, -22.5, 91.2,
// MZ2_SUPERTANK_ROCKET_2			71
X	16.0, -33.4, 86.7,
// MZ2_SUPERTANK_ROCKET_3			72
X	16.0, -42.8, 83.3,
X
// --- Start Xian Stuff ---
// MZ2_BOSS2_MACHINEGUN_L1			73
X	32,	-40,	70,
// MZ2_BOSS2_MACHINEGUN_L2			74
X	32,	-40,	70,
// MZ2_BOSS2_MACHINEGUN_L3			75
X	32,	-40,	70,
// MZ2_BOSS2_MACHINEGUN_L4			76
X	32,	-40,	70,
// MZ2_BOSS2_MACHINEGUN_L5			77
X	32,	-40,	70,
// --- End Xian Stuff
X
// MZ2_BOSS2_ROCKET_1				78
X	22.0, 16.0, 10.0,
// MZ2_BOSS2_ROCKET_2				79
X	22.0, 8.0, 10.0,
// MZ2_BOSS2_ROCKET_3				80
X	22.0, -8.0, 10.0,
// MZ2_BOSS2_ROCKET_4				81
X	22.0, -16.0, 10.0,
X
// MZ2_FLOAT_BLASTER_1				82
X	32.5, -0.8, 10,
X
// MZ2_SOLDIER_BLASTER_3			83
X	20.8 * 1.2, 10.1 * 1.2, -2.7 * 1.2,
// MZ2_SOLDIER_SHOTGUN_3			84
X	20.8 * 1.2, 10.1 * 1.2, -2.7 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_3			85
X	20.8 * 1.2, 10.1 * 1.2, -2.7 * 1.2,
// MZ2_SOLDIER_BLASTER_4			86
X	7.6 * 1.2, 9.3 * 1.2, 0.8 * 1.2,
// MZ2_SOLDIER_SHOTGUN_4			87
X	7.6 * 1.2, 9.3 * 1.2, 0.8 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_4			88
X	7.6 * 1.2, 9.3 * 1.2, 0.8 * 1.2,
// MZ2_SOLDIER_BLASTER_5			89
X	30.5 * 1.2, 9.9 * 1.2, -18.7 * 1.2,
// MZ2_SOLDIER_SHOTGUN_5			90
X	30.5 * 1.2, 9.9 * 1.2, -18.7 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_5			91
X	30.5 * 1.2, 9.9 * 1.2, -18.7 * 1.2,
// MZ2_SOLDIER_BLASTER_6			92
X	27.6 * 1.2, 3.4 * 1.2, -10.4 * 1.2,
// MZ2_SOLDIER_SHOTGUN_6			93
X	27.6 * 1.2, 3.4 * 1.2, -10.4 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_6			94
X	27.6 * 1.2, 3.4 * 1.2, -10.4 * 1.2,
// MZ2_SOLDIER_BLASTER_7			95
X	28.9 * 1.2, 4.6 * 1.2, -8.1 * 1.2,
// MZ2_SOLDIER_SHOTGUN_7			96
X	28.9 * 1.2, 4.6 * 1.2, -8.1 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_7			97
X	28.9 * 1.2, 4.6 * 1.2, -8.1 * 1.2,
// MZ2_SOLDIER_BLASTER_8			98
//	34.5 * 1.2, 9.6 * 1.2, 6.1 * 1.2,
X	31.5 * 1.2, 9.6 * 1.2, 10.1 * 1.2,
// MZ2_SOLDIER_SHOTGUN_8			99
X	34.5 * 1.2, 9.6 * 1.2, 6.1 * 1.2,
// MZ2_SOLDIER_MACHINEGUN_8			100
X	34.5 * 1.2, 9.6 * 1.2, 6.1 * 1.2,
X
// --- Xian shit below ---
// MZ2_MAKRON_BFG					101
X	17,		-19.5,	62.9,
// MZ2_MAKRON_BLASTER_1				102
X	-3.6,	-24.1,	59.5,
// MZ2_MAKRON_BLASTER_2				103
X	-1.6,	-19.3,	59.5,
// MZ2_MAKRON_BLASTER_3				104
X	-0.1,	-14.4,	59.5,		
// MZ2_MAKRON_BLASTER_4				105
X	2.0,	-7.6,	59.5,	
// MZ2_MAKRON_BLASTER_5				106
X	3.4,	1.3,	59.5,
// MZ2_MAKRON_BLASTER_6				107
X	3.7,	11.1,	59.5,	
// MZ2_MAKRON_BLASTER_7				108
X	-0.3,	22.3,	59.5,
// MZ2_MAKRON_BLASTER_8				109
X	-6,		33,		59.5,
// MZ2_MAKRON_BLASTER_9				110
X	-9.3,	36.4,	59.5,
// MZ2_MAKRON_BLASTER_10			111
X	-7,		35,		59.5,
// MZ2_MAKRON_BLASTER_11			112
X	-2.1,	29,		59.5,
// MZ2_MAKRON_BLASTER_12			113
X	3.9,	17.3,	59.5,
// MZ2_MAKRON_BLASTER_13			114
X	6.1,	5.8,	59.5,
// MZ2_MAKRON_BLASTER_14			115
X	5.9,	-4.4,	59.5,
// MZ2_MAKRON_BLASTER_15			116
X	4.2,	-14.1,	59.5,		
// MZ2_MAKRON_BLASTER_16			117
X	2.4,	-18.8,	59.5,
// MZ2_MAKRON_BLASTER_17			118
X	-1.8,	-25.5,	59.5,
// MZ2_MAKRON_RAILGUN_1				119
X	-17.3,	7.8,	72.4,
X
// MZ2_JORG_MACHINEGUN_L1			120
X	78.5,	-47.1,	96,			
// MZ2_JORG_MACHINEGUN_L2			121
X	78.5,	-47.1,	96,			
// MZ2_JORG_MACHINEGUN_L3			122
X	78.5,	-47.1,	96,			
// MZ2_JORG_MACHINEGUN_L4			123
X	78.5,	-47.1,	96,			
// MZ2_JORG_MACHINEGUN_L5			124
X	78.5,	-47.1,	96,			
// MZ2_JORG_MACHINEGUN_L6			125
X	78.5,	-47.1,	96,			
// MZ2_JORG_MACHINEGUN_R1			126
X	78.5,	46.7,  96,			
// MZ2_JORG_MACHINEGUN_R2			127
X	78.5,	46.7,	96,			
// MZ2_JORG_MACHINEGUN_R3			128
X	78.5,	46.7,	96,			
// MZ2_JORG_MACHINEGUN_R4			129
X	78.5,	46.7,	96,			
// MZ2_JORG_MACHINEGUN_R5			130
X	78.5,	46.7,	96,			
// MZ2_JORG_MACHINEGUN_R6			131
X	78.5,	46.7,	96,			
// MZ2_JORG_BFG_1					132
X	6.3,	-9,		111.2,
X
// MZ2_BOSS2_MACHINEGUN_R1			73
X	32,	40,	70,
// MZ2_BOSS2_MACHINEGUN_R2			74
X	32,	40,	70,
// MZ2_BOSS2_MACHINEGUN_R3			75
X	32,	40,	70,
// MZ2_BOSS2_MACHINEGUN_R4			76
X	32,	40,	70,
// MZ2_BOSS2_MACHINEGUN_R5			77
X	32,	40,	70,
X
// --- End Xian Shit ---
X
// ROGUE
// note that the above really ends at 137
// carrier machineguns
// MZ2_CARRIER_MACHINEGUN_L1
X	56,	-32, 32,
// MZ2_CARRIER_MACHINEGUN_R1
X	56,	32, 32,
// MZ2_CARRIER_GRENADE
X	42,	24, 50,
// MZ2_TURRET_MACHINEGUN			141
X	16, 0, 0,
// MZ2_TURRET_ROCKET				142
X	16, 0, 0,
// MZ2_TURRET_BLASTER				143
X	16, 0, 0,
// MZ2_STALKER_BLASTER				144
X	24, 0, 6,
// MZ2_DAEDALUS_BLASTER				145
X	32.5, -0.8, 10.0,
// MZ2_MEDIC_BLASTER_2				146
X	12.1, 5.4, 16.5,
// MZ2_CARRIER_RAILGUN				147
X	32, 0, 6, 
// MZ2_WIDOW_DISRUPTOR				148
X	57.72, 14.50, 88.81,
// MZ2_WIDOW_BLASTER				149
X	56,	32, 32,
// MZ2_WIDOW_RAIL					150
X	62, -20, 84, 
// MZ2_WIDOW_PLASMABEAM				151		// PMM - not used!
X	32, 0, 6, 
// MZ2_CARRIER_MACHINEGUN_L2		152
X	61,	-32, 12,
// MZ2_CARRIER_MACHINEGUN_R2		153
X	61,	32, 12,
// MZ2_WIDOW_RAIL_LEFT				154
X	17, -62, 91, 
// MZ2_WIDOW_RAIL_RIGHT				155
X	68, 12, 86, 
// MZ2_WIDOW_BLASTER_SWEEP1			156			pmm - the sweeps need to be in sequential order
X	47.5, 56, 89,
// MZ2_WIDOW_BLASTER_SWEEP2			157
X	54, 52, 91,
// MZ2_WIDOW_BLASTER_SWEEP3			158
X	58, 40, 91,
// MZ2_WIDOW_BLASTER_SWEEP4			159
X	68, 30, 88,
// MZ2_WIDOW_BLASTER_SWEEP5			160
X	74, 20, 88,
// MZ2_WIDOW_BLASTER_SWEEP6			161
X	73, 11, 87,
// MZ2_WIDOW_BLASTER_SWEEP7			162
X	73, 3, 87,
// MZ2_WIDOW_BLASTER_SWEEP8			163
X	70, -12, 87,
// MZ2_WIDOW_BLASTER_SWEEP9			164
X	67, -20, 90,
// MZ2_WIDOW_BLASTER_100			165
X	-20, 76, 90,
// MZ2_WIDOW_BLASTER_90				166
X	-8, 74, 90,
// MZ2_WIDOW_BLASTER_80				167
X	0, 72, 90,
// MZ2_WIDOW_BLASTER_70				168		d06
X	10, 71, 89,
// MZ2_WIDOW_BLASTER_60				169		d07
X	23, 70, 87,
// MZ2_WIDOW_BLASTER_50				170		d08
X	32, 64, 85,
// MZ2_WIDOW_BLASTER_40				171
X	40, 58, 84,
// MZ2_WIDOW_BLASTER_30				172		d10
X	48, 50, 83,
// MZ2_WIDOW_BLASTER_20				173
X	54, 42, 82,
// MZ2_WIDOW_BLASTER_10				174		d12
X	56, 34, 82,
// MZ2_WIDOW_BLASTER_0				175
X	58, 26, 82,
// MZ2_WIDOW_BLASTER_10L			176		d14
X	60, 16, 82,
// MZ2_WIDOW_BLASTER_20L			177
X	59, 6, 81,
// MZ2_WIDOW_BLASTER_30L			178		d16
X	58, -2, 80,
// MZ2_WIDOW_BLASTER_40L			179
X	57, -10, 79,
// MZ2_WIDOW_BLASTER_50L			180		d18
X	54, -18, 78,
// MZ2_WIDOW_BLASTER_60L			181
X	42, -32, 80,
// MZ2_WIDOW_BLASTER_70L			182		d20
X	36, -40, 78,
// MZ2_WIDOW_RUN_1					183
X	68.4, 10.88, 82.08,
// MZ2_WIDOW_RUN_2					184
X	68.51, 8.64, 85.14,
// MZ2_WIDOW_RUN_3					185
X	68.66, 6.38, 88.78,
// MZ2_WIDOW_RUN_4					186
X	68.73, 5.1, 84.47,
// MZ2_WIDOW_RUN_5					187
X	68.82, 4.79, 80.52,
// MZ2_WIDOW_RUN_6					188
X	68.77, 6.11, 85.37,
// MZ2_WIDOW_RUN_7					189
X	68.67, 7.99, 90.24,
// MZ2_WIDOW_RUN_8					190
X	68.55, 9.54, 87.36,
// MZ2_CARRIER_ROCKET_1				191
X	0, 0, -5,
// MZ2_CARRIER_ROCKET_2				192
X	0, 0, -5,
// MZ2_CARRIER_ROCKET_3				193
X	0, 0, -5,
// MZ2_CARRIER_ROCKET_4				194
X	0, 0, -5,
// MZ2_WIDOW2_BEAMER_1				195
//	72.13, -17.63, 93.77,
X	69.00, -17.63, 93.77,
// MZ2_WIDOW2_BEAMER_2				196
//	71.46, -17.08, 89.82,
X	69.00, -17.08, 89.82,
// MZ2_WIDOW2_BEAMER_3				197
//	71.47, -18.40, 90.70,
X	69.00, -18.40, 90.70,
// MZ2_WIDOW2_BEAMER_4				198
//	71.96, -18.34, 94.32,
X	69.00, -18.34, 94.32,
// MZ2_WIDOW2_BEAMER_5				199
//	72.25, -18.30, 97.98,
X	69.00, -18.30, 97.98,
// MZ2_WIDOW2_BEAM_SWEEP_1			200
X	45.04, -59.02, 92.24,
// MZ2_WIDOW2_BEAM_SWEEP_2			201
X	50.68, -54.70, 91.96,
// MZ2_WIDOW2_BEAM_SWEEP_3			202
X	56.57, -47.72, 91.65,
// MZ2_WIDOW2_BEAM_SWEEP_4			203
X	61.75, -38.75, 91.38,
// MZ2_WIDOW2_BEAM_SWEEP_5			204
X	65.55, -28.76, 91.24,
// MZ2_WIDOW2_BEAM_SWEEP_6			205
X	67.79, -18.90, 91.22,
// MZ2_WIDOW2_BEAM_SWEEP_7			206
X	68.60, -9.52, 91.23,
// MZ2_WIDOW2_BEAM_SWEEP_8			207
X	68.08, 0.18, 91.32,
// MZ2_WIDOW2_BEAM_SWEEP_9			208
X	66.14, 9.79, 91.44,
// MZ2_WIDOW2_BEAM_SWEEP_10			209
X	62.77, 18.91, 91.65,
// MZ2_WIDOW2_BEAM_SWEEP_11			210
X	58.29, 27.11, 92.00,
X
// end of table
X	0.0, 0.0, 0.0
};
SHAR_EOF
  $shar_touch -am 1130175398 'm_flash.c' &&
  chmod 0664 'm_flash.c' ||
  $echo 'restore of' 'm_flash.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_flash.c:' 'MD5 check failed'
fc41b90164d8168fc825a8a9d6e7bdf0  m_flash.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_flash.c'`"
    test 11714 -eq "$shar_count" ||
    $echo 'm_flash.c:' 'original size' '11714,' 'current size' "$shar_count!"
  fi
fi
# ============= m_flipper.c ==============
if test -f 'm_flipper.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_flipper.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_flipper.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_flipper.c' &&
/*
==============================================================================
X
FLIPPER
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_flipper.h"
X
X
static int	sound_chomp;
static int	sound_attack;
static int	sound_pain1;
static int	sound_pain2;
static int	sound_death;
static int	sound_idle;
static int	sound_search;
static int	sound_sight;
X
X
void flipper_stand (edict_t *self);
X
mframe_t flipper_frames_stand [] =
{
X	ai_stand, 0, NULL
};
X	
mmove_t	flipper_move_stand = {FRAME_flphor01, FRAME_flphor01, flipper_frames_stand, NULL};
X
void flipper_stand (edict_t *self)
{
X		self->monsterinfo.currentmove = &flipper_move_stand;
}
X
#define FLIPPER_RUN_SPEED	24
X
mframe_t flipper_frames_run [] =
{
X	ai_run, FLIPPER_RUN_SPEED, NULL,	// 6
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,	// 10
X
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,	// 20
X
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL,
X	ai_run, FLIPPER_RUN_SPEED, NULL		// 29
};
mmove_t flipper_move_run_loop = {FRAME_flpver06, FRAME_flpver29, flipper_frames_run, NULL};
X
void flipper_run_loop (edict_t *self)
{
X	self->monsterinfo.currentmove = &flipper_move_run_loop;
}
X
mframe_t flipper_frames_run_start [] =
{
X	ai_run, 8, NULL,
X	ai_run, 8, NULL,
X	ai_run, 8, NULL,
X	ai_run, 8, NULL,
X	ai_run, 8, NULL,
X	ai_run, 8, NULL
};
mmove_t flipper_move_run_start = {FRAME_flpver01, FRAME_flpver06, flipper_frames_run_start, flipper_run_loop};
X
void flipper_run (edict_t *self)
{
X	self->monsterinfo.currentmove = &flipper_move_run_start;
}
X
/* Standard Swimming */ 
mframe_t flipper_frames_walk [] =
{
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 4, NULL
};
mmove_t flipper_move_walk = {FRAME_flphor01, FRAME_flphor24, flipper_frames_walk, NULL};
X
void flipper_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &flipper_move_walk;
}
X
mframe_t flipper_frames_start_run [] =
{
X	ai_run, 8, NULL,
X	ai_run, 8, NULL,
X	ai_run, 8, NULL,
X	ai_run, 8, NULL,
X	ai_run, 8, flipper_run
};
mmove_t flipper_move_start_run = {FRAME_flphor01, FRAME_flphor05, flipper_frames_start_run, NULL};
X
void flipper_start_run (edict_t *self)
{
X	self->monsterinfo.currentmove = &flipper_move_start_run;
}
X
mframe_t flipper_frames_pain2 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0, NULL
};
mmove_t flipper_move_pain2 = {FRAME_flppn101, FRAME_flppn105, flipper_frames_pain2, flipper_run};
X
mframe_t flipper_frames_pain1 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0, NULL
};
mmove_t flipper_move_pain1 = {FRAME_flppn201, FRAME_flppn205, flipper_frames_pain1, flipper_run};
X
void flipper_bite (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, 0, 0);
X	fire_hit (self, aim, 5, 0);
}
X
void flipper_preattack (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_chomp, 1, ATTN_NORM, 0);
}
X
mframe_t flipper_frames_attack [] =
{
X	ai_charge, 0,	flipper_preattack,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	flipper_bite,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	flipper_bite,
X	ai_charge, 0,	NULL
};
mmove_t flipper_move_attack = {FRAME_flpbit01, FRAME_flpbit20, flipper_frames_attack, flipper_run};
X
void flipper_melee(edict_t *self)
{
X	self->monsterinfo.currentmove = &flipper_move_attack;
}
X
void flipper_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	int		n;
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X	
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	n = (rand() + 1) % 2;
X	if (n == 0)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &flipper_move_pain1;
X	}
X	else
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &flipper_move_pain2;
X	}
}
X
void flipper_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t flipper_frames_death [] =
{
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL
};
mmove_t flipper_move_death = {FRAME_flpdth01, FRAME_flpdth56, flipper_frames_death, flipper_dead};
X
void flipper_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void flipper_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->monsterinfo.currentmove = &flipper_move_death;
}
X
/*QUAKED monster_flipper (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_flipper (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1		= gi.soundindex ("flipper/flppain1.wav");	
X	sound_pain2		= gi.soundindex ("flipper/flppain2.wav");	
X	sound_death		= gi.soundindex ("flipper/flpdeth1.wav");	
X	sound_chomp		= gi.soundindex ("flipper/flpatck1.wav");
X	sound_attack	= gi.soundindex ("flipper/flpatck2.wav");
X	sound_idle		= gi.soundindex ("flipper/flpidle1.wav");
X	sound_search	= gi.soundindex ("flipper/flpsrch1.wav");
X	sound_sight		= gi.soundindex ("flipper/flpsght1.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/flipper/tris.md2");
X	VectorSet (self->mins, -16, -16, 0);
X	VectorSet (self->maxs, 16, 16, 32);
X
X	self->health = 50;
X	self->gib_health = -30;
X	self->mass = 100;
X
X	self->pain = flipper_pain;
X	self->die = flipper_die;
X
X	self->monsterinfo.stand = flipper_stand;
X	self->monsterinfo.walk = flipper_walk;
X	self->monsterinfo.run = flipper_start_run;
X	self->monsterinfo.melee = flipper_melee;
X	self->monsterinfo.sight = flipper_sight;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &flipper_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	swimmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_flipper.c' &&
  chmod 0664 'm_flipper.c' ||
  $echo 'restore of' 'm_flipper.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_flipper.c:' 'MD5 check failed'
46bc8473f88001cf2776585b28469662  m_flipper.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_flipper.c'`"
    test 8962 -eq "$shar_count" ||
    $echo 'm_flipper.c:' 'original size' '8962,' 'current size' "$shar_count!"
  fi
fi
# ============= m_flipper.h ==============
if test -f 'm_flipper.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_flipper.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_flipper.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_flipper.h' &&
// G:\quake2\baseq2\models/monsters/flipper
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_flpbit01        	0
#define FRAME_flpbit02        	1
#define FRAME_flpbit03        	2
#define FRAME_flpbit04        	3
#define FRAME_flpbit05        	4
#define FRAME_flpbit06        	5
#define FRAME_flpbit07        	6
#define FRAME_flpbit08        	7
#define FRAME_flpbit09        	8
#define FRAME_flpbit10        	9
#define FRAME_flpbit11        	10
#define FRAME_flpbit12        	11
#define FRAME_flpbit13        	12
#define FRAME_flpbit14        	13
#define FRAME_flpbit15        	14
#define FRAME_flpbit16        	15
#define FRAME_flpbit17        	16
#define FRAME_flpbit18        	17
#define FRAME_flpbit19        	18
#define FRAME_flpbit20        	19
#define FRAME_flptal01        	20
#define FRAME_flptal02        	21
#define FRAME_flptal03        	22
#define FRAME_flptal04        	23
#define FRAME_flptal05        	24
#define FRAME_flptal06        	25
#define FRAME_flptal07        	26
#define FRAME_flptal08        	27
#define FRAME_flptal09        	28
#define FRAME_flptal10        	29
#define FRAME_flptal11        	30
#define FRAME_flptal12        	31
#define FRAME_flptal13        	32
#define FRAME_flptal14        	33
#define FRAME_flptal15        	34
#define FRAME_flptal16        	35
#define FRAME_flptal17        	36
#define FRAME_flptal18        	37
#define FRAME_flptal19        	38
#define FRAME_flptal20        	39
#define FRAME_flptal21        	40
#define FRAME_flphor01        	41
#define FRAME_flphor02        	42
#define FRAME_flphor03        	43
#define FRAME_flphor04        	44
#define FRAME_flphor05        	45
#define FRAME_flphor06        	46
#define FRAME_flphor07        	47
#define FRAME_flphor08        	48
#define FRAME_flphor09        	49
#define FRAME_flphor10        	50
#define FRAME_flphor11        	51
#define FRAME_flphor12        	52
#define FRAME_flphor13        	53
#define FRAME_flphor14        	54
#define FRAME_flphor15        	55
#define FRAME_flphor16        	56
#define FRAME_flphor17        	57
#define FRAME_flphor18        	58
#define FRAME_flphor19        	59
#define FRAME_flphor20        	60
#define FRAME_flphor21        	61
#define FRAME_flphor22        	62
#define FRAME_flphor23        	63
#define FRAME_flphor24        	64
#define FRAME_flpver01        	65
#define FRAME_flpver02        	66
#define FRAME_flpver03        	67
#define FRAME_flpver04        	68
#define FRAME_flpver05        	69
#define FRAME_flpver06        	70
#define FRAME_flpver07        	71
#define FRAME_flpver08        	72
#define FRAME_flpver09        	73
#define FRAME_flpver10        	74
#define FRAME_flpver11        	75
#define FRAME_flpver12        	76
#define FRAME_flpver13        	77
#define FRAME_flpver14        	78
#define FRAME_flpver15        	79
#define FRAME_flpver16        	80
#define FRAME_flpver17        	81
#define FRAME_flpver18        	82
#define FRAME_flpver19        	83
#define FRAME_flpver20        	84
#define FRAME_flpver21        	85
#define FRAME_flpver22        	86
#define FRAME_flpver23        	87
#define FRAME_flpver24        	88
#define FRAME_flpver25        	89
#define FRAME_flpver26        	90
#define FRAME_flpver27        	91
#define FRAME_flpver28        	92
#define FRAME_flpver29        	93
#define FRAME_flppn101        	94
#define FRAME_flppn102        	95
#define FRAME_flppn103        	96
#define FRAME_flppn104        	97
#define FRAME_flppn105        	98
#define FRAME_flppn201        	99
#define FRAME_flppn202        	100
#define FRAME_flppn203        	101
#define FRAME_flppn204        	102
#define FRAME_flppn205        	103
#define FRAME_flpdth01        	104
#define FRAME_flpdth02        	105
#define FRAME_flpdth03        	106
#define FRAME_flpdth04        	107
#define FRAME_flpdth05        	108
#define FRAME_flpdth06        	109
#define FRAME_flpdth07        	110
#define FRAME_flpdth08        	111
#define FRAME_flpdth09        	112
#define FRAME_flpdth10        	113
#define FRAME_flpdth11        	114
#define FRAME_flpdth12        	115
#define FRAME_flpdth13        	116
#define FRAME_flpdth14        	117
#define FRAME_flpdth15        	118
#define FRAME_flpdth16        	119
#define FRAME_flpdth17        	120
#define FRAME_flpdth18        	121
#define FRAME_flpdth19        	122
#define FRAME_flpdth20        	123
#define FRAME_flpdth21        	124
#define FRAME_flpdth22        	125
#define FRAME_flpdth23        	126
#define FRAME_flpdth24        	127
#define FRAME_flpdth25        	128
#define FRAME_flpdth26        	129
#define FRAME_flpdth27        	130
#define FRAME_flpdth28        	131
#define FRAME_flpdth29        	132
#define FRAME_flpdth30        	133
#define FRAME_flpdth31        	134
#define FRAME_flpdth32        	135
#define FRAME_flpdth33        	136
#define FRAME_flpdth34        	137
#define FRAME_flpdth35        	138
#define FRAME_flpdth36        	139
#define FRAME_flpdth37        	140
#define FRAME_flpdth38        	141
#define FRAME_flpdth39        	142
#define FRAME_flpdth40        	143
#define FRAME_flpdth41        	144
#define FRAME_flpdth42        	145
#define FRAME_flpdth43        	146
#define FRAME_flpdth44        	147
#define FRAME_flpdth45        	148
#define FRAME_flpdth46        	149
#define FRAME_flpdth47        	150
#define FRAME_flpdth48        	151
#define FRAME_flpdth49        	152
#define FRAME_flpdth50        	153
#define FRAME_flpdth51        	154
#define FRAME_flpdth52        	155
#define FRAME_flpdth53        	156
#define FRAME_flpdth54        	157
#define FRAME_flpdth55        	158
#define FRAME_flpdth56        	159
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_flipper.h' &&
  chmod 0664 'm_flipper.h' ||
  $echo 'restore of' 'm_flipper.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_flipper.h:' 'MD5 check failed'
7e001c883d53623360f2d0feab8c63a8  m_flipper.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_flipper.h'`"
    test 5618 -eq "$shar_count" ||
    $echo 'm_flipper.h:' 'original size' '5618,' 'current size' "$shar_count!"
  fi
fi
# ============= m_float.c ==============
if test -f 'm_float.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_float.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_float.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_float.c' &&
/*
==============================================================================
X
floater
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_float.h"
X
X
static int	sound_attack2;
static int	sound_attack3;
static int	sound_death1;
static int	sound_idle;
static int	sound_pain1;
static int	sound_pain2;
static int	sound_sight;
X
X
void floater_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void floater_idle (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
X
//void floater_stand1 (edict_t *self);
void floater_dead (edict_t *self);
void floater_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
void floater_run (edict_t *self);
void floater_wham (edict_t *self);
void floater_zap (edict_t *self);
X
X
void floater_fire_blaster (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	forward, right;
X	vec3_t	end;
X	vec3_t	dir;
X	int		effect;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	if ((self->s.frame == FRAME_attak104) || (self->s.frame == FRAME_attak107))
X		effect = EF_HYPERBLASTER;
X	else
X		effect = 0;
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_FLOAT_BLASTER_1], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, end);
X	end[2] += self->enemy->viewheight;
X	VectorSubtract (end, start, dir);
X
X	monster_fire_blaster (self, start, dir, 1, 1000, MZ2_FLOAT_BLASTER_1, effect);
}
X
X
mframe_t floater_frames_stand1 [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	floater_move_stand1 = {FRAME_stand101, FRAME_stand152, floater_frames_stand1, NULL};
X
mframe_t floater_frames_stand2 [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	floater_move_stand2 = {FRAME_stand201, FRAME_stand252, floater_frames_stand2, NULL};
X
void floater_stand (edict_t *self)
{
X	if (random() <= 0.5)		
X		self->monsterinfo.currentmove = &floater_move_stand1;
X	else
X		self->monsterinfo.currentmove = &floater_move_stand2;
}
X
mframe_t floater_frames_activate [] =
{
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL,	
X	ai_move,	0,	NULL
};
mmove_t floater_move_activate = {FRAME_actvat01, FRAME_actvat31, floater_frames_activate, NULL};
X
mframe_t floater_frames_attack1 [] =
{
X	ai_charge,	0,	NULL,			// Blaster attack
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	floater_fire_blaster,			// BOOM (0, -25.8, 32.5)	-- LOOP Starts
X	ai_charge,	0,	floater_fire_blaster,
X	ai_charge,	0,	floater_fire_blaster,
X	ai_charge,	0,	floater_fire_blaster,
X	ai_charge,	0,	floater_fire_blaster,
X	ai_charge,	0,	floater_fire_blaster,
X	ai_charge,	0,	floater_fire_blaster,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL			//							-- LOOP Ends
};
mmove_t floater_move_attack1 = {FRAME_attak101, FRAME_attak114, floater_frames_attack1, floater_run};
X
// PMM - circle strafe frames
mframe_t floater_frames_attack1a [] =
{
X	ai_charge,	10,	NULL,			// Blaster attack
X	ai_charge,	10,	NULL,
X	ai_charge,	10,	NULL,
X	ai_charge,	10,	floater_fire_blaster,			// BOOM (0, -25.8, 32.5)	-- LOOP Starts
X	ai_charge,	10,	floater_fire_blaster,
X	ai_charge,	10,	floater_fire_blaster,
X	ai_charge,	10,	floater_fire_blaster,
X	ai_charge,	10,	floater_fire_blaster,
X	ai_charge,	10,	floater_fire_blaster,
X	ai_charge,	10,	floater_fire_blaster,
X	ai_charge,	10,	NULL,
X	ai_charge,	10,	NULL,
X	ai_charge,	10,	NULL,
X	ai_charge,	10,	NULL			//							-- LOOP Ends
};
mmove_t floater_move_attack1a = {FRAME_attak101, FRAME_attak114, floater_frames_attack1a, floater_run};
//pmm
mframe_t floater_frames_attack2 [] =
{
X	ai_charge,	0,	NULL,			// Claws
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	floater_wham,			// WHAM (0, -45, 29.6)		-- LOOP Starts
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,			//							-- LOOP Ends
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL
};
mmove_t floater_move_attack2 = {FRAME_attak201, FRAME_attak225, floater_frames_attack2, floater_run};
X
mframe_t floater_frames_attack3 [] =
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	floater_zap,		//								-- LOOP Starts
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,		//								-- LOOP Ends
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL
};
mmove_t floater_move_attack3 = {FRAME_attak301, FRAME_attak334, floater_frames_attack3, floater_run};
X
mframe_t floater_frames_death [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t floater_move_death = {FRAME_death01, FRAME_death13, floater_frames_death, floater_dead};
X
mframe_t floater_frames_pain1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t floater_move_pain1 = {FRAME_pain101, FRAME_pain107, floater_frames_pain1, floater_run};
X
mframe_t floater_frames_pain2 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t floater_move_pain2 = {FRAME_pain201, FRAME_pain208, floater_frames_pain2, floater_run};
X
mframe_t floater_frames_pain3 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t floater_move_pain3 = {FRAME_pain301, FRAME_pain312, floater_frames_pain3, floater_run};
X
mframe_t floater_frames_walk [] =
{
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL
};
mmove_t	floater_move_walk = {FRAME_stand101, FRAME_stand152, floater_frames_walk, NULL};
X
mframe_t floater_frames_run [] =
{
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL,
X	ai_run, 13, NULL
};
mmove_t	floater_move_run = {FRAME_stand101, FRAME_stand152, floater_frames_run, NULL};
X
void floater_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &floater_move_stand1;
X	else
X		self->monsterinfo.currentmove = &floater_move_run;
}
X
void floater_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &floater_move_walk;
}
X
void floater_wham (edict_t *self)
{
X	static	vec3_t	aim = {MELEE_DISTANCE, 0, 0};
X	gi.sound (self, CHAN_WEAPON, sound_attack3, 1, ATTN_NORM, 0);
X	fire_hit (self, aim, 5 + rand() % 6, -50);
}
X
void floater_zap (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	origin;
X	vec3_t	dir;
X	vec3_t	offset;
X
X	VectorSubtract (self->enemy->s.origin, self->s.origin, dir);
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	//FIXME use a flash and replace these two lines with the commented one
X	VectorSet (offset, 18.5, -0.9, 10);
X	G_ProjectSource (self->s.origin, offset, forward, right, origin);
//	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, origin);
X
X	gi.sound (self, CHAN_WEAPON, sound_attack2, 1, ATTN_NORM, 0);
X
X	//FIXME use the flash, Luke
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_SPLASH);
X	gi.WriteByte (32);
X	gi.WritePosition (origin);
X	gi.WriteDir (dir);
X	gi.WriteByte (1);	//sparks
X	gi.multicast (origin, MULTICAST_PVS);
X
X	T_Damage (self->enemy, self, self, dir, self->enemy->s.origin, vec3_origin, 5 + rand() % 6, -10, DAMAGE_ENERGY, MOD_UNKNOWN);
}
X
void floater_attack(edict_t *self)
{
X	float chance;
/*	if (random() <= 0.5)	
X		self->monsterinfo.currentmove = &flyer_move_attack1;
X	else */
X	// 0% chance of circle in easy
X	// 50% chance in normal
X	// 75% chance in hard
X	// 86.67% chance in nightmare
X	if (!skill->value)
X		chance = 0;
X	else
X		chance = 1.0 - (0.5/(float)(skill->value));
X
X	if (random() > chance)
X	{
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X		self->monsterinfo.currentmove = &floater_move_attack1;
X	}
X	else // circle strafe
X	{
X		if (random () <= 0.5) // switch directions
X			self->monsterinfo.lefty = 1 - self->monsterinfo.lefty;
X		self->monsterinfo.attack_state = AS_SLIDING;
X		self->monsterinfo.currentmove = &floater_move_attack1a;
X	}
}
X
X
void floater_melee(edict_t *self)
{
X	if (random() < 0.5)		
X		self->monsterinfo.currentmove = &floater_move_attack3;
X	else
X		self->monsterinfo.currentmove = &floater_move_attack2;
}
X
X
void floater_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	int		n;
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	n = (rand() + 1) % 3;
X	if (n == 0)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &floater_move_pain1;
X	}
X	else
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &floater_move_pain2;
X	}
}
X
void floater_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
void floater_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	gi.sound (self, CHAN_VOICE, sound_death1, 1, ATTN_NORM, 0);
X	BecomeExplosion1(self);
}
X
//===========
//PGM
qboolean floater_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	return false;
}
//PGM
//===========
X
/*QUAKED monster_floater (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_floater (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_attack2 = gi.soundindex ("floater/fltatck2.wav");
X	sound_attack3 = gi.soundindex ("floater/fltatck3.wav");
X	sound_death1 = gi.soundindex ("floater/fltdeth1.wav");
X	sound_idle = gi.soundindex ("floater/fltidle1.wav");
X	sound_pain1 = gi.soundindex ("floater/fltpain1.wav");
X	sound_pain2 = gi.soundindex ("floater/fltpain2.wav");
X	sound_sight = gi.soundindex ("floater/fltsght1.wav");
X
X	gi.soundindex ("floater/fltatck1.wav");
X
X	self->s.sound = gi.soundindex ("floater/fltsrch1.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/float/tris.md2");
X	VectorSet (self->mins, -24, -24, -24);
X	VectorSet (self->maxs, 24, 24, 32);
X
X	self->health = 200;
X	self->gib_health = -80;
X	self->mass = 300;
X
X	self->pain = floater_pain;
X	self->die = floater_die;
X
X	self->monsterinfo.stand = floater_stand;
X	self->monsterinfo.walk = floater_walk;
X	self->monsterinfo.run = floater_run;
//	self->monsterinfo.dodge = floater_dodge;
X	self->monsterinfo.attack = floater_attack;
X	self->monsterinfo.melee = floater_melee;
X	self->monsterinfo.sight = floater_sight;
X	self->monsterinfo.idle = floater_idle;
X	self->monsterinfo.blocked = floater_blocked;		// PGM
X
X	gi.linkentity (self);
X
X	if (random() <= 0.5)		
X		self->monsterinfo.currentmove = &floater_move_stand1;	
X	else
X		self->monsterinfo.currentmove = &floater_move_stand2;	
X	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	flymonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_float.c' &&
  chmod 0664 'm_float.c' ||
  $echo 'restore of' 'm_float.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_float.c:' 'MD5 check failed'
dc4af842e5acaf9334506a891786c1d5  m_float.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_float.c'`"
    test 16513 -eq "$shar_count" ||
    $echo 'm_float.c:' 'original size' '16513,' 'current size' "$shar_count!"
  fi
fi
# ============= m_float.h ==============
if test -f 'm_float.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_float.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_float.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_float.h' &&
// G:\quake2\baseq2\models/monsters/float
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_actvat01        	0
#define FRAME_actvat02        	1
#define FRAME_actvat03        	2
#define FRAME_actvat04        	3
#define FRAME_actvat05        	4
#define FRAME_actvat06        	5
#define FRAME_actvat07        	6
#define FRAME_actvat08        	7
#define FRAME_actvat09        	8
#define FRAME_actvat10        	9
#define FRAME_actvat11        	10
#define FRAME_actvat12        	11
#define FRAME_actvat13        	12
#define FRAME_actvat14        	13
#define FRAME_actvat15        	14
#define FRAME_actvat16        	15
#define FRAME_actvat17        	16
#define FRAME_actvat18        	17
#define FRAME_actvat19        	18
#define FRAME_actvat20        	19
#define FRAME_actvat21        	20
#define FRAME_actvat22        	21
#define FRAME_actvat23        	22
#define FRAME_actvat24        	23
#define FRAME_actvat25        	24
#define FRAME_actvat26        	25
#define FRAME_actvat27        	26
#define FRAME_actvat28        	27
#define FRAME_actvat29        	28
#define FRAME_actvat30        	29
#define FRAME_actvat31        	30
#define FRAME_attak101        	31
#define FRAME_attak102        	32
#define FRAME_attak103        	33
#define FRAME_attak104        	34
#define FRAME_attak105        	35
#define FRAME_attak106        	36
#define FRAME_attak107        	37
#define FRAME_attak108        	38
#define FRAME_attak109        	39
#define FRAME_attak110        	40
#define FRAME_attak111        	41
#define FRAME_attak112        	42
#define FRAME_attak113        	43
#define FRAME_attak114        	44
#define FRAME_attak201        	45
#define FRAME_attak202        	46
#define FRAME_attak203        	47
#define FRAME_attak204        	48
#define FRAME_attak205        	49
#define FRAME_attak206        	50
#define FRAME_attak207        	51
#define FRAME_attak208        	52
#define FRAME_attak209        	53
#define FRAME_attak210        	54
#define FRAME_attak211        	55
#define FRAME_attak212        	56
#define FRAME_attak213        	57
#define FRAME_attak214        	58
#define FRAME_attak215        	59
#define FRAME_attak216        	60
#define FRAME_attak217        	61
#define FRAME_attak218        	62
#define FRAME_attak219        	63
#define FRAME_attak220        	64
#define FRAME_attak221        	65
#define FRAME_attak222        	66
#define FRAME_attak223        	67
#define FRAME_attak224        	68
#define FRAME_attak225        	69
#define FRAME_attak301        	70
#define FRAME_attak302        	71
#define FRAME_attak303        	72
#define FRAME_attak304        	73
#define FRAME_attak305        	74
#define FRAME_attak306        	75
#define FRAME_attak307        	76
#define FRAME_attak308        	77
#define FRAME_attak309        	78
#define FRAME_attak310        	79
#define FRAME_attak311        	80
#define FRAME_attak312        	81
#define FRAME_attak313        	82
#define FRAME_attak314        	83
#define FRAME_attak315        	84
#define FRAME_attak316        	85
#define FRAME_attak317        	86
#define FRAME_attak318        	87
#define FRAME_attak319        	88
#define FRAME_attak320        	89
#define FRAME_attak321        	90
#define FRAME_attak322        	91
#define FRAME_attak323        	92
#define FRAME_attak324        	93
#define FRAME_attak325        	94
#define FRAME_attak326        	95
#define FRAME_attak327        	96
#define FRAME_attak328        	97
#define FRAME_attak329        	98
#define FRAME_attak330        	99
#define FRAME_attak331        	100
#define FRAME_attak332        	101
#define FRAME_attak333        	102
#define FRAME_attak334        	103
#define FRAME_death01         	104
#define FRAME_death02         	105
#define FRAME_death03         	106
#define FRAME_death04         	107
#define FRAME_death05         	108
#define FRAME_death06         	109
#define FRAME_death07         	110
#define FRAME_death08         	111
#define FRAME_death09         	112
#define FRAME_death10         	113
#define FRAME_death11         	114
#define FRAME_death12         	115
#define FRAME_death13         	116
#define FRAME_pain101         	117
#define FRAME_pain102         	118
#define FRAME_pain103         	119
#define FRAME_pain104         	120
#define FRAME_pain105         	121
#define FRAME_pain106         	122
#define FRAME_pain107         	123
#define FRAME_pain201         	124
#define FRAME_pain202         	125
#define FRAME_pain203         	126
#define FRAME_pain204         	127
#define FRAME_pain205         	128
#define FRAME_pain206         	129
#define FRAME_pain207         	130
#define FRAME_pain208         	131
#define FRAME_pain301         	132
#define FRAME_pain302         	133
#define FRAME_pain303         	134
#define FRAME_pain304         	135
#define FRAME_pain305         	136
#define FRAME_pain306         	137
#define FRAME_pain307         	138
#define FRAME_pain308         	139
#define FRAME_pain309         	140
#define FRAME_pain310         	141
#define FRAME_pain311         	142
#define FRAME_pain312         	143
#define FRAME_stand101        	144
#define FRAME_stand102        	145
#define FRAME_stand103        	146
#define FRAME_stand104        	147
#define FRAME_stand105        	148
#define FRAME_stand106        	149
#define FRAME_stand107        	150
#define FRAME_stand108        	151
#define FRAME_stand109        	152
#define FRAME_stand110        	153
#define FRAME_stand111        	154
#define FRAME_stand112        	155
#define FRAME_stand113        	156
#define FRAME_stand114        	157
#define FRAME_stand115        	158
#define FRAME_stand116        	159
#define FRAME_stand117        	160
#define FRAME_stand118        	161
#define FRAME_stand119        	162
#define FRAME_stand120        	163
#define FRAME_stand121        	164
#define FRAME_stand122        	165
#define FRAME_stand123        	166
#define FRAME_stand124        	167
#define FRAME_stand125        	168
#define FRAME_stand126        	169
#define FRAME_stand127        	170
#define FRAME_stand128        	171
#define FRAME_stand129        	172
#define FRAME_stand130        	173
#define FRAME_stand131        	174
#define FRAME_stand132        	175
#define FRAME_stand133        	176
#define FRAME_stand134        	177
#define FRAME_stand135        	178
#define FRAME_stand136        	179
#define FRAME_stand137        	180
#define FRAME_stand138        	181
#define FRAME_stand139        	182
#define FRAME_stand140        	183
#define FRAME_stand141        	184
#define FRAME_stand142        	185
#define FRAME_stand143        	186
#define FRAME_stand144        	187
#define FRAME_stand145        	188
#define FRAME_stand146        	189
#define FRAME_stand147        	190
#define FRAME_stand148        	191
#define FRAME_stand149        	192
#define FRAME_stand150        	193
#define FRAME_stand151        	194
#define FRAME_stand152        	195
#define FRAME_stand201        	196
#define FRAME_stand202        	197
#define FRAME_stand203        	198
#define FRAME_stand204        	199
#define FRAME_stand205        	200
#define FRAME_stand206        	201
#define FRAME_stand207        	202
#define FRAME_stand208        	203
#define FRAME_stand209        	204
#define FRAME_stand210        	205
#define FRAME_stand211        	206
#define FRAME_stand212        	207
#define FRAME_stand213        	208
#define FRAME_stand214        	209
#define FRAME_stand215        	210
#define FRAME_stand216        	211
#define FRAME_stand217        	212
#define FRAME_stand218        	213
#define FRAME_stand219        	214
#define FRAME_stand220        	215
#define FRAME_stand221        	216
#define FRAME_stand222        	217
#define FRAME_stand223        	218
#define FRAME_stand224        	219
#define FRAME_stand225        	220
#define FRAME_stand226        	221
#define FRAME_stand227        	222
#define FRAME_stand228        	223
#define FRAME_stand229        	224
#define FRAME_stand230        	225
#define FRAME_stand231        	226
#define FRAME_stand232        	227
#define FRAME_stand233        	228
#define FRAME_stand234        	229
#define FRAME_stand235        	230
#define FRAME_stand236        	231
#define FRAME_stand237        	232
#define FRAME_stand238        	233
#define FRAME_stand239        	234
#define FRAME_stand240        	235
#define FRAME_stand241        	236
#define FRAME_stand242        	237
#define FRAME_stand243        	238
#define FRAME_stand244        	239
#define FRAME_stand245        	240
#define FRAME_stand246        	241
#define FRAME_stand247        	242
#define FRAME_stand248        	243
#define FRAME_stand249        	244
#define FRAME_stand250        	245
#define FRAME_stand251        	246
#define FRAME_stand252        	247
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_float.h' &&
  chmod 0664 'm_float.h' ||
  $echo 'restore of' 'm_float.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_float.h:' 'MD5 check failed'
33014576740b90976dbd12bf86275d3e  m_float.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_float.h'`"
    test 8696 -eq "$shar_count" ||
    $echo 'm_float.h:' 'original size' '8696,' 'current size' "$shar_count!"
  fi
fi
# ============= m_flyer.c ==============
if test -f 'm_flyer.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_flyer.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_flyer.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_flyer.c' &&
/*
==============================================================================
X
flyer
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_flyer.h"
X
qboolean visible (edict_t *self, edict_t *other);
X
static int	nextmove;			// Used for start/stop frames
X
static int	sound_sight;
static int	sound_idle;
static int	sound_pain1;
static int	sound_pain2;
static int	sound_slash;
static int	sound_sproing;
static int	sound_die;
X
X
void flyer_check_melee(edict_t *self);
void flyer_loop_melee (edict_t *self);
void flyer_melee (edict_t *self);
void flyer_setstart (edict_t *self);
void flyer_stand (edict_t *self);
void flyer_nextmove (edict_t *self);
X
// ROGUE - kamikaze stuff
void flyer_kamikaze (edict_t *self);
void flyer_kamikaze_check (edict_t *self);
void flyer_die(edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
/*
void showme1 (edict_t *self)
{
X	if (!self->dmg)
X	{
X		gi.dprintf ("straight - %d\n", self->monsterinfo.lefty);
X		self->dmg = 1;
X	}
}
X
void showme2 (edict_t *self)
{
X	if (!self->dmg)
X	{
X		gi.dprintf ("strafe - %d\n", self->monsterinfo.lefty);
X		self->dmg = 1;
X	}
}
*/
X
void flyer_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void flyer_idle (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
void flyer_pop_blades (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_sproing, 1, ATTN_NORM, 0);
}
X
X
mframe_t flyer_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	flyer_move_stand = {FRAME_stand01, FRAME_stand45, flyer_frames_stand, NULL};
X
X
mframe_t flyer_frames_walk [] =
{
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 5, NULL
};
mmove_t	flyer_move_walk = {FRAME_stand01, FRAME_stand45, flyer_frames_walk, NULL};
X
mframe_t flyer_frames_run [] =
{
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL,
X	ai_run, 10, NULL
};
mmove_t	flyer_move_run = {FRAME_stand01, FRAME_stand45, flyer_frames_run, NULL};
X
mframe_t flyer_frames_kamizake [] =
{
X	ai_charge, 40,	flyer_kamikaze_check,
X	ai_charge, 40,	flyer_kamikaze_check,
X	ai_charge, 40,	flyer_kamikaze_check,
X	ai_charge, 40,	flyer_kamikaze_check,
X	ai_charge, 40,	flyer_kamikaze_check
};
mmove_t flyer_move_kamikaze = {FRAME_rollr02, FRAME_rollr06, flyer_frames_kamizake, flyer_kamikaze};
X
void flyer_run (edict_t *self)
{
X	if (self->mass > 50)
X		self->monsterinfo.currentmove = &flyer_move_kamikaze;
X	else
X		if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X			self->monsterinfo.currentmove = &flyer_move_stand;
X		else
X			self->monsterinfo.currentmove = &flyer_move_run;
}
X
void flyer_walk (edict_t *self)
{
X	if (self->mass > 50)
X		flyer_run (self);
X	else
X		self->monsterinfo.currentmove = &flyer_move_walk;
}
X
void flyer_stand (edict_t *self)
{
X	if (self->mass > 50)
X		flyer_run (self);
X	else
X		self->monsterinfo.currentmove = &flyer_move_stand;
}
X
// ROGUE - kamikaze stuff
X
void flyer_kamikaze_explode (edict_t *self)
{
X	vec3_t dir;
X
X	if (self->monsterinfo.commander && self->monsterinfo.commander->inuse && 
X		!strcmp(self->monsterinfo.commander->classname, "monster_carrier"))
X	{
X		self->monsterinfo.commander->monsterinfo.monster_slots++;
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("suicide hit!. %d slots left\n", self->monsterinfo.commander->monsterinfo.monster_slots);
X	}
X
//	gi.dprintf ("boom!\n");
//	T_RadiusDamage(self, self->owner, 125, self, self->dmg_radius, MOD_NUKE);
//	T_RadiusDamage(self, self->owner, 125, self, 150, MOD_NUKE);
X	if (self->enemy)
X	{
X		VectorSubtract (self->enemy->s.origin, self->s.origin, dir);
//void T_Damage (edict_t *targ, edict_t *inflictor, edict_t *attacker, vec3_t dir, vec3_t point, 
//			   vec3_t normal, int damage, int knockback, int dflags, int mod)
X		T_Damage (self->enemy, self, self, dir, self->s.origin, vec3_origin, (int)50, (int)50, DAMAGE_RADIUS, MOD_UNKNOWN);
X	}
X
X	flyer_die (self, NULL, NULL, 0, dir);
/*	VectorMA (self->s.origin, -0.02, self->velocity, origin);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_ROCKET_EXPLOSION);
X	gi.WritePosition (origin);
X	gi.multicast (self->s.origin, MULTICAST_PHS);
X
X	G_FreeEdict (self);
*/
}
X
void flyer_kamikaze (edict_t *self)
{
X	self->monsterinfo.currentmove = &flyer_move_kamikaze;
}
X
void flyer_kamikaze_check (edict_t *self)
{
X	float	dist;
X
X	// PMM - this needed because we could have gone away before we get here (blocked code)
X	if (!self->inuse)
X		return;
X
X	if ((!self->enemy) || (!self->enemy->inuse))
X	{
X		flyer_kamikaze_explode (self);
X		return;
X	}
X
X	self->goalentity = self->enemy;
X
X	dist = realrange (self, self->enemy);
X
X	if (dist < 90)
X		flyer_kamikaze_explode (self);
}
X
// rogue - kamikaze
X
mframe_t flyer_frames_start [] =
{
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	flyer_nextmove
};
mmove_t flyer_move_start = {FRAME_start01, FRAME_start06, flyer_frames_start, NULL};
X
mframe_t flyer_frames_stop [] =
{
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	NULL,
X		ai_move, 0,	flyer_nextmove
};
mmove_t flyer_move_stop = {FRAME_stop01, FRAME_stop07, flyer_frames_stop, NULL};
X
void flyer_stop (edict_t *self)
{
X		self->monsterinfo.currentmove = &flyer_move_stop;
}
X
void flyer_start (edict_t *self)
{
X		self->monsterinfo.currentmove = &flyer_move_start;
}
X
X
mframe_t flyer_frames_rollright [] =
{
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_rollright = {FRAME_rollr01, FRAME_rollr09, flyer_frames_rollright, NULL};
X
mframe_t flyer_frames_rollleft [] =
{
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_rollleft = {FRAME_rollf01, FRAME_rollf09, flyer_frames_rollleft, NULL};
X
mframe_t flyer_frames_pain3 [] =
{	
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_pain3 = {FRAME_pain301, FRAME_pain304, flyer_frames_pain3, flyer_run};
X
mframe_t flyer_frames_pain2 [] =
{
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_pain2 = {FRAME_pain201, FRAME_pain204, flyer_frames_pain2, flyer_run};
X
mframe_t flyer_frames_pain1 [] =
{
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_pain1 = {FRAME_pain101, FRAME_pain109, flyer_frames_pain1, flyer_run};
X
mframe_t flyer_frames_defense [] = 
{
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,		// Hold this frame
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_defense = {FRAME_defens01, FRAME_defens06, flyer_frames_defense, NULL};
X
mframe_t flyer_frames_bankright [] =
{
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_bankright = {FRAME_bankr01, FRAME_bankr07, flyer_frames_bankright, NULL};
X
mframe_t flyer_frames_bankleft [] =
{
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL,
X		ai_move, 0, NULL
};
mmove_t flyer_move_bankleft = {FRAME_bankl01, FRAME_bankl07, flyer_frames_bankleft, NULL};		
X
X
void flyer_fire (edict_t *self, int flash_number)
{
X	vec3_t	start;
X	vec3_t	forward, right;
X	vec3_t	end;
X	vec3_t	dir;
X	int		effect;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	if ((self->s.frame == FRAME_attak204) || (self->s.frame == FRAME_attak207) || (self->s.frame == FRAME_attak210))
X		effect = EF_HYPERBLASTER;
X	else
X		effect = 0;
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X	
X	VectorCopy (self->enemy->s.origin, end);
X	end[2] += self->enemy->viewheight;
X	VectorSubtract (end, start, dir);
X
X	monster_fire_blaster (self, start, dir, 1, 1000, flash_number, effect);
}
X
void flyer_fireleft (edict_t *self)
{
X	flyer_fire (self, MZ2_FLYER_BLASTER_1);
}
X
void flyer_fireright (edict_t *self)
{
X	flyer_fire (self, MZ2_FLYER_BLASTER_2);
}
X
X
mframe_t flyer_frames_attack2 [] =
{
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, -10, flyer_fireleft,			// left gun
X		ai_charge, -10, flyer_fireright,		// right gun
X		ai_charge, -10, flyer_fireleft,			// left gun
X		ai_charge, -10, flyer_fireright,		// right gun
X		ai_charge, -10, flyer_fireleft,			// left gun
X		ai_charge, -10, flyer_fireright,		// right gun
X		ai_charge, -10, flyer_fireleft,			// left gun
X		ai_charge, -10, flyer_fireright,		// right gun
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL
};
mmove_t flyer_move_attack2 = {FRAME_attak201, FRAME_attak217, flyer_frames_attack2, flyer_run};
X
// PMM
// circle strafe frames
X
mframe_t flyer_frames_attack3 [] =
{
X		ai_charge, 10, NULL,
X		ai_charge, 10, NULL,
X		ai_charge, 10, NULL,
X		ai_charge, 10, flyer_fireleft,			// left gun
X		ai_charge, 10, flyer_fireright,		// right gun
X		ai_charge, 10, flyer_fireleft,			// left gun
X		ai_charge, 10, flyer_fireright,		// right gun
X		ai_charge, 10, flyer_fireleft,			// left gun
X		ai_charge, 10, flyer_fireright,		// right gun
X		ai_charge, 10, flyer_fireleft,			// left gun
X		ai_charge, 10, flyer_fireright,		// right gun
X		ai_charge, 10, NULL,
X		ai_charge, 10, NULL,
X		ai_charge, 10, NULL,
X		ai_charge, 10, NULL,
X		ai_charge, 10, NULL,
X		ai_charge, 10, NULL
};
mmove_t flyer_move_attack3 = {FRAME_attak201, FRAME_attak217, flyer_frames_attack3, flyer_run};
// pmm
X
void flyer_slash_left (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->mins[0], 0);
X	fire_hit (self, aim, 5, 0);
X	gi.sound (self, CHAN_WEAPON, sound_slash, 1, ATTN_NORM, 0);
}
X
void flyer_slash_right (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->maxs[0], 0);
X	fire_hit (self, aim, 5, 0);
X	gi.sound (self, CHAN_WEAPON, sound_slash, 1, ATTN_NORM, 0);
}
X
mframe_t flyer_frames_start_melee [] =
{
X		ai_charge, 0, flyer_pop_blades,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL
};
mmove_t flyer_move_start_melee = {FRAME_attak101, FRAME_attak106, flyer_frames_start_melee, flyer_loop_melee};
X
mframe_t flyer_frames_end_melee [] =
{
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL
};
mmove_t flyer_move_end_melee = {FRAME_attak119, FRAME_attak121, flyer_frames_end_melee, flyer_run};
X
X
mframe_t flyer_frames_loop_melee [] =
{
X		ai_charge, 0, NULL,		// Loop Start
X		ai_charge, 0, NULL,
X		ai_charge, 0, flyer_slash_left,		// Left Wing Strike
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, flyer_slash_right,	// Right Wing Strike
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL,
X		ai_charge, 0, NULL		// Loop Ends
X		
};
mmove_t flyer_move_loop_melee = {FRAME_attak107, FRAME_attak118, flyer_frames_loop_melee, flyer_check_melee};
X
void flyer_loop_melee (edict_t *self)
{
/*	if (random() <= 0.5)	
X		self->monsterinfo.currentmove = &flyer_move_attack1;
X	else */
X	self->monsterinfo.currentmove = &flyer_move_loop_melee;
}
X
X
X
void flyer_attack (edict_t *self)
{
X	float chance;
/*	if (random() <= 0.5)	
X		self->monsterinfo.currentmove = &flyer_move_attack1;
X	else */
X	// 0% chance of circle in easy
X	// 50% chance in normal
X	// 75% chance in hard
X	// 86.67% chance in nightmare
X
X	if (self->mass > 50)
X	{
X		flyer_run (self);
X		return;
X	}
X
X	if (!skill->value)
X		chance = 0;
X	else
X		chance = 1.0 - (0.5/(float)(skill->value));
X
X	if (random() > chance)
X	{
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X		self->monsterinfo.currentmove = &flyer_move_attack2;
X	}
X	else // circle strafe
X	{
X		if (random () <= 0.5) // switch directions
X			self->monsterinfo.lefty = 1 - self->monsterinfo.lefty;
X		self->monsterinfo.attack_state = AS_SLIDING;
X		self->monsterinfo.currentmove = &flyer_move_attack3;
X	}
}
X
void flyer_setstart (edict_t *self)
{
X	nextmove = ACTION_run;
X	self->monsterinfo.currentmove = &flyer_move_start;
}
X
void flyer_nextmove (edict_t *self)
{
X	if (nextmove == ACTION_attack1)
X		self->monsterinfo.currentmove = &flyer_move_start_melee;
X	else if (nextmove == ACTION_attack2)
X		self->monsterinfo.currentmove = &flyer_move_attack2;
X	else if (nextmove == ACTION_run)
X		self->monsterinfo.currentmove = &flyer_move_run;
}
X
void flyer_melee (edict_t *self)
{
//	flyer.nextmove = ACTION_attack1;
//	self->monsterinfo.currentmove = &flyer_move_stop;
X	if (self->mass > 50)
X		flyer_run (self);
X	else
X		self->monsterinfo.currentmove = &flyer_move_start_melee;
}
X
void flyer_check_melee(edict_t *self)
{
X	if (range (self, self->enemy) == RANGE_MELEE)
X		if (random() <= 0.8)
X			self->monsterinfo.currentmove = &flyer_move_loop_melee;
X		else
X			self->monsterinfo.currentmove = &flyer_move_end_melee;
X	else
X		self->monsterinfo.currentmove = &flyer_move_end_melee;
}
X
void flyer_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	int		n;
X
X	//	pmm	 - kamikaze's don't feel pain
X	if (self->mass != 50)
X		return;
X	// pmm
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	n = rand() % 3;
X	if (n == 0)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &flyer_move_pain1;
X	}
X	else if (n == 1)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &flyer_move_pain2;
X	}
X	else
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &flyer_move_pain3;
X	}
}
X
X
void flyer_die(edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	gi.sound (self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
X	BecomeExplosion1(self);
}
X
// PMM - kamikaze code .. blow up if blocked	
int flyer_blocked (edict_t *self, float dist)
{
X	vec3_t origin;
X
X	// kamikaze = 100, normal = 50
X	if (self->mass == 100)
X	{
X		flyer_kamikaze_check(self);
X
X		// if the above didn't blow us up (i.e. I got blocked by the player)
X		if (self->inuse)
X		{
X			if (self->monsterinfo.commander && self->monsterinfo.commander->inuse && 
X				!strcmp(self->monsterinfo.commander->classname, "monster_carrier"))
X			{
X				self->monsterinfo.commander->monsterinfo.monster_slots++;
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("suicide blocked, exploding.  %d slots left\n", self->monsterinfo.commander->monsterinfo.monster_slots);
X			}
X
X			VectorMA (self->s.origin, -0.02, self->velocity, origin);
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_ROCKET_EXPLOSION);
X			gi.WritePosition (origin);
X			gi.multicast (self->s.origin, MULTICAST_PHS);
X
X			G_FreeEdict (self);
X		}
X		return true;
X	}
X	// we're a normal flyer
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	return false;
}
X
/*QUAKED monster_flyer (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_flyer (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	// fix a map bug in jail5.bsp
X	if (!Q_stricmp(level.mapname, "jail5") && (self->s.origin[2] == -104))
X	{
X		self->targetname = self->target;
X		self->target = NULL;
X	}
X
X	sound_sight = gi.soundindex ("flyer/flysght1.wav");
X	sound_idle = gi.soundindex ("flyer/flysrch1.wav");
X	sound_pain1 = gi.soundindex ("flyer/flypain1.wav");
X	sound_pain2 = gi.soundindex ("flyer/flypain2.wav");
X	sound_slash = gi.soundindex ("flyer/flyatck2.wav");
X	sound_sproing = gi.soundindex ("flyer/flyatck1.wav");
X	sound_die = gi.soundindex ("flyer/flydeth1.wav");
X
X	gi.soundindex ("flyer/flyatck3.wav");
X
X	self->s.modelindex = gi.modelindex ("models/monsters/flyer/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	// PMM - shortened to 16 from 32
X	VectorSet (self->maxs, 16, 16, 16);
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X
X	self->s.sound = gi.soundindex ("flyer/flyidle1.wav");
X
X	self->health = 50;
X	self->mass = 50;
X
X	self->pain = flyer_pain;
X	self->die = flyer_die;
X
X	self->monsterinfo.stand = flyer_stand;
X	self->monsterinfo.walk = flyer_walk;
X	self->monsterinfo.run = flyer_run;
X	self->monsterinfo.attack = flyer_attack;
X	self->monsterinfo.melee = flyer_melee;
X	self->monsterinfo.sight = flyer_sight;
X	self->monsterinfo.idle = flyer_idle;
X	self->monsterinfo.blocked = flyer_blocked;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &flyer_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	flymonster_start (self);
}
X
// PMM - suicide fliers
void SP_monster_kamikaze (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_sight = gi.soundindex ("flyer/flysght1.wav");
X	sound_idle = gi.soundindex ("flyer/flysrch1.wav");
X	sound_pain1 = gi.soundindex ("flyer/flypain1.wav");
X	sound_pain2 = gi.soundindex ("flyer/flypain2.wav");
X	sound_slash = gi.soundindex ("flyer/flyatck2.wav");
X	sound_sproing = gi.soundindex ("flyer/flyatck1.wav");
X	sound_die = gi.soundindex ("flyer/flydeth1.wav");
X
X	gi.soundindex ("flyer/flyatck3.wav");
X
X	self->s.modelindex = gi.modelindex ("models/monsters/flyer/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	// used to be 32 tall .. was WAY too big
X	VectorSet (self->maxs, 16, 16, 16);
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X
X	self->s.sound = gi.soundindex ("flyer/flyidle1.wav");
X	
X	self->s.effects |= EF_ROCKET;
X
X	self->health = 50;
X	// PMM - normal flyer has mass of 50
X	self->mass = 100;
X
X	self->pain = flyer_pain;
X	self->die = flyer_die;
X
X	self->monsterinfo.stand = flyer_stand;
X	self->monsterinfo.walk = flyer_walk;
X	self->monsterinfo.run = flyer_run;
X	self->monsterinfo.attack = flyer_attack;
X	self->monsterinfo.melee = flyer_melee;
X	self->monsterinfo.sight = flyer_sight;
X	self->monsterinfo.idle = flyer_idle;
X
X	self->monsterinfo.blocked = flyer_blocked;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &flyer_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	flymonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_flyer.c' &&
  chmod 0664 'm_flyer.c' ||
  $echo 'restore of' 'm_flyer.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_flyer.c:' 'MD5 check failed'
4380dd4733dc3d31364e1606f1e5e8b5  m_flyer.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_flyer.c'`"
    test 20893 -eq "$shar_count" ||
    $echo 'm_flyer.c:' 'original size' '20893,' 'current size' "$shar_count!"
  fi
fi
# ============= m_flyer.h ==============
if test -f 'm_flyer.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_flyer.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_flyer.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_flyer.h' &&
// G:\quake2\baseq2\models/monsters/flyer
X
// This file generated by ModelGen - Do NOT Modify
X
#define ACTION_nothing			0
#define ACTION_attack1			1
#define ACTION_attack2			2
#define ACTION_run				3
#define ACTION_walk				4
X
#define FRAME_start01         	0
#define FRAME_start02         	1
#define FRAME_start03         	2
#define FRAME_start04         	3
#define FRAME_start05         	4
#define FRAME_start06         	5
#define FRAME_stop01          	6
#define FRAME_stop02          	7
#define FRAME_stop03          	8
#define FRAME_stop04          	9
#define FRAME_stop05          	10
#define FRAME_stop06          	11
#define FRAME_stop07          	12
#define FRAME_stand01         	13
#define FRAME_stand02         	14
#define FRAME_stand03         	15
#define FRAME_stand04         	16
#define FRAME_stand05         	17
#define FRAME_stand06         	18
#define FRAME_stand07         	19
#define FRAME_stand08         	20
#define FRAME_stand09         	21
#define FRAME_stand10         	22
#define FRAME_stand11         	23
#define FRAME_stand12         	24
#define FRAME_stand13         	25
#define FRAME_stand14         	26
#define FRAME_stand15         	27
#define FRAME_stand16         	28
#define FRAME_stand17         	29
#define FRAME_stand18         	30
#define FRAME_stand19         	31
#define FRAME_stand20         	32
#define FRAME_stand21         	33
#define FRAME_stand22         	34
#define FRAME_stand23         	35
#define FRAME_stand24         	36
#define FRAME_stand25         	37
#define FRAME_stand26         	38
#define FRAME_stand27         	39
#define FRAME_stand28         	40
#define FRAME_stand29         	41
#define FRAME_stand30         	42
#define FRAME_stand31         	43
#define FRAME_stand32         	44
#define FRAME_stand33         	45
#define FRAME_stand34         	46
#define FRAME_stand35         	47
#define FRAME_stand36         	48
#define FRAME_stand37         	49
#define FRAME_stand38         	50
#define FRAME_stand39         	51
#define FRAME_stand40         	52
#define FRAME_stand41         	53
#define FRAME_stand42         	54
#define FRAME_stand43         	55
#define FRAME_stand44         	56
#define FRAME_stand45         	57
#define FRAME_attak101        	58
#define FRAME_attak102        	59
#define FRAME_attak103        	60
#define FRAME_attak104        	61
#define FRAME_attak105        	62
#define FRAME_attak106        	63
#define FRAME_attak107        	64
#define FRAME_attak108        	65
#define FRAME_attak109        	66
#define FRAME_attak110        	67
#define FRAME_attak111        	68
#define FRAME_attak112        	69
#define FRAME_attak113        	70
#define FRAME_attak114        	71
#define FRAME_attak115        	72
#define FRAME_attak116        	73
#define FRAME_attak117        	74
#define FRAME_attak118        	75
#define FRAME_attak119        	76
#define FRAME_attak120        	77
#define FRAME_attak121        	78
#define FRAME_attak201        	79
#define FRAME_attak202        	80
#define FRAME_attak203        	81
#define FRAME_attak204        	82
#define FRAME_attak205        	83
#define FRAME_attak206        	84
#define FRAME_attak207        	85
#define FRAME_attak208        	86
#define FRAME_attak209        	87
#define FRAME_attak210        	88
#define FRAME_attak211        	89
#define FRAME_attak212        	90
#define FRAME_attak213        	91
#define FRAME_attak214        	92
#define FRAME_attak215        	93
#define FRAME_attak216        	94
#define FRAME_attak217        	95
#define FRAME_bankl01         	96
#define FRAME_bankl02         	97
#define FRAME_bankl03         	98
#define FRAME_bankl04         	99
#define FRAME_bankl05         	100
#define FRAME_bankl06         	101
#define FRAME_bankl07         	102
#define FRAME_bankr01         	103
#define FRAME_bankr02         	104
#define FRAME_bankr03         	105
#define FRAME_bankr04         	106
#define FRAME_bankr05         	107
#define FRAME_bankr06         	108
#define FRAME_bankr07         	109
#define FRAME_rollf01         	110
#define FRAME_rollf02         	111
#define FRAME_rollf03         	112
#define FRAME_rollf04         	113
#define FRAME_rollf05         	114
#define FRAME_rollf06         	115
#define FRAME_rollf07         	116
#define FRAME_rollf08         	117
#define FRAME_rollf09         	118
#define FRAME_rollr01         	119
#define FRAME_rollr02         	120
#define FRAME_rollr03         	121
#define FRAME_rollr04         	122
#define FRAME_rollr05         	123
#define FRAME_rollr06         	124
#define FRAME_rollr07         	125
#define FRAME_rollr08         	126
#define FRAME_rollr09         	127
#define FRAME_defens01        	128
#define FRAME_defens02        	129
#define FRAME_defens03        	130
#define FRAME_defens04        	131
#define FRAME_defens05        	132
#define FRAME_defens06        	133
#define FRAME_pain101         	134
#define FRAME_pain102         	135
#define FRAME_pain103         	136
#define FRAME_pain104         	137
#define FRAME_pain105         	138
#define FRAME_pain106         	139
#define FRAME_pain107         	140
#define FRAME_pain108         	141
#define FRAME_pain109         	142
#define FRAME_pain201         	143
#define FRAME_pain202         	144
#define FRAME_pain203         	145
#define FRAME_pain204         	146
#define FRAME_pain301         	147
#define FRAME_pain302         	148
#define FRAME_pain303         	149
#define FRAME_pain304         	150
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_flyer.h' &&
  chmod 0664 'm_flyer.h' ||
  $echo 'restore of' 'm_flyer.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_flyer.h:' 'MD5 check failed'
bd6889a1702ab0ca9a3d1fd4133331bd  m_flyer.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_flyer.h'`"
    test 5432 -eq "$shar_count" ||
    $echo 'm_flyer.h:' 'original size' '5432,' 'current size' "$shar_count!"
  fi
fi
# ============= m_gladiator.c ==============
if test -f 'm_gladiator.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_gladiator.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_gladiator.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_gladiator.c' &&
/*
==============================================================================
X
GLADIATOR
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_gladiator.h"
X
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_die;
static int	sound_gun;
static int	sound_cleaver_swing;
static int	sound_cleaver_hit;
static int	sound_cleaver_miss;
static int	sound_idle;
static int	sound_search;
static int	sound_sight;
X
X
void gladiator_idle (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
void gladiator_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void gladiator_search (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
}
X
void gladiator_cleaver_swing (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_cleaver_swing, 1, ATTN_NORM, 0);
}
X
mframe_t gladiator_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t gladiator_move_stand = {FRAME_stand1, FRAME_stand7, gladiator_frames_stand, NULL};
X
void gladiator_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &gladiator_move_stand;
}
X
X
mframe_t gladiator_frames_walk [] =
{
X	ai_walk, 15, NULL,
X	ai_walk, 7,  NULL,
X	ai_walk, 6,  NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 8,  NULL,
X	ai_walk, 12, NULL,
X	ai_walk, 8,  NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 1,  NULL,
X	ai_walk, 8,  NULL
};
mmove_t gladiator_move_walk = {FRAME_walk1, FRAME_walk16, gladiator_frames_walk, NULL};
X
void gladiator_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &gladiator_move_walk;
}
X
X
mframe_t gladiator_frames_run [] =
{
X	ai_run, 23,	NULL,
X	ai_run, 14,	NULL,
X	ai_run, 14,	NULL,
X	ai_run, 21,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 13,	NULL
};
mmove_t gladiator_move_run = {FRAME_run1, FRAME_run6, gladiator_frames_run, NULL};
X
void gladiator_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &gladiator_move_stand;
X	else
X		self->monsterinfo.currentmove = &gladiator_move_run;
}
X
X
void GaldiatorMelee (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->mins[0], -4);
X	if (fire_hit (self, aim, (20 + (rand() %5)), 300))
X		gi.sound (self, CHAN_AUTO, sound_cleaver_hit, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_AUTO, sound_cleaver_miss, 1, ATTN_NORM, 0);
}
X
mframe_t gladiator_frames_attack_melee [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, gladiator_cleaver_swing,
X	ai_charge, 0, NULL,
X	ai_charge, 0, GaldiatorMelee,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, gladiator_cleaver_swing,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, GaldiatorMelee,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t gladiator_move_attack_melee = {FRAME_melee1, FRAME_melee17, gladiator_frames_attack_melee, gladiator_run};
X
void gladiator_melee(edict_t *self)
{
X	self->monsterinfo.currentmove = &gladiator_move_attack_melee;
}
X
X
void GladiatorGun (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	forward, right;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_GLADIATOR_RAILGUN_1], forward, right, start);
X
X	// calc direction to where we targted
X	VectorSubtract (self->pos1, start, dir);
X	VectorNormalize (dir);
X
X	monster_fire_railgun (self, start, dir, 50, 100, MZ2_GLADIATOR_RAILGUN_1);
}
X
mframe_t gladiator_frames_attack_gun [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, GladiatorGun,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t gladiator_move_attack_gun = {FRAME_attack1, FRAME_attack9, gladiator_frames_attack_gun, gladiator_run};
X
void gladiator_attack(edict_t *self)
{
X	float	range;
X	vec3_t	v;
X
X	// a small safe zone
X	VectorSubtract (self->s.origin, self->enemy->s.origin, v);
X	range = VectorLength(v);
X	if (range <= (MELEE_DISTANCE + 32))
X		return;
X
X	// charge up the railgun
X	gi.sound (self, CHAN_WEAPON, sound_gun, 1, ATTN_NORM, 0);
X	VectorCopy (self->enemy->s.origin, self->pos1);	//save for aiming the shot
X	self->pos1[2] += self->enemy->viewheight;
X	self->monsterinfo.currentmove = &gladiator_move_attack_gun;
}
X
X
mframe_t gladiator_frames_pain [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t gladiator_move_pain = {FRAME_pain1, FRAME_pain6, gladiator_frames_pain, gladiator_run};
X
mframe_t gladiator_frames_pain_air [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t gladiator_move_pain_air = {FRAME_painup1, FRAME_painup7, gladiator_frames_pain_air, gladiator_run};
X
void gladiator_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X	{
X		if ((self->velocity[2] > 100) && (self->monsterinfo.currentmove == &gladiator_move_pain))
X			self->monsterinfo.currentmove = &gladiator_move_pain_air;
X		return;
X	}
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (random() < 0.5)
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	if (self->velocity[2] > 100)
X		self->monsterinfo.currentmove = &gladiator_move_pain_air;
X	else
X		self->monsterinfo.currentmove = &gladiator_move_pain;
X	
}
X
X
void gladiator_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t gladiator_frames_death [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t gladiator_move_death = {FRAME_death1, FRAME_death22, gladiator_frames_death, gladiator_dead};
X
void gladiator_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	self->monsterinfo.currentmove = &gladiator_move_death;
}
X
//===========
//PGM
qboolean gladiator_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
//PGM
//===========
X
/*QUAKED monster_gladiator (1 .5 0) (-32 -32 -24) (32 32 64) Ambush Trigger_Spawn Sight
*/
void SP_monster_gladiator (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X
X	sound_pain1 = gi.soundindex ("gladiator/pain.wav");	
X	sound_pain2 = gi.soundindex ("gladiator/gldpain2.wav");	
X	sound_die = gi.soundindex ("gladiator/glddeth2.wav");	
X	sound_gun = gi.soundindex ("gladiator/railgun.wav");
X	sound_cleaver_swing = gi.soundindex ("gladiator/melee1.wav");
X	sound_cleaver_hit = gi.soundindex ("gladiator/melee2.wav");
X	sound_cleaver_miss = gi.soundindex ("gladiator/melee3.wav");
X	sound_idle = gi.soundindex ("gladiator/gldidle1.wav");
X	sound_search = gi.soundindex ("gladiator/gldsrch1.wav");
X	sound_sight = gi.soundindex ("gladiator/sight.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/gladiatr/tris.md2");
X	VectorSet (self->mins, -32, -32, -24);
X	VectorSet (self->maxs, 32, 32, 64);
X
X	self->health = 400;
X	self->gib_health = -175;
X	self->mass = 400;
X
X	self->pain = gladiator_pain;
X	self->die = gladiator_die;
X
X	self->monsterinfo.stand = gladiator_stand;
X	self->monsterinfo.walk = gladiator_walk;
X	self->monsterinfo.run = gladiator_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = gladiator_attack;
X	self->monsterinfo.melee = gladiator_melee;
X	self->monsterinfo.sight = gladiator_sight;
X	self->monsterinfo.idle = gladiator_idle;
X	self->monsterinfo.search = gladiator_search;
X	self->monsterinfo.blocked = gladiator_blocked;		// PGM
X
X	gi.linkentity (self);
X	self->monsterinfo.currentmove = &gladiator_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_gladiator.c' &&
  chmod 0664 'm_gladiator.c' ||
  $echo 'restore of' 'm_gladiator.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_gladiator.c:' 'MD5 check failed'
c99790dbad4caf1e9d27690d92664f95  m_gladiator.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_gladiator.c'`"
    test 9435 -eq "$shar_count" ||
    $echo 'm_gladiator.c:' 'original size' '9435,' 'current size' "$shar_count!"
  fi
fi
# ============= m_gladiator.h ==============
if test -f 'm_gladiator.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_gladiator.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_gladiator.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_gladiator.h' &&
// G:\quake2\baseq2\models/monsters/gladiatr
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_stand1          	0
#define FRAME_stand2          	1
#define FRAME_stand3          	2
#define FRAME_stand4          	3
#define FRAME_stand5          	4
#define FRAME_stand6          	5
#define FRAME_stand7          	6
#define FRAME_walk1           	7
#define FRAME_walk2           	8
#define FRAME_walk3           	9
#define FRAME_walk4           	10
#define FRAME_walk5           	11
#define FRAME_walk6           	12
#define FRAME_walk7           	13
#define FRAME_walk8           	14
#define FRAME_walk9           	15
#define FRAME_walk10          	16
#define FRAME_walk11          	17
#define FRAME_walk12          	18
#define FRAME_walk13          	19
#define FRAME_walk14          	20
#define FRAME_walk15          	21
#define FRAME_walk16          	22
#define FRAME_run1            	23
#define FRAME_run2            	24
#define FRAME_run3            	25
#define FRAME_run4            	26
#define FRAME_run5            	27
#define FRAME_run6            	28
#define FRAME_melee1          	29
#define FRAME_melee2          	30
#define FRAME_melee3          	31
#define FRAME_melee4          	32
#define FRAME_melee5          	33
#define FRAME_melee6          	34
#define FRAME_melee7          	35
#define FRAME_melee8          	36
#define FRAME_melee9          	37
#define FRAME_melee10         	38
#define FRAME_melee11         	39
#define FRAME_melee12         	40
#define FRAME_melee13         	41
#define FRAME_melee14         	42
#define FRAME_melee15         	43
#define FRAME_melee16         	44
#define FRAME_melee17         	45
#define FRAME_attack1         	46
#define FRAME_attack2         	47
#define FRAME_attack3         	48
#define FRAME_attack4         	49
#define FRAME_attack5         	50
#define FRAME_attack6         	51
#define FRAME_attack7         	52
#define FRAME_attack8         	53
#define FRAME_attack9         	54
#define FRAME_pain1           	55
#define FRAME_pain2           	56
#define FRAME_pain3           	57
#define FRAME_pain4           	58
#define FRAME_pain5           	59
#define FRAME_pain6           	60
#define FRAME_death1          	61
#define FRAME_death2          	62
#define FRAME_death3          	63
#define FRAME_death4          	64
#define FRAME_death5          	65
#define FRAME_death6          	66
#define FRAME_death7          	67
#define FRAME_death8          	68
#define FRAME_death9          	69
#define FRAME_death10         	70
#define FRAME_death11         	71
#define FRAME_death12         	72
#define FRAME_death13         	73
#define FRAME_death14         	74
#define FRAME_death15         	75
#define FRAME_death16         	76
#define FRAME_death17         	77
#define FRAME_death18         	78
#define FRAME_death19         	79
#define FRAME_death20         	80
#define FRAME_death21         	81
#define FRAME_death22         	82
#define FRAME_painup1         	83
#define FRAME_painup2         	84
#define FRAME_painup3         	85
#define FRAME_painup4         	86
#define FRAME_painup5         	87
#define FRAME_painup6         	88
#define FRAME_painup7         	89
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_gladiator.h' &&
  chmod 0664 'm_gladiator.h' ||
  $echo 'restore of' 'm_gladiator.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_gladiator.h:' 'MD5 check failed'
4dda7f37646c9ae8887776f8ef7936d9  m_gladiator.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_gladiator.h'`"
    test 3179 -eq "$shar_count" ||
    $echo 'm_gladiator.h:' 'original size' '3179,' 'current size' "$shar_count!"
  fi
fi
# ============= m_gunner.c ==============
if test -f 'm_gunner.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_gunner.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_gunner.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_gunner.c' &&
/*
==============================================================================
X
GUNNER
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_gunner.h"
X
X
static int	sound_pain;
static int	sound_pain2;
static int	sound_death;
static int	sound_idle;
static int	sound_open;
static int	sound_search;
static int	sound_sight;
X
void gunner_idlesound (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
void gunner_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void gunner_search (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
}
X
X
qboolean visible (edict_t *self, edict_t *other);
void GunnerGrenade (edict_t *self);
void GunnerFire (edict_t *self);
void gunner_fire_chain(edict_t *self);
void gunner_refire_chain(edict_t *self);
X
X
void gunner_stand (edict_t *self);
X
mframe_t gunner_frames_fidget [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, gunner_idlesound,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	gunner_move_fidget = {FRAME_stand31, FRAME_stand70, gunner_frames_fidget, gunner_stand};
X
void gunner_fidget (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		return;
X	if (random() <= 0.05)
X		self->monsterinfo.currentmove = &gunner_move_fidget;
}
X
mframe_t gunner_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, gunner_fidget,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, gunner_fidget,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, gunner_fidget
};
mmove_t	gunner_move_stand = {FRAME_stand01, FRAME_stand30, gunner_frames_stand, NULL};
X
void gunner_stand (edict_t *self)
{
X		self->monsterinfo.currentmove = &gunner_move_stand;
}
X
X
mframe_t gunner_frames_walk [] =
{
X	ai_walk, 0, NULL,
X	ai_walk, 3, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 7, NULL,
X	ai_walk, 2, NULL,
X	ai_walk, 6, NULL,
X	ai_walk, 4, NULL,
X	ai_walk, 2, NULL,
X	ai_walk, 7, NULL,
X	ai_walk, 5, NULL,
X	ai_walk, 7, NULL,
X	ai_walk, 4, NULL
};
mmove_t gunner_move_walk = {FRAME_walk07, FRAME_walk19, gunner_frames_walk, NULL};
X
void gunner_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &gunner_move_walk;
}
X
mframe_t gunner_frames_run [] =
{
X	ai_run, 26, NULL,
X	ai_run, 9,  NULL,
X	ai_run, 9,  NULL,
X	ai_run, 9,  monster_done_dodge,
X	ai_run, 15, NULL,
X	ai_run, 10, NULL,
X	ai_run, 13, NULL,
X	ai_run, 6,  NULL
};
X
mmove_t gunner_move_run = {FRAME_run01, FRAME_run08, gunner_frames_run, NULL};
X
void gunner_run (edict_t *self)
{
X	monster_done_dodge(self);
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &gunner_move_stand;
X	else
X		self->monsterinfo.currentmove = &gunner_move_run;
}
X
mframe_t gunner_frames_runandshoot [] =
{
X	ai_run, 32, NULL,
X	ai_run, 15, NULL,
X	ai_run, 10, NULL,
X	ai_run, 18, NULL,
X	ai_run, 8,  NULL,
X	ai_run, 20, NULL
};
X
mmove_t gunner_move_runandshoot = {FRAME_runs01, FRAME_runs06, gunner_frames_runandshoot, NULL};
X
void gunner_runandshoot (edict_t *self)
{
X	self->monsterinfo.currentmove = &gunner_move_runandshoot;
}
X
mframe_t gunner_frames_pain3 [] =
{
X	ai_move, -3, NULL,
X	ai_move, 1,	 NULL,
X	ai_move, 1,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 1,	 NULL
};
mmove_t gunner_move_pain3 = {FRAME_pain301, FRAME_pain305, gunner_frames_pain3, gunner_run};
X
mframe_t gunner_frames_pain2 [] =
{
X	ai_move, -2, NULL,
X	ai_move, 11, NULL,
X	ai_move, 6,	 NULL,
X	ai_move, 2,	 NULL,
X	ai_move, -1, NULL,
X	ai_move, -7, NULL,
X	ai_move, -2, NULL,
X	ai_move, -7, NULL
};
mmove_t gunner_move_pain2 = {FRAME_pain201, FRAME_pain208, gunner_frames_pain2, gunner_run};
X
mframe_t gunner_frames_pain1 [] =
{
X	ai_move, 2,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, -5, NULL,
X	ai_move, 3,	 NULL,
X	ai_move, -1, NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 1,	 NULL,
X	ai_move, 1,	 NULL,
X	ai_move, 2,	 NULL,
X	ai_move, 1,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, -2, NULL,
X	ai_move, -2, NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL
};
mmove_t gunner_move_pain1 = {FRAME_pain101, FRAME_pain118, gunner_frames_pain1, gunner_run};
X
void gunner_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	monster_done_dodge (self);
X
X	if (!self->groundentity)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("gunner: pain avoided due to no ground\n");
X		return;
X	}
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (rand()&1)
X		gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	if (damage <= 10)
X		self->monsterinfo.currentmove = &gunner_move_pain3;
X	else if (damage <= 25)
X		self->monsterinfo.currentmove = &gunner_move_pain2;
X	else
X		self->monsterinfo.currentmove = &gunner_move_pain1;
X
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X
X	// PMM - clear duck flag
X	if (self->monsterinfo.aiflags & AI_DUCKED)
X		monster_duck_up(self);
}
X
void gunner_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t gunner_frames_death [] =
{
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, -7, NULL,
X	ai_move, -3, NULL,
X	ai_move, -5, NULL,
X	ai_move, 8,	 NULL,
X	ai_move, 6,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL
};
mmove_t gunner_move_death = {FRAME_death01, FRAME_death11, gunner_frames_death, gunner_dead};
X
void gunner_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->monsterinfo.currentmove = &gunner_move_death;
}
X
// PMM - changed to duck code for new dodge
X
//
// this is specific to the gunner, leave it be
//
void gunner_duck_down (edict_t *self)
{
//	if (self->monsterinfo.aiflags & AI_DUCKED)
//		return;
X	self->monsterinfo.aiflags |= AI_DUCKED;
X	if (skill->value >= 2)
X	{
X		if (random() > 0.5)
X			GunnerGrenade (self);
X	}
X
//	self->maxs[2] -= 32;
X	self->maxs[2] = self->monsterinfo.base_height - 32;
X	self->takedamage = DAMAGE_YES;
X	if (self->monsterinfo.duck_wait_time < level.time)
X		self->monsterinfo.duck_wait_time = level.time + 1;
X	gi.linkentity (self);
}
X
mframe_t gunner_frames_duck [] =
{
X	ai_move, 1,  gunner_duck_down,
X	ai_move, 1,  NULL,
X	ai_move, 1,  monster_duck_hold,
X	ai_move, 0,  NULL,
X	ai_move, -1, NULL,
X	ai_move, -1, NULL,
X	ai_move, 0,  monster_duck_up,
X	ai_move, -1, NULL
};
mmove_t	gunner_move_duck = {FRAME_duck01, FRAME_duck08, gunner_frames_duck, gunner_run};
X
// PMM - gunner dodge moved below so I know about attack sequences
X
void gunner_opengun (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_open, 1, ATTN_IDLE, 0);
}
X
void GunnerFire (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	forward, right;
X	vec3_t	target;
X	vec3_t	aim;
X	int		flash_number;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	flash_number = MZ2_GUNNER_MACHINEGUN_1 + (self->s.frame - FRAME_attak216);
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	// project enemy back a bit and target there
X	VectorCopy (self->enemy->s.origin, target);
X	VectorMA (target, -0.2, self->enemy->velocity, target);
X	target[2] += self->enemy->viewheight;
X
X	VectorSubtract (target, start, aim);
X	VectorNormalize (aim);
X	monster_fire_bullet (self, start, aim, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
}
X
qboolean gunner_grenade_check(edict_t *self)
{
X	vec3_t		start;
X	vec3_t		forward, right;
X	trace_t		tr;
X	vec3_t		target, dir;
X
X	if(!self->enemy)
X		return false;
X
X	// if the player is above my head, use machinegun.
X
X	// check for flag telling us that we're blindfiring
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X	{
X		if (self->s.origin[2]+self->viewheight < self->monsterinfo.blind_fire_target[2])
X		{
//			if(g_showlogic && g_showlogic->value)
//				gi.dprintf("blind_fire_target is above my head, using machinegun\n");
X			return false;
X		}
X	}
X	else if(self->absmax[2] <= self->enemy->absmin[2])
X	{
//		if(g_showlogic && g_showlogic->value)
//			gi.dprintf("player is above my head, using machinegun\n");
X		return false;
X	}
X
X	// check to see that we can trace to the player before we start
X	// tossing grenades around.
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_GUNNER_GRENADE_1], forward, right, start);
X
X	// pmm - check for blindfire flag
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X		VectorCopy (self->monsterinfo.blind_fire_target, target);
X	else
X		VectorCopy (self->enemy->s.origin, target);
X
X	// see if we're too close
X	VectorSubtract (self->s.origin, target, dir);
X
X	if (VectorLength(dir) < 100)
X		return false;
X
X	tr = gi.trace(start, vec3_origin, vec3_origin, target, self, MASK_SHOT);
X	if(tr.ent == self->enemy || tr.fraction == 1)
X		return true;
X
//	if(g_showlogic && g_showlogic->value)
//		gi.dprintf("can't trace to target, using machinegun\n");
X	return false;
}
X
void GunnerGrenade (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	forward, right, up;
X	vec3_t	aim;
X	int		flash_number;
X	float	spread;
X	float	pitch;
X	// PMM
X	vec3_t	target;	
X	qboolean blindfire;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	// pmm
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X		blindfire = true;
X
X	if (self->s.frame == FRAME_attak105)
X	{
X		spread = .02;
X		flash_number = MZ2_GUNNER_GRENADE_1;
X	}
X	else if (self->s.frame == FRAME_attak108)
X	{
X		spread = .05;
X		flash_number = MZ2_GUNNER_GRENADE_2;
X	}
X	else if (self->s.frame == FRAME_attak111)
X	{
X		spread = .08;
X		flash_number = MZ2_GUNNER_GRENADE_3;
X	}
X	else // (self->s.frame == FRAME_attak114)
X	{
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		spread = .11;
X		flash_number = MZ2_GUNNER_GRENADE_4;
X	}
X
X	//	pmm
X	// if we're shooting blind and we still can't see our enemy
X	if ((blindfire) && (!visible(self, self->enemy)))
X	{
X		// and we have a valid blind_fire_target
X		if (VectorCompare (self->monsterinfo.blind_fire_target, vec3_origin))
X			return;
X		
//		gi.dprintf ("blind_fire_target = %s\n", vtos (self->monsterinfo.blind_fire_target));
//		gi.dprintf ("GunnerGrenade: ideal yaw is %f\n", self->ideal_yaw);
X		VectorCopy (self->monsterinfo.blind_fire_target, target);
X	}
X	else
X		VectorCopy (self->s.origin, target);
X	// pmm
X
X	AngleVectors (self->s.angles, forward, right, up);	//PGM
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
//PGM
X	if(self->enemy)
X	{
X		float	dist;
X
//		VectorSubtract(self->enemy->s.origin, self->s.origin, aim);
X		VectorSubtract(target, self->s.origin, aim);
X		dist = VectorLength(aim);
X
X		// aim up if they're on the same level as me and far away.
X		if((dist > 512) && (aim[2] < 64) && (aim[2] > -64))
X		{
X			aim[2] += (dist - 512);
X		}
X
X		VectorNormalize (aim);
X		pitch = aim[2];
X		if(pitch > 0.4)
X		{
X			pitch = 0.4;
X		}
X		else if(pitch < -0.5)
X			pitch = -0.5;
X	}
//PGM
X
X	//FIXME : do a spread -225 -75 75 225 degrees around forward
//	VectorCopy (forward, aim);
X	VectorMA (forward, spread, right, aim);
X	VectorMA (aim, pitch, up, aim);
X
X	monster_fire_grenade (self, start, aim, 50, 600, flash_number);
}
X
mframe_t gunner_frames_attack_chain [] =
{
X	/*
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	*/
X	ai_charge, 0, gunner_opengun,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t gunner_move_attack_chain = {FRAME_attak209, FRAME_attak215, gunner_frames_attack_chain, gunner_fire_chain};
X
mframe_t gunner_frames_fire_chain [] =
{
X	ai_charge,   0, GunnerFire,
X	ai_charge,   0, GunnerFire,
X	ai_charge,   0, GunnerFire,
X	ai_charge,   0, GunnerFire,
X	ai_charge,   0, GunnerFire,
X	ai_charge,   0, GunnerFire,
X	ai_charge,   0, GunnerFire,
X	ai_charge,   0, GunnerFire
};
mmove_t gunner_move_fire_chain = {FRAME_attak216, FRAME_attak223, gunner_frames_fire_chain, gunner_refire_chain};
X
mframe_t gunner_frames_endfire_chain [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t gunner_move_endfire_chain = {FRAME_attak224, FRAME_attak230, gunner_frames_endfire_chain, gunner_run};
X
void gunner_blind_check (edict_t *self)
{
X	vec3_t	aim;
X
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X	{
X		VectorSubtract(self->monsterinfo.blind_fire_target, self->s.origin, aim);
X		self->ideal_yaw = vectoyaw(aim);
X		
//		gi.dprintf ("blind_fire_target = %s\n", vtos (self->monsterinfo.blind_fire_target));
//		gi.dprintf ("gunner_attack: ideal yaw is %f\n", self->ideal_yaw);
X	}
}
X
mframe_t gunner_frames_attack_grenade [] =
{
X	ai_charge, 0, gunner_blind_check,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, GunnerGrenade,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, GunnerGrenade,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, GunnerGrenade,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, GunnerGrenade,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t gunner_move_attack_grenade = {FRAME_attak101, FRAME_attak121, gunner_frames_attack_grenade, gunner_run};
X
void gunner_attack(edict_t *self)
{
X	float chance, r;
X
X	monster_done_dodge(self);
X
X	// PMM 
X	if (self->monsterinfo.attack_state == AS_BLIND)
X	{
X		// setup shot probabilities
X		if (self->monsterinfo.blind_fire_delay < 1.0)
X			chance = 1.0;
X		else if (self->monsterinfo.blind_fire_delay < 7.5)
X			chance = 0.4;
X		else
X			chance = 0.1;
X
X		r = random();
X
X		// minimum of 2 seconds, plus 0-3, after the shots are done
X		self->monsterinfo.blind_fire_delay += 2.1 + 2.0 + random()*3.0;
X
X		// don't shoot at the origin
X		if (VectorCompare (self->monsterinfo.blind_fire_target, vec3_origin))
X			return;
X
X		// don't shoot if the dice say not to
X		if (r > chance)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("blindfire - NO SHOT\n");
X			return;
X		}
X
X		// turn on manual steering to signal both manual steering and blindfire
X		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X		if (gunner_grenade_check(self))
X		{
X			// if the check passes, go for the attack
X			self->monsterinfo.currentmove = &gunner_move_attack_grenade;
X			self->monsterinfo.attack_finished = level.time + 2*random();
X		}
X		// pmm - should this be active?
//		else
//			self->monsterinfo.currentmove = &gunner_move_attack_chain;
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("blind grenade check failed, doing nothing\n");
X
X		// turn off blindfire flag
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		return;
X	}
X	// pmm
X
X	// PGM - gunner needs to use his chaingun if he's being attacked by a tesla.
X	if ((range (self, self->enemy) == RANGE_MELEE) || self->bad_area)
X	{
X		self->monsterinfo.currentmove = &gunner_move_attack_chain;
X	}
X	else
X	{
X		if (random() <= 0.5 && gunner_grenade_check(self))
X			self->monsterinfo.currentmove = &gunner_move_attack_grenade;
X		else
X			self->monsterinfo.currentmove = &gunner_move_attack_chain;
X	}
}
X
void gunner_fire_chain(edict_t *self)
{
X	self->monsterinfo.currentmove = &gunner_move_fire_chain;
}
X
void gunner_refire_chain(edict_t *self)
{
X	if (self->enemy->health > 0)
X		if ( visible (self, self->enemy) )
X			if (random() <= 0.5)
X			{
X				self->monsterinfo.currentmove = &gunner_move_fire_chain;
X				return;
X			}
X	self->monsterinfo.currentmove = &gunner_move_endfire_chain;
}
/*
void gunner_dodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
// original quake2 dodge code
X
X	if (random() > 0.25)
X		return;
X
X	if (!self->enemy)
X		self->enemy = attacker;
X
X	self->monsterinfo.currentmove = &gunner_move_duck;
X
//===========
//PMM - rogue rewrite of gunner dodge code.
X	float	r;
X	float	height;
X	int		shooting = 0;
X
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget (self);
X	}
X
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X		return;
X
X	r = random();
X	if (r > (0.25*((skill->value)+1)))
X		return;
X
X	if ((self->monsterinfo.currentmove == &gunner_move_attack_chain) ||
X		(self->monsterinfo.currentmove == &gunner_move_fire_chain) ||
X		(self->monsterinfo.currentmove == &gunner_move_attack_grenade)
X		)
X	{
X		shooting = 1;
X	}
X	if (self->monsterinfo.aiflags & AI_DODGING)
X	{
X		height = self->absmax[2];
X	}
X	else
X	{
X		height = self->absmax[2]-32-1;  // the -1 is because the absmax is s.origin + maxs + 1
X	}
X
X	// check to see if it makes sense to duck
X	if (tr->endpos[2] <= height)
X	{
X		vec3_t right, diff;
X		if (shooting)
X		{
X			self->monsterinfo.attack_state = AS_SLIDING;
X			return;
X		}
X		AngleVectors (self->s.angles, NULL, right, NULL);
X		VectorSubtract (tr->endpos, self->s.origin, diff);
X		if (DotProduct (right, diff) < 0)
X		{
X			self->monsterinfo.lefty = 1;
X		}
X		// if it doesn't sense to duck, try to strafe away
X		monster_done_dodge (self);
X		self->monsterinfo.currentmove = &gunner_move_run;
X		self->monsterinfo.attack_state = AS_SLIDING;
X		return;
X	}
X
X	if (skill->value == 0)
X	{
X		self->monsterinfo.currentmove = &gunner_move_duck;
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		self->monsterinfo.aiflags |= AI_DODGING;
X		return;
X	}
X
X	if (!shooting)
X	{
X		self->monsterinfo.currentmove = &gunner_move_duck;
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X		self->monsterinfo.aiflags |= AI_DODGING;
X	}
X	return;
//PMM
//===========
}
*/
//===========
//PGM
void gunner_jump_now (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 100, forward, self->velocity);
X	VectorMA(self->velocity, 300, up, self->velocity);
}
X
void gunner_jump2_now (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 150, forward, self->velocity);
X	VectorMA(self->velocity, 400, up, self->velocity);
}
X
void gunner_jump_wait_land (edict_t *self)
{
X	if(self->groundentity == NULL)
X	{
X		self->monsterinfo.nextframe = self->s.frame;
X
X		if(monster_jump_finished (self))
X			self->monsterinfo.nextframe = self->s.frame + 1;
X	}
X	else 
X		self->monsterinfo.nextframe = self->s.frame + 1;
}
X
mframe_t gunner_frames_jump [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, gunner_jump_now,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, gunner_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t gunner_move_jump = { FRAME_jump01, FRAME_jump10, gunner_frames_jump, gunner_run };
X
mframe_t gunner_frames_jump2 [] =
{
X	ai_move, -8, NULL,
X	ai_move, -4, NULL,
X	ai_move, -4, NULL,
X	ai_move, 0, gunner_jump_now,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, gunner_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t gunner_move_jump2 = { FRAME_jump01, FRAME_jump10, gunner_frames_jump2, gunner_run };
X
void gunner_jump (edict_t *self)
{
X	if(!self->enemy)
X		return;
X
X	monster_done_dodge (self);
X
X	if(self->enemy->s.origin[2] > self->s.origin[2])
X		self->monsterinfo.currentmove = &gunner_move_jump2;
X	else
X		self->monsterinfo.currentmove = &gunner_move_jump;
}
X
//===========
//PGM
qboolean gunner_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	if(blocked_checkjump (self, dist, 192, 40))
X	{
X		gunner_jump(self);
X		return true;
X	}
X
X	return false;
}
//PGM
//===========
X
// PMM - new duck code
void gunner_duck (edict_t *self, float eta)
{
X	if ((self->monsterinfo.currentmove == &gunner_move_jump2) ||
X		(self->monsterinfo.currentmove == &gunner_move_jump))
X	{
X		return;
X	}
X
X	if ((self->monsterinfo.currentmove == &gunner_move_attack_chain) ||
X		(self->monsterinfo.currentmove == &gunner_move_fire_chain) ||
X		(self->monsterinfo.currentmove == &gunner_move_attack_grenade)
X		)
X	{
X		// if we're shooting, and not on easy, don't dodge
X		if (skill->value)
X		{
X			self->monsterinfo.aiflags &= ~AI_DUCKED;
X			return;
X		}
X	}
X
X	if (skill->value == 0)
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X	else
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X
X	// has to be done immediately otherwise he can get stuck
X	gunner_duck_down(self);
X
X	self->monsterinfo.nextframe = FRAME_duck01;
X	self->monsterinfo.currentmove = &gunner_move_duck;
X	return;
}
X
void gunner_sidestep (edict_t *self)
{
X	if ((self->monsterinfo.currentmove == &gunner_move_jump2) ||
X		(self->monsterinfo.currentmove == &gunner_move_jump))
X	{
X		return;
X	}
X
X	if ((self->monsterinfo.currentmove == &gunner_move_attack_chain) ||
X		(self->monsterinfo.currentmove == &gunner_move_fire_chain) ||
X		(self->monsterinfo.currentmove == &gunner_move_attack_grenade)
X		)
X	{
X		// if we're shooting, and not on easy, don't dodge
X		if (skill->value)
X		{
X			self->monsterinfo.aiflags &= ~AI_DODGING;
X			return;
X		}
X	}
X
X	if (self->monsterinfo.currentmove != &gunner_move_run)
X		self->monsterinfo.currentmove = &gunner_move_run;
}
X
X
/*QUAKED monster_gunner (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_gunner (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_death = gi.soundindex ("gunner/death1.wav");	
X	sound_pain = gi.soundindex ("gunner/gunpain2.wav");	
X	sound_pain2 = gi.soundindex ("gunner/gunpain1.wav");	
X	sound_idle = gi.soundindex ("gunner/gunidle1.wav");	
X	sound_open = gi.soundindex ("gunner/gunatck1.wav");	
X	sound_search = gi.soundindex ("gunner/gunsrch1.wav");	
X	sound_sight = gi.soundindex ("gunner/sight1.wav");	
X
X	gi.soundindex ("gunner/gunatck2.wav");
X	gi.soundindex ("gunner/gunatck3.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/gunner/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X
X	self->health = 175;
X	self->gib_health = -70;
X	self->mass = 200;
X
X	self->pain = gunner_pain;
X	self->die = gunner_die;
X
X	self->monsterinfo.stand = gunner_stand;
X	self->monsterinfo.walk = gunner_walk;
X	self->monsterinfo.run = gunner_run;
X	// pmm
X	self->monsterinfo.dodge = M_MonsterDodge;
X	self->monsterinfo.duck = gunner_duck;
X	self->monsterinfo.unduck = monster_duck_up;
X	self->monsterinfo.sidestep = gunner_sidestep;
//	self->monsterinfo.dodge = gunner_dodge;
X	// pmm
X	self->monsterinfo.attack = gunner_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = gunner_sight;
X	self->monsterinfo.search = gunner_search;
X	self->monsterinfo.blocked = gunner_blocked;		//PGM
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &gunner_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	// PMM
X	self->monsterinfo.blindfire = true;
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_gunner.c' &&
  chmod 0664 'm_gunner.c' ||
  $echo 'restore of' 'm_gunner.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_gunner.c:' 'MD5 check failed'
183ebef8bc08ed4f92dab9ce50d4a351  m_gunner.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_gunner.c'`"
    test 25358 -eq "$shar_count" ||
    $echo 'm_gunner.c:' 'original size' '25358,' 'current size' "$shar_count!"
  fi
fi
# ============= m_gunner.h ==============
if test -f 'm_gunner.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_gunner.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_gunner.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_gunner.h' &&
// G:\quake2\baseq2\models/gunner
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_stand01         	0
#define FRAME_stand02         	1
#define FRAME_stand03         	2
#define FRAME_stand04         	3
#define FRAME_stand05         	4
#define FRAME_stand06         	5
#define FRAME_stand07         	6
#define FRAME_stand08         	7
#define FRAME_stand09         	8
#define FRAME_stand10         	9
#define FRAME_stand11         	10
#define FRAME_stand12         	11
#define FRAME_stand13         	12
#define FRAME_stand14         	13
#define FRAME_stand15         	14
#define FRAME_stand16         	15
#define FRAME_stand17         	16
#define FRAME_stand18         	17
#define FRAME_stand19         	18
#define FRAME_stand20         	19
#define FRAME_stand21         	20
#define FRAME_stand22         	21
#define FRAME_stand23         	22
#define FRAME_stand24         	23
#define FRAME_stand25         	24
#define FRAME_stand26         	25
#define FRAME_stand27         	26
#define FRAME_stand28         	27
#define FRAME_stand29         	28
#define FRAME_stand30         	29
#define FRAME_stand31         	30
#define FRAME_stand32         	31
#define FRAME_stand33         	32
#define FRAME_stand34         	33
#define FRAME_stand35         	34
#define FRAME_stand36         	35
#define FRAME_stand37         	36
#define FRAME_stand38         	37
#define FRAME_stand39         	38
#define FRAME_stand40         	39
#define FRAME_stand41         	40
#define FRAME_stand42         	41
#define FRAME_stand43         	42
#define FRAME_stand44         	43
#define FRAME_stand45         	44
#define FRAME_stand46         	45
#define FRAME_stand47         	46
#define FRAME_stand48         	47
#define FRAME_stand49         	48
#define FRAME_stand50         	49
#define FRAME_stand51         	50
#define FRAME_stand52         	51
#define FRAME_stand53         	52
#define FRAME_stand54         	53
#define FRAME_stand55         	54
#define FRAME_stand56         	55
#define FRAME_stand57         	56
#define FRAME_stand58         	57
#define FRAME_stand59         	58
#define FRAME_stand60         	59
#define FRAME_stand61         	60
#define FRAME_stand62         	61
#define FRAME_stand63         	62
#define FRAME_stand64         	63
#define FRAME_stand65         	64
#define FRAME_stand66         	65
#define FRAME_stand67         	66
#define FRAME_stand68         	67
#define FRAME_stand69         	68
#define FRAME_stand70         	69
#define FRAME_walk01          	70
#define FRAME_walk02          	71
#define FRAME_walk03          	72
#define FRAME_walk04          	73
#define FRAME_walk05          	74
#define FRAME_walk06          	75
#define FRAME_walk07          	76
#define FRAME_walk08          	77
#define FRAME_walk09          	78
#define FRAME_walk10          	79
#define FRAME_walk11          	80
#define FRAME_walk12          	81
#define FRAME_walk13          	82
#define FRAME_walk14          	83
#define FRAME_walk15          	84
#define FRAME_walk16          	85
#define FRAME_walk17          	86
#define FRAME_walk18          	87
#define FRAME_walk19          	88
#define FRAME_walk20          	89
#define FRAME_walk21          	90
#define FRAME_walk22          	91
#define FRAME_walk23          	92
#define FRAME_walk24          	93
#define FRAME_run01           	94
#define FRAME_run02           	95
#define FRAME_run03           	96
#define FRAME_run04           	97
#define FRAME_run05           	98
#define FRAME_run06           	99
#define FRAME_run07           	100
#define FRAME_run08           	101
#define FRAME_runs01          	102
#define FRAME_runs02          	103
#define FRAME_runs03          	104
#define FRAME_runs04          	105
#define FRAME_runs05          	106
#define FRAME_runs06          	107
#define FRAME_attak101        	108
#define FRAME_attak102        	109
#define FRAME_attak103        	110
#define FRAME_attak104        	111
#define FRAME_attak105        	112
#define FRAME_attak106        	113
#define FRAME_attak107        	114
#define FRAME_attak108        	115
#define FRAME_attak109        	116
#define FRAME_attak110        	117
#define FRAME_attak111        	118
#define FRAME_attak112        	119
#define FRAME_attak113        	120
#define FRAME_attak114        	121
#define FRAME_attak115        	122
#define FRAME_attak116        	123
#define FRAME_attak117        	124
#define FRAME_attak118        	125
#define FRAME_attak119        	126
#define FRAME_attak120        	127
#define FRAME_attak121        	128
#define FRAME_attak201        	129
#define FRAME_attak202        	130
#define FRAME_attak203        	131
#define FRAME_attak204        	132
#define FRAME_attak205        	133
#define FRAME_attak206        	134
#define FRAME_attak207        	135
#define FRAME_attak208        	136
#define FRAME_attak209        	137
#define FRAME_attak210        	138
#define FRAME_attak211        	139
#define FRAME_attak212        	140
#define FRAME_attak213        	141
#define FRAME_attak214        	142
#define FRAME_attak215        	143
#define FRAME_attak216        	144
#define FRAME_attak217        	145
#define FRAME_attak218        	146
#define FRAME_attak219        	147
#define FRAME_attak220        	148
#define FRAME_attak221        	149
#define FRAME_attak222        	150
#define FRAME_attak223        	151
#define FRAME_attak224        	152
#define FRAME_attak225        	153
#define FRAME_attak226        	154
#define FRAME_attak227        	155
#define FRAME_attak228        	156
#define FRAME_attak229        	157
#define FRAME_attak230        	158
#define FRAME_pain101         	159
#define FRAME_pain102         	160
#define FRAME_pain103         	161
#define FRAME_pain104         	162
#define FRAME_pain105         	163
#define FRAME_pain106         	164
#define FRAME_pain107         	165
#define FRAME_pain108         	166
#define FRAME_pain109         	167
#define FRAME_pain110         	168
#define FRAME_pain111         	169
#define FRAME_pain112         	170
#define FRAME_pain113         	171
#define FRAME_pain114         	172
#define FRAME_pain115         	173
#define FRAME_pain116         	174
#define FRAME_pain117         	175
#define FRAME_pain118         	176
#define FRAME_pain201         	177
#define FRAME_pain202         	178
#define FRAME_pain203         	179
#define FRAME_pain204         	180
#define FRAME_pain205         	181
#define FRAME_pain206         	182
#define FRAME_pain207         	183
#define FRAME_pain208         	184
#define FRAME_pain301         	185
#define FRAME_pain302         	186
#define FRAME_pain303         	187
#define FRAME_pain304         	188
#define FRAME_pain305         	189
#define FRAME_death01         	190
#define FRAME_death02         	191
#define FRAME_death03         	192
#define FRAME_death04         	193
#define FRAME_death05         	194
#define FRAME_death06         	195
#define FRAME_death07         	196
#define FRAME_death08         	197
#define FRAME_death09         	198
#define FRAME_death10         	199
#define FRAME_death11         	200
#define FRAME_duck01          	201
#define FRAME_duck02          	202
#define FRAME_duck03          	203
#define FRAME_duck04          	204
#define FRAME_duck05          	205
#define FRAME_duck06          	206
#define FRAME_duck07          	207
#define FRAME_duck08          	208
#define FRAME_jump01			209
#define FRAME_jump02			210
#define FRAME_jump03			211
#define FRAME_jump04			212
#define FRAME_jump05			213
#define FRAME_jump06			214
#define FRAME_jump07			215
#define FRAME_jump08			216
#define FRAME_jump09			217
#define FRAME_jump10			218
X
#define MODEL_SCALE		1.150000
SHAR_EOF
  $shar_touch -am 1130175398 'm_gunner.h' &&
  chmod 0664 'm_gunner.h' ||
  $echo 'restore of' 'm_gunner.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_gunner.h:' 'MD5 check failed'
e29ba2b3730432c015f666f7a593b96a  m_gunner.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_gunner.h'`"
    test 7593 -eq "$shar_count" ||
    $echo 'm_gunner.h:' 'original size' '7593,' 'current size' "$shar_count!"
  fi
fi
# ============= m_hover.c ==============
if test -f 'm_hover.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_hover.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_hover.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_hover.c' &&
/*
==============================================================================
X
hover
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_hover.h"
X
qboolean visible (edict_t *self, edict_t *other);
X
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_death1;
static int	sound_death2;
static int	sound_sight;
static int	sound_search1;
static int	sound_search2;
X
// daedalus sounds
static int	daed_sound_pain1;
static int	daed_sound_pain2;
static int	daed_sound_death1;
static int	daed_sound_death2;
static int	daed_sound_sight;
static int	daed_sound_search1;
static int	daed_sound_search2;
X
X
void hover_sight (edict_t *self, edict_t *other)
{
X	// PMM - daedalus sounds
X	if (self->mass < 225)
X		gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, daed_sound_sight, 1, ATTN_NORM, 0);
}
X
void hover_search (edict_t *self)
{
X	// PMM - daedalus sounds
X	if (self->mass < 225)
X	{
X		if (random() < 0.5)
X			gi.sound (self, CHAN_VOICE, sound_search1, 1, ATTN_NORM, 0);
X		else
X			gi.sound (self, CHAN_VOICE, sound_search2, 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		if (random() < 0.5)
X			gi.sound (self, CHAN_VOICE, daed_sound_search1, 1, ATTN_NORM, 0);
X		else
X			gi.sound (self, CHAN_VOICE, daed_sound_search2, 1, ATTN_NORM, 0);
X	}
}
X
X
void hover_run (edict_t *self);
void hover_stand (edict_t *self);
void hover_dead (edict_t *self);
void hover_attack (edict_t *self);
void hover_reattack (edict_t *self);
void hover_fire_blaster (edict_t *self);
void hover_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
X
mframe_t hover_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	hover_move_stand = {FRAME_stand01, FRAME_stand30, hover_frames_stand, NULL};
/*
mframe_t hover_frames_stop1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t hover_move_stop1 = {FRAME_stop101, FRAME_stop109, hover_frames_stop1, NULL};
X
mframe_t hover_frames_stop2 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t hover_move_stop2 = {FRAME_stop201, FRAME_stop208, hover_frames_stop2, NULL};
*/
/*
mframe_t hover_frames_takeoff [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	-2,	NULL,
X	ai_move,	5,	NULL,
X	ai_move,	-1,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-1,	NULL,
X	ai_move,	-1,	NULL,
X	ai_move,	-1,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	-6,	NULL,
X	ai_move,	-9,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	0,	NULL
};
mmove_t hover_move_takeoff = {FRAME_takeof01, FRAME_takeof30, hover_frames_takeoff, NULL};
*/
mframe_t hover_frames_pain3 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t hover_move_pain3 = {FRAME_pain301, FRAME_pain309, hover_frames_pain3, hover_run};
X
mframe_t hover_frames_pain2 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t hover_move_pain2 = {FRAME_pain201, FRAME_pain212, hover_frames_pain2, hover_run};
X
mframe_t hover_frames_pain1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	-8,	NULL,
X	ai_move,	-4,	NULL,
X	ai_move,	-6,	NULL,
X	ai_move,	-4,	NULL,
X	ai_move,	-3,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	7,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	5,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	4,	NULL
};
mmove_t hover_move_pain1 = {FRAME_pain101, FRAME_pain128, hover_frames_pain1, hover_run};
X
/*
mframe_t hover_frames_land [] =
{
X	ai_move,	0,	NULL
};
mmove_t hover_move_land = {FRAME_land01, FRAME_land01, hover_frames_land, NULL};
*/
/*
mframe_t hover_frames_forward [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t hover_move_forward = {FRAME_forwrd01, FRAME_forwrd35, hover_frames_forward, NULL};
*/
mframe_t hover_frames_walk [] =
{
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL,
X	ai_walk,	4,	NULL
};
mmove_t hover_move_walk = {FRAME_forwrd01, FRAME_forwrd35, hover_frames_walk, NULL};
X
mframe_t hover_frames_run [] =
{
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL,
X	ai_run,	10,	NULL
};
mmove_t hover_move_run = {FRAME_forwrd01, FRAME_forwrd35, hover_frames_run, NULL};
X
mframe_t hover_frames_death1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	-10,NULL,
X	ai_move,	3,	NULL,
X	ai_move,	5,	NULL,
X	ai_move,	4,	NULL,
X	ai_move,	7,	NULL
};
mmove_t hover_move_death1 = {FRAME_death101, FRAME_death111, hover_frames_death1, hover_dead};
/*
mframe_t hover_frames_backward [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t hover_move_backward = {FRAME_backwd01, FRAME_backwd24, hover_frames_backward, NULL};
*/
mframe_t hover_frames_start_attack [] =
{
X	ai_charge,	1,	NULL,
X	ai_charge,	1,	NULL,
X	ai_charge,	1,	NULL
};
mmove_t hover_move_start_attack = {FRAME_attak101, FRAME_attak103, hover_frames_start_attack, hover_attack};
X
mframe_t hover_frames_attack1 [] =
{
X	ai_charge,	-10,	hover_fire_blaster,
X	ai_charge,	-10,	hover_fire_blaster,
X	ai_charge,	0,		hover_reattack,
};
mmove_t hover_move_attack1 = {FRAME_attak104, FRAME_attak106, hover_frames_attack1, NULL};
X
X
mframe_t hover_frames_end_attack [] =
{
X	ai_charge,	1,	NULL,
X	ai_charge,	1,	NULL
};
mmove_t hover_move_end_attack = {FRAME_attak107, FRAME_attak108, hover_frames_end_attack, hover_run};
X
/* PMM - circle strafing code */
X
mframe_t hover_frames_start_attack2 [] =
{
X	ai_charge,	15,	NULL,
X	ai_charge,	15,	NULL,
X	ai_charge,	15,	NULL
};
mmove_t hover_move_start_attack2 = {FRAME_attak101, FRAME_attak103, hover_frames_start_attack2, hover_attack};
X
mframe_t hover_frames_attack2 [] =
{
X	ai_charge,	10,	hover_fire_blaster,
X	ai_charge,	10,	hover_fire_blaster,
X	ai_charge,	10,		hover_reattack,
};
mmove_t hover_move_attack2 = {FRAME_attak104, FRAME_attak106, hover_frames_attack2, NULL};
X
X
mframe_t hover_frames_end_attack2 [] =
{
X	ai_charge,	15,	NULL,
X	ai_charge,	15,	NULL
};
mmove_t hover_move_end_attack2 = {FRAME_attak107, FRAME_attak108, hover_frames_end_attack2, hover_run};
X
// end of circle strafe
X
X
void hover_reattack (edict_t *self)
{
X	if (self->enemy->health > 0 )
X		if (visible (self, self->enemy) )
X			if (random() <= 0.6)		
X			{
X				if (self->monsterinfo.attack_state == AS_STRAIGHT)
X				{
X					self->monsterinfo.currentmove = &hover_move_attack1;
X					return;
X				}
X				else if (self->monsterinfo.attack_state == AS_SLIDING)
X				{
X					self->monsterinfo.currentmove = &hover_move_attack2;
X					return;
X				}
X				else
X					gi.dprintf ("hover_reattack: unexpected state %d\n", self->monsterinfo.attack_state);
X			}
X	self->monsterinfo.currentmove = &hover_move_end_attack;
}
X
X
void hover_fire_blaster (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	forward, right;
X	vec3_t	end;
X	vec3_t	dir;
X	int		effect;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	if (self->s.frame == FRAME_attak104)
X		effect = EF_HYPERBLASTER;
X	else
X		effect = 0;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_HOVER_BLASTER_1], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, end);
X	end[2] += self->enemy->viewheight;
X	VectorSubtract (end, start, dir);
X
//PGM	- daedalus fires blaster2
X	if(self->mass < 200)
X		monster_fire_blaster (self, start, dir, 1, 1000, MZ2_HOVER_BLASTER_1, effect);
X	else
X		monster_fire_blaster2 (self, start, dir, 1, 1000, MZ2_DAEDALUS_BLASTER, EF_BLASTER);
X		// fixme - different muzzle flash
//PGM
}
X
X
void hover_stand (edict_t *self)
{
X		self->monsterinfo.currentmove = &hover_move_stand;
}
X
void hover_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &hover_move_stand;
X	else
X		self->monsterinfo.currentmove = &hover_move_run;
}
X
void hover_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &hover_move_walk;
}
X
void hover_start_attack (edict_t *self)
{
X	self->monsterinfo.currentmove = &hover_move_start_attack;
}
X
void hover_attack(edict_t *self)
{
X	float chance;
/*	if (random() <= 0.5)	
X		self->monsterinfo.currentmove = &flyer_move_attack1;
X	else */
X	// 0% chance of circle in easy
X	// 50% chance in normal
X	// 75% chance in hard
X	// 86.67% chance in nightmare
X	if (!skill->value)
X		chance = 0;
X	else
X		chance = 1.0 - (0.5/(float)(skill->value));
X
X	if (self->mass > 150)  // the daedalus strafes more
X		chance += 0.1;
X
X	if (random() > chance)
X	{
X		self->monsterinfo.currentmove = &hover_move_attack1;
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
X	else // circle strafe
X	{
X		if (random () <= 0.5) // switch directions
X			self->monsterinfo.lefty = 1 - self->monsterinfo.lefty;
X		self->monsterinfo.currentmove = &hover_move_attack2;
X		self->monsterinfo.attack_state = AS_SLIDING;
X	}
}
X
X
void hover_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum |= 1;	// PGM support for skins 2 & 3.
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	if (damage <= 25)
X	{
X		if (random() < 0.5)
X		{
X			// PMM - daedalus sounds
X			if (self->mass < 225)
X				gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X			else
X				gi.sound (self, CHAN_VOICE, daed_sound_pain1, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &hover_move_pain3;
X		}
X		else
X		{
X			// PMM - daedalus sounds
X			if (self->mass < 225)
X				gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X			else
X				gi.sound (self, CHAN_VOICE, daed_sound_pain2, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &hover_move_pain2;
X		}
X	}
X	else
X	{
//====
//PGM pain sequence is WAY too long
X		if (random() < (0.45 - (0.1 * skill->value)))
X		{
X			// PMM - daedalus sounds
X			if (self->mass < 225)
X				gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X			else
X				gi.sound (self, CHAN_VOICE, daed_sound_pain1, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &hover_move_pain1;
X		}
X		else
X		{
X			// PMM - daedalus sounds
X			if (self->mass < 225)
X				gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X			else
X				gi.sound (self, CHAN_VOICE, daed_sound_pain2, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &hover_move_pain2;
X		}
//PGM
//====
X	}
}
X
void hover_deadthink (edict_t *self)
{
X	if (!self->groundentity && level.time < self->timestamp)
X	{
X		self->nextthink = level.time + FRAMETIME;
X		return;
X	}
X	BecomeExplosion1(self);
}
X
void hover_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->think = hover_deadthink;
X	self->nextthink = level.time + FRAMETIME;
X	self->timestamp = level.time + 15;
X	gi.linkentity (self);
}
X
void hover_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
X	self->s.effects = 0;
X	self->monsterinfo.power_armor_type = POWER_ARMOR_NONE;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	// PMM - daedalus sounds
X	if (self->mass < 225)
X	{
X		if (random() < 0.5)
X			gi.sound (self, CHAN_VOICE, sound_death1, 1, ATTN_NORM, 0);
X		else
X			gi.sound (self, CHAN_VOICE, sound_death2, 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		if (random() < 0.5)
X			gi.sound (self, CHAN_VOICE, daed_sound_death1, 1, ATTN_NORM, 0);
X		else
X			gi.sound (self, CHAN_VOICE, daed_sound_death2, 1, ATTN_NORM, 0);
X	}
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->monsterinfo.currentmove = &hover_move_death1;
}
X
//===========
//PGM
qboolean hover_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	return false;
}
//PGM
//===========
X
/*QUAKED monster_hover (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
/*QUAKED monster_daedalus (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
This is the improved icarus monster.
*/
void SP_monster_hover (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex("models/monsters/hover/tris.md2");
X	VectorSet (self->mins, -24, -24, -24);
X	VectorSet (self->maxs, 24, 24, 32);
X
X	self->health = 240;
X	self->gib_health = -100;
X	self->mass = 150;
X
X	self->pain = hover_pain;
X	self->die = hover_die;
X
X	self->monsterinfo.stand = hover_stand;
X	self->monsterinfo.walk = hover_walk;
X	self->monsterinfo.run = hover_run;
//	self->monsterinfo.dodge = hover_dodge;
X	self->monsterinfo.attack = hover_start_attack;
X	self->monsterinfo.sight = hover_sight;
X	self->monsterinfo.search = hover_search;
X	self->monsterinfo.blocked = hover_blocked;		// PGM
X
//PGM
X	if (strcmp(self->classname, "monster_daedalus") == 0)
X	{
X		self->health = 450;
X		self->mass = 225;
X		self->yaw_speed = 25;
X		self->monsterinfo.power_armor_type = POWER_ARMOR_SCREEN;
X		self->monsterinfo.power_armor_power = 100;
X		// PMM - daedalus sounds
X		self->s.sound = gi.soundindex ("daedalus/daedidle1.wav");
X		daed_sound_pain1 = gi.soundindex ("daedalus/daedpain1.wav");	
X		daed_sound_pain2 = gi.soundindex ("daedalus/daedpain2.wav");	
X		daed_sound_death1 = gi.soundindex ("daedalus/daeddeth1.wav");	
X		daed_sound_death2 = gi.soundindex ("daedalus/daeddeth2.wav");	
X		daed_sound_sight = gi.soundindex ("daedalus/daedsght1.wav");	
X		daed_sound_search1 = gi.soundindex ("daedalus/daedsrch1.wav");	
X		daed_sound_search2 = gi.soundindex ("daedalus/daedsrch2.wav");	
X		gi.soundindex ("tank/tnkatck3.wav");	
X		// pmm 
X	}
X	else
X	{
X		sound_pain1 = gi.soundindex ("hover/hovpain1.wav");	
X		sound_pain2 = gi.soundindex ("hover/hovpain2.wav");	
X		sound_death1 = gi.soundindex ("hover/hovdeth1.wav");	
X		sound_death2 = gi.soundindex ("hover/hovdeth2.wav");	
X		sound_sight = gi.soundindex ("hover/hovsght1.wav");	
X		sound_search1 = gi.soundindex ("hover/hovsrch1.wav");	
X		sound_search2 = gi.soundindex ("hover/hovsrch2.wav");	
X		gi.soundindex ("hover/hovatck1.wav");	
X
X		self->s.sound = gi.soundindex ("hover/hovidle1.wav");
X	}
//PGM
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &hover_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	flymonster_start (self);
X
//PGM
X	if (strcmp(self->classname, "monster_daedalus") == 0)
X		self->s.skinnum = 2;
//PGM
X
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_hover.c' &&
  chmod 0664 'm_hover.c' ||
  $echo 'restore of' 'm_hover.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_hover.c:' 'MD5 check failed'
8c91e7f498fd0417b77bac8e2ca1ff3b  m_hover.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_hover.c'`"
    test 18430 -eq "$shar_count" ||
    $echo 'm_hover.c:' 'original size' '18430,' 'current size' "$shar_count!"
  fi
fi
# ============= m_hover.h ==============
if test -f 'm_hover.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_hover.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_hover.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_hover.h' &&
// G:\quake2\baseq2\models/monsters/hover
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_stand01         	0
#define FRAME_stand02         	1
#define FRAME_stand03         	2
#define FRAME_stand04         	3
#define FRAME_stand05         	4
#define FRAME_stand06         	5
#define FRAME_stand07         	6
#define FRAME_stand08         	7
#define FRAME_stand09         	8
#define FRAME_stand10         	9
#define FRAME_stand11         	10
#define FRAME_stand12         	11
#define FRAME_stand13         	12
#define FRAME_stand14         	13
#define FRAME_stand15         	14
#define FRAME_stand16         	15
#define FRAME_stand17         	16
#define FRAME_stand18         	17
#define FRAME_stand19         	18
#define FRAME_stand20         	19
#define FRAME_stand21         	20
#define FRAME_stand22         	21
#define FRAME_stand23         	22
#define FRAME_stand24         	23
#define FRAME_stand25         	24
#define FRAME_stand26         	25
#define FRAME_stand27         	26
#define FRAME_stand28         	27
#define FRAME_stand29         	28
#define FRAME_stand30         	29
#define FRAME_forwrd01        	30
#define FRAME_forwrd02        	31
#define FRAME_forwrd03        	32
#define FRAME_forwrd04        	33
#define FRAME_forwrd05        	34
#define FRAME_forwrd06        	35
#define FRAME_forwrd07        	36
#define FRAME_forwrd08        	37
#define FRAME_forwrd09        	38
#define FRAME_forwrd10        	39
#define FRAME_forwrd11        	40
#define FRAME_forwrd12        	41
#define FRAME_forwrd13        	42
#define FRAME_forwrd14        	43
#define FRAME_forwrd15        	44
#define FRAME_forwrd16        	45
#define FRAME_forwrd17        	46
#define FRAME_forwrd18        	47
#define FRAME_forwrd19        	48
#define FRAME_forwrd20        	49
#define FRAME_forwrd21        	50
#define FRAME_forwrd22        	51
#define FRAME_forwrd23        	52
#define FRAME_forwrd24        	53
#define FRAME_forwrd25        	54
#define FRAME_forwrd26        	55
#define FRAME_forwrd27        	56
#define FRAME_forwrd28        	57
#define FRAME_forwrd29        	58
#define FRAME_forwrd30        	59
#define FRAME_forwrd31        	60
#define FRAME_forwrd32        	61
#define FRAME_forwrd33        	62
#define FRAME_forwrd34        	63
#define FRAME_forwrd35        	64
#define FRAME_stop101         	65
#define FRAME_stop102         	66
#define FRAME_stop103         	67
#define FRAME_stop104         	68
#define FRAME_stop105         	69
#define FRAME_stop106         	70
#define FRAME_stop107         	71
#define FRAME_stop108         	72
#define FRAME_stop109         	73
#define FRAME_stop201         	74
#define FRAME_stop202         	75
#define FRAME_stop203         	76
#define FRAME_stop204         	77
#define FRAME_stop205         	78
#define FRAME_stop206         	79
#define FRAME_stop207         	80
#define FRAME_stop208         	81
#define FRAME_takeof01        	82
#define FRAME_takeof02        	83
#define FRAME_takeof03        	84
#define FRAME_takeof04        	85
#define FRAME_takeof05        	86
#define FRAME_takeof06        	87
#define FRAME_takeof07        	88
#define FRAME_takeof08        	89
#define FRAME_takeof09        	90
#define FRAME_takeof10        	91
#define FRAME_takeof11        	92
#define FRAME_takeof12        	93
#define FRAME_takeof13        	94
#define FRAME_takeof14        	95
#define FRAME_takeof15        	96
#define FRAME_takeof16        	97
#define FRAME_takeof17        	98
#define FRAME_takeof18        	99
#define FRAME_takeof19        	100
#define FRAME_takeof20        	101
#define FRAME_takeof21        	102
#define FRAME_takeof22        	103
#define FRAME_takeof23        	104
#define FRAME_takeof24        	105
#define FRAME_takeof25        	106
#define FRAME_takeof26        	107
#define FRAME_takeof27        	108
#define FRAME_takeof28        	109
#define FRAME_takeof29        	110
#define FRAME_takeof30        	111
#define FRAME_land01          	112
#define FRAME_pain101         	113
#define FRAME_pain102         	114
#define FRAME_pain103         	115
#define FRAME_pain104         	116
#define FRAME_pain105         	117
#define FRAME_pain106         	118
#define FRAME_pain107         	119
#define FRAME_pain108         	120
#define FRAME_pain109         	121
#define FRAME_pain110         	122
#define FRAME_pain111         	123
#define FRAME_pain112         	124
#define FRAME_pain113         	125
#define FRAME_pain114         	126
#define FRAME_pain115         	127
#define FRAME_pain116         	128
#define FRAME_pain117         	129
#define FRAME_pain118         	130
#define FRAME_pain119         	131
#define FRAME_pain120         	132
#define FRAME_pain121         	133
#define FRAME_pain122         	134
#define FRAME_pain123         	135
#define FRAME_pain124         	136
#define FRAME_pain125         	137
#define FRAME_pain126         	138
#define FRAME_pain127         	139
#define FRAME_pain128         	140
#define FRAME_pain201         	141
#define FRAME_pain202         	142
#define FRAME_pain203         	143
#define FRAME_pain204         	144
#define FRAME_pain205         	145
#define FRAME_pain206         	146
#define FRAME_pain207         	147
#define FRAME_pain208         	148
#define FRAME_pain209         	149
#define FRAME_pain210         	150
#define FRAME_pain211         	151
#define FRAME_pain212         	152
#define FRAME_pain301         	153
#define FRAME_pain302         	154
#define FRAME_pain303         	155
#define FRAME_pain304         	156
#define FRAME_pain305         	157
#define FRAME_pain306         	158
#define FRAME_pain307         	159
#define FRAME_pain308         	160
#define FRAME_pain309         	161
#define FRAME_death101        	162
#define FRAME_death102        	163
#define FRAME_death103        	164
#define FRAME_death104        	165
#define FRAME_death105        	166
#define FRAME_death106        	167
#define FRAME_death107        	168
#define FRAME_death108        	169
#define FRAME_death109        	170
#define FRAME_death110        	171
#define FRAME_death111        	172
#define FRAME_backwd01        	173
#define FRAME_backwd02        	174
#define FRAME_backwd03        	175
#define FRAME_backwd04        	176
#define FRAME_backwd05        	177
#define FRAME_backwd06        	178
#define FRAME_backwd07        	179
#define FRAME_backwd08        	180
#define FRAME_backwd09        	181
#define FRAME_backwd10        	182
#define FRAME_backwd11        	183
#define FRAME_backwd12        	184
#define FRAME_backwd13        	185
#define FRAME_backwd14        	186
#define FRAME_backwd15        	187
#define FRAME_backwd16        	188
#define FRAME_backwd17        	189
#define FRAME_backwd18        	190
#define FRAME_backwd19        	191
#define FRAME_backwd20        	192
#define FRAME_backwd21        	193
#define FRAME_backwd22        	194
#define FRAME_backwd23        	195
#define FRAME_backwd24        	196
#define FRAME_attak101        	197
#define FRAME_attak102        	198
#define FRAME_attak103        	199
#define FRAME_attak104        	200
#define FRAME_attak105        	201
#define FRAME_attak106        	202
#define FRAME_attak107        	203
#define FRAME_attak108        	204
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_hover.h' &&
  chmod 0664 'm_hover.h' ||
  $echo 'restore of' 'm_hover.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_hover.h:' 'MD5 check failed'
03807e4d4a40b33514de31a901b73bc4  m_hover.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_hover.h'`"
    test 7191 -eq "$shar_count" ||
    $echo 'm_hover.h:' 'original size' '7191,' 'current size' "$shar_count!"
  fi
fi
# ============= m_infantry.c ==============
if test -f 'm_infantry.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_infantry.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_infantry.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_infantry.c' &&
/*
==============================================================================
X
INFANTRY
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_infantry.h"
X
void InfantryMachineGun (edict_t *self);
X
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_die1;
static int	sound_die2;
X
static int	sound_gunshot;
static int	sound_weapon_cock;
static int	sound_punch_swing;
static int	sound_punch_hit;
static int	sound_sight;
static int	sound_search;
static int	sound_idle;
X
mframe_t infantry_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t infantry_move_stand = {FRAME_stand50, FRAME_stand71, infantry_frames_stand, NULL};
X
void infantry_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &infantry_move_stand;
}
X
X
mframe_t infantry_frames_fidget [] =
{
X	ai_stand, 1,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, 3,  NULL,
X	ai_stand, 6,  NULL,
X	ai_stand, 3,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, -1, NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, -2, NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, -1, NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, -1, NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, -1, NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 1,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, -1, NULL,
X	ai_stand, -1, NULL,
X	ai_stand, 0,  NULL,
X	ai_stand, -3, NULL,
X	ai_stand, -2, NULL,
X	ai_stand, -3, NULL,
X	ai_stand, -3, NULL,
X	ai_stand, -2, NULL
};
mmove_t infantry_move_fidget = {FRAME_stand01, FRAME_stand49, infantry_frames_fidget, infantry_stand};
X
void infantry_fidget (edict_t *self)
{
X	self->monsterinfo.currentmove = &infantry_move_fidget;
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
mframe_t infantry_frames_walk [] =
{
X	ai_walk, 5,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 6,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 5,  NULL
};
mmove_t infantry_move_walk = {FRAME_walk03, FRAME_walk14, infantry_frames_walk, NULL};
X
void infantry_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &infantry_move_walk;
}
X
mframe_t infantry_frames_run [] =
{
X	ai_run, 10, NULL,
X	ai_run, 20, NULL,
X	ai_run, 5,  NULL,
X	ai_run, 7,  monster_done_dodge,
X	ai_run, 30, NULL,
X	ai_run, 35, NULL,
X	ai_run, 2,  NULL,
X	ai_run, 6,  NULL
};
mmove_t infantry_move_run = {FRAME_run01, FRAME_run08, infantry_frames_run, NULL};
X
void infantry_run (edict_t *self)
{
X	monster_done_dodge (self);
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &infantry_move_stand;
X	else
X		self->monsterinfo.currentmove = &infantry_move_run;
}
X
X
mframe_t infantry_frames_pain1 [] =
{
X	ai_move, -3, NULL,
X	ai_move, -2, NULL,
X	ai_move, -1, NULL,
X	ai_move, -2, NULL,
X	ai_move, -1, NULL,
X	ai_move, 1,  NULL,
X	ai_move, -1, NULL,
X	ai_move, 1,  NULL,
X	ai_move, 6,  NULL,
X	ai_move, 2,  NULL
};
mmove_t infantry_move_pain1 = {FRAME_pain101, FRAME_pain110, infantry_frames_pain1, infantry_run};
X
mframe_t infantry_frames_pain2 [] =
{
X	ai_move, -3, NULL,
X	ai_move, -3, NULL,
X	ai_move, 0,  NULL,
X	ai_move, -1, NULL,
X	ai_move, -2, NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 2,  NULL,
X	ai_move, 5,  NULL,
X	ai_move, 2,  NULL
};
mmove_t infantry_move_pain2 = {FRAME_pain201, FRAME_pain210, infantry_frames_pain2, infantry_run};
X
void infantry_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	int		n;
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (!self->groundentity)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("infantry: pain avoided due to no ground\n");
X		return;
X	}
X
X	monster_done_dodge (self);
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X	
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	n = rand() % 2;
X	if (n == 0)
X	{
X		self->monsterinfo.currentmove = &infantry_move_pain1;
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &infantry_move_pain2;
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X	}
X
X	// PMM - clear duck flag
X	if (self->monsterinfo.aiflags & AI_DUCKED)
X		monster_duck_up(self);
}
X
X
vec3_t	aimangles[] =
{
X	0.0, 5.0, 0.0,
X	10.0, 15.0, 0.0,
X	20.0, 25.0, 0.0,
X	25.0, 35.0, 0.0,
X	30.0, 40.0, 0.0,
X	30.0, 45.0, 0.0,
X	25.0, 50.0, 0.0,
X	20.0, 40.0, 0.0,
X	15.0, 35.0, 0.0,
X	40.0, 35.0, 0.0,
X	70.0, 35.0, 0.0,
X	90.0, 35.0, 0.0
};
X
void InfantryMachineGun (edict_t *self)
{
X	vec3_t	start, target;
X	vec3_t	forward, right;
X	vec3_t	vec;
X	int		flash_number;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	// pmm - new attack start frame
X	if (self->s.frame == FRAME_attak104)
X	{
X		flash_number = MZ2_INFANTRY_MACHINEGUN_1;
X		AngleVectors (self->s.angles, forward, right, NULL);
X		G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X		if (self->enemy)
X		{
X			VectorMA (self->enemy->s.origin, -0.2, self->enemy->velocity, target);
X			target[2] += self->enemy->viewheight;
X			VectorSubtract (target, start, forward);
X			VectorNormalize (forward);
X		}
X		else
X		{
X			AngleVectors (self->s.angles, forward, right, NULL);
X		}
X	}
X	else
X	{
X		flash_number = MZ2_INFANTRY_MACHINEGUN_2 + (self->s.frame - FRAME_death211);
X
X		AngleVectors (self->s.angles, forward, right, NULL);
X		G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X		VectorSubtract (self->s.angles, aimangles[flash_number-MZ2_INFANTRY_MACHINEGUN_2], vec);
X		AngleVectors (vec, forward, NULL, NULL);
X	}
X
X	monster_fire_bullet (self, start, forward, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
}
X
void infantry_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_BODY, sound_sight, 1, ATTN_NORM, 0);
}
X
void infantry_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	gi.linkentity (self);
X
X	M_FlyCheck (self);
}
X
mframe_t infantry_frames_death1 [] =
{
X	ai_move, -4, NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, -1, NULL,
X	ai_move, -4, NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, -1, NULL,
X	ai_move, 3,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, -2, NULL,
X	ai_move, 2,  NULL,
X	ai_move, 2,  NULL,
X	ai_move, 9,  NULL,
X	ai_move, 9,  NULL,
X	ai_move, 5,  NULL,
X	ai_move, -3, NULL,
X	ai_move, -3, NULL
};
mmove_t infantry_move_death1 = {FRAME_death101, FRAME_death120, infantry_frames_death1, infantry_dead};
X
// Off with his head
mframe_t infantry_frames_death2 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 5,   NULL,
X	ai_move, -1,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 4,   NULL,
X	ai_move, 3,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -2,  InfantryMachineGun,
X	ai_move, -2,  InfantryMachineGun,
X	ai_move, -3,  InfantryMachineGun,
X	ai_move, -1,  InfantryMachineGun,
X	ai_move, -2,  InfantryMachineGun,
X	ai_move, 0,   InfantryMachineGun,
X	ai_move, 2,   InfantryMachineGun,
X	ai_move, 2,   InfantryMachineGun,
X	ai_move, 3,   InfantryMachineGun,
X	ai_move, -10, InfantryMachineGun,
X	ai_move, -7,  InfantryMachineGun,
X	ai_move, -8,  InfantryMachineGun,
X	ai_move, -6,  NULL,
X	ai_move, 4,   NULL,
X	ai_move, 0,   NULL
};
mmove_t infantry_move_death2 = {FRAME_death201, FRAME_death225, infantry_frames_death2, infantry_dead};
X
mframe_t infantry_frames_death3 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -6,  NULL,
X	ai_move, -11, NULL,
X	ai_move, -3,  NULL,
X	ai_move, -11, NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL
};
mmove_t infantry_move_death3 = {FRAME_death301, FRAME_death309, infantry_frames_death3, infantry_dead};
X
X
void infantry_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	n = rand() % 3;
X	if (n == 0)
X	{
X		self->monsterinfo.currentmove = &infantry_move_death1;
X		gi.sound (self, CHAN_VOICE, sound_die2, 1, ATTN_NORM, 0);
X	}
X	else if (n == 1)
X	{
X		self->monsterinfo.currentmove = &infantry_move_death2;
X		gi.sound (self, CHAN_VOICE, sound_die1, 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &infantry_move_death3;
X		gi.sound (self, CHAN_VOICE, sound_die2, 1, ATTN_NORM, 0);
X	}
}
X
mframe_t infantry_frames_duck [] =
{
X	ai_move, -2, monster_duck_down,
X	ai_move, -5, monster_duck_hold,
X	ai_move, 3,  NULL,
X	ai_move, 4,  monster_duck_up,
X	ai_move, 0,  NULL
};
mmove_t infantry_move_duck = {FRAME_duck01, FRAME_duck05, infantry_frames_duck, infantry_run};
X
// PMM - dodge code moved below so I can see the attack frames
X
X
void infantry_cock_gun (edict_t *self)
{
X	// pmm .. code that was here no longer needed
X	gi.sound (self, CHAN_WEAPON, sound_weapon_cock, 1, ATTN_NORM, 0);
}
X
void infantry_fire (edict_t *self)
{
X	InfantryMachineGun (self);
X	if (level.time >= self->monsterinfo.pausetime)
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X	else
X		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
}
X
// this is here instead of cock_gun
X
void infantry_fire_prep (edict_t *self)
{
X	int n;
X	n = (rand() & 15) + 3 + 1;
X	self->monsterinfo.pausetime = level.time + n*FRAMETIME;
}
X
// pmm
// frames reordered, tweaked for new frames
X
mframe_t infantry_frames_attack1 [] =
{
X	ai_charge, -3, NULL,					//101
X	ai_charge, -2, NULL,					//102
X	ai_charge, -1, infantry_fire_prep,		//103
X	ai_charge, 5,  infantry_fire,			//104
X	ai_charge, 1,  NULL,					//105
X	ai_charge, -3, NULL,					//106
X	ai_charge, -2, NULL,					//107
X	ai_charge, 2,  infantry_cock_gun,		//108
X	ai_charge, 1,  NULL,					//109
X	ai_charge, 1,  NULL,					//110
X	ai_charge, -1, NULL,					//111
X	ai_charge, 0,  NULL,					//112
X	ai_charge, -1, NULL,					//113
X	ai_charge, -1, NULL,					//114
X	ai_charge, 4,  NULL						//115
};
mmove_t infantry_move_attack1 = {FRAME_attak101, FRAME_attak115, infantry_frames_attack1, infantry_run};
X
X
void infantry_swing (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_punch_swing, 1, ATTN_NORM, 0);
}
X
void infantry_smack (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, 0, 0);
X	if (fire_hit (self, aim, (5 + (rand() % 5)), 50))
X		gi.sound (self, CHAN_WEAPON, sound_punch_hit, 1, ATTN_NORM, 0);
}
X
mframe_t infantry_frames_attack2 [] =
{
X	ai_charge, 3, NULL,
X	ai_charge, 6, NULL,
X	ai_charge, 0, infantry_swing,
X	ai_charge, 8, NULL,
X	ai_charge, 5, NULL,
X	ai_charge, 8, infantry_smack,
X	ai_charge, 6, NULL,
X	ai_charge, 3, NULL,
};
mmove_t infantry_move_attack2 = {FRAME_attak201, FRAME_attak208, infantry_frames_attack2, infantry_run};
X
void infantry_attack(edict_t *self)
{
X	monster_done_dodge (self);
X
X	if (range (self, self->enemy) == RANGE_MELEE)
X		self->monsterinfo.currentmove = &infantry_move_attack2;
X	else
X		self->monsterinfo.currentmove = &infantry_move_attack1;
}
X
//===========
//PGM
void infantry_jump_now (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 100, forward, self->velocity);
X	VectorMA(self->velocity, 300, up, self->velocity);
}
X
void infantry_jump2_now (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 150, forward, self->velocity);
X	VectorMA(self->velocity, 400, up, self->velocity);
}
X
void infantry_jump_wait_land (edict_t *self)
{
X	if(self->groundentity == NULL)
X	{
X		self->monsterinfo.nextframe = self->s.frame;
X
X		if(monster_jump_finished (self))
X			self->monsterinfo.nextframe = self->s.frame + 1;
X	}
X	else 
X		self->monsterinfo.nextframe = self->s.frame + 1;
}
X
mframe_t infantry_frames_jump [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, infantry_jump_now,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, infantry_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t infantry_move_jump = { FRAME_jump01, FRAME_jump10, infantry_frames_jump, infantry_run };
X
mframe_t infantry_frames_jump2 [] =
{
X	ai_move, -8, NULL,
X	ai_move, -4, NULL,
X	ai_move, -4, NULL,
X	ai_move, 0, infantry_jump_now,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, infantry_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t infantry_move_jump2 = { FRAME_jump01, FRAME_jump10, infantry_frames_jump2, infantry_run };
X
void infantry_jump (edict_t *self)
{
X	if(!self->enemy)
X		return;
X
X	monster_done_dodge(self);
X
X	if(self->enemy->s.origin[2] > self->s.origin[2])
X		self->monsterinfo.currentmove = &infantry_move_jump2;
X	else
X		self->monsterinfo.currentmove = &infantry_move_jump;
}
X
qboolean infantry_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkjump (self, dist, 192, 40))
X	{
X		infantry_jump(self);
X		return true;
X	}
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
//PGM
//===========
/*
void infantry_dodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
//===========
//PMM - rogue rewrite of gunner dodge code.
X	float	r;
X	float	height;
X	int		shooting = 0;
X
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget (self);
X	}
X
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X		return;
X
X	r = random();
X	if (r > (0.25*((skill->value)+1)))
X		return;
X
X	if ((self->monsterinfo.currentmove == &infantry_move_attack1) ||
X		(self->monsterinfo.currentmove == &infantry_move_attack2))
X	{
X		shooting = 1;
X	}
X	if (self->monsterinfo.aiflags & AI_DODGING)
X	{
X		height = self->absmax[2];
X	}
X	else
X	{
X		height = self->absmax[2]-32-1;  // the -1 is because the absmax is s.origin + maxs + 1
X	}
X
X	// check to see if it makes sense to duck
X	if (tr->endpos[2] <= height)
X	{
X		vec3_t right,diff;
X
X		if (shooting)
X		{
X			self->monsterinfo.attack_state = AS_SLIDING;
X			return;
X		}
X		AngleVectors (self->s.angles, NULL, right, NULL);
X		VectorSubtract (tr->endpos, self->s.origin, diff);
X		if (DotProduct (right, diff) < 0)
X		{
X			self->monsterinfo.lefty = 1;
X		}
X		// if it doesn't sense to duck, try to strafe away
X		monster_done_dodge (self);
X		self->monsterinfo.currentmove = &infantry_move_run;
X		self->monsterinfo.attack_state = AS_SLIDING;
X		return;
X	}
X
X	if (skill->value == 0)
X	{
X		self->monsterinfo.currentmove = &infantry_move_duck;
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		self->monsterinfo.aiflags |= AI_DODGING;
X		return;
X	}
X
X	if (!shooting)
X	{
X		self->monsterinfo.currentmove = &infantry_move_duck;
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X		self->monsterinfo.aiflags |= AI_DODGING;
X	}
X	return;
//PMM
//===========
*/
X
void infantry_duck (edict_t *self, float eta)
{
X	// if we're jumping, don't dodge
X	if ((self->monsterinfo.currentmove == &infantry_move_jump) ||
X		(self->monsterinfo.currentmove == &infantry_move_jump2))
X	{
X		return;
X	}
X
X	if ((self->monsterinfo.currentmove == &infantry_move_attack1) ||
X		(self->monsterinfo.currentmove == &infantry_move_attack2))
X	{
X		// if we're shooting, and not on easy, don't dodge
X		if (skill->value)
X		{
X			self->monsterinfo.aiflags &= ~AI_DUCKED;
X			return;
X		}
X	}
X
X	if (skill->value == 0)
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X	else
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X
X	// has to be done immediately otherwise he can get stuck
X	monster_duck_down(self);
X
X	self->monsterinfo.nextframe = FRAME_duck01;
X	self->monsterinfo.currentmove = &infantry_move_duck;
X	return;
}
X
void infantry_sidestep (edict_t *self)
{
X	// if we're jumping, don't dodge
X	if ((self->monsterinfo.currentmove == &infantry_move_jump) ||
X		(self->monsterinfo.currentmove == &infantry_move_jump2))
X	{
X		return;
X	}
X
X	if ((self->monsterinfo.currentmove == &infantry_move_attack1) ||
X		(self->monsterinfo.currentmove == &infantry_move_attack2))
X	{
X		// if we're shooting, and not on easy, don't dodge
X		if (skill->value)
X		{
X			self->monsterinfo.aiflags &= ~AI_DODGING;
X			return;
X		}
X	}
X
X	if (self->monsterinfo.currentmove != &infantry_move_run)
X		self->monsterinfo.currentmove = &infantry_move_run;
}
X
/*QUAKED monster_infantry (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_infantry (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("infantry/infpain1.wav");
X	sound_pain2 = gi.soundindex ("infantry/infpain2.wav");
X	sound_die1 = gi.soundindex ("infantry/infdeth1.wav");
X	sound_die2 = gi.soundindex ("infantry/infdeth2.wav");
X
X	sound_gunshot = gi.soundindex ("infantry/infatck1.wav");
X	sound_weapon_cock = gi.soundindex ("infantry/infatck3.wav");
X	sound_punch_swing = gi.soundindex ("infantry/infatck2.wav");
X	sound_punch_hit = gi.soundindex ("infantry/melee2.wav");
X	
X	sound_sight = gi.soundindex ("infantry/infsght1.wav");
X	sound_search = gi.soundindex ("infantry/infsrch1.wav");
X	sound_idle = gi.soundindex ("infantry/infidle1.wav");
X	
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex("models/monsters/infantry/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X
X	self->health = 100;
X	self->gib_health = -40;
X	self->mass = 200;
X
X	self->pain = infantry_pain;
X	self->die = infantry_die;
X
X	self->monsterinfo.stand = infantry_stand;
X	self->monsterinfo.walk = infantry_walk;
X	self->monsterinfo.run = infantry_run;
X	// pmm
X	self->monsterinfo.dodge = M_MonsterDodge;
X	self->monsterinfo.duck = infantry_duck;
X	self->monsterinfo.unduck = monster_duck_up;
X	self->monsterinfo.sidestep = infantry_sidestep;
//	self->monsterinfo.dodge = infantry_dodge;
X	// pmm
X	self->monsterinfo.attack = infantry_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = infantry_sight;
X	self->monsterinfo.idle = infantry_fidget;
X	self->monsterinfo.blocked = infantry_blocked;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &infantry_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_infantry.c' &&
  chmod 0664 'm_infantry.c' ||
  $echo 'restore of' 'm_infantry.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_infantry.c:' 'MD5 check failed'
73b5a784deb6ef4ce09286b851a1f322  m_infantry.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_infantry.c'`"
    test 19624 -eq "$shar_count" ||
    $echo 'm_infantry.c:' 'original size' '19624,' 'current size' "$shar_count!"
  fi
fi
# ============= m_infantry.h ==============
if test -f 'm_infantry.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_infantry.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_infantry.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_infantry.h' &&
// G:\quake2\baseq2\models/monsters/infantry
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_gun02           	0
#define FRAME_stand01         	1
#define FRAME_stand02         	2
#define FRAME_stand03         	3
#define FRAME_stand04         	4
#define FRAME_stand05         	5
#define FRAME_stand06         	6
#define FRAME_stand07         	7
#define FRAME_stand08         	8
#define FRAME_stand09         	9
#define FRAME_stand10         	10
#define FRAME_stand11         	11
#define FRAME_stand12         	12
#define FRAME_stand13         	13
#define FRAME_stand14         	14
#define FRAME_stand15         	15
#define FRAME_stand16         	16
#define FRAME_stand17         	17
#define FRAME_stand18         	18
#define FRAME_stand19         	19
#define FRAME_stand20         	20
#define FRAME_stand21         	21
#define FRAME_stand22         	22
#define FRAME_stand23         	23
#define FRAME_stand24         	24
#define FRAME_stand25         	25
#define FRAME_stand26         	26
#define FRAME_stand27         	27
#define FRAME_stand28         	28
#define FRAME_stand29         	29
#define FRAME_stand30         	30
#define FRAME_stand31         	31
#define FRAME_stand32         	32
#define FRAME_stand33         	33
#define FRAME_stand34         	34
#define FRAME_stand35         	35
#define FRAME_stand36         	36
#define FRAME_stand37         	37
#define FRAME_stand38         	38
#define FRAME_stand39         	39
#define FRAME_stand40         	40
#define FRAME_stand41         	41
#define FRAME_stand42         	42
#define FRAME_stand43         	43
#define FRAME_stand44         	44
#define FRAME_stand45         	45
#define FRAME_stand46         	46
#define FRAME_stand47         	47
#define FRAME_stand48         	48
#define FRAME_stand49         	49
#define FRAME_stand50         	50
#define FRAME_stand51         	51
#define FRAME_stand52         	52
#define FRAME_stand53         	53
#define FRAME_stand54         	54
#define FRAME_stand55         	55
#define FRAME_stand56         	56
#define FRAME_stand57         	57
#define FRAME_stand58         	58
#define FRAME_stand59         	59
#define FRAME_stand60         	60
#define FRAME_stand61         	61
#define FRAME_stand62         	62
#define FRAME_stand63         	63
#define FRAME_stand64         	64
#define FRAME_stand65         	65
#define FRAME_stand66         	66
#define FRAME_stand67         	67
#define FRAME_stand68         	68
#define FRAME_stand69         	69
#define FRAME_stand70         	70
#define FRAME_stand71         	71
#define FRAME_walk01          	72
#define FRAME_walk02          	73
#define FRAME_walk03          	74
#define FRAME_walk04          	75
#define FRAME_walk05          	76
#define FRAME_walk06          	77
#define FRAME_walk07          	78
#define FRAME_walk08          	79
#define FRAME_walk09          	80
#define FRAME_walk10          	81
#define FRAME_walk11          	82
#define FRAME_walk12          	83
#define FRAME_walk13          	84
#define FRAME_walk14          	85
#define FRAME_walk15          	86
#define FRAME_walk16          	87
#define FRAME_walk17          	88
#define FRAME_walk18          	89
#define FRAME_walk19          	90
#define FRAME_walk20          	91
#define FRAME_run01           	92
#define FRAME_run02           	93
#define FRAME_run03           	94
#define FRAME_run04           	95
#define FRAME_run05           	96
#define FRAME_run06           	97
#define FRAME_run07           	98
#define FRAME_run08           	99
#define FRAME_pain101         	100
#define FRAME_pain102         	101
#define FRAME_pain103         	102
#define FRAME_pain104         	103
#define FRAME_pain105         	104
#define FRAME_pain106         	105
#define FRAME_pain107         	106
#define FRAME_pain108         	107
#define FRAME_pain109         	108
#define FRAME_pain110         	109
#define FRAME_pain201         	110
#define FRAME_pain202         	111
#define FRAME_pain203         	112
#define FRAME_pain204         	113
#define FRAME_pain205         	114
#define FRAME_pain206         	115
#define FRAME_pain207         	116
#define FRAME_pain208         	117
#define FRAME_pain209         	118
#define FRAME_pain210         	119
#define FRAME_duck01          	120
#define FRAME_duck02          	121
#define FRAME_duck03          	122
#define FRAME_duck04          	123
#define FRAME_duck05          	124
#define FRAME_death101        	125
#define FRAME_death102        	126
#define FRAME_death103        	127
#define FRAME_death104        	128
#define FRAME_death105        	129
#define FRAME_death106        	130
#define FRAME_death107        	131
#define FRAME_death108        	132
#define FRAME_death109        	133
#define FRAME_death110        	134
#define FRAME_death111        	135
#define FRAME_death112        	136
#define FRAME_death113        	137
#define FRAME_death114        	138
#define FRAME_death115        	139
#define FRAME_death116        	140
#define FRAME_death117        	141
#define FRAME_death118        	142
#define FRAME_death119        	143
#define FRAME_death120        	144
#define FRAME_death201        	145
#define FRAME_death202        	146
#define FRAME_death203        	147
#define FRAME_death204        	148
#define FRAME_death205        	149
#define FRAME_death206        	150
#define FRAME_death207        	151
#define FRAME_death208        	152
#define FRAME_death209        	153
#define FRAME_death210        	154
#define FRAME_death211        	155
#define FRAME_death212        	156
#define FRAME_death213        	157
#define FRAME_death214        	158
#define FRAME_death215        	159
#define FRAME_death216        	160
#define FRAME_death217        	161
#define FRAME_death218        	162
#define FRAME_death219        	163
#define FRAME_death220        	164
#define FRAME_death221        	165
#define FRAME_death222        	166
#define FRAME_death223        	167
#define FRAME_death224        	168
#define FRAME_death225        	169
#define FRAME_death301        	170
#define FRAME_death302        	171
#define FRAME_death303        	172
#define FRAME_death304        	173
#define FRAME_death305        	174
#define FRAME_death306        	175
#define FRAME_death307        	176
#define FRAME_death308        	177
#define FRAME_death309        	178
#define FRAME_block01         	179
#define FRAME_block02         	180
#define FRAME_block03         	181
#define FRAME_block04         	182
#define FRAME_block05         	183
#define FRAME_attak101        	184
#define FRAME_attak102        	185
#define FRAME_attak103        	186
#define FRAME_attak104        	187
#define FRAME_attak105        	188
#define FRAME_attak106        	189
#define FRAME_attak107        	190
#define FRAME_attak108        	191
#define FRAME_attak109        	192
#define FRAME_attak110        	193
#define FRAME_attak111        	194
#define FRAME_attak112        	195
#define FRAME_attak113        	196
#define FRAME_attak114        	197
#define FRAME_attak115        	198
#define FRAME_attak201        	199
#define FRAME_attak202        	200
#define FRAME_attak203        	201
#define FRAME_attak204        	202
#define FRAME_attak205        	203
#define FRAME_attak206        	204
#define FRAME_attak207        	205
#define FRAME_attak208        	206
X
//PGM
#define FRAME_jump01			207
#define FRAME_jump02			208
#define FRAME_jump03			209
#define FRAME_jump04			210
#define FRAME_jump05			211
#define FRAME_jump06			212
#define FRAME_jump07			213
#define FRAME_jump08			214
#define FRAME_jump09			215
#define FRAME_jump10			216
//PGM
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_infantry.h' &&
  chmod 0664 'm_infantry.h' ||
  $echo 'restore of' 'm_infantry.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_infantry.h:' 'MD5 check failed'
2a6127180885004505e1ec8aa1590b58  m_infantry.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_infantry.h'`"
    test 7547 -eq "$shar_count" ||
    $echo 'm_infantry.h:' 'original size' '7547,' 'current size' "$shar_count!"
  fi
fi
# ============= m_insane.c ==============
if test -f 'm_insane.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_insane.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_insane.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_insane.c' &&
/*
==============================================================================
X
insane
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_insane.h"
X
X
static int	sound_fist;
static int	sound_shake;
static int	sound_moan;
static int	sound_scream[8];
X
void insane_fist (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_fist, 1, ATTN_IDLE, 0);
}
X
void insane_shake (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_shake, 1, ATTN_IDLE, 0);
}
X
void insane_moan (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_moan, 1, ATTN_IDLE, 0);
}
X
void insane_scream (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_scream[rand()%8], 1, ATTN_IDLE, 0);
}
X
X
void insane_stand (edict_t *self);
void insane_dead (edict_t *self);
void insane_cross (edict_t *self);
void insane_walk (edict_t *self);
void insane_run (edict_t *self);
void insane_checkdown (edict_t *self);
void insane_checkup (edict_t *self);
void insane_onground (edict_t *self);
X
X
mframe_t insane_frames_stand_normal [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, insane_checkdown
};
mmove_t insane_move_stand_normal = {FRAME_stand60, FRAME_stand65, insane_frames_stand_normal, insane_stand};
X
mframe_t insane_frames_stand_insane [] =
{
X	ai_stand,	0,	insane_shake,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	NULL,
X	ai_stand,	0,	insane_checkdown
};
mmove_t insane_move_stand_insane = {FRAME_stand65, FRAME_stand94, insane_frames_stand_insane, insane_stand};
X
mframe_t insane_frames_uptodown [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	insane_moan,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X
X	ai_move,	2.7,	NULL,
X	ai_move,	4.1,	NULL,
X	ai_move,	6,		NULL,
X	ai_move,	7.6,	NULL,
X	ai_move,	3.6,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	insane_fist,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	insane_fist,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t insane_move_uptodown = {FRAME_stand1, FRAME_stand40, insane_frames_uptodown, insane_onground};
X
X
mframe_t insane_frames_downtoup [] =
{
X	ai_move,	-0.7,	NULL,			// 41
X	ai_move,	-1.2,	NULL,			// 42
X	ai_move,	-1.5,		NULL,		// 43
X	ai_move,	-4.5,		NULL,		// 44
X	ai_move,	-3.5,	NULL,			// 45
X	ai_move,	-0.2,	NULL,			// 46
X	ai_move,	0,	NULL,			// 47
X	ai_move,	-1.3,	NULL,			// 48
X	ai_move,	-3,	NULL,				// 49
X	ai_move,	-2,	NULL,			// 50
X	ai_move,	0,	NULL,				// 51
X	ai_move,	0,	NULL,				// 52
X	ai_move,	0,	NULL,				// 53
X	ai_move,	-3.3,	NULL,			// 54
X	ai_move,	-1.6,	NULL,			// 55
X	ai_move,	-0.3,	NULL,			// 56
X	ai_move,	0,	NULL,				// 57
X	ai_move,	0,	NULL,				// 58
X	ai_move,	0,	NULL				// 59
};
mmove_t insane_move_downtoup = {FRAME_stand41, FRAME_stand59, insane_frames_downtoup, insane_stand};
X
mframe_t insane_frames_jumpdown [] =
{
X	ai_move,	0.2,	NULL,
X	ai_move,	11.5,	NULL,
X	ai_move,	5.1,	NULL,
X	ai_move,	7.1,	NULL,
X	ai_move,	0,	NULL
};
mmove_t insane_move_jumpdown = {FRAME_stand96, FRAME_stand100, insane_frames_jumpdown, insane_onground};
X
X
mframe_t insane_frames_down [] =
{
X	ai_move,	0,		NULL,		// 100
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,		// 110
X	ai_move,	-1.7,		NULL,
X	ai_move,	-1.6,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		insane_fist,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,		// 120
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,		// 130
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		insane_moan,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,		// 140
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,		// 150
X	ai_move,	0.5,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	-0.2,		insane_scream,
X	ai_move,	0,		NULL,
X	ai_move,	0.2,		NULL,
X	ai_move,	0.4,		NULL,
X	ai_move,	0.6,		NULL,
X	ai_move,	0.8,		NULL,
X	ai_move,	0.7,		NULL,
X	ai_move,	0,		insane_checkup		// 160
};
mmove_t insane_move_down = {FRAME_stand100, FRAME_stand160, insane_frames_down, insane_onground};
X
mframe_t insane_frames_walk_normal [] =
{
X	ai_walk,	0,		insane_scream,
X	ai_walk,	2.5,	NULL,
X	ai_walk,	3.5,	NULL,
X	ai_walk,	1.7,	NULL,
X	ai_walk,	2.3,	NULL,
X	ai_walk,	2.4,	NULL,
X	ai_walk,	2.2,	NULL,
X	ai_walk,	4.2,	NULL,
X	ai_walk,	5.6,	NULL,
X	ai_walk,	3.3,	NULL,
X	ai_walk,	2.4,	NULL,
X	ai_walk,	0.9,	NULL,
X	ai_walk,	0,		NULL
};
mmove_t insane_move_walk_normal = {FRAME_walk27, FRAME_walk39, insane_frames_walk_normal, insane_walk};
mmove_t insane_move_run_normal = {FRAME_walk27, FRAME_walk39, insane_frames_walk_normal, insane_run};
X
mframe_t insane_frames_walk_insane [] =
{
X	ai_walk,	0,		insane_scream,		// walk 1
X	ai_walk,	3.4,	NULL,		// walk 2
X	ai_walk,	3.6,	NULL,		// 3
X	ai_walk,	2.9,	NULL,		// 4
X	ai_walk,	2.2,	NULL,		// 5
X	ai_walk,	2.6,	NULL,		// 6
X	ai_walk,	0,		NULL,		// 7
X	ai_walk,	0.7,	NULL,		// 8
X	ai_walk,	4.8,	NULL,		// 9
X	ai_walk,	5.3,	NULL,		// 10
X	ai_walk,	1.1,	NULL,		// 11
X	ai_walk,	2,		NULL,		// 12
X	ai_walk,	0.5,	NULL,		// 13
X	ai_walk,	0,		NULL,		// 14
X	ai_walk,	0,		NULL,		// 15
X	ai_walk,	4.9,	NULL,		// 16
X	ai_walk,	6.7,	NULL,		// 17
X	ai_walk,	3.8,	NULL,		// 18
X	ai_walk,	2,		NULL,		// 19
X	ai_walk,	0.2,	NULL,		// 20
X	ai_walk,	0,		NULL,		// 21
X	ai_walk,	3.4,	NULL,		// 22
X	ai_walk,	6.4,	NULL,		// 23
X	ai_walk,	5,		NULL,		// 24
X	ai_walk,	1.8,	NULL,		// 25
X	ai_walk,	0,		NULL		// 26
};
mmove_t insane_move_walk_insane = {FRAME_walk1, FRAME_walk26, insane_frames_walk_insane, insane_walk};
mmove_t insane_move_run_insane = {FRAME_walk1, FRAME_walk26, insane_frames_walk_insane, insane_run};
X
mframe_t insane_frames_stand_pain [] =
{
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL
};
mmove_t insane_move_stand_pain = {FRAME_st_pain2, FRAME_st_pain12, insane_frames_stand_pain, insane_run};
X
mframe_t insane_frames_stand_death [] =
{
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL
};
mmove_t insane_move_stand_death = {FRAME_st_death2, FRAME_st_death18, insane_frames_stand_death, insane_dead};
X
mframe_t insane_frames_crawl [] =
{
X	ai_walk,	0,		insane_scream,
X	ai_walk,	1.5,	NULL,
X	ai_walk,	2.1,	NULL,
X	ai_walk,	3.6,	NULL,
X	ai_walk,	2,		NULL,
X	ai_walk,	0.9,	NULL,
X	ai_walk,	3,		NULL,
X	ai_walk,	3.4,	NULL,
X	ai_walk,	2.4,	NULL
};
mmove_t insane_move_crawl = {FRAME_crawl1, FRAME_crawl9, insane_frames_crawl, NULL};
mmove_t insane_move_runcrawl = {FRAME_crawl1, FRAME_crawl9, insane_frames_crawl, NULL};
X
mframe_t insane_frames_crawl_pain [] =
{
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL
};
mmove_t insane_move_crawl_pain = {FRAME_cr_pain2, FRAME_cr_pain10, insane_frames_crawl_pain, insane_run};
X
mframe_t insane_frames_crawl_death [] =
{
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL
};
mmove_t insane_move_crawl_death = {FRAME_cr_death10, FRAME_cr_death16, insane_frames_crawl_death, insane_dead};
X
mframe_t insane_frames_cross [] =
{
X	ai_move,	0,		insane_moan,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL
};
mmove_t insane_move_cross = {FRAME_cross1, FRAME_cross15, insane_frames_cross, insane_cross};
X
mframe_t insane_frames_struggle_cross [] =
{
X	ai_move,	0,		insane_scream,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL,
X	ai_move,	0,		NULL
};
mmove_t insane_move_struggle_cross = {FRAME_cross16, FRAME_cross30, insane_frames_struggle_cross, insane_cross};
X
void insane_cross (edict_t *self)
{
X	if (random() < 0.8)		
X		self->monsterinfo.currentmove = &insane_move_cross;
X	else
X		self->monsterinfo.currentmove = &insane_move_struggle_cross;
}
X
void insane_walk (edict_t *self)
{
X	if ( self->spawnflags & 16 )			// Hold Ground?
X		if (self->s.frame == FRAME_cr_pain10)
X		{
X			self->monsterinfo.currentmove = &insane_move_down;
X			return;
X		}
X	if (self->spawnflags & 4)
X		self->monsterinfo.currentmove = &insane_move_crawl;
X	else
X		if (random() <= 0.5)
X			self->monsterinfo.currentmove = &insane_move_walk_normal;
X		else
X			self->monsterinfo.currentmove = &insane_move_walk_insane;
}
X
void insane_run (edict_t *self)
{
X	if ( self->spawnflags & 16 )			// Hold Ground?
X		if (self->s.frame == FRAME_cr_pain10)
X		{
X			self->monsterinfo.currentmove = &insane_move_down;
X			return;
X		}
X	if (self->spawnflags & 4)				// Crawling?
X		self->monsterinfo.currentmove = &insane_move_runcrawl;
X	else
X		if (random() <= 0.5)				// Else, mix it up
X			self->monsterinfo.currentmove = &insane_move_run_normal;
X		else
X			self->monsterinfo.currentmove = &insane_move_run_insane;
}
X
X
void insane_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	int	l,r;
X
//	if (self->health < (self->max_health / 2))
//		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	r = 1 + (rand()&1);
X	if (self->health < 25)
X		l = 25;
X	else if (self->health < 50)
X		l = 50;
X	else if (self->health < 75)
X		l = 75;
X	else
X		l = 100;
X	gi.sound (self, CHAN_VOICE, gi.soundindex (va("player/male/pain%i_%i.wav", l, r)), 1, ATTN_IDLE, 0);
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	// Don't go into pain frames if crucified.
X	if (self->spawnflags & 8)
X	{
X		self->monsterinfo.currentmove = &insane_move_struggle_cross;			
X		return;
X	}
X	
X	if  ( ((self->s.frame >= FRAME_crawl1) && (self->s.frame <= FRAME_crawl9)) || ((self->s.frame >= FRAME_stand99) && (self->s.frame <= FRAME_stand160)) )
X	{
X		self->monsterinfo.currentmove = &insane_move_crawl_pain;
X	}
X	else
X		self->monsterinfo.currentmove = &insane_move_stand_pain;
X
}
X
void insane_onground (edict_t *self)
{
X	self->monsterinfo.currentmove = &insane_move_down;
}
X
void insane_checkdown (edict_t *self)
{
//	if ( (self->s.frame == FRAME_stand94) || (self->s.frame == FRAME_stand65) )
X	if (self->spawnflags & 32)				// Always stand
X		return;
X	if (random() < 0.3)
X		if (random() < 0.5)
X			self->monsterinfo.currentmove = &insane_move_uptodown;
X		else
X			self->monsterinfo.currentmove = &insane_move_jumpdown; 
}
X
void insane_checkup (edict_t *self)
{
X	// If Hold_Ground and Crawl are set
X	if ( (self->spawnflags & 4) && (self->spawnflags & 16) )
X		return;
X	if (random() < 0.5)
X		self->monsterinfo.currentmove = &insane_move_downtoup;				
X
}
X
void insane_stand (edict_t *self)
{
X	if (self->spawnflags & 8)			// If crucified
X	{
X		self->monsterinfo.currentmove = &insane_move_cross;
X		self->monsterinfo.aiflags |= AI_STAND_GROUND;
X	}
X	// If Hold_Ground and Crawl are set
X	else if ( (self->spawnflags & 4) && (self->spawnflags & 16) )
X		self->monsterinfo.currentmove = &insane_move_down;
X	else
X		if (random() < 0.5)
X			self->monsterinfo.currentmove = &insane_move_stand_normal;
X		else
X			self->monsterinfo.currentmove = &insane_move_stand_insane;
}
X
void insane_dead (edict_t *self)
{
X	if (self->spawnflags & 8)
X	{
X		self->flags |= FL_FLY;
X	}
X	else
X	{
X		VectorSet (self->mins, -16, -16, -24);
X		VectorSet (self->maxs, 16, 16, -8);
X		self->movetype = MOVETYPE_TOSS;
X	}
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
X
void insane_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_IDLE, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
X	gi.sound (self, CHAN_VOICE, gi.soundindex(va("player/male/death%i.wav", (rand()%4)+1)), 1, ATTN_IDLE, 0);
X
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	if (self->spawnflags & 8)
X	{
X		insane_dead (self);
X	}
X	else
X	{
X		if ( ((self->s.frame >= FRAME_crawl1) && (self->s.frame <= FRAME_crawl9)) || ((self->s.frame >= FRAME_stand99) && (self->s.frame <= FRAME_stand160)) )		
X			self->monsterinfo.currentmove = &insane_move_crawl_death;
X		else
X			self->monsterinfo.currentmove = &insane_move_stand_death;
X	}
}
X
X
/*QUAKED misc_insane (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn CRAWL CRUCIFIED STAND_GROUND ALWAYS_STAND
*/
void SP_misc_insane (edict_t *self)
{
//	static int skin = 0;	//@@
X
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_fist = gi.soundindex ("insane/insane11.wav");
X	sound_shake = gi.soundindex ("insane/insane5.wav");
X	sound_moan = gi.soundindex ("insane/insane7.wav");
X	sound_scream[0] = gi.soundindex ("insane/insane1.wav");
X	sound_scream[1] = gi.soundindex ("insane/insane2.wav");
X	sound_scream[2] = gi.soundindex ("insane/insane3.wav");
X	sound_scream[3] = gi.soundindex ("insane/insane4.wav");
X	sound_scream[4] = gi.soundindex ("insane/insane6.wav");
X	sound_scream[5] = gi.soundindex ("insane/insane8.wav");
X	sound_scream[6] = gi.soundindex ("insane/insane9.wav");
X	sound_scream[7] = gi.soundindex ("insane/insane10.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex("models/monsters/insane/tris.md2");
X
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X
X	self->health = 100;
X	self->gib_health = -50;
X	self->mass = 300;
X
X	self->pain = insane_pain;
X	self->die = insane_die;
X
X	self->monsterinfo.stand = insane_stand;
X	self->monsterinfo.walk = insane_walk;
X	self->monsterinfo.run = insane_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = NULL;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = NULL;
X	self->monsterinfo.aiflags |= AI_GOOD_GUY;
X
//@@
//	self->s.skinnum = skin;
//	skin++;
//	if (skin > 12)
//		skin = 0;
X
X	gi.linkentity (self);
X
X	if (self->spawnflags & 16)				// Stand Ground
X		self->monsterinfo.aiflags |= AI_STAND_GROUND;
X
X	self->monsterinfo.currentmove = &insane_move_stand_normal;
X	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	if (self->spawnflags & 8)					// Crucified ?
X	{
X		VectorSet (self->mins, -16, 0, 0);
X		VectorSet (self->maxs, 16, 8, 32);
X		self->flags |= FL_NO_KNOCKBACK;
X		flymonster_start (self);
X	}
X	else
X	{
X		walkmonster_start (self);
X		self->s.skinnum = rand()%3;
X	}
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_insane.c' &&
  chmod 0664 'm_insane.c' ||
  $echo 'restore of' 'm_insane.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_insane.c:' 'MD5 check failed'
45e21eb581197d906ed30ff3ba57b309  m_insane.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_insane.c'`"
    test 16523 -eq "$shar_count" ||
    $echo 'm_insane.c:' 'original size' '16523,' 'current size' "$shar_count!"
  fi
fi
# ============= m_insane.h ==============
if test -f 'm_insane.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_insane.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_insane.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_insane.h' &&
// G:\quake2\baseq2\models/monsters/insane
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_stand1          	0
#define FRAME_stand2          	1
#define FRAME_stand3          	2
#define FRAME_stand4          	3
#define FRAME_stand5          	4
#define FRAME_stand6          	5
#define FRAME_stand7          	6
#define FRAME_stand8          	7
#define FRAME_stand9          	8
#define FRAME_stand10         	9
#define FRAME_stand11         	10
#define FRAME_stand12         	11
#define FRAME_stand13         	12
#define FRAME_stand14         	13
#define FRAME_stand15         	14
#define FRAME_stand16         	15
#define FRAME_stand17         	16
#define FRAME_stand18         	17
#define FRAME_stand19         	18
#define FRAME_stand20         	19
#define FRAME_stand21         	20
#define FRAME_stand22         	21
#define FRAME_stand23         	22
#define FRAME_stand24         	23
#define FRAME_stand25         	24
#define FRAME_stand26         	25
#define FRAME_stand27         	26
#define FRAME_stand28         	27
#define FRAME_stand29         	28
#define FRAME_stand30         	29
#define FRAME_stand31         	30
#define FRAME_stand32         	31
#define FRAME_stand33         	32
#define FRAME_stand34         	33
#define FRAME_stand35         	34
#define FRAME_stand36         	35
#define FRAME_stand37         	36
#define FRAME_stand38         	37
#define FRAME_stand39         	38
#define FRAME_stand40         	39
#define FRAME_stand41         	40
#define FRAME_stand42         	41
#define FRAME_stand43         	42
#define FRAME_stand44         	43
#define FRAME_stand45         	44
#define FRAME_stand46         	45
#define FRAME_stand47         	46
#define FRAME_stand48         	47
#define FRAME_stand49         	48
#define FRAME_stand50         	49
#define FRAME_stand51         	50
#define FRAME_stand52         	51
#define FRAME_stand53         	52
#define FRAME_stand54         	53
#define FRAME_stand55         	54
#define FRAME_stand56         	55
#define FRAME_stand57         	56
#define FRAME_stand58         	57
#define FRAME_stand59         	58
#define FRAME_stand60         	59
#define FRAME_stand61         	60
#define FRAME_stand62         	61
#define FRAME_stand63         	62
#define FRAME_stand64         	63
#define FRAME_stand65         	64
#define FRAME_stand66         	65
#define FRAME_stand67         	66
#define FRAME_stand68         	67
#define FRAME_stand69         	68
#define FRAME_stand70         	69
#define FRAME_stand71         	70
#define FRAME_stand72         	71
#define FRAME_stand73         	72
#define FRAME_stand74         	73
#define FRAME_stand75         	74
#define FRAME_stand76         	75
#define FRAME_stand77         	76
#define FRAME_stand78         	77
#define FRAME_stand79         	78
#define FRAME_stand80         	79
#define FRAME_stand81         	80
#define FRAME_stand82         	81
#define FRAME_stand83         	82
#define FRAME_stand84         	83
#define FRAME_stand85         	84
#define FRAME_stand86         	85
#define FRAME_stand87         	86
#define FRAME_stand88         	87
#define FRAME_stand89         	88
#define FRAME_stand90         	89
#define FRAME_stand91         	90
#define FRAME_stand92         	91
#define FRAME_stand93         	92
#define FRAME_stand94         	93
#define FRAME_stand95         	94
#define FRAME_stand96         	95
#define FRAME_stand97         	96
#define FRAME_stand98         	97
#define FRAME_stand99         	98
#define FRAME_stand100        	99
#define FRAME_stand101        	100
#define FRAME_stand102        	101
#define FRAME_stand103        	102
#define FRAME_stand104        	103
#define FRAME_stand105        	104
#define FRAME_stand106        	105
#define FRAME_stand107        	106
#define FRAME_stand108        	107
#define FRAME_stand109        	108
#define FRAME_stand110        	109
#define FRAME_stand111        	110
#define FRAME_stand112        	111
#define FRAME_stand113        	112
#define FRAME_stand114        	113
#define FRAME_stand115        	114
#define FRAME_stand116        	115
#define FRAME_stand117        	116
#define FRAME_stand118        	117
#define FRAME_stand119        	118
#define FRAME_stand120        	119
#define FRAME_stand121        	120
#define FRAME_stand122        	121
#define FRAME_stand123        	122
#define FRAME_stand124        	123
#define FRAME_stand125        	124
#define FRAME_stand126        	125
#define FRAME_stand127        	126
#define FRAME_stand128        	127
#define FRAME_stand129        	128
#define FRAME_stand130        	129
#define FRAME_stand131        	130
#define FRAME_stand132        	131
#define FRAME_stand133        	132
#define FRAME_stand134        	133
#define FRAME_stand135        	134
#define FRAME_stand136        	135
#define FRAME_stand137        	136
#define FRAME_stand138        	137
#define FRAME_stand139        	138
#define FRAME_stand140        	139
#define FRAME_stand141        	140
#define FRAME_stand142        	141
#define FRAME_stand143        	142
#define FRAME_stand144        	143
#define FRAME_stand145        	144
#define FRAME_stand146        	145
#define FRAME_stand147        	146
#define FRAME_stand148        	147
#define FRAME_stand149        	148
#define FRAME_stand150        	149
#define FRAME_stand151        	150
#define FRAME_stand152        	151
#define FRAME_stand153        	152
#define FRAME_stand154        	153
#define FRAME_stand155        	154
#define FRAME_stand156        	155
#define FRAME_stand157        	156
#define FRAME_stand158        	157
#define FRAME_stand159        	158
#define FRAME_stand160        	159
#define FRAME_walk27          	160
#define FRAME_walk28          	161
#define FRAME_walk29          	162
#define FRAME_walk30          	163
#define FRAME_walk31          	164
#define FRAME_walk32          	165
#define FRAME_walk33          	166
#define FRAME_walk34          	167
#define FRAME_walk35          	168
#define FRAME_walk36          	169
#define FRAME_walk37          	170
#define FRAME_walk38          	171
#define FRAME_walk39          	172
#define FRAME_walk1           	173
#define FRAME_walk2           	174
#define FRAME_walk3           	175
#define FRAME_walk4           	176
#define FRAME_walk5           	177
#define FRAME_walk6           	178
#define FRAME_walk7           	179
#define FRAME_walk8           	180
#define FRAME_walk9           	181
#define FRAME_walk10          	182
#define FRAME_walk11          	183
#define FRAME_walk12          	184
#define FRAME_walk13          	185
#define FRAME_walk14          	186
#define FRAME_walk15          	187
#define FRAME_walk16          	188
#define FRAME_walk17          	189
#define FRAME_walk18          	190
#define FRAME_walk19          	191
#define FRAME_walk20          	192
#define FRAME_walk21          	193
#define FRAME_walk22          	194
#define FRAME_walk23          	195
#define FRAME_walk24          	196
#define FRAME_walk25          	197
#define FRAME_walk26          	198
#define FRAME_st_pain2        	199
#define FRAME_st_pain3        	200
#define FRAME_st_pain4        	201
#define FRAME_st_pain5        	202
#define FRAME_st_pain6        	203
#define FRAME_st_pain7        	204
#define FRAME_st_pain8        	205
#define FRAME_st_pain9        	206
#define FRAME_st_pain10       	207
#define FRAME_st_pain11       	208
#define FRAME_st_pain12       	209
#define FRAME_st_death2       	210
#define FRAME_st_death3       	211
#define FRAME_st_death4       	212
#define FRAME_st_death5       	213
#define FRAME_st_death6       	214
#define FRAME_st_death7       	215
#define FRAME_st_death8       	216
#define FRAME_st_death9       	217
#define FRAME_st_death10      	218
#define FRAME_st_death11      	219
#define FRAME_st_death12      	220
#define FRAME_st_death13      	221
#define FRAME_st_death14      	222
#define FRAME_st_death15      	223
#define FRAME_st_death16      	224
#define FRAME_st_death17      	225
#define FRAME_st_death18      	226
#define FRAME_crawl1          	227
#define FRAME_crawl2          	228
#define FRAME_crawl3          	229
#define FRAME_crawl4          	230
#define FRAME_crawl5          	231
#define FRAME_crawl6          	232
#define FRAME_crawl7          	233
#define FRAME_crawl8          	234
#define FRAME_crawl9          	235
#define FRAME_cr_pain2        	236
#define FRAME_cr_pain3        	237
#define FRAME_cr_pain4        	238
#define FRAME_cr_pain5        	239
#define FRAME_cr_pain6        	240
#define FRAME_cr_pain7        	241
#define FRAME_cr_pain8        	242
#define FRAME_cr_pain9        	243
#define FRAME_cr_pain10       	244
#define FRAME_cr_death10      	245
#define FRAME_cr_death11      	246
#define FRAME_cr_death12      	247
#define FRAME_cr_death13      	248
#define FRAME_cr_death14      	249
#define FRAME_cr_death15      	250
#define FRAME_cr_death16      	251
#define FRAME_cross1          	252
#define FRAME_cross2          	253
#define FRAME_cross3          	254
#define FRAME_cross4          	255
#define FRAME_cross5          	256
#define FRAME_cross6          	257
#define FRAME_cross7          	258
#define FRAME_cross8          	259
#define FRAME_cross9          	260
#define FRAME_cross10         	261
#define FRAME_cross11         	262
#define FRAME_cross12         	263
#define FRAME_cross13         	264
#define FRAME_cross14         	265
#define FRAME_cross15         	266
#define FRAME_cross16         	267
#define FRAME_cross17         	268
#define FRAME_cross18         	269
#define FRAME_cross19         	270
#define FRAME_cross20         	271
#define FRAME_cross21         	272
#define FRAME_cross22         	273
#define FRAME_cross23         	274
#define FRAME_cross24         	275
#define FRAME_cross25         	276
#define FRAME_cross26         	277
#define FRAME_cross27         	278
#define FRAME_cross28         	279
#define FRAME_cross29         	280
#define FRAME_cross30         	281
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_insane.h' &&
  chmod 0664 'm_insane.h' ||
  $echo 'restore of' 'm_insane.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_insane.h:' 'MD5 check failed'
0565eedb564565d9a270ad32309c02d0  m_insane.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_insane.h'`"
    test 9887 -eq "$shar_count" ||
    $echo 'm_insane.h:' 'original size' '9887,' 'current size' "$shar_count!"
  fi
fi
# ============= m_medic.c ==============
if test -f 'm_medic.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_medic.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_medic.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_medic.c' &&
/*
==============================================================================
X
MEDIC
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_medic.h"
X
#define	MEDIC_MIN_DISTANCE	32
#define MEDIC_MAX_HEAL_DISTANCE	400
#define	MEDIC_TRY_TIME		10.0
X
// FIXME -
//
// owner moved to monsterinfo.healer instead
//
// For some reason, the healed monsters are rarely ending up in the floor
//
// 5/15/1998 I think I fixed these, keep an eye on them
X
qboolean visible (edict_t *self, edict_t *other);
void M_SetEffects (edict_t *ent);
qboolean FindTarget (edict_t *self);
void HuntTarget (edict_t *self);
void FoundTarget (edict_t *self);
char *ED_NewString (char *string);
void spawngrow_think (edict_t *self);
void SpawnGrow_Spawn (vec3_t startpos, int size);
void ED_CallSpawn (edict_t *ent);
void M_FliesOff (edict_t *self);
void M_FliesOn (edict_t *self);
X
X
static int	sound_idle1;
static int	sound_pain1;
static int	sound_pain2;
static int	sound_die;
static int	sound_sight;
static int	sound_search;
static int	sound_hook_launch;
static int	sound_hook_hit;
static int	sound_hook_heal;
static int	sound_hook_retract;
X
// PMM - commander sounds
static int	commander_sound_idle1;
static int	commander_sound_pain1;
static int	commander_sound_pain2;
static int	commander_sound_die;
static int	commander_sound_sight;
static int	commander_sound_search;
static int	commander_sound_hook_launch;
static int	commander_sound_hook_hit;
static int	commander_sound_hook_heal;
static int	commander_sound_hook_retract;
static int	commander_sound_spawn;
X
char * reinforcements[] = {
X	{"monster_soldier_light"},	// 0
X	{"monster_soldier"},		// 1
X	{"monster_soldier_ss"},		// 2
X	{"monster_infantry"},		// 3
X	{"monster_gunner"},			// 4
//	{"monster_chick"},			// 4
X	{"monster_medic"},			// 5
X	{"monster_gladiator"}		// 6
};
X
vec3_t reinforcement_mins[] = {
X	{-16, -16, -24},
X	{-16, -16, -24},
X	{-16, -16, -24},
X	{-16, -16, -24},
X	{-16, -16, -24},
X	{-16, -16, -24},
X	{-32, -32, -24}
};
X
vec3_t reinforcement_maxs[] = {
X	{16, 16, 32},
X	{16, 16, 32},
X	{16, 16, 32},
X	{16, 16, 32},
X	{16, 16, 32},
X	{16, 16, 32},
X	{32, 32, 64}
};
X
vec3_t reinforcement_position[] = {
X	{80, 0, 0},
X	{40, 60, 0},
X	{40, -60, 0},
X	{0, 80, 0},
X	{0, -80, 0}
};
X
void cleanupHeal (edict_t *self, qboolean change_frame)
{
X	// clean up target, if we have one and it's legit
X	if (self->enemy && self->enemy->inuse)
X	{
X		self->enemy->monsterinfo.healer = NULL;
X		self->enemy->monsterinfo.aiflags &= ~AI_RESURRECTING;
X		self->enemy->takedamage = DAMAGE_YES;
X		M_SetEffects (self->enemy);
X	}
X
X	if (change_frame)
X		self->monsterinfo.nextframe = FRAME_attack52;
}
X
void abortHeal (edict_t *self, qboolean change_frame, qboolean gib, qboolean mark)
{
X	int hurt;
X	static vec3_t	pain_normal = { 0, 0, 1 };
X
X	// clean up target
X	cleanupHeal (self, change_frame);
X	// gib em!
X	if ((mark) && (self->enemy) && (self->enemy->inuse))
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("%s - marking target as bad\n", self->classname);
X		// if the first badMedic slot is filled by a medic, skip it and use the second one
X		if ((self->enemy->monsterinfo.badMedic1) && (self->enemy->monsterinfo.badMedic1->inuse)
X			&& (!strncmp(self->enemy->monsterinfo.badMedic1->classname, "monster_medic", 13)) )
X		{
X			self->enemy->monsterinfo.badMedic2 = self;
X		}
X		else
X		{
X			self->enemy->monsterinfo.badMedic1 = self;
X		}
X	}
X	if ((gib) && (self->enemy) && (self->enemy->inuse))
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("%s - gibbing bad heal target", self->classname);
X
X		if(self->enemy->gib_health)
X			hurt = - self->enemy->gib_health;
X		else
X			hurt = 500;
X
X		T_Damage (self->enemy, self, self, vec3_origin, self->enemy->s.origin,
X					pain_normal, hurt, 0, 0, MOD_UNKNOWN);
X	}
X	// clean up self
X
X	self->monsterinfo.aiflags &= ~AI_MEDIC;
X	if ((self->oldenemy) && (self->oldenemy->inuse))
X		self->enemy = self->oldenemy;
X	else
X		self->enemy = NULL;
X
X	self->monsterinfo.medicTries = 0;
}
X
qboolean canReach (edict_t *self, edict_t *other)
{
X	vec3_t	spot1;
X	vec3_t	spot2;
X	trace_t	trace;
X
X	VectorCopy (self->s.origin, spot1);
X	spot1[2] += self->viewheight;
X	VectorCopy (other->s.origin, spot2);
X	spot2[2] += other->viewheight;
X	trace = gi.trace (spot1, vec3_origin, vec3_origin, spot2, self, MASK_SHOT|MASK_WATER);
X	
X	if (trace.fraction == 1.0 || trace.ent == other)		// PGM
X		return true;
X	return false;
}
X
edict_t *medic_FindDeadMonster (edict_t *self)
{
X	float	radius;
X	edict_t	*ent = NULL;
X	edict_t	*best = NULL;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		radius = MEDIC_MAX_HEAL_DISTANCE;
X	else
X		radius = 1024;
X
X	while ((ent = findradius(ent, self->s.origin, radius)) != NULL)
X	{
X		if (ent == self)
X			continue;
X		if (!(ent->svflags & SVF_MONSTER))
X			continue;
X		if (ent->monsterinfo.aiflags & AI_GOOD_GUY)
X			continue;
X		// check to make sure we haven't bailed on this guy already
X		if ((ent->monsterinfo.badMedic1 == self) || (ent->monsterinfo.badMedic2 == self))
X			continue;
X		if (ent->monsterinfo.healer)
X			// FIXME - this is correcting a bug that is somewhere else
X			// if the healer is a monster, and it's in medic mode .. continue .. otherwise
X			//   we will override the healer, if it passes all the other tests
X			if ((ent->monsterinfo.healer->inuse) && (ent->monsterinfo.healer->health > 0) &&
X				(ent->monsterinfo.healer->svflags & SVF_MONSTER) && (ent->monsterinfo.healer->monsterinfo.aiflags & AI_MEDIC))
X				continue;
X		if (ent->health > 0)
X			continue;
X		if ((ent->nextthink) && !((ent->think == M_FliesOn) || (ent->think == M_FliesOff)))
X			continue;
X		if (!visible(self, ent))
//		if (!canReach(self, ent))
X			continue;
X		if (!strncmp(ent->classname, "player", 6))		 // stop it from trying to heal player_noise entities
X			continue;
X		// FIXME - there's got to be a better way ..
X		// make sure we don't spawn people right on top of us
X		if (realrange(self, ent) <= MEDIC_MIN_DISTANCE)
X			continue;
X		if (!best)
X		{
X			best = ent;
X			continue;
X		}
X		if (ent->max_health <= best->max_health)
X			continue;
X		best = ent;
X	}
X
X	if (best)
X		self->timestamp = level.time + MEDIC_TRY_TIME;
X
X	return best;
}
X
void medic_idle (edict_t *self)
{
X	edict_t	*ent;
X
X	// PMM - commander sounds
X	if (self->mass == 400)
X		gi.sound (self, CHAN_VOICE, sound_idle1, 1, ATTN_IDLE, 0);
X	else
X		gi.sound (self, CHAN_VOICE, commander_sound_idle1, 1, ATTN_IDLE, 0);
X		
X
X	if (!self->oldenemy)
X	{
X		ent = medic_FindDeadMonster(self);
X		if (ent)
X		{
X			self->oldenemy = self->enemy;
X			self->enemy = ent;
X			self->enemy->monsterinfo.healer = self;
X			self->monsterinfo.aiflags |= AI_MEDIC;
X			FoundTarget (self);
X		}
X	}
}
X
void medic_search (edict_t *self)
{
X	edict_t	*ent;
X
X	// PMM - commander sounds
X	if (self->mass == 400)
X		gi.sound (self, CHAN_VOICE, sound_search, 1, ATTN_IDLE, 0);
X	else
X		gi.sound (self, CHAN_VOICE, commander_sound_search, 1, ATTN_IDLE, 0);
X
X	if (!self->oldenemy)
X	{
X		ent = medic_FindDeadMonster(self);
X		if (ent)
X		{
X			self->oldenemy = self->enemy;
X			self->enemy = ent;
X			self->enemy->monsterinfo.healer = self;
X			self->monsterinfo.aiflags |= AI_MEDIC;
X			FoundTarget (self);
X		}
X	}
}
X
void medic_sight (edict_t *self, edict_t *other)
{
X	// PMM - commander sounds
X	if (self->mass == 400)
X		gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, commander_sound_sight, 1, ATTN_NORM, 0);
}
X
X
mframe_t medic_frames_stand [] =
{
X	ai_stand, 0, medic_idle,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
};
mmove_t medic_move_stand = {FRAME_wait1, FRAME_wait90, medic_frames_stand, NULL};
X
void medic_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &medic_move_stand;
}
X
X
mframe_t medic_frames_walk [] =
{
X	ai_walk, 6.2,	NULL,
X	ai_walk, 18.1,  NULL,
X	ai_walk, 1,		NULL,
X	ai_walk, 9,		NULL,
X	ai_walk, 10,	NULL,
X	ai_walk, 9,		NULL,
X	ai_walk, 11,	NULL,
X	ai_walk, 11.6,  NULL,
X	ai_walk, 2,		NULL,
X	ai_walk, 9.9,	NULL,
X	ai_walk, 14,	NULL,
X	ai_walk, 9.3,	NULL
};
mmove_t medic_move_walk = {FRAME_walk1, FRAME_walk12, medic_frames_walk, NULL};
X
void medic_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &medic_move_walk;
}
X
X
mframe_t medic_frames_run [] =
{
X	ai_run, 18,		NULL,
X	ai_run, 22.5,	NULL,
X	ai_run, 25.4,	monster_done_dodge,
X	ai_run, 23.4,	NULL,
X	ai_run, 24,		NULL,
X	ai_run, 35.6,	NULL		//pmm
X	
};
mmove_t medic_move_run = {FRAME_run1, FRAME_run6, medic_frames_run, NULL};
X
void medic_run (edict_t *self)
{
X	monster_done_dodge (self);
X	if (!(self->monsterinfo.aiflags & AI_MEDIC))
X	{
X		edict_t	*ent;
X
X		ent = medic_FindDeadMonster(self);
X		if (ent)
X		{
X			self->oldenemy = self->enemy;
X			self->enemy = ent;
X			self->enemy->monsterinfo.healer = self;
X			self->monsterinfo.aiflags |= AI_MEDIC;
X			FoundTarget (self);
X			return;
X		}
X	}
//	else if (!canReach(self, self->enemy))
//	{
//		abortHeal (self, 0);
//	}
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &medic_move_stand;
X	else
X		self->monsterinfo.currentmove = &medic_move_run;
}
X
X
mframe_t medic_frames_pain1 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t medic_move_pain1 = {FRAME_paina1, FRAME_paina8, medic_frames_pain1, medic_run};
X
mframe_t medic_frames_pain2 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t medic_move_pain2 = {FRAME_painb1, FRAME_painb15, medic_frames_pain2, medic_run};
X
void medic_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	monster_done_dodge (self);
X
X	if ((self->health < (self->max_health / 2)))
X		if (self->mass > 400)
X			self->s.skinnum = 3;
X		else
X			self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	// if we're healing someone, we ignore pain
X	if (self->monsterinfo.aiflags & AI_MEDIC)
X		return;
X
X	if (self->mass > 400)
X	{
X		if (damage < 35)
X		{
X			gi.sound (self, CHAN_VOICE, commander_sound_pain1, 1, ATTN_NORM, 0);
X			return;
X		}
X
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X
X		gi.sound (self, CHAN_VOICE, commander_sound_pain2, 1, ATTN_NORM, 0);
X
X		if (random() < (min(((float)damage * 0.005), 0.5)))		// no more than 50% chance of big pain
X			self->monsterinfo.currentmove = &medic_move_pain2;
X		else
X			self->monsterinfo.currentmove = &medic_move_pain1;
X	}
X	else if (random() < 0.5)
X	{
X		self->monsterinfo.currentmove = &medic_move_pain1;
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &medic_move_pain2;
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X	}
X	// PMM - clear duck flag
X	if (self->monsterinfo.aiflags & AI_DUCKED)
X		monster_duck_up(self);
}
X
void medic_fire_blaster (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	forward, right;
X	vec3_t	end;
X	vec3_t	dir;
X	int		effect;
X	int		damage = 2;
X
X	// paranoia checking
X	if (!(self->enemy && self->enemy->inuse))
X		return;
X
X	if ((self->s.frame == FRAME_attack9) || (self->s.frame == FRAME_attack12))
X		effect = EF_BLASTER;
X	else if ((self->s.frame == FRAME_attack19) || (self->s.frame == FRAME_attack22) || (self->s.frame == FRAME_attack25) || (self->s.frame == FRAME_attack28))
X		effect = EF_HYPERBLASTER;
X	else
X		effect = 0;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_MEDIC_BLASTER_1], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, end);
X	end[2] += self->enemy->viewheight;
X	VectorSubtract (end, start, dir);
X
X	if (!strcmp(self->enemy->classname, "tesla"))
X		damage = 3;
X
X	// medic commander shoots blaster2
X	if (self->mass > 400)
X		monster_fire_blaster2 (self, start, dir, damage, 1000, MZ2_MEDIC_BLASTER_2, effect);
X	else
X		monster_fire_blaster (self, start, dir, damage, 1000, MZ2_MEDIC_BLASTER_1, effect);
}
X
void medic_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t medic_frames_death [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t medic_move_death = {FRAME_death1, FRAME_death30, medic_frames_death, medic_dead};
X
void medic_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
X	// if we had a pending patient, he was already freed up in Killed
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	//	PMM
X	if (self->mass == 400)
X		gi.sound (self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, commander_sound_die, 1, ATTN_NORM, 0);
X	//
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	self->monsterinfo.currentmove = &medic_move_death;
}
X
mframe_t medic_frames_duck [] =
{
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,
X	ai_move, -1,	monster_duck_down,
X	ai_move, -1,	monster_duck_hold,
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,		// PMM - duck up used to be here
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL,
X	ai_move, -1,	monster_duck_up,
X	ai_move, -1,	NULL,
X	ai_move, -1,	NULL
};
mmove_t medic_move_duck = {FRAME_duck1, FRAME_duck16, medic_frames_duck, medic_run};
X
// PMM -- moved dodge code to after attack code so I can reference attack frames
X
mframe_t medic_frames_attackHyperBlaster [] =
{
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	medic_fire_blaster
};
mmove_t medic_move_attackHyperBlaster = {FRAME_attack15, FRAME_attack30, medic_frames_attackHyperBlaster, medic_run};
X
X
void medic_continue (edict_t *self)
{
X	if (visible (self, self->enemy) )
X		if (random() <= 0.95)
X			self->monsterinfo.currentmove = &medic_move_attackHyperBlaster;
}
X
X
mframe_t medic_frames_attackBlaster [] =
{
X	ai_charge, 0,	NULL,
X	ai_charge, 5,	NULL,
X	ai_charge, 5,	NULL,
X	ai_charge, 3,	NULL,
X	ai_charge, 2,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	medic_fire_blaster,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	medic_fire_blaster,	
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	medic_continue	// Change to medic_continue... Else, go to frame 32
};
mmove_t medic_move_attackBlaster = {FRAME_attack1, FRAME_attack14, medic_frames_attackBlaster, medic_run};
X
X
void medic_hook_launch (edict_t *self)
{
X	// PMM - commander sounds
X	if (self->mass == 400)
X		gi.sound (self, CHAN_WEAPON, sound_hook_launch, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_WEAPON, commander_sound_hook_launch, 1, ATTN_NORM, 0);
}
X
static vec3_t	medic_cable_offsets[] =
{
X	45.0,  -9.2, 15.5,
X	48.4,  -9.7, 15.2,
X	47.8,  -9.8, 15.8,
X	47.3,  -9.3, 14.3,
X	45.4, -10.1, 13.1,
X	41.9, -12.7, 12.0,
X	37.8, -15.8, 11.2,
X	34.3, -18.4, 10.7,
X	32.7, -19.7, 10.4,
X	32.7, -19.7, 10.4
};
X
void medic_cable_attack (edict_t *self)
{
X	vec3_t	offset, start, end, f, r;
X	trace_t	tr;
X	vec3_t	dir;
//	vec3_t  angles;
X	float	distance;
X
X	if ((!self->enemy) || (!self->enemy->inuse) || (self->enemy->s.effects & EF_GIB))
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("medic_commander - aborting heal due to target's disappearance\n");
X		abortHeal (self, true, false, false);
X		return;
X	}
X
X	// see if our enemy has changed to a client, or our target has more than 0 health,
X	// abort it .. we got switched to someone else due to damage
X	if ((self->enemy->client) || (self->enemy->health > 0))
X	{
X		abortHeal (self, true, false, false);
X		return;
X	}
X	AngleVectors (self->s.angles, f, r, NULL);
X	VectorCopy (medic_cable_offsets[self->s.frame - FRAME_attack42], offset);
X	G_ProjectSource (self->s.origin, offset, f, r, start);
X
X	// check for max distance
X	// not needed, done in checkattack
X	// check for min distance
X	VectorSubtract (start, self->enemy->s.origin, dir);
X	distance = VectorLength(dir);
X	if (distance < MEDIC_MIN_DISTANCE)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("medic_commander - aborting heal due to proximity to target ");
X		abortHeal (self, true, true, false );
X		return;
X	}
//	if ((g_showlogic)&&(g_showlogic->value))
//		gi.dprintf ("distance to target is %f\n", distance);
//	if (distance > 300)
//		return;
X
X	// check for min/max pitch
X	// PMM -- took out since it doesn't look bad when it fails
//	vectoangles (dir, angles);
//	if (angles[0] < -180)
//		angles[0] += 360;
//	if (fabs(angles[0]) > 45)
//	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("medic_commander - aborting heal due to bad angle\n");
//		abortHeal(self);
//		return;
//	}
X
X	tr = gi.trace (start, NULL, NULL, self->enemy->s.origin, self, MASK_SOLID);
X	if (tr.fraction != 1.0 && tr.ent != self->enemy)
X	{
X		if (tr.ent == world)
X		{
X			// give up on second try
X			if (self->monsterinfo.medicTries > 1)
X			{
X				abortHeal (self, true, false, true);
X				return;
X			}
X			self->monsterinfo.medicTries++;
X			cleanupHeal (self, 1);
X			return;
X		}
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("medic_commander - aborting heal due to beamus interruptus\n");
X		abortHeal (self, true, false, false);
X		return;
X	}
X
X	if (self->s.frame == FRAME_attack43)
X	{
X		// PMM - commander sounds
X		if (self->mass == 400)
X			gi.sound (self->enemy, CHAN_AUTO, sound_hook_hit, 1, ATTN_NORM, 0);
X		else
X			gi.sound (self->enemy, CHAN_AUTO, commander_sound_hook_hit, 1, ATTN_NORM, 0);
X
X		self->enemy->monsterinfo.aiflags |= AI_RESURRECTING;
X		self->enemy->takedamage = DAMAGE_NO;
X		M_SetEffects (self->enemy);
X	}
X	else if (self->s.frame == FRAME_attack50)
X	{
X		vec3_t	maxs;
X		self->enemy->spawnflags = 0;
X		self->enemy->monsterinfo.aiflags = 0;
X		self->enemy->target = NULL;
X		self->enemy->targetname = NULL;
X		self->enemy->combattarget = NULL;
X		self->enemy->deathtarget = NULL;
X		self->enemy->monsterinfo.healer = self;
X
X		VectorCopy (self->enemy->maxs, maxs);
X		maxs[2] += 48;   // compensate for change when they die
X
X		tr = gi.trace (self->enemy->s.origin, self->enemy->mins, maxs, self->enemy->s.origin, self->enemy, MASK_MONSTERSOLID);
X		if (tr.startsolid || tr.allsolid)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("Spawn point obstructed, aborting heal!\n");
X			abortHeal (self, true, true, false);
X			return;
X		} 
X		else if (tr.ent != world)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf("heal in entity %s\n", tr.ent->classname);
X			abortHeal (self, true, true, false);
X			return;
X		}
/*		else if (tr.ent == world)
X		{
X			if ((g_showlogic) && (g_showlogic->value))
X				gi.dprintf ("heal in world, aborting!\n");
X			abortHeal (self, 1);
X			return;
X		}
*/		else
X		{
X			self->enemy->monsterinfo.aiflags |= AI_DO_NOT_COUNT;
X			ED_CallSpawn (self->enemy);
X
X			if (self->enemy->think)
X			{
X				self->enemy->nextthink = level.time;
X				self->enemy->think (self->enemy);
X			}
X	//		self->enemy->monsterinfo.aiflags |= AI_RESURRECTING;
X			self->enemy->monsterinfo.aiflags &= ~AI_RESURRECTING;
X			self->enemy->monsterinfo.aiflags |= AI_IGNORE_SHOTS|AI_DO_NOT_COUNT;
X			// turn off flies
X			self->enemy->s.effects &= ~EF_FLIES;
X			self->enemy->monsterinfo.healer = NULL;
X
X			if ((self->oldenemy) && (self->oldenemy->inuse) && (self->oldenemy->health > 0))
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("setting heal target's enemy to %s\n", self->oldenemy->classname);
X				self->enemy->enemy = self->oldenemy;
//				HuntTarget (self->enemy);
X				FoundTarget (self->enemy);
X			}
X			else
X			{
//				if (g_showlogic && g_showlogic->value)
//					gi.dprintf ("no valid enemy to set!\n");
X				self->enemy->enemy = NULL;
X				if (!FindTarget (self->enemy))
X				{
X					// no valid enemy, so stop acting
X					self->enemy->monsterinfo.pausetime = level.time + 100000000;
X					self->enemy->monsterinfo.stand (self->enemy);
X				}
X				self->enemy = NULL;
X				self->oldenemy = NULL;
X				if (!FindTarget (self))
X				{
X					// no valid enemy, so stop acting
X					self->monsterinfo.pausetime = level.time + 100000000;
X					self->monsterinfo.stand (self);
X					return;
X				}
X			}
X		}
X	}
X	else
X	{
X		if (self->s.frame == FRAME_attack44)
X			// PMM - medic commander sounds
X			if (self->mass == 400)
X				gi.sound (self, CHAN_WEAPON, sound_hook_heal, 1, ATTN_NORM, 0);
X			else
X				gi.sound (self, CHAN_WEAPON, commander_sound_hook_heal, 1, ATTN_NORM, 0);
X	}
X
X	// adjust start for beam origin being in middle of a segment
X	VectorMA (start, 8, f, start);
X
X	// adjust end z for end spot since the monster is currently dead
X	VectorCopy (self->enemy->s.origin, end);
X	end[2] = self->enemy->absmin[2] + self->enemy->size[2] / 2;
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_MEDIC_CABLE_ATTACK);
X	gi.WriteShort (self - g_edicts);
X	gi.WritePosition (start);
X	gi.WritePosition (end);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
}
X
void medic_hook_retract (edict_t *self)
{
X	if (self->mass == 400)
X		gi.sound (self, CHAN_WEAPON, sound_hook_retract, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_WEAPON, sound_hook_retract, 1, ATTN_NORM, 0);
X
X	self->monsterinfo.aiflags &= ~AI_MEDIC;
X	if ((self->oldenemy) && (self->oldenemy->inuse))
X		self->enemy = self->oldenemy;
X	else
X	{
X		self->enemy = NULL;
X		self->oldenemy = NULL;
X		if (!FindTarget (self))
X		{
X			// no valid enemy, so stop acting
X			self->monsterinfo.pausetime = level.time + 100000000;
X			self->monsterinfo.stand (self);
X			return;
X		}
X	}
}
X
mframe_t medic_frames_attackCable [] =
{
// ROGUE - negated 36-40 so he scoots back from his target a little
// ROGUE - switched 33-36 to ai_charge
// ROGUE - changed frame 52 to 0 to compensate for changes in 36-40
X	ai_charge, 2,		NULL,					//33
X	ai_charge, 3,		NULL,
X	ai_charge, 5,		NULL,
X	ai_charge, -4.4,	NULL,					//36
X	ai_charge, -4.7,	NULL,					//37
X	ai_charge, -5,	NULL,
X	ai_charge, -6,	NULL,
X	ai_charge, -4,	NULL,					//40
X	ai_charge, 0,	NULL,
X	ai_move, 0,		medic_hook_launch,		//42
X	ai_move, 0,		medic_cable_attack,		//43
X	ai_move, 0,		medic_cable_attack,
X	ai_move, 0,		medic_cable_attack,
X	ai_move, 0,		medic_cable_attack,
X	ai_move, 0,		medic_cable_attack,
X	ai_move, 0,		medic_cable_attack,
X	ai_move, 0,		medic_cable_attack,
X	ai_move, 0,		medic_cable_attack,
X	ai_move, 0,		medic_cable_attack,		//51
X	ai_move, 0,		medic_hook_retract,		//52
X	ai_move, -1.5,	NULL,
X	ai_move, -1.2,	NULL,
X	ai_move, -3,	NULL,
X	ai_move, -2,	NULL,
X	ai_move, 0.3,	NULL,
X	ai_move, 0.7,	NULL,
X	ai_move, 1.2,	NULL,
X	ai_move, 1.3,	NULL					//60
};
mmove_t medic_move_attackCable = {FRAME_attack33, FRAME_attack60, medic_frames_attackCable, medic_run};
X
X
void medic_start_spawn (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, commander_sound_spawn, 1, ATTN_NORM, 0);
X	self->monsterinfo.nextframe = FRAME_attack48;
}
X
void medic_determine_spawn (edict_t *self)
{
X	vec3_t	f, r, offset, startpoint, spawnpoint;
X	float	lucky;
X	int		summonStr;
X	int		count;
X	int		inc;
X	int		num_summoned; // should be 1, 3, or 5
X	int		num_success = 0;
X
X	lucky = random();
X	summonStr = skill->value;
X
X	// bell curve - 0 = 67%, 1 = 93%, 2 = 99% -- too steep
X	// this ends up with
X	// -3 = 5%
X	// -2 = 10%
X	// -1 = 15%
X	// 0  = 40%
X	// +1 = 15%
X	// +2 = 10%
X	// +3 = 5%
X	if (lucky < 0.05)
X		summonStr -= 3;
X	else if (lucky < 0.15)
X		summonStr -= 2;
X	else if (lucky < 0.3)
X		summonStr -= 1;
X	else if (lucky > 0.95)
X		summonStr += 3;
X	else if (lucky > 0.85)
X		summonStr += 2;
X	else if (lucky > 0.7)
X		summonStr += 1;
X
X	if (summonStr < 0)
X		summonStr = 0;
X
X	//FIXME - need to remember this, might as well use this int that isn't used for monsters
X	self->plat2flags = summonStr;
X	AngleVectors (self->s.angles, f, r, NULL);
X
// this yields either 1, 3, or 5
X	if (summonStr)
X		num_summoned = (summonStr - 1) + (summonStr % 2);
X	else
X		num_summoned = 1;
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("medic_commander: summonStr = %d num = %d\n", summonStr, num_summoned);
X
X	for (count = 0; count < num_summoned; count++)
X	{
X		inc = count + (count%2); // 0, 2, 2, 4, 4
X		VectorCopy (reinforcement_position[count], offset);
X
X		G_ProjectSource (self->s.origin, offset, f, r, startpoint);
X		// a little off the ground
X		startpoint[2] += 10;
X
X		if (FindSpawnPoint (startpoint, reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc], spawnpoint, 32))
X		{
X			if (CheckGroundSpawnPoint(spawnpoint, 
X				reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc], 
X				256, -1))
X			{
X				num_success++;
X				// we found a spot, we're done here
X				count = num_summoned;
X			}
//			else if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("medic_commander: CheckGroundSpawnPoint says bad stuff down there!\n");
X		}
X	}
X
X	if (num_success == 0)
X	{
X		for (count = 0; count < num_summoned; count++)
X		{
X			inc = count + (count%2); // 0, 2, 2, 4, 4
X			VectorCopy (reinforcement_position[count], offset);
X			
X			// check behind
X			offset[0] *= -1.0;
X			offset[1] *= -1.0;
X			G_ProjectSource (self->s.origin, offset, f, r, startpoint);
X			// a little off the ground
X			startpoint[2] += 10;
X
X			if (FindSpawnPoint (startpoint, reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc], spawnpoint, 32))
X			{
X				if (CheckGroundSpawnPoint(spawnpoint, 
X					reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc], 
X					256, -1))
X				{
X					num_success++;
X					// we found a spot, we're done here
X					count = num_summoned;
X				}
X			}
X		}
X
X		if (num_success)
X		{
X			self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X			self->ideal_yaw = anglemod(self->s.angles[YAW]) + 180;
X			if (self->ideal_yaw > 360.0)
X				self->ideal_yaw -= 360.0;
//			self->plat2flags *= -1;
X		}
X	}
X
X	if (num_success == 0)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("medic_commander: failed to find any spawn points, aborting!\n");
X		self->monsterinfo.nextframe = FRAME_attack53;
X	}
}
X
void medic_spawngrows (edict_t *self)
{
X	vec3_t	f, r, offset, startpoint, spawnpoint;
X	int		summonStr;
X	int		count;
X	int		inc;
X	int		num_summoned; // should be 1, 3, or 5
X	int		num_success = 0;
X	float	current_yaw;
X	qboolean	behind = false;
X
X	// if we've been directed to turn around
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X	{
X		current_yaw = anglemod(self->s.angles[YAW]);
X		if (fabs(current_yaw - self->ideal_yaw) > 0.1)
X		{
X			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
X			return;
X		}
X
X		// done turning around
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X	}
X
//	if (self->plat2flags < 0)
//	{
//		summonStr = -1.0 * self->plat2flags;
//		behind = true;
//	}
//	else
X		summonStr = self->plat2flags;
X
X	AngleVectors (self->s.angles, f, r, NULL);
X
//	num_summoned = ((((summonStr-1)/2)+1)*2)-1;  // this yields either 1, 3, or 5
X	if (summonStr)
X		num_summoned = (summonStr - 1) + (summonStr % 2);
X	else
X		num_summoned = 1;
X
X	for (count = 0; count < num_summoned; count++)
X	{
X		inc = count + (count%2); // 0, 2, 2, 4, 4
X		VectorCopy (reinforcement_position[count], offset);
X
X		G_ProjectSource (self->s.origin, offset, f, r, startpoint);
X		// a little off the ground
X		startpoint[2] += 10;
X
X		if (FindSpawnPoint (startpoint, reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc], spawnpoint, 32))
X		{
X			if (CheckGroundSpawnPoint(spawnpoint, 
X				reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc], 
X				256, -1))
X			{
X				num_success++;
X				if ((summonStr-inc) > 3)
X					SpawnGrow_Spawn (spawnpoint, 1);		// big monster
X				else
X					SpawnGrow_Spawn (spawnpoint, 0);		// normal size
X			}
X		}
X	}
X
X	if (num_success == 0)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("medic_commander: spawngrows bad, aborting!\n");
X		self->monsterinfo.nextframe = FRAME_attack53;
X	}
}
X
void medic_finish_spawn (edict_t *self)
{
X	edict_t *ent;
X	vec3_t	f, r, offset, startpoint, spawnpoint;
X	int		summonStr;
X	int		count;
X	int		inc;
X	int		num_summoned; // should be 1, 3, or 5
X	qboolean	behind = false;
X	edict_t	*designated_enemy;
X
//	trace_t		tr;
//	vec3_t mins, maxs;
X
X	// this is one bigger than the soldier's real mins .. just for paranoia's sake
//	VectorSet (mins, -17, -17, -25);
//	VectorSet (maxs, 17, 17, 33);
X
X	//FIXME - better place to store this info?
X	if (self->plat2flags < 0)
X	{
X		behind = true;
X		self->plat2flags *= -1;
X	}
X	summonStr = self->plat2flags;
X
X	AngleVectors (self->s.angles, f, r, NULL);
X
//	num_summoned = ((((summonStr-1)/2)+1)*2)-1;  // this yields either 1, 3, or 5
X	if (summonStr)
X		num_summoned = (summonStr - 1) + (summonStr % 2);
X	else
X		num_summoned = 1;
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("medic_commander: summonStr = %d num = %d\n", summonStr, num_summoned);
X
X	for (count = 0; count < num_summoned; count++)
X	{
X		inc = count + (count%2); // 0, 2, 2, 4, 4
X		VectorCopy (reinforcement_position[count], offset);
X
X		G_ProjectSource (self->s.origin, offset, f, r, startpoint);
X
X		// a little off the ground
X		startpoint[2] += 10;
X
X		ent = NULL;
X		if (FindSpawnPoint (startpoint, reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc], spawnpoint, 32))
X		{
X			if (CheckSpawnPoint (spawnpoint, reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc]))
X				ent = CreateGroundMonster (spawnpoint, self->s.angles,
X					reinforcement_mins[summonStr-inc], reinforcement_maxs[summonStr-inc],
X					reinforcements[summonStr-inc], 256);
//			else if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("CheckSpawnPoint failed volume check!\n");
X		}
X		else
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("FindSpawnPoint failed to find a point!\n");
X		}
X
X		if (!ent)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("Spawn point obstructed for %s, aborting!\n", reinforcements[summonStr-inc]);
X			continue;
X		}
X
//		gi.sound (self, CHAN_WEAPON, commander_sound_spawn, 1, ATTN_NORM, 0);
X
X		if (ent->think)
X		{
X			ent->nextthink = level.time;
X			ent->think (ent);
X		}
X
X		ent->monsterinfo.aiflags |= AI_IGNORE_SHOTS|AI_DO_NOT_COUNT|AI_SPAWNED_MEDIC_C;
X		ent->monsterinfo.commander = self;
X		self->monsterinfo.monster_slots--;
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("medic_commander: %d slots remaining\n", self->monsterinfo.monster_slots);
X
X		if (self->monsterinfo.aiflags & AI_MEDIC)
X			designated_enemy = self->oldenemy;
X		else
X			designated_enemy = self->enemy;
X
X		if (coop && coop->value)
X		{
X			designated_enemy = PickCoopTarget(ent);
X			if (designated_enemy)
X			{
X				// try to avoid using my enemy
X				if (designated_enemy == self->enemy)
X				{
X					designated_enemy = PickCoopTarget(ent);
X					if (designated_enemy)
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//						{
//							gi.dprintf ("PickCoopTarget returned a %s - ", designated_enemy->classname);
//							if (designated_enemy->client)
//								gi.dprintf ("with name %s\n", designated_enemy->client->pers.netname);
//							else
//								gi.dprintf ("NOT A CLIENT\n");
//						}
X					}
X					else
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("pick coop failed, using my current enemy\n");
X						designated_enemy = self->enemy;
X					}
X				}
X			}
X			else
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf ("pick coop failed, using my current enemy\n");
X				designated_enemy = self->enemy;
X			}
X		}
X
X		if ((designated_enemy) && (designated_enemy->inuse) && (designated_enemy->health > 0))
X		{
X			// fixme
//			if ((g_showlogic) && (g_showlogic -> value))
//				gi.dprintf  ("setting enemy to %s\n", designated_enemy->classname);
X			ent->enemy = designated_enemy;
X			FoundTarget (ent);
X		}
X		else
X		{
X			ent->enemy = NULL;
X			ent->monsterinfo.stand (ent);
X		}
//		ent->s.event = EV_PLAYER_TELEPORT;
X	}
}
X
mframe_t medic_frames_callReinforcements [] =
{
X	// ROGUE - 33-36 now ai_charge
X	ai_charge, 2,		NULL,					//33
X	ai_charge, 3,		NULL,
X	ai_charge, 5,		NULL,
X	ai_charge, 4.4,	NULL,					//36
X	ai_charge, 4.7,	NULL,
X	ai_charge, 5,	NULL,
X	ai_charge, 6,	NULL,
X	ai_charge, 4,	NULL,					//40
X	ai_charge, 0,	NULL,
X	ai_move, 0,		medic_start_spawn,		//42
X	ai_move, 0,		NULL,		//43 -- 43 through 47 are skipped
X	ai_move, 0,		NULL,
X	ai_move, 0,		NULL,
X	ai_move, 0,		NULL,
X	ai_move, 0,		NULL,
X	ai_move, 0,		medic_determine_spawn,		//48
X	ai_charge, 0,		medic_spawngrows,			//49
X	ai_move, 0,		NULL,		//50
X	ai_move, 0,		NULL,		//51
X	ai_move, -15,	medic_finish_spawn,		//52
X	ai_move, -1.5,	NULL,
X	ai_move, -1.2,	NULL,
X	ai_move, -3,	NULL,
X	ai_move, -2,	NULL,
X	ai_move, 0.3,	NULL,
X	ai_move, 0.7,	NULL,
X	ai_move, 1.2,	NULL,
X	ai_move, 1.3,	NULL					//60
};
mmove_t medic_move_callReinforcements = {FRAME_attack33, FRAME_attack60, medic_frames_callReinforcements, medic_run};
X
void medic_attack(edict_t *self)
{
X	int		enemy_range;
X	float	r;
X
X	monster_done_dodge (self);
X
X	enemy_range = range(self, self->enemy);
X
X	// signal from checkattack to spawn
X	if (self->monsterinfo.aiflags & AI_BLOCKED)
X	{
X		self->monsterinfo.currentmove = &medic_move_callReinforcements;
X		self->monsterinfo.aiflags &= ~AI_BLOCKED;
X	}
X
X	r = random();
X	if (self->monsterinfo.aiflags & AI_MEDIC)
X	{
X		if ((self->mass > 400) && (r > 0.8) && (self->monsterinfo.monster_slots > 2))
X			self->monsterinfo.currentmove = &medic_move_callReinforcements;
X		else	
X			self->monsterinfo.currentmove = &medic_move_attackCable;
X	}
X	else
X	{
X		if (self->monsterinfo.attack_state == AS_BLIND)
X		{
X			self->monsterinfo.currentmove = &medic_move_callReinforcements;
X			return;
X		}
X		if ((self->mass > 400) && (r > 0.2) && (enemy_range != RANGE_MELEE) && (self->monsterinfo.monster_slots > 2))
X			self->monsterinfo.currentmove = &medic_move_callReinforcements;
X		else
X			self->monsterinfo.currentmove = &medic_move_attackBlaster;
X	}
}
X
qboolean medic_checkattack (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_MEDIC)
X	{
X		// if our target went away
X		if ((!self->enemy) || (!self->enemy->inuse))
X		{
//			if (g_showlogic && g_showlogic->value)
//				gi.dprintf ("aborting heal target due to gib\n");
X			abortHeal (self, true, false, false);
X			return false;
X		}
X
X		// if we ran out of time, give up
X		if (self->timestamp < level.time)
X		{
//			if (g_showlogic && g_showlogic->value)
//				gi.dprintf ("aborting heal target (%s) due to time\n", self->enemy->classname);
X			abortHeal (self, true, false, true);
X			self->timestamp = 0;
X			return false;
X		}
X	
X		if (realrange(self, self->enemy) < MEDIC_MAX_HEAL_DISTANCE+10)
X		{
X			medic_attack(self);
X			return true;
X		}
X		else
X		{
X			self->monsterinfo.attack_state = AS_STRAIGHT;
X			return false;
X		}
X	}
X
X	if (self->enemy->client && !visible (self, self->enemy) && (self->monsterinfo.monster_slots > 2))
X	{
X		self->monsterinfo.attack_state = AS_BLIND;
X		return true;
X	}
X
X	// give a LARGE bias to spawning things when we have room
X	// use AI_BLOCKED as a signal to attack to spawn
X	if ((random() < 0.8) && (self->monsterinfo.monster_slots > 5) && (realrange(self, self->enemy) > 150))
X	{
X		self->monsterinfo.aiflags |= AI_BLOCKED;
X		self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X	
X	// ROGUE
X	// since his idle animation looks kinda bad in combat, if we're not in easy mode, always attack
X	// when he's on a combat point
X	if (skill->value > 0)
X		if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		{
X			self->monsterinfo.attack_state = AS_MISSILE;
X			return true;
X		}
X
X	return M_CheckAttack (self);
}
/*
void medic_dodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
X
X	if (random() > 0.25)
X		return;
X
X	if (!self->enemy)
X		self->enemy = attacker;
X
X	self->monsterinfo.currentmove = &medic_move_duck;
X
//===========
//PMM - rogue rewrite of dodge code.
X	float	r;
X	float	height;
X	int		shooting = 0;
X
X	// this needs to be before the AI_MEDIC check, because
X	//   a) if AI_MEDIC is set, we should have an enemy anyway and
X	//   b) FoundTarget calls medic_run, which can set AI_MEDIC
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget (self);
X	}
X
//	don't dodge if you're healing
X	if (self->monsterinfo.aiflags & AI_MEDIC)
X		return;
X
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X		return;
X
X	r = random();
X	if (r > (0.25*((skill->value)+1)))
X		return;
X
X	if ((self->monsterinfo.currentmove == &medic_move_attackHyperBlaster) ||
X		(self->monsterinfo.currentmove == &medic_move_attackCable) ||
X		(self->monsterinfo.currentmove == &medic_move_attackBlaster))
X	{
X		shooting = 1;
X	}
X	if (self->monsterinfo.aiflags & AI_DODGING)
X	{
X		height = self->absmax[2];
X	}
X	else
X	{
X		height = self->absmax[2]-32-1;  // the -1 is because the absmax is s.origin + maxs + 1
X	}
X
X	// check to see if it makes sense to duck
X	if (tr->endpos[2] <= height)
X	{
X		vec3_t right, diff;
X		if (shooting)
X		{
X			self->monsterinfo.attack_state = AS_SLIDING;
X			return;
X		}
X		AngleVectors (self->s.angles, NULL, right, NULL);
X		VectorSubtract (tr->endpos, self->s.origin, diff);
X		if (DotProduct (right, diff) < 0)
X		{
X			self->monsterinfo.lefty = 1;
X		}
X		// if it doesn't sense to duck, try to strafe away
X		monster_done_dodge (self);
X		self->monsterinfo.currentmove = &medic_move_run;
X		self->monsterinfo.attack_state = AS_SLIDING;
X		return;
X	}
X
X	if (skill->value == 0)
X	{
X		self->monsterinfo.currentmove = &medic_move_duck;
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		self->monsterinfo.aiflags |= AI_DODGING;
X		return;
X	}
X
X	if (!shooting)
X	{
X		self->monsterinfo.currentmove = &medic_move_duck;
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X		self->monsterinfo.aiflags |= AI_DODGING;
X	}
X	return;
X
//PMM
//===========
X
}
*/
void MedicCommanderCache (void)
{
X	edict_t	*newEnt;
X	int	modelidx;
X	int i;
X
X	//FIXME - better way to do this?  this is quick and dirty
X	for (i=0; i < 7; i++)
X	{
X		newEnt = G_Spawn();
X
X		VectorCopy(vec3_origin, newEnt->s.origin);
X		VectorCopy(vec3_origin, newEnt->s.angles);
X		newEnt->classname = ED_NewString (reinforcements[i]);
X		
X		newEnt->monsterinfo.aiflags |= AI_DO_NOT_COUNT;
X
X		ED_CallSpawn(newEnt);
X		// FIXME - could copy mins/maxs into reinforcements from here
X		G_FreeEdict (newEnt);
X	}
X
X	modelidx = gi.modelindex("models/items/spawngro/tris.md2");
X	modelidx = gi.modelindex("models/items/spawngro2/tris.md2");
}
X
void medic_duck (edict_t *self, float eta)
{
//	don't dodge if you're healing
X	if (self->monsterinfo.aiflags & AI_MEDIC)
X		return;
X
X	if ((self->monsterinfo.currentmove == &medic_move_attackHyperBlaster) ||
X		(self->monsterinfo.currentmove == &medic_move_attackCable) ||
X		(self->monsterinfo.currentmove == &medic_move_attackBlaster) ||
X		(self->monsterinfo.currentmove == &medic_move_callReinforcements))
X	{
X		// he ignores skill
X		self->monsterinfo.aiflags &= ~AI_DUCKED;
X		return;
X	}
X
X	if (skill->value == 0)
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X	else
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X
X	// has to be done immediately otherwise he can get stuck
X	monster_duck_down(self);
X
X	self->monsterinfo.nextframe = FRAME_duck1;
X	self->monsterinfo.currentmove = &medic_move_duck;
X	return;
}
X
void medic_sidestep (edict_t *self)
{
X	if ((self->monsterinfo.currentmove == &medic_move_attackHyperBlaster) ||
X		(self->monsterinfo.currentmove == &medic_move_attackCable) ||
X		(self->monsterinfo.currentmove == &medic_move_attackBlaster) ||
X		(self->monsterinfo.currentmove == &medic_move_callReinforcements))
X	{
X		// if we're shooting, and not on easy, don't dodge
X		if (skill->value)
X		{
X			self->monsterinfo.aiflags &= ~AI_DODGING;
X			return;
X		}
X	}
X
X	if (self->monsterinfo.currentmove != &medic_move_run)
X		self->monsterinfo.currentmove = &medic_move_run;
}
X
//===========
//PGM
qboolean medic_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
//PGM
//===========
X
/*QUAKED monster_medic_commander (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
/*QUAKED monster_medic (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_medic (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/medic/tris.md2");
X	VectorSet (self->mins, -24, -24, -24);
X	VectorSet (self->maxs, 24, 24, 32);
X
//PMM
X	if (strcmp(self->classname, "monster_medic_commander") == 0)
X	{
X		self->health = 600;			//	fixme
X		self->gib_health = -130;
X		self->mass = 600;
X		self->yaw_speed = 40; // default is 20
X		MedicCommanderCache();
//		self->s.skinnum = 2;
X	}
X	else
X	{
//PMM
X		self->health = 300;
X		self->gib_health = -130;
X		self->mass = 400;
//		self->s.skinnum = 0;
X	}
X
X	self->pain = medic_pain;
X	self->die = medic_die;
X
X	self->monsterinfo.stand = medic_stand;
X	self->monsterinfo.walk = medic_walk;
X	self->monsterinfo.run = medic_run;
X	// pmm
X	self->monsterinfo.dodge = M_MonsterDodge;
X	self->monsterinfo.duck = medic_duck;
X	self->monsterinfo.unduck = monster_duck_up;
X	self->monsterinfo.sidestep = medic_sidestep;
//	self->monsterinfo.dodge = medic_dodge;
X	// pmm
X	self->monsterinfo.attack = medic_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = medic_sight;
X	self->monsterinfo.idle = medic_idle;
X	self->monsterinfo.search = medic_search;
X	self->monsterinfo.checkattack = medic_checkattack;
X	self->monsterinfo.blocked = medic_blocked;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &medic_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start (self);
X
X	//PMM
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X
X
X	if (self->mass > 400)
X	{
X		self->s.skinnum = 2;
X		if (skill->value == 0)
X			self->monsterinfo.monster_slots = 3;
X		else if (skill->value == 1)
X			self->monsterinfo.monster_slots = 4;
X		else if (skill->value == 2)
X			self->monsterinfo.monster_slots = 6;
X		else if (skill->value == 3)
X			self->monsterinfo.monster_slots = 6;
X		// commander sounds
X		commander_sound_idle1 = gi.soundindex ("medic_commander/medidle.wav");
X		commander_sound_pain1 = gi.soundindex ("medic_commander/medpain1.wav");
X		commander_sound_pain2 = gi.soundindex ("medic_commander/medpain2.wav");
X		commander_sound_die = gi.soundindex ("medic_commander/meddeth.wav");
X		commander_sound_sight = gi.soundindex ("medic_commander/medsght.wav");
X		commander_sound_search = gi.soundindex ("medic_commander/medsrch.wav");
X		commander_sound_hook_launch = gi.soundindex ("medic_commander/medatck2c.wav");
X		commander_sound_hook_hit = gi.soundindex ("medic_commander/medatck3a.wav");
X		commander_sound_hook_heal = gi.soundindex ("medic_commander/medatck4a.wav");
X		commander_sound_hook_retract = gi.soundindex ("medic_commander/medatck5a.wav");
X		commander_sound_spawn = gi.soundindex ("medic_commander/monsterspawn1.wav");
X		gi.soundindex ("tank/tnkatck3.wav");
X	}
X	else
X	{
X		sound_idle1 = gi.soundindex ("medic/idle.wav");
X		sound_pain1 = gi.soundindex ("medic/medpain1.wav");
X		sound_pain2 = gi.soundindex ("medic/medpain2.wav");
X		sound_die = gi.soundindex ("medic/meddeth1.wav");
X		sound_sight = gi.soundindex ("medic/medsght1.wav");
X		sound_search = gi.soundindex ("medic/medsrch1.wav");
X		sound_hook_launch = gi.soundindex ("medic/medatck2.wav");
X		sound_hook_hit = gi.soundindex ("medic/medatck3.wav");
X		sound_hook_heal = gi.soundindex ("medic/medatck4.wav");
X		sound_hook_retract = gi.soundindex ("medic/medatck5.wav");
X		gi.soundindex ("medic/medatck1.wav");
X
X		self->s.skinnum = 0;
X	}
X	//pmm
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_medic.c' &&
  chmod 0664 'm_medic.c' ||
  $echo 'restore of' 'm_medic.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_medic.c:' 'MD5 check failed'
46c00c53e48ed88403aef01e649248c6  m_medic.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_medic.c'`"
    test 46875 -eq "$shar_count" ||
    $echo 'm_medic.c:' 'original size' '46875,' 'current size' "$shar_count!"
  fi
fi
# ============= m_medic.h ==============
if test -f 'm_medic.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_medic.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_medic.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_medic.h' &&
// G:\quake2\baseq2\models/monsters/medic
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_walk1           	0
#define FRAME_walk2           	1
#define FRAME_walk3           	2
#define FRAME_walk4           	3
#define FRAME_walk5           	4
#define FRAME_walk6           	5
#define FRAME_walk7           	6
#define FRAME_walk8           	7
#define FRAME_walk9           	8
#define FRAME_walk10          	9
#define FRAME_walk11          	10
#define FRAME_walk12          	11
#define FRAME_wait1           	12
#define FRAME_wait2           	13
#define FRAME_wait3           	14
#define FRAME_wait4           	15
#define FRAME_wait5           	16
#define FRAME_wait6           	17
#define FRAME_wait7           	18
#define FRAME_wait8           	19
#define FRAME_wait9           	20
#define FRAME_wait10          	21
#define FRAME_wait11          	22
#define FRAME_wait12          	23
#define FRAME_wait13          	24
#define FRAME_wait14          	25
#define FRAME_wait15          	26
#define FRAME_wait16          	27
#define FRAME_wait17          	28
#define FRAME_wait18          	29
#define FRAME_wait19          	30
#define FRAME_wait20          	31
#define FRAME_wait21          	32
#define FRAME_wait22          	33
#define FRAME_wait23          	34
#define FRAME_wait24          	35
#define FRAME_wait25          	36
#define FRAME_wait26          	37
#define FRAME_wait27          	38
#define FRAME_wait28          	39
#define FRAME_wait29          	40
#define FRAME_wait30          	41
#define FRAME_wait31          	42
#define FRAME_wait32          	43
#define FRAME_wait33          	44
#define FRAME_wait34          	45
#define FRAME_wait35          	46
#define FRAME_wait36          	47
#define FRAME_wait37          	48
#define FRAME_wait38          	49
#define FRAME_wait39          	50
#define FRAME_wait40          	51
#define FRAME_wait41          	52
#define FRAME_wait42          	53
#define FRAME_wait43          	54
#define FRAME_wait44          	55
#define FRAME_wait45          	56
#define FRAME_wait46          	57
#define FRAME_wait47          	58
#define FRAME_wait48          	59
#define FRAME_wait49          	60
#define FRAME_wait50          	61
#define FRAME_wait51          	62
#define FRAME_wait52          	63
#define FRAME_wait53          	64
#define FRAME_wait54          	65
#define FRAME_wait55          	66
#define FRAME_wait56          	67
#define FRAME_wait57          	68
#define FRAME_wait58          	69
#define FRAME_wait59          	70
#define FRAME_wait60          	71
#define FRAME_wait61          	72
#define FRAME_wait62          	73
#define FRAME_wait63          	74
#define FRAME_wait64          	75
#define FRAME_wait65          	76
#define FRAME_wait66          	77
#define FRAME_wait67          	78
#define FRAME_wait68          	79
#define FRAME_wait69          	80
#define FRAME_wait70          	81
#define FRAME_wait71          	82
#define FRAME_wait72          	83
#define FRAME_wait73          	84
#define FRAME_wait74          	85
#define FRAME_wait75          	86
#define FRAME_wait76          	87
#define FRAME_wait77          	88
#define FRAME_wait78          	89
#define FRAME_wait79          	90
#define FRAME_wait80          	91
#define FRAME_wait81          	92
#define FRAME_wait82          	93
#define FRAME_wait83          	94
#define FRAME_wait84          	95
#define FRAME_wait85          	96
#define FRAME_wait86          	97
#define FRAME_wait87          	98
#define FRAME_wait88          	99
#define FRAME_wait89          	100
#define FRAME_wait90          	101
#define FRAME_run1            	102
#define FRAME_run2            	103
#define FRAME_run3            	104
#define FRAME_run4            	105
#define FRAME_run5            	106
#define FRAME_run6            	107
#define FRAME_paina1          	108
#define FRAME_paina2          	109
#define FRAME_paina3          	110
#define FRAME_paina4          	111
#define FRAME_paina5          	112
#define FRAME_paina6          	113
#define FRAME_paina7          	114
#define FRAME_paina8          	115
#define FRAME_painb1          	116
#define FRAME_painb2          	117
#define FRAME_painb3          	118
#define FRAME_painb4          	119
#define FRAME_painb5          	120
#define FRAME_painb6          	121
#define FRAME_painb7          	122
#define FRAME_painb8          	123
#define FRAME_painb9          	124
#define FRAME_painb10         	125
#define FRAME_painb11         	126
#define FRAME_painb12         	127
#define FRAME_painb13         	128
#define FRAME_painb14         	129
#define FRAME_painb15         	130
#define FRAME_duck1           	131
#define FRAME_duck2           	132
#define FRAME_duck3           	133
#define FRAME_duck4           	134
#define FRAME_duck5           	135
#define FRAME_duck6           	136
#define FRAME_duck7           	137
#define FRAME_duck8           	138
#define FRAME_duck9           	139
#define FRAME_duck10          	140
#define FRAME_duck11          	141
#define FRAME_duck12          	142
#define FRAME_duck13          	143
#define FRAME_duck14          	144
#define FRAME_duck15          	145
#define FRAME_duck16          	146
#define FRAME_death1          	147
#define FRAME_death2          	148
#define FRAME_death3          	149
#define FRAME_death4          	150
#define FRAME_death5          	151
#define FRAME_death6          	152
#define FRAME_death7          	153
#define FRAME_death8          	154
#define FRAME_death9          	155
#define FRAME_death10         	156
#define FRAME_death11         	157
#define FRAME_death12         	158
#define FRAME_death13         	159
#define FRAME_death14         	160
#define FRAME_death15         	161
#define FRAME_death16         	162
#define FRAME_death17         	163
#define FRAME_death18         	164
#define FRAME_death19         	165
#define FRAME_death20         	166
#define FRAME_death21         	167
#define FRAME_death22         	168
#define FRAME_death23         	169
#define FRAME_death24         	170
#define FRAME_death25         	171
#define FRAME_death26         	172
#define FRAME_death27         	173
#define FRAME_death28         	174
#define FRAME_death29         	175
#define FRAME_death30         	176
#define FRAME_attack1         	177
#define FRAME_attack2         	178
#define FRAME_attack3         	179
#define FRAME_attack4         	180
#define FRAME_attack5         	181
#define FRAME_attack6         	182
#define FRAME_attack7         	183
#define FRAME_attack8         	184
#define FRAME_attack9         	185
#define FRAME_attack10        	186
#define FRAME_attack11        	187
#define FRAME_attack12        	188
#define FRAME_attack13        	189
#define FRAME_attack14        	190
#define FRAME_attack15        	191
#define FRAME_attack16        	192
#define FRAME_attack17        	193
#define FRAME_attack18        	194
#define FRAME_attack19        	195
#define FRAME_attack20        	196
#define FRAME_attack21        	197
#define FRAME_attack22        	198
#define FRAME_attack23        	199
#define FRAME_attack24        	200
#define FRAME_attack25        	201
#define FRAME_attack26        	202
#define FRAME_attack27        	203
#define FRAME_attack28        	204
#define FRAME_attack29        	205
#define FRAME_attack30        	206
#define FRAME_attack31        	207
#define FRAME_attack32        	208
#define FRAME_attack33        	209
#define FRAME_attack34        	210
#define FRAME_attack35        	211
#define FRAME_attack36        	212
#define FRAME_attack37        	213
#define FRAME_attack38        	214
#define FRAME_attack39        	215
#define FRAME_attack40        	216
#define FRAME_attack41        	217
#define FRAME_attack42        	218
#define FRAME_attack43        	219
#define FRAME_attack44        	220
#define FRAME_attack45        	221
#define FRAME_attack46        	222
#define FRAME_attack47        	223
#define FRAME_attack48        	224
#define FRAME_attack49        	225
#define FRAME_attack50        	226
#define FRAME_attack51        	227
#define FRAME_attack52        	228
#define FRAME_attack53        	229
#define FRAME_attack54        	230
#define FRAME_attack55        	231
#define FRAME_attack56        	232
#define FRAME_attack57        	233
#define FRAME_attack58        	234
#define FRAME_attack59        	235
#define FRAME_attack60        	236
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_medic.h' &&
  chmod 0664 'm_medic.h' ||
  $echo 'restore of' 'm_medic.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_medic.h:' 'MD5 check failed'
81815ef5112133dc1bfc0a5eb2388e0e  m_medic.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_medic.h'`"
    test 8311 -eq "$shar_count" ||
    $echo 'm_medic.h:' 'original size' '8311,' 'current size' "$shar_count!"
  fi
fi
# ============= m_move.c ==============
if test -f 'm_move.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_move.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_move.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_move.c' &&
// m_move.c -- monster movement
X
#include "g_local.h"
X
#define	STEPSIZE	18
X
// this is used for communications out of sv_movestep to say what entity
// is blocking us
edict_t		*new_bad;			//pmm
X
/*
=============
M_CheckBottom
X
Returns false if any part of the bottom of the entity is off an edge that
is not a staircase.
X
=============
*/
int c_yes, c_no;
X
qboolean M_CheckBottom (edict_t *ent)
{
X	vec3_t	mins, maxs, start, stop;
X	trace_t	trace;
X	int		x, y;
X	float	mid, bottom;
X	
X	VectorAdd (ent->s.origin, ent->mins, mins);
X	VectorAdd (ent->s.origin, ent->maxs, maxs);
X
// if all of the points under the corners are solid world, don't bother
// with the tougher checks
// the corners must be within 16 of the midpoint
X
//PGM
#ifdef ROGUE_GRAVITY
X	// FIXME - this will only handle 0,0,1 and 0,0,-1 gravity vectors
X	start[2] = mins[2] - 1;
X	if(ent->gravityVector[2] > 0)
X		start[2] = maxs[2] + 1;
#else
X	start[2] = mins[2] - 1;
#endif
//PGM
X
X	for	(x=0 ; x<=1 ; x++)
X		for	(y=0 ; y<=1 ; y++)
X		{
X			start[0] = x ? maxs[0] : mins[0];
X			start[1] = y ? maxs[1] : mins[1];
X			if (gi.pointcontents (start) != CONTENTS_SOLID)
X				goto realcheck;
X		}
X
X	c_yes++;
X	return true;		// we got out easy
X
realcheck:
X	c_no++;
//
// check it for real...
//
X	start[2] = mins[2];
X	
// the midpoint must be within 16 of the bottom
X	start[0] = stop[0] = (mins[0] + maxs[0])*0.5;
X	start[1] = stop[1] = (mins[1] + maxs[1])*0.5;
X
//PGM
#ifdef ROGUE_GRAVITY
X	if(ent->gravityVector[2] < 0)
X	{
X		start[2] = mins[2];
X		stop[2] = start[2] - STEPSIZE - STEPSIZE;
X	}
X	else
X	{
X		start[2] = maxs[2];
X		stop[2] = start[2] + STEPSIZE + STEPSIZE;
X	}
#else
X	stop[2] = start[2] - 2*STEPSIZE;
#endif
//PGM
X
X	trace = gi.trace (start, vec3_origin, vec3_origin, stop, ent, MASK_MONSTERSOLID);
X
X	if (trace.fraction == 1.0)
X		return false;
X	mid = bottom = trace.endpos[2];
X	
// the corners must be within 16 of the midpoint	
X	for	(x=0 ; x<=1 ; x++)
X		for	(y=0 ; y<=1 ; y++)
X		{
X			start[0] = stop[0] = x ? maxs[0] : mins[0];
X			start[1] = stop[1] = y ? maxs[1] : mins[1];
X			
X			trace = gi.trace (start, vec3_origin, vec3_origin, stop, ent, MASK_MONSTERSOLID);
X
//PGM
#ifdef ROGUE_GRAVITY
X			// FIXME - this will only handle 0,0,1 and 0,0,-1 gravity vectors
X			if(ent->gravityVector[2] > 0)
X			{
X				if (trace.fraction != 1.0 && trace.endpos[2] < bottom)
X					bottom = trace.endpos[2];
X				if (trace.fraction == 1.0 || trace.endpos[2] - mid > STEPSIZE)
X					return false;
X			}
X			else
X			{
X				if (trace.fraction != 1.0 && trace.endpos[2] > bottom)
X					bottom = trace.endpos[2];
X				if (trace.fraction == 1.0 || mid - trace.endpos[2] > STEPSIZE)
X					return false;
X			}
#else
X			if (trace.fraction != 1.0 && trace.endpos[2] > bottom)
X				bottom = trace.endpos[2];
X			if (trace.fraction == 1.0 || mid - trace.endpos[2] > STEPSIZE)
X				return false;
#endif
//PGM
X		}
X
X	c_yes++;
X	return true;
}
X
//============
// ROGUE
qboolean IsBadAhead (edict_t *self, edict_t *bad, vec3_t move)
{
X	vec3_t	dir;
X	vec3_t	forward;
X	float	dp_bad, dp_move;
X	vec3_t	move_copy;
X
X	VectorCopy (move, move_copy);
X
X	VectorSubtract (bad->s.origin, self->s.origin, dir);
X	VectorNormalize (dir);
X	AngleVectors (self->s.angles, forward, NULL, NULL);
X	dp_bad = DotProduct (forward, dir);
X
X	VectorNormalize (move_copy);
X	AngleVectors (self->s.angles, forward, NULL, NULL);
X	dp_move = DotProduct (forward, move_copy);
X
X	if ((dp_bad < 0) && (dp_move < 0))
X		return true;
X	if ((dp_bad > 0) && (dp_move > 0))
X		return true;
X
X	return false;
/*
X	if(DotProduct(forward, dir) > 0)
X	{
//		gi.dprintf ("bad ahead...\n");
X		return true;
X	}
X
//	gi.dprintf ("bad behind...\n");
X	return false;
X	*/
}
// ROGUE
//============
X
/*
=============
SV_movestep
X
Called by monster program code.
The move will be adjusted for slopes and stairs, but if the move isn't
possible, no move is done, false is returned, and
pr_global_struct->trace_normal is set to the normal of the blocking wall
=============
*/
//FIXME since we need to test end position contents here, can we avoid doing
//it again later in catagorize position?
qboolean SV_movestep (edict_t *ent, vec3_t move, qboolean relink)
{
X	float		dz;
X	vec3_t		oldorg, neworg, end;
X	trace_t		trace;
X	int			i;
X	float		stepsize;
X	vec3_t		test;
X	int			contents;
X	edict_t		*current_bad;		// PGM
X	float		minheight;			// pmm
X
//======
//PGM
X
X	// PMM - who cares about bad areas if you're dead?
X	if (ent->health > 0)
X	{
X		current_bad = CheckForBadArea(ent);
X		if(current_bad)
X		{
X			ent->bad_area = current_bad;
X			 
X			if(ent->enemy && !strcmp(ent->enemy->classname, "tesla"))
X			{
X				// if the tesla is in front of us, back up...
X				if (IsBadAhead (ent, current_bad, move))
X					VectorScale(move, -1, move);
X			}
X		}
X		else if(ent->bad_area)
X		{
X			// if we're no longer in a bad area, get back to business.
X			ent->bad_area = NULL;
X			if(ent->oldenemy)// && ent->bad_area->owner == ent->enemy)
X			{
X	//			gi.dprintf("resuming being pissed at %s\n", ent->oldenemy->classname);
X				ent->enemy = ent->oldenemy;
X				ent->goalentity = ent->oldenemy;
X				FoundTarget(ent);
X	// FIXME - remove this when ready!!!
//	if (ent->lastMoveTime == level.time)
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Duplicate move detected for %s, please tell programmers!\n", ent->classname);
//	ent->lastMoveTime = level.time;
X	// FIXME
X
X				return true;
X			}
X		}
X	}
//PGM
//======
X
// try the move	
X	VectorCopy (ent->s.origin, oldorg);
X	VectorAdd (ent->s.origin, move, neworg);
X
// flying monsters don't step up
X	if ( ent->flags & (FL_SWIM | FL_FLY) )
X	{
X	// try one move with vertical motion, then one without
X		for (i=0 ; i<2 ; i++)
X		{
X			VectorAdd (ent->s.origin, move, neworg);
X			if (i == 0 && ent->enemy)
X			{
X				if (!ent->goalentity)
X					ent->goalentity = ent->enemy;
X				dz = ent->s.origin[2] - ent->goalentity->s.origin[2];
X				if (ent->goalentity->client)
X				{
X					// we want the carrier to stay a certain distance off the ground, to help prevent him
X					// from shooting his fliers, who spawn in below him
X					//
X					if (!strcmp(ent->classname, "monster_carrier"))
X						minheight = 104;
X					else
X						minheight = 40;
//					if (dz > 40)
X					if (dz > minheight)
//	pmm		
X						neworg[2] -= 8;
X					if (!((ent->flags & FL_SWIM) && (ent->waterlevel < 2)))
X						if (dz < (minheight - 10))
X							neworg[2] += 8;
X				}
X				else
X				{
X					if (dz > 8)
X						neworg[2] -= 8;
X					else if (dz > 0)
X						neworg[2] -= dz;
X					else if (dz < -8)
X						neworg[2] += 8;
X					else
X						neworg[2] += dz;
X				}
X			}
X
X			trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, neworg, ent, MASK_MONSTERSOLID);
X	
X			// fly monsters don't enter water voluntarily
X			if (ent->flags & FL_FLY)
X			{
X				if (!ent->waterlevel)
X				{
X					test[0] = trace.endpos[0];
X					test[1] = trace.endpos[1];
X					test[2] = trace.endpos[2] + ent->mins[2] + 1;
X					contents = gi.pointcontents(test);
X					if (contents & MASK_WATER)
X						return false;
X				}
X			}
X
X			// swim monsters don't exit water voluntarily
X			if (ent->flags & FL_SWIM)
X			{
X				if (ent->waterlevel < 2)
X				{
X					test[0] = trace.endpos[0];
X					test[1] = trace.endpos[1];
X					test[2] = trace.endpos[2] + ent->mins[2] + 1;
X					contents = gi.pointcontents(test);
X					if (!(contents & MASK_WATER))
X						return false;
X				}
X			}
X
//			if (trace.fraction == 1)
X
X			// PMM - changed above to this
X			if ((trace.fraction == 1) && (!trace.allsolid) && (!trace.startsolid))
X			{
X				VectorCopy (trace.endpos, ent->s.origin);
//=====
//PGM				
X				if(!current_bad && CheckForBadArea(ent))
X				{
//						gi.dprintf("Oooh! Bad Area!\n");
X					VectorCopy (oldorg, ent->s.origin);
X				}
X				else
X				{
X					if (relink)
X					{
X						gi.linkentity (ent);
X						G_TouchTriggers (ent);
X					}
X	// FIXME - remove this when ready!!!
//	if (ent->lastMoveTime == level.time)
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Duplicate move detected for %s, please tell programmers!\n", ent->classname);
//	ent->lastMoveTime = level.time;
X	// FIXME
X
X					return true;
X				}
//PGM
//=====
X			}
X			
X			if (!ent->enemy)
X				break;
X		}
X		
X		return false;
X	}
X
// push down from a step height above the wished position
X	if (!(ent->monsterinfo.aiflags & AI_NOSTEP))
X		stepsize = STEPSIZE;
X	else
X		stepsize = 1;
X
//PGM
#ifdef ROGUE_GRAVITY
X	// trace from 1 stepsize gravityUp to 2 stepsize gravityDown.
X	VectorMA(neworg, -1 * stepsize, ent->gravityVector, neworg);
X	VectorMA(neworg, 2 * stepsize, ent->gravityVector, end);
#else
X	neworg[2] += stepsize;
X	VectorCopy (neworg, end);
X	end[2] -= stepsize*2;
#endif
//PGM
X
X	trace = gi.trace (neworg, ent->mins, ent->maxs, end, ent, MASK_MONSTERSOLID);
X
X	if (trace.allsolid)
X		return false;
X
X	if (trace.startsolid)
X	{
X		neworg[2] -= stepsize;
X		trace = gi.trace (neworg, ent->mins, ent->maxs, end, ent, MASK_MONSTERSOLID);
X		if (trace.allsolid || trace.startsolid)
X			return false;
X	}
X
X
X	// don't go in to water
X	if (ent->waterlevel == 0)
X	{
//PGM
#ifdef ROGUE_GRAVITY
X		test[0] = trace.endpos[0];
X		test[1] = trace.endpos[1];
X		if(ent->gravityVector[2] > 0)
X			test[2] = trace.endpos[2] + ent->maxs[2] - 1;	
X		else
X			test[2] = trace.endpos[2] + ent->mins[2] + 1;
#else
X		test[0] = trace.endpos[0];
X		test[1] = trace.endpos[1];
X		test[2] = trace.endpos[2] + ent->mins[2] + 1;	
#endif
//PGM
X
X		contents = gi.pointcontents(test);
X
X		if (contents & MASK_WATER)
X			return false;
X	}
X
X	if (trace.fraction == 1)
X	{
X	// if monster had the ground pulled out, go ahead and fall
X		if ( ent->flags & FL_PARTIALGROUND )
X		{
X			VectorAdd (ent->s.origin, move, ent->s.origin);
X			if (relink)
X			{
X				gi.linkentity (ent);
X				G_TouchTriggers (ent);
X			}
X			ent->groundentity = NULL;
X	// FIXME - remove this when ready!!!
//	if (ent->lastMoveTime == level.time)
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Duplicate move detected for %s, please tell programmers!\n", ent->classname);
//	ent->lastMoveTime = level.time;
X	// FIXME
X
X			return true;
X		}
X	
X		return false;		// walked off an edge
X	}
X
// check point traces down for dangling corners
X	VectorCopy (trace.endpos, ent->s.origin);
X
//PGM
X	// PMM - don't bother with bad areas if we're dead
X	if (ent->health > 0)
X	{
X		// use AI_BLOCKED to tell the calling layer that we're now mad at a tesla
X		new_bad = CheckForBadArea(ent);
X		if(!current_bad && new_bad)
X		{
X			if (new_bad->owner)
X			{
//				if ((g_showlogic) && (g_showlogic->value))
//					gi.dprintf("Blocked -");
X				if (!strcmp(new_bad->owner->classname, "tesla"))
X				{
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("it's a tesla -");
X					if ((!(ent->enemy)) || (!(ent->enemy->inuse)))
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("I don't have a valid enemy, attacking tesla!\n");
X						TargetTesla (ent, new_bad->owner);
X						ent->monsterinfo.aiflags |= AI_BLOCKED;
X					}
X					else if (!strcmp(ent->enemy->classname, "telsa"))
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("but we're already mad at a tesla\n");
X					}
X					else if ((ent->enemy) && (ent->enemy->client))
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("we have a player enemy -");
X						if (visible(ent, ent->enemy))
X						{
//							if ((g_showlogic) && (g_showlogic->value))
//								gi.dprintf ("we can see him -");
X						}
X						else
X						{
//							if ((g_showlogic) && (g_showlogic->value))
//								gi.dprintf ("can't see him, kill the tesla! -");
X							TargetTesla (ent, new_bad->owner);
X							ent->monsterinfo.aiflags |= AI_BLOCKED;
X						}
X					}
X					else
X					{
//						if ((g_showlogic) && (g_showlogic->value))
//							gi.dprintf ("the enemy isn't a player, killing tesla -");
X						TargetTesla (ent, new_bad->owner);
X						ent->monsterinfo.aiflags |= AI_BLOCKED;
X					}
X				}
//				else if ((g_showlogic) && (g_showlogic->value))
//				{
//					gi.dprintf(" by non-tesla bad area!");
//				}
X			}
//			gi.dprintf ("\n");
X
X			VectorCopy (oldorg, ent->s.origin);
X			return false;
X		}
X	}
//PGM
X
X	if (!M_CheckBottom (ent))
X	{
X		if ( ent->flags & FL_PARTIALGROUND )
X		{	// entity had floor mostly pulled out from underneath it
X			// and is trying to correct
X			if (relink)
X			{
X				gi.linkentity (ent);
X				G_TouchTriggers (ent);
X			}
X	// FIXME - remove this when ready!!!
//	if (ent->lastMoveTime == level.time)
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Duplicate move detected for %s, please tell programmers!\n", ent->classname);
//	ent->lastMoveTime = level.time;
X	// FIXME
X
X			return true;
X		}
X		VectorCopy (oldorg, ent->s.origin);
X		return false;
X	}
X
X	if ( ent->flags & FL_PARTIALGROUND )
X	{
X		ent->flags &= ~FL_PARTIALGROUND;
X	}
X	ent->groundentity = trace.ent;
X	ent->groundentity_linkcount = trace.ent->linkcount;
X
// the move is ok
X	if (relink)
X	{
X		gi.linkentity (ent);
X		G_TouchTriggers (ent);
X	}
X	// FIXME - remove this when ready!!!
//	if (ent->lastMoveTime == level.time)
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("Duplicate move detected for %s, please tell programmers!\n", ent->classname);
//	ent->lastMoveTime = level.time;
X	// FIXME
X
X	return true;
}
X
X
//============================================================================
X
/*
===============
M_ChangeYaw
X
===============
*/
void M_ChangeYaw (edict_t *ent)
{
X	float	ideal;
X	float	current;
X	float	move;
X	float	speed;
X	
X	current = anglemod(ent->s.angles[YAW]);
X	ideal = ent->ideal_yaw;
X
X	if (current == ideal)
X		return;
X
X	move = ideal - current;
X	speed = ent->yaw_speed;
X	if (ideal > current)
X	{
X		if (move >= 180)
X			move = move - 360;
X	}
X	else
X	{
X		if (move <= -180)
X			move = move + 360;
X	}
X	if (move > 0)
X	{
X		if (move > speed)
X			move = speed;
X	}
X	else
X	{
X		if (move < -speed)
X			move = -speed;
X	}
X	
X	ent->s.angles[YAW] = anglemod (current + move);
}
X
X
/*
======================
SV_StepDirection
X
Turns to the movement direction, and walks the current distance if
facing it.
X
======================
*/
qboolean SV_StepDirection (edict_t *ent, float yaw, float dist)
{
X	vec3_t		move, oldorigin;
X	float		delta;
X	
X	if(!ent->inuse)	return true;		// PGM g_touchtrigger free problem
X
X	ent->ideal_yaw = yaw;
X	M_ChangeYaw (ent);
X	
X	yaw = yaw*M_PI*2 / 360;
X	move[0] = cos(yaw)*dist;
X	move[1] = sin(yaw)*dist;
X	move[2] = 0;
X
X	VectorCopy (ent->s.origin, oldorigin);
X	if (SV_movestep (ent, move, false))
X	{
X		ent->monsterinfo.aiflags &= ~AI_BLOCKED;
X		if(!ent->inuse)	return true;		// PGM g_touchtrigger free problem
X
X		delta = ent->s.angles[YAW] - ent->ideal_yaw;
X		if (strncmp(ent->classname, "monster_widow", 13))
X		{
X			if (delta > 45 && delta < 315)
X			{		// not turned far enough, so don't take the step
X				VectorCopy (oldorigin, ent->s.origin);
X			}
X		}
X		gi.linkentity (ent);
X		G_TouchTriggers (ent);
X		return true;
X	}
X	gi.linkentity (ent);
X	G_TouchTriggers (ent);
X	return false;
}
X
/*
======================
SV_FixCheckBottom
X
======================
*/
void SV_FixCheckBottom (edict_t *ent)
{
X	ent->flags |= FL_PARTIALGROUND;
}
X
X
X
/*
================
SV_NewChaseDir
X
================
*/
#define	DI_NODIR	-1
void SV_NewChaseDir (edict_t *actor, edict_t *enemy, float dist)
{
X	float	deltax,deltay;
X	float	d[3];
X	float	tdir, olddir, turnaround;
X
X	//FIXME: how did we get here with no enemy
X	if (!enemy)
X		return;
X
X	olddir = anglemod( (int)(actor->ideal_yaw/45)*45 );
X	turnaround = anglemod(olddir - 180);
X
X	deltax = enemy->s.origin[0] - actor->s.origin[0];
X	deltay = enemy->s.origin[1] - actor->s.origin[1];
X	if (deltax>10)
X		d[1]= 0;
X	else if (deltax<-10)
X		d[1]= 180;
X	else
X		d[1]= DI_NODIR;
X	if (deltay<-10)
X		d[2]= 270;
X	else if (deltay>10)
X		d[2]= 90;
X	else
X		d[2]= DI_NODIR;
X
// try direct route
X	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
X	{
X		if (d[1] == 0)
X			tdir = d[2] == 90 ? 45 : 315;
X		else
X			tdir = d[2] == 90 ? 135 : 215;
X			
X		if (tdir != turnaround && SV_StepDirection(actor, tdir, dist))
X			return;
X	}
X
// try other directions
X	if ( ((rand()&3) & 1) ||  abs(deltay)>abs(deltax))
X	{
X		tdir=d[1];
X		d[1]=d[2];
X		d[2]=tdir;
X	}
X
X	if (d[1]!=DI_NODIR && d[1]!=turnaround 
X	&& SV_StepDirection(actor, d[1], dist))
X			return;
X
X	if (d[2]!=DI_NODIR && d[2]!=turnaround
X	&& SV_StepDirection(actor, d[2], dist))
X			return;
X
//ROGUE
X	if(actor->monsterinfo.blocked)
X	{
X		if ((actor->inuse) && (actor->health > 0))
X		{
X			if((actor->monsterinfo.blocked)(actor, dist))
X				return;
X		}
X	}
//ROGUE
X
/* there is no direct path to the player, so pick another direction */
X
X	if (olddir!=DI_NODIR && SV_StepDirection(actor, olddir, dist))
X			return;
X
X	if (rand()&1) 	/*randomly determine direction of search*/
X	{
X		for (tdir=0 ; tdir<=315 ; tdir += 45)
X			if (tdir!=turnaround && SV_StepDirection(actor, tdir, dist) )
X					return;
X	}
X	else
X	{
X		for (tdir=315 ; tdir >=0 ; tdir -= 45)
X			if (tdir!=turnaround && SV_StepDirection(actor, tdir, dist) )
X					return;
X	}
X
X	if (turnaround != DI_NODIR && SV_StepDirection(actor, turnaround, dist) )
X			return;
X
X	actor->ideal_yaw = olddir;		// can't move
X
// if a bridge was pulled out from underneath a monster, it may not have
// a valid standing position at all
X
X	if (!M_CheckBottom (actor))
X		SV_FixCheckBottom (actor);
}
X
/*
======================
SV_CloseEnough
X
======================
*/
qboolean SV_CloseEnough (edict_t *ent, edict_t *goal, float dist)
{
X	int		i;
X	
X	for (i=0 ; i<3 ; i++)
X	{
X		if (goal->absmin[i] > ent->absmax[i] + dist)
X			return false;
X		if (goal->absmax[i] < ent->absmin[i] - dist)
X			return false;
X	}
X	return true;
}
X
/*
======================
M_MoveToGoal
======================
*/
void M_MoveToGoal (edict_t *ent, float dist)
{
X	edict_t		*goal;
X	
X	goal = ent->goalentity;
X
X	if (!ent->groundentity && !(ent->flags & (FL_FLY|FL_SWIM)))
X		return;
X
// if the next step hits the enemy, return immediately
X	if (ent->enemy &&  SV_CloseEnough (ent, ent->enemy, dist) )
X		return;
X
// bump around...
//	if ( (rand()&3)==1 || !SV_StepDirection (ent, ent->ideal_yaw, dist))
// PMM - charging monsters (AI_CHARGING) don't deflect unless they have to
X	if ( (((rand()&3)==1) && !(ent->monsterinfo.aiflags & AI_CHARGING)) || !SV_StepDirection (ent, ent->ideal_yaw, dist))
X	{
X		if (ent->monsterinfo.aiflags & AI_BLOCKED)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("tesla attack detected, not changing direction!\n");
X			ent->monsterinfo.aiflags &= ~AI_BLOCKED;
X			return;
X		}
X		if (ent->inuse)
X			SV_NewChaseDir (ent, goal, dist);
X	}
}
X
X
/*
===============
M_walkmove
===============
*/
qboolean M_walkmove (edict_t *ent, float yaw, float dist)
{
X	vec3_t	move;
X	// PMM
X	qboolean	retval;
X	
X	if (!ent->groundentity && !(ent->flags & (FL_FLY|FL_SWIM)))
X		return false;
X
X	yaw = yaw*M_PI*2 / 360;
X	
X	move[0] = cos(yaw)*dist;
X	move[1] = sin(yaw)*dist;
X	move[2] = 0;
X
X	// PMM
X	retval = SV_movestep(ent, move, true);
X	ent->monsterinfo.aiflags &= ~AI_BLOCKED;
X	return retval;
X	// pmm
X	//return SV_movestep(ent, move, true);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_move.c' &&
  chmod 0664 'm_move.c' ||
  $echo 'restore of' 'm_move.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_move.c:' 'MD5 check failed'
b1c83e55efe7a560c9331966d09a87a8  m_move.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_move.c'`"
    test 18787 -eq "$shar_count" ||
    $echo 'm_move.c:' 'original size' '18787,' 'current size' "$shar_count!"
  fi
fi
# ============= m_move2.c ==============
if test -f 'm_move2.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_move2.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_move2.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_move2.c' &&
// m_move.c -- monster movement
X
#include "g_local.h"
X
#define	STEPSIZE	18
X
// this is used for communications out of sv_movestep to say what entity
// is blocking us
edict_t		*new_bad;			//pmm
X
/*
=============
M_CheckBottom
X
Returns false if any part of the bottom of the entity is off an edge that
is not a staircase.
X
=============
*/
int c_yes, c_no;
X
qboolean M_CheckBottom (edict_t *ent)
{
X	vec3_t	mins, maxs, start, stop;
X	trace_t	trace;
X	int		x, y;
X	float	mid, bottom;
X	
X	VectorAdd (ent->s.origin, ent->mins, mins);
X	VectorAdd (ent->s.origin, ent->maxs, maxs);
X
// if all of the points under the corners are solid world, don't bother
// with the tougher checks
// the corners must be within 16 of the midpoint
X
//PGM
#ifdef ROGUE_GRAVITY
X	// FIXME - this will only handle 0,0,1 and 0,0,-1 gravity vectors
X	start[2] = mins[2] - 1;
X	if(ent->gravityVector[2] > 0)
X		start[2] = maxs[2] + 1;
#else
X	start[2] = mins[2] - 1;
#endif
//PGM
X
X	for	(x=0 ; x<=1 ; x++)
X		for	(y=0 ; y<=1 ; y++)
X		{
X			start[0] = x ? maxs[0] : mins[0];
X			start[1] = y ? maxs[1] : mins[1];
X			if (gi.pointcontents (start) != CONTENTS_SOLID)
X				goto realcheck;
X		}
X
X	c_yes++;
X	return true;		// we got out easy
X
realcheck:
X	c_no++;
//
// check it for real...
//
X	start[2] = mins[2];
X	
// the midpoint must be within 16 of the bottom
X	start[0] = stop[0] = (mins[0] + maxs[0])*0.5;
X	start[1] = stop[1] = (mins[1] + maxs[1])*0.5;
X
//PGM
#ifdef ROGUE_GRAVITY
X	if(ent->gravityVector[2] < 0)
X	{
X		start[2] = mins[2];
X		stop[2] = start[2] - STEPSIZE - STEPSIZE;
X	}
X	else
X	{
X		start[2] = maxs[2];
X		stop[2] = start[2] + STEPSIZE + STEPSIZE;
X	}
#else
X	stop[2] = start[2] - 2*STEPSIZE;
#endif
//PGM
X
X	trace = gi.trace (start, vec3_origin, vec3_origin, stop, ent, MASK_MONSTERSOLID);
X
X	if (trace.fraction == 1.0)
X		return false;
X	mid = bottom = trace.endpos[2];
X	
// the corners must be within 16 of the midpoint	
X	for	(x=0 ; x<=1 ; x++)
X		for	(y=0 ; y<=1 ; y++)
X		{
X			start[0] = stop[0] = x ? maxs[0] : mins[0];
X			start[1] = stop[1] = y ? maxs[1] : mins[1];
X			
X			trace = gi.trace (start, vec3_origin, vec3_origin, stop, ent, MASK_MONSTERSOLID);
X
//PGM
#ifdef ROGUE_GRAVITY
X			// FIXME - this will only handle 0,0,1 and 0,0,-1 gravity vectors
X			if(ent->gravityVector[2] > 0)
X			{
X				if (trace.fraction != 1.0 && trace.endpos[2] < bottom)
X					bottom = trace.endpos[2];
X				if (trace.fraction == 1.0 || trace.endpos[2] - mid > STEPSIZE)
X					return false;
X			}
X			else
X			{
X				if (trace.fraction != 1.0 && trace.endpos[2] > bottom)
X					bottom = trace.endpos[2];
X				if (trace.fraction == 1.0 || mid - trace.endpos[2] > STEPSIZE)
X					return false;
X			}
#else
X			if (trace.fraction != 1.0 && trace.endpos[2] > bottom)
X				bottom = trace.endpos[2];
X			if (trace.fraction == 1.0 || mid - trace.endpos[2] > STEPSIZE)
X				return false;
#endif
//PGM
X		}
X
X	c_yes++;
X	return true;
}
X
X
/*
=============
SV_movestep
X
Called by monster program code.
The move will be adjusted for slopes and stairs, but if the move isn't
possible, no move is done, false is returned, and
pr_global_struct->trace_normal is set to the normal of the blocking wall
=============
*/
//FIXME since we need to test end position contents here, can we avoid doing
//it again later in catagorize position?
qboolean SV_movestep (edict_t *ent, vec3_t move, qboolean relink)
{
X	float		dz;
X	vec3_t		oldorg, neworg, end;
X	trace_t		trace;
X	int			i;
X	float		stepsize;
X	vec3_t		test;
X	int			contents;
X	edict_t		*current_bad;		// PGM
X	float		minheight;			// pmm
X
//======
//PGM
X	current_bad = CheckForBadArea(ent);
X	if(current_bad)
X	{
//		gi.dprintf("in bad area\n");
X		ent->bad_area = current_bad;
X		 
X		if(ent->enemy && !strcmp(ent->enemy->classname, "tesla"))
X		{
//			gi.dprintf("%s  -->>  ", vtos(move));
X			VectorScale(move, -1, move);
//			gi.dprintf("%s\n", vtos(move));
X		}
X	}
X	else if(ent->bad_area)
X	{
X		// if we're no longer in a bad area, get back to business.
X		ent->bad_area = NULL;
X		if(ent->oldenemy)// && ent->bad_area->owner == ent->enemy)
X		{
//			gi.dprintf("resuming being pissed at %s\n", ent->oldenemy->classname);
X			ent->enemy = ent->oldenemy;
X			ent->goalentity = ent->oldenemy;
X			FoundTarget(ent);
X			return true;
X		}
X	}
//PGM
//======
X
// try the move	
X	VectorCopy (ent->s.origin, oldorg);
X	VectorAdd (ent->s.origin, move, neworg);
X
// flying monsters don't step up
X	if ( ent->flags & (FL_SWIM | FL_FLY) )
X	{
X	// try one move with vertical motion, then one without
X		for (i=0 ; i<2 ; i++)
X		{
X			VectorAdd (ent->s.origin, move, neworg);
X			if (i == 0 && ent->enemy)
X			{
X				if (!ent->goalentity)
X					ent->goalentity = ent->enemy;
X				dz = ent->s.origin[2] - ent->goalentity->s.origin[2];
X				if (ent->goalentity->client)
X				{
X					// we want the carrier to stay a certain distance off the ground, to help prevent him
X					// from shooting his fliers, who spawn in below him
X					//
X					if (!strcmp(ent->classname, "monster_carrier"))
X						minheight = 104;
X					else
X						minheight = 40;
//					if (dz > 40)
X					if (dz > minheight)
//	pmm		
X						neworg[2] -= 8;
X					if (!((ent->flags & FL_SWIM) && (ent->waterlevel < 2)))
X						if (dz < (minheight - 10))
X							neworg[2] += 8;
X				}
X				else
X				{
X					if (dz > 8)
X						neworg[2] -= 8;
X					else if (dz > 0)
X						neworg[2] -= dz;
X					else if (dz < -8)
X						neworg[2] += 8;
X					else
X						neworg[2] += dz;
X				}
X			}
X
X			trace = gi.trace (ent->s.origin, ent->mins, ent->maxs, neworg, ent, MASK_MONSTERSOLID);
X	
X			// fly monsters don't enter water voluntarily
X			if (ent->flags & FL_FLY)
X			{
X				if (!ent->waterlevel)
X				{
X					test[0] = trace.endpos[0];
X					test[1] = trace.endpos[1];
X					test[2] = trace.endpos[2] + ent->mins[2] + 1;
X					contents = gi.pointcontents(test);
X					if (contents & MASK_WATER)
X						return false;
X				}
X			}
X
X			// swim monsters don't exit water voluntarily
X			if (ent->flags & FL_SWIM)
X			{
X				if (ent->waterlevel < 2)
X				{
X					test[0] = trace.endpos[0];
X					test[1] = trace.endpos[1];
X					test[2] = trace.endpos[2] + ent->mins[2] + 1;
X					contents = gi.pointcontents(test);
X					if (!(contents & MASK_WATER))
X						return false;
X				}
X			}
X
//			if (trace.fraction == 1)
X
X			// PMM - changed above to this
X			if ((trace.fraction == 1) && (!trace.allsolid) && (!trace.startsolid))
X			{
X				VectorCopy (trace.endpos, ent->s.origin);
//=====
//PGM				
X				if(!current_bad && CheckForBadArea(ent))
X				{
//						gi.dprintf("Oooh! Bad Area!\n");
X					VectorCopy (oldorg, ent->s.origin);
X				}
X				else
X				{
X					if (relink)
X					{
X						gi.linkentity (ent);
X						G_TouchTriggers (ent);
X					}
X					return true;
X				}
//PGM
//=====
X			}
X			
X			if (!ent->enemy)
X				break;
X		}
X		
X		return false;
X	}
X
// push down from a step height above the wished position
X	if (!(ent->monsterinfo.aiflags & AI_NOSTEP))
X		stepsize = STEPSIZE;
X	else
X		stepsize = 1;
X
//PGM
#ifdef ROGUE_GRAVITY
X	// trace from 1 stepsize gravityUp to 2 stepsize gravityDown.
X	VectorMA(neworg, -1 * stepsize, ent->gravityVector, neworg);
X	VectorMA(neworg, 2 * stepsize, ent->gravityVector, end);
#else
X	neworg[2] += stepsize;
X	VectorCopy (neworg, end);
X	end[2] -= stepsize*2;
#endif
//PGM
X
X	trace = gi.trace (neworg, ent->mins, ent->maxs, end, ent, MASK_MONSTERSOLID);
X
X	if (trace.allsolid)
X		return false;
X
X	if (trace.startsolid)
X	{
X		neworg[2] -= stepsize;
X		trace = gi.trace (neworg, ent->mins, ent->maxs, end, ent, MASK_MONSTERSOLID);
X		if (trace.allsolid || trace.startsolid)
X			return false;
X	}
X
X
X	// don't go in to water
X	if (ent->waterlevel == 0)
X	{
//PGM
#ifdef ROGUE_GRAVITY
X		test[0] = trace.endpos[0];
X		test[1] = trace.endpos[1];
X		if(ent->gravityVector[2] > 0)
X			test[2] = trace.endpos[2] + ent->maxs[2] - 1;	
X		else
X			test[2] = trace.endpos[2] + ent->mins[2] + 1;
#else
X		test[0] = trace.endpos[0];
X		test[1] = trace.endpos[1];
X		test[2] = trace.endpos[2] + ent->mins[2] + 1;	
#endif
//PGM
X
X		contents = gi.pointcontents(test);
X
X		if (contents & MASK_WATER)
X			return false;
X	}
X
X	if (trace.fraction == 1)
X	{
X	// if monster had the ground pulled out, go ahead and fall
X		if ( ent->flags & FL_PARTIALGROUND )
X		{
X			VectorAdd (ent->s.origin, move, ent->s.origin);
X			if (relink)
X			{
X				gi.linkentity (ent);
X				G_TouchTriggers (ent);
X			}
X			ent->groundentity = NULL;
X			return true;
X		}
X	
X		return false;		// walked off an edge
X	}
X
// check point traces down for dangling corners
X	VectorCopy (trace.endpos, ent->s.origin);
X
//PGM
X	new_bad = CheckForBadArea(ent);
X	if(!current_bad && new_bad)
X	{
X		if (new_bad->owner)
X		{
X			if ((g_showlogic) && (g_showlogic->value))
X				gi.dprintf("Blocked -");
X			if (!strcmp(new_bad->owner->classname, "tesla"))
X			{
X				if ((g_showlogic) && (g_showlogic->value))
X					gi.dprintf ("it's a tesla -");
X				if ((!(ent->enemy)) || (!(ent->enemy->inuse)))
X				{
X					if ((g_showlogic) && (g_showlogic->value))
X						gi.dprintf ("I don't have a valid enemy!\n");
X				}
X				else if (!strcmp(ent->enemy->classname, "telsa"))
X				{
X					if ((g_showlogic) && (g_showlogic->value))
X						gi.dprintf ("but we're already mad at a tesla\n");
X				}
X				else if ((ent->enemy) && (ent->enemy->client))
X				{
X					if ((g_showlogic) && (g_showlogic->value))
X						gi.dprintf ("we have a player enemy -");
X					if (visible(ent, ent->enemy))
X					{
X						if ((g_showlogic) && (g_showlogic->value))
X							gi.dprintf ("we can see him -");
X					}
X					else
X					{
X						if ((g_showlogic) && (g_showlogic->value))
X							gi.dprintf ("can't see him, kill the tesla! -");
X					}
X				}
X				else
X				{
X					if ((g_showlogic) && (g_showlogic->value))
X						gi.dprintf ("the enemy isn't a player -");
X				}
X			}
X		}
X		gi.dprintf ("\n");
X
X
X		VectorCopy (oldorg, ent->s.origin);
X		return false;
X	}
//PGM
X
X	if (!M_CheckBottom (ent))
X	{
X		if ( ent->flags & FL_PARTIALGROUND )
X		{	// entity had floor mostly pulled out from underneath it
X			// and is trying to correct
X			if (relink)
X			{
X				gi.linkentity (ent);
X				G_TouchTriggers (ent);
X			}
X			return true;
X		}
X		VectorCopy (oldorg, ent->s.origin);
X		return false;
X	}
X
X	if ( ent->flags & FL_PARTIALGROUND )
X	{
X		ent->flags &= ~FL_PARTIALGROUND;
X	}
X	ent->groundentity = trace.ent;
X	ent->groundentity_linkcount = trace.ent->linkcount;
X
// the move is ok
X	if (relink)
X	{
X		gi.linkentity (ent);
X		G_TouchTriggers (ent);
X	}
X	return true;
}
X
X
//============================================================================
X
/*
===============
M_ChangeYaw
X
===============
*/
void M_ChangeYaw (edict_t *ent)
{
X	float	ideal;
X	float	current;
X	float	move;
X	float	speed;
X	
X	current = anglemod(ent->s.angles[YAW]);
X	ideal = ent->ideal_yaw;
X
X	if (current == ideal)
X		return;
X
X	move = ideal - current;
X	speed = ent->yaw_speed;
X	if (ideal > current)
X	{
X		if (move >= 180)
X			move = move - 360;
X	}
X	else
X	{
X		if (move <= -180)
X			move = move + 360;
X	}
X	if (move > 0)
X	{
X		if (move > speed)
X			move = speed;
X	}
X	else
X	{
X		if (move < -speed)
X			move = -speed;
X	}
X	
X	ent->s.angles[YAW] = anglemod (current + move);
}
X
X
/*
======================
SV_StepDirection
X
Turns to the movement direction, and walks the current distance if
facing it.
X
======================
*/
qboolean SV_StepDirection (edict_t *ent, float yaw, float dist)
{
X	vec3_t		move, oldorigin;
X	float		delta;
X	
X	if(!ent->inuse)	return true;		// PGM g_touchtrigger free problem
X
X	ent->ideal_yaw = yaw;
X	M_ChangeYaw (ent);
X	
X	yaw = yaw*M_PI*2 / 360;
X	move[0] = cos(yaw)*dist;
X	move[1] = sin(yaw)*dist;
X	move[2] = 0;
X
X	VectorCopy (ent->s.origin, oldorigin);
X	if (SV_movestep (ent, move, false))
X	{
X		if(!ent->inuse)	return true;		// PGM g_touchtrigger free problem
X
X		delta = ent->s.angles[YAW] - ent->ideal_yaw;
X		if (strncmp(ent->classname, "monster_widow", 13))
X		{
X			if (delta > 45 && delta < 315)
X			{		// not turned far enough, so don't take the step
X				VectorCopy (oldorigin, ent->s.origin);
X			}
X		}
X		gi.linkentity (ent);
X		G_TouchTriggers (ent);
X		return true;
X	}
X	gi.linkentity (ent);
X	G_TouchTriggers (ent);
X	return false;
}
X
/*
======================
SV_FixCheckBottom
X
======================
*/
void SV_FixCheckBottom (edict_t *ent)
{
X	ent->flags |= FL_PARTIALGROUND;
}
X
X
X
/*
================
SV_NewChaseDir
X
================
*/
#define	DI_NODIR	-1
void SV_NewChaseDir (edict_t *actor, edict_t *enemy, float dist)
{
X	float	deltax,deltay;
X	float	d[3];
X	float	tdir, olddir, turnaround;
X
X	//FIXME: how did we get here with no enemy
X	if (!enemy)
X		return;
X
X	olddir = anglemod( (int)(actor->ideal_yaw/45)*45 );
X	turnaround = anglemod(olddir - 180);
X
X	deltax = enemy->s.origin[0] - actor->s.origin[0];
X	deltay = enemy->s.origin[1] - actor->s.origin[1];
X	if (deltax>10)
X		d[1]= 0;
X	else if (deltax<-10)
X		d[1]= 180;
X	else
X		d[1]= DI_NODIR;
X	if (deltay<-10)
X		d[2]= 270;
X	else if (deltay>10)
X		d[2]= 90;
X	else
X		d[2]= DI_NODIR;
X
// try direct route
X	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
X	{
X		if (d[1] == 0)
X			tdir = d[2] == 90 ? 45 : 315;
X		else
X			tdir = d[2] == 90 ? 135 : 215;
X			
X		if (tdir != turnaround && SV_StepDirection(actor, tdir, dist))
X			return;
X	}
X
// try other directions
X	if ( ((rand()&3) & 1) ||  abs(deltay)>abs(deltax))
X	{
X		tdir=d[1];
X		d[1]=d[2];
X		d[2]=tdir;
X	}
X
X	if (d[1]!=DI_NODIR && d[1]!=turnaround 
X	&& SV_StepDirection(actor, d[1], dist))
X			return;
X
X	if (d[2]!=DI_NODIR && d[2]!=turnaround
X	&& SV_StepDirection(actor, d[2], dist))
X			return;
X
//ROGUE
X	if(actor->monsterinfo.blocked)
X	{
X		if((actor->monsterinfo.blocked)(actor, dist))
X			return;
X	}
//ROGUE
X
/* there is no direct path to the player, so pick another direction */
X
X	if (olddir!=DI_NODIR && SV_StepDirection(actor, olddir, dist))
X			return;
X
X	if (rand()&1) 	/*randomly determine direction of search*/
X	{
X		for (tdir=0 ; tdir<=315 ; tdir += 45)
X			if (tdir!=turnaround && SV_StepDirection(actor, tdir, dist) )
X					return;
X	}
X	else
X	{
X		for (tdir=315 ; tdir >=0 ; tdir -= 45)
X			if (tdir!=turnaround && SV_StepDirection(actor, tdir, dist) )
X					return;
X	}
X
X	if (turnaround != DI_NODIR && SV_StepDirection(actor, turnaround, dist) )
X			return;
X
X	actor->ideal_yaw = olddir;		// can't move
X
// if a bridge was pulled out from underneath a monster, it may not have
// a valid standing position at all
X
X	if (!M_CheckBottom (actor))
X		SV_FixCheckBottom (actor);
}
X
/*
======================
SV_CloseEnough
X
======================
*/
qboolean SV_CloseEnough (edict_t *ent, edict_t *goal, float dist)
{
X	int		i;
X	
X	for (i=0 ; i<3 ; i++)
X	{
X		if (goal->absmin[i] > ent->absmax[i] + dist)
X			return false;
X		if (goal->absmax[i] < ent->absmin[i] - dist)
X			return false;
X	}
X	return true;
}
X
/*
======================
M_MoveToGoal
======================
*/
void M_MoveToGoal (edict_t *ent, float dist)
{
X	edict_t		*goal;
X	
X	goal = ent->goalentity;
X
X	if (!ent->groundentity && !(ent->flags & (FL_FLY|FL_SWIM)))
X		return;
X
// if the next step hits the enemy, return immediately
X	if (ent->enemy &&  SV_CloseEnough (ent, ent->enemy, dist) )
X		return;
X
// bump around...
//	if ( (rand()&3)==1 || !SV_StepDirection (ent, ent->ideal_yaw, dist))
// PMM - charging monsters (AI_CHARGING) don't deflect unless they have to
X	if ( (((rand()&3)==1) && !(ent->monsterinfo.aiflags & AI_CHARGING)) || !SV_StepDirection (ent, ent->ideal_yaw, dist))
X	{
X		if (ent->inuse)
X			SV_NewChaseDir (ent, goal, dist);
X	}
}
X
X
/*
===============
M_walkmove
===============
*/
qboolean M_walkmove (edict_t *ent, float yaw, float dist)
{
X	vec3_t	move;
X	
X	if (!ent->groundentity && !(ent->flags & (FL_FLY|FL_SWIM)))
X		return false;
X
X	yaw = yaw*M_PI*2 / 360;
X	
X	move[0] = cos(yaw)*dist;
X	move[1] = sin(yaw)*dist;
X	move[2] = 0;
X
X	return SV_movestep(ent, move, true);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_move2.c' &&
  chmod 0664 'm_move2.c' ||
  $echo 'restore of' 'm_move2.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_move2.c:' 'MD5 check failed'
23e46a24e0dc7bf200d9fd6988166cac  m_move2.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_move2.c'`"
    test 15467 -eq "$shar_count" ||
    $echo 'm_move2.c:' 'original size' '15467,' 'current size' "$shar_count!"
  fi
fi
# ============= m_mutant.c ==============
if test -f 'm_mutant.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_mutant.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_mutant.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_mutant.c' &&
/*
==============================================================================
X
mutant
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_mutant.h"
X
X
static int	sound_swing;
static int	sound_hit;
static int	sound_hit2;
static int	sound_death;
static int	sound_idle;
static int	sound_pain1;
static int	sound_pain2;
static int	sound_sight;
static int	sound_search;
static int	sound_step1;
static int	sound_step2;
static int	sound_step3;
static int	sound_thud;
X
//
// SOUNDS
//
X
void mutant_step (edict_t *self)
{
X	int		n;
X	n = (rand() + 1) % 3;
X	if (n == 0)
X		gi.sound (self, CHAN_VOICE, sound_step1, 1, ATTN_NORM, 0);		
X	else if (n == 1)
X		gi.sound (self, CHAN_VOICE, sound_step2, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_step3, 1, ATTN_NORM, 0);
}
X
void mutant_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
void mutant_search (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
}
X
void mutant_swing (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_swing, 1, ATTN_NORM, 0);
}
X
X
//
// STAND
//
X
mframe_t mutant_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 10
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 20
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 30
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 40
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,		// 50
X
X	ai_stand, 0, NULL
};
mmove_t mutant_move_stand = {FRAME_stand101, FRAME_stand151, mutant_frames_stand, NULL};
X
void mutant_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &mutant_move_stand;
}
X
X
//
// IDLE
//
X
void mutant_idle_loop (edict_t *self)
{
X	if (random() < 0.75)
X		self->monsterinfo.nextframe = FRAME_stand155;
}
X
mframe_t mutant_frames_idle [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,					// scratch loop start
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, mutant_idle_loop,		// scratch loop end
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t mutant_move_idle = {FRAME_stand152, FRAME_stand164, mutant_frames_idle, mutant_stand};
X
void mutant_idle (edict_t *self)
{
X	self->monsterinfo.currentmove = &mutant_move_idle;
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
X
//
// WALK
//
X
void mutant_walk (edict_t *self);
X
mframe_t mutant_frames_walk [] =
{
X	ai_walk,	3,		NULL,
X	ai_walk,	1,		NULL,
X	ai_walk,	5,		NULL,
X	ai_walk,	10,		NULL,
X	ai_walk,	13,		NULL,
X	ai_walk,	10,		NULL,
X	ai_walk,	0,		NULL,
X	ai_walk,	5,		NULL,
X	ai_walk,	6,		NULL,
X	ai_walk,	16,		NULL,
X	ai_walk,	15,		NULL,
X	ai_walk,	6,		NULL
};
mmove_t mutant_move_walk = {FRAME_walk05, FRAME_walk16, mutant_frames_walk, NULL};
X
void mutant_walk_loop (edict_t *self)
{
X	self->monsterinfo.currentmove = &mutant_move_walk;
}
X
mframe_t mutant_frames_start_walk [] =
{
X	ai_walk,	5,		NULL,
X	ai_walk,	5,		NULL,
X	ai_walk,	-2,		NULL,
X	ai_walk,	1,		NULL
};
mmove_t mutant_move_start_walk = {FRAME_walk01, FRAME_walk04, mutant_frames_start_walk, mutant_walk_loop};
X
void mutant_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &mutant_move_start_walk;
}
X
X
//
// RUN
//
X
mframe_t mutant_frames_run [] =
{
X	ai_run,	40,		NULL,
X	ai_run,	40,		mutant_step,
X	ai_run,	24,		NULL,
X	ai_run,	5,		mutant_step,
X	ai_run,	17,		NULL,
X	ai_run,	10,		NULL
};
mmove_t mutant_move_run = {FRAME_run03, FRAME_run08, mutant_frames_run, NULL};
X
void mutant_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &mutant_move_stand;
X	else
X		self->monsterinfo.currentmove = &mutant_move_run;
}
X
X
//
// MELEE
//
X
void mutant_hit_left (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->mins[0], 8);
X	if (fire_hit (self, aim, (10 + (rand() %5)), 100))
X		gi.sound (self, CHAN_WEAPON, sound_hit, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_WEAPON, sound_swing, 1, ATTN_NORM, 0);
}
X
void mutant_hit_right (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, self->maxs[0], 8);
X	if (fire_hit (self, aim, (10 + (rand() %5)), 100))
X		gi.sound (self, CHAN_WEAPON, sound_hit2, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_WEAPON, sound_swing, 1, ATTN_NORM, 0);
}
X
void mutant_check_refire (edict_t *self)
{
X	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
X		return;
X
X	if ( ((skill->value == 3) && (random() < 0.5)) || (range(self, self->enemy) == RANGE_MELEE) )
X		self->monsterinfo.nextframe = FRAME_attack09;
}
X
mframe_t mutant_frames_attack [] =
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	mutant_hit_left,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	mutant_hit_right,
X	ai_charge,	0,	mutant_check_refire
};
mmove_t mutant_move_attack = {FRAME_attack09, FRAME_attack15, mutant_frames_attack, mutant_run};
X
void mutant_melee (edict_t *self)
{
X	self->monsterinfo.currentmove = &mutant_move_attack;
}
X
X
//
// ATTACK
//
X
void mutant_jump_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X	if (self->health <= 0)
X	{
X		self->touch = NULL;
X		return;
X	}
X
X	if (other->takedamage)
X	{
X		if (VectorLength(self->velocity) > 400)
X		{
X			vec3_t	point;
X			vec3_t	normal;
X			int		damage;
X
X			VectorCopy (self->velocity, normal);
X			VectorNormalize(normal);
X			VectorMA (self->s.origin, self->maxs[0], normal, point);
X			damage = 40 + 10 * random();
X			T_Damage (other, self, self, self->velocity, point, normal, damage, damage, 0, MOD_UNKNOWN);
X		}
X	}
X
X	if (!M_CheckBottom (self))
X	{
X		if (self->groundentity)
X		{
X			self->monsterinfo.nextframe = FRAME_attack02;
X			self->touch = NULL;
X		}
X		return;
X	}
X
X	self->touch = NULL;
}
X
void mutant_jump_takeoff (edict_t *self)
{
X	vec3_t	forward;
X
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
X	AngleVectors (self->s.angles, forward, NULL, NULL);
X	self->s.origin[2] += 1;
X	VectorScale (forward, 600, self->velocity);
X	self->velocity[2] = 250;
X	self->groundentity = NULL;
X	self->monsterinfo.aiflags |= AI_DUCKED;
X	self->monsterinfo.attack_finished = level.time + 3;
X	self->touch = mutant_jump_touch;
}
X
void mutant_check_landing (edict_t *self)
{
X	if (self->groundentity)
X	{
X		gi.sound (self, CHAN_WEAPON, sound_thud, 1, ATTN_NORM, 0);
X		self->monsterinfo.attack_finished = 0;
X		self->monsterinfo.aiflags &= ~AI_DUCKED;
X		return;
X	}
X
X	if (level.time > self->monsterinfo.attack_finished)
X		self->monsterinfo.nextframe = FRAME_attack02;
X	else
X		self->monsterinfo.nextframe = FRAME_attack05;
}
X
mframe_t mutant_frames_jump [] =
{
X	ai_charge,	 0,	NULL,
X	ai_charge,	17,	NULL,
X	ai_charge,	15,	mutant_jump_takeoff,
X	ai_charge,	15,	NULL,
X	ai_charge,	15,	mutant_check_landing,
X	ai_charge,	 0,	NULL,
X	ai_charge,	 3,	NULL,
X	ai_charge,	 0,	NULL
};
mmove_t mutant_move_jump = {FRAME_attack01, FRAME_attack08, mutant_frames_jump, mutant_run};
X
void mutant_jump (edict_t *self)
{
X	self->monsterinfo.currentmove = &mutant_move_jump;
}
X
X
//
// CHECKATTACK
//
X
qboolean mutant_check_melee (edict_t *self)
{
X	if (range (self, self->enemy) == RANGE_MELEE)
X		return true;
X	return false;
}
X
qboolean mutant_check_jump (edict_t *self)
{
X	vec3_t	v;
X	float	distance;
X
X	if (self->absmin[2] > (self->enemy->absmin[2] + 0.75 * self->enemy->size[2]))
X		return false;
X
X	if (self->absmax[2] < (self->enemy->absmin[2] + 0.25 * self->enemy->size[2]))
X		return false;
X
X	v[0] = self->s.origin[0] - self->enemy->s.origin[0];
X	v[1] = self->s.origin[1] - self->enemy->s.origin[1];
X	v[2] = 0;
X	distance = VectorLength(v);
X
X	if (distance < 100)
X		return false;
X	if (distance > 100)
X	{
X		if (random() < 0.9)
X			return false;
X	}
X
X	return true;
}
X
qboolean mutant_checkattack (edict_t *self)
{
X	if (!self->enemy || self->enemy->health <= 0)
X		return false;
X
X	if (mutant_check_melee(self))
X	{
X		self->monsterinfo.attack_state = AS_MELEE;
X		return true;
X	}
X
X	if (mutant_check_jump(self))
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
X		// FIXME play a jump sound here
X		return true;
X	}
X
X	return false;
}
X
X
//
// PAIN
//
X
mframe_t mutant_frames_pain1 [] =
{
X	ai_move,	4,	NULL,
X	ai_move,	-3,	NULL,
X	ai_move,	-8,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	5,	NULL
};
mmove_t mutant_move_pain1 = {FRAME_pain101, FRAME_pain105, mutant_frames_pain1, mutant_run};
X
mframe_t mutant_frames_pain2 [] =
{
X	ai_move,	-24,NULL,
X	ai_move,	11,	NULL,
X	ai_move,	5,	NULL,
X	ai_move,	-2,	NULL,
X	ai_move,	6,	NULL,
X	ai_move,	4,	NULL
};
mmove_t mutant_move_pain2 = {FRAME_pain201, FRAME_pain206, mutant_frames_pain2, mutant_run};
X
mframe_t mutant_frames_pain3 [] =
{
X	ai_move,	-22,NULL,
X	ai_move,	3,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	1,	NULL,
X	ai_move,	6,	NULL,
X	ai_move,	3,	NULL,
X	ai_move,	2,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	1,	NULL
};
mmove_t mutant_move_pain3 = {FRAME_pain301, FRAME_pain311, mutant_frames_pain3, mutant_run};
X
void mutant_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	float	r;
X
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	r = random();
X	if (r < 0.33)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &mutant_move_pain1;
X	}
X	else if (r < 0.66)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &mutant_move_pain2;
X	}
X	else
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X		self->monsterinfo.currentmove = &mutant_move_pain3;
X	}
}
X
X
//
// DEATH
//
X
void mutant_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	gi.linkentity (self);
X
X	M_FlyCheck (self);
}
X
mframe_t mutant_frames_death1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t mutant_move_death1 = {FRAME_death101, FRAME_death109, mutant_frames_death1, mutant_dead};
X
mframe_t mutant_frames_death2 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t mutant_move_death2 = {FRAME_death201, FRAME_death210, mutant_frames_death2, mutant_dead};
X
void mutant_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->s.skinnum = 1;
X
X	if (random() < 0.5)
X		self->monsterinfo.currentmove = &mutant_move_death1;
X	else
X		self->monsterinfo.currentmove = &mutant_move_death2;
}
X
X
X
//================
//ROGUE
void mutant_jump_down (edict_t *self)
{
X	vec3_t	forward,up;
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 100, forward, self->velocity);
X	VectorMA(self->velocity, 300, up, self->velocity);
}
X
void mutant_jump_up (edict_t *self)
{
X	vec3_t	forward,up;
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 200, forward, self->velocity);
X	VectorMA(self->velocity, 450, up, self->velocity);
}
X
void mutant_jump_wait_land (edict_t *self)
{
X	if(self->groundentity == NULL)
X		self->monsterinfo.nextframe = self->s.frame;
X	else 
X		self->monsterinfo.nextframe = self->s.frame + 1;
}
X
mframe_t mutant_frames_jump_up [] =
{
X	ai_move, -8, NULL,
X	ai_move, -8, mutant_jump_up,
X	ai_move, 0, mutant_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t mutant_move_jump_up = { FRAME_jump01, FRAME_jump05, mutant_frames_jump_up, mutant_run };
X
mframe_t mutant_frames_jump_down [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, mutant_jump_down,
X	ai_move, 0, mutant_jump_wait_land,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t mutant_move_jump_down = { FRAME_jump01, FRAME_jump05, mutant_frames_jump_down, mutant_run };
X
void mutant_jump_updown (edict_t *self)
{
X	if(!self->enemy)
X		return;
X
X	if(self->enemy->s.origin[2] > self->s.origin[2])
X		self->monsterinfo.currentmove = &mutant_move_jump_up;
X	else
X		self->monsterinfo.currentmove = &mutant_move_jump_down;
}
X
/*
===
Blocked
===
*/
qboolean mutant_blocked (edict_t *self, float dist)
{
X	if(blocked_checkjump (self, dist, 256, 68))
X	{
X		mutant_jump_updown (self);
X		return true;
X	}
X
X	if(blocked_checkplat (self, dist))
X		return true;
}
//ROGUE
//================
X
//
// SPAWN
//
X
/*QUAKED monster_mutant (1 .5 0) (-32 -32 -24) (32 32 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_mutant (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_swing = gi.soundindex ("mutant/mutatck1.wav");
X	sound_hit = gi.soundindex ("mutant/mutatck2.wav");
X	sound_hit2 = gi.soundindex ("mutant/mutatck3.wav");
X	sound_death = gi.soundindex ("mutant/mutdeth1.wav");
X	sound_idle = gi.soundindex ("mutant/mutidle1.wav");
X	sound_pain1 = gi.soundindex ("mutant/mutpain1.wav");
X	sound_pain2 = gi.soundindex ("mutant/mutpain2.wav");
X	sound_sight = gi.soundindex ("mutant/mutsght1.wav");
X	sound_search = gi.soundindex ("mutant/mutsrch1.wav");
X	sound_step1 = gi.soundindex ("mutant/step1.wav");
X	sound_step2 = gi.soundindex ("mutant/step2.wav");
X	sound_step3 = gi.soundindex ("mutant/step3.wav");
X	sound_thud = gi.soundindex ("mutant/thud1.wav");
X	
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/mutant/tris.md2");
X	VectorSet (self->mins, -32, -32, -24);
X	VectorSet (self->maxs, 32, 32, 48);
X
X	self->health = 300;
X	self->gib_health = -120;
X	self->mass = 300;
X
X	self->pain = mutant_pain;
X	self->die = mutant_die;
X
X	self->monsterinfo.stand = mutant_stand;
X	self->monsterinfo.walk = mutant_walk;
X	self->monsterinfo.run = mutant_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = mutant_jump;
X	self->monsterinfo.melee = mutant_melee;
X	self->monsterinfo.sight = mutant_sight;
X	self->monsterinfo.search = mutant_search;
X	self->monsterinfo.idle = mutant_idle;
X	self->monsterinfo.checkattack = mutant_checkattack;
X	self->monsterinfo.blocked = mutant_blocked;			// PGM
X
X	gi.linkentity (self);
X	
X	self->monsterinfo.currentmove = &mutant_move_stand;
X
X	self->monsterinfo.scale = MODEL_SCALE;
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_mutant.c' &&
  chmod 0664 'm_mutant.c' ||
  $echo 'restore of' 'm_mutant.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_mutant.c:' 'MD5 check failed'
c96590a4ef460e2d6e407ca1eddd1a32  m_mutant.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_mutant.c'`"
    test 15668 -eq "$shar_count" ||
    $echo 'm_mutant.c:' 'original size' '15668,' 'current size' "$shar_count!"
  fi
fi
# ============= m_mutant.h ==============
if test -f 'm_mutant.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_mutant.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_mutant.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_mutant.h' &&
// G:\quake2\baseq2\models/monsters/mutant
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_attack01        	0
#define FRAME_attack02        	1
#define FRAME_attack03        	2
#define FRAME_attack04        	3
#define FRAME_attack05        	4
#define FRAME_attack06        	5
#define FRAME_attack07        	6
#define FRAME_attack08        	7
#define FRAME_attack09        	8
#define FRAME_attack10        	9
#define FRAME_attack11        	10
#define FRAME_attack12        	11
#define FRAME_attack13        	12
#define FRAME_attack14        	13
#define FRAME_attack15        	14
#define FRAME_death101        	15
#define FRAME_death102        	16
#define FRAME_death103        	17
#define FRAME_death104        	18
#define FRAME_death105        	19
#define FRAME_death106        	20
#define FRAME_death107        	21
#define FRAME_death108        	22
#define FRAME_death109        	23
#define FRAME_death201        	24
#define FRAME_death202        	25
#define FRAME_death203        	26
#define FRAME_death204        	27
#define FRAME_death205        	28
#define FRAME_death206        	29
#define FRAME_death207        	30
#define FRAME_death208        	31
#define FRAME_death209        	32
#define FRAME_death210        	33
#define FRAME_pain101         	34
#define FRAME_pain102         	35
#define FRAME_pain103         	36
#define FRAME_pain104         	37
#define FRAME_pain105         	38
#define FRAME_pain201         	39
#define FRAME_pain202         	40
#define FRAME_pain203         	41
#define FRAME_pain204         	42
#define FRAME_pain205         	43
#define FRAME_pain206         	44
#define FRAME_pain301         	45
#define FRAME_pain302         	46
#define FRAME_pain303         	47
#define FRAME_pain304         	48
#define FRAME_pain305         	49
#define FRAME_pain306         	50
#define FRAME_pain307         	51
#define FRAME_pain308         	52
#define FRAME_pain309         	53
#define FRAME_pain310         	54
#define FRAME_pain311         	55
#define FRAME_run03           	56
#define FRAME_run04           	57
#define FRAME_run05           	58
#define FRAME_run06           	59
#define FRAME_run07           	60
#define FRAME_run08           	61
#define FRAME_stand101        	62
#define FRAME_stand102        	63
#define FRAME_stand103        	64
#define FRAME_stand104        	65
#define FRAME_stand105        	66
#define FRAME_stand106        	67
#define FRAME_stand107        	68
#define FRAME_stand108        	69
#define FRAME_stand109        	70
#define FRAME_stand110        	71
#define FRAME_stand111        	72
#define FRAME_stand112        	73
#define FRAME_stand113        	74
#define FRAME_stand114        	75
#define FRAME_stand115        	76
#define FRAME_stand116        	77
#define FRAME_stand117        	78
#define FRAME_stand118        	79
#define FRAME_stand119        	80
#define FRAME_stand120        	81
#define FRAME_stand121        	82
#define FRAME_stand122        	83
#define FRAME_stand123        	84
#define FRAME_stand124        	85
#define FRAME_stand125        	86
#define FRAME_stand126        	87
#define FRAME_stand127        	88
#define FRAME_stand128        	89
#define FRAME_stand129        	90
#define FRAME_stand130        	91
#define FRAME_stand131        	92
#define FRAME_stand132        	93
#define FRAME_stand133        	94
#define FRAME_stand134        	95
#define FRAME_stand135        	96
#define FRAME_stand136        	97
#define FRAME_stand137        	98
#define FRAME_stand138        	99
#define FRAME_stand139        	100
#define FRAME_stand140        	101
#define FRAME_stand141        	102
#define FRAME_stand142        	103
#define FRAME_stand143        	104
#define FRAME_stand144        	105
#define FRAME_stand145        	106
#define FRAME_stand146        	107
#define FRAME_stand147        	108
#define FRAME_stand148        	109
#define FRAME_stand149        	110
#define FRAME_stand150        	111
#define FRAME_stand151        	112
#define FRAME_stand152        	113
#define FRAME_stand153        	114
#define FRAME_stand154        	115
#define FRAME_stand155        	116
#define FRAME_stand156        	117
#define FRAME_stand157        	118
#define FRAME_stand158        	119
#define FRAME_stand159        	120
#define FRAME_stand160        	121
#define FRAME_stand161        	122
#define FRAME_stand162        	123
#define FRAME_stand163        	124
#define FRAME_stand164        	125
#define FRAME_walk01          	126
#define FRAME_walk02          	127
#define FRAME_walk03          	128
#define FRAME_walk04          	129
#define FRAME_walk05          	130
#define FRAME_walk06          	131
#define FRAME_walk07          	132
#define FRAME_walk08          	133
#define FRAME_walk09          	134
#define FRAME_walk10          	135
#define FRAME_walk11          	136
#define FRAME_walk12          	137
#define FRAME_walk13          	138
#define FRAME_walk14          	139
#define FRAME_walk15          	140
#define FRAME_walk16          	141
#define FRAME_walk17          	142
#define FRAME_walk18          	143
#define FRAME_walk19          	144
#define FRAME_walk20          	145
#define FRAME_walk21          	146
#define FRAME_walk22          	147
#define FRAME_walk23          	148
X
#define FRAME_jump01			149
#define FRAME_jump02			150
#define FRAME_jump03			151
#define FRAME_jump04			152
#define FRAME_jump05			153
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_mutant.h' &&
  chmod 0664 'm_mutant.h' ||
  $echo 'restore of' 'm_mutant.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_mutant.h:' 'MD5 check failed'
de3918cf230fb249c608b6dd2a2f0735  m_mutant.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_mutant.h'`"
    test 5368 -eq "$shar_count" ||
    $echo 'm_mutant.h:' 'original size' '5368,' 'current size' "$shar_count!"
  fi
fi
# ============= m_parasite.c ==============
if test -f 'm_parasite.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_parasite.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_parasite.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_parasite.c' &&
/*
==============================================================================
X
parasite
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_parasite.h"
X
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_die;
static int	sound_launch;
static int	sound_impact;
static int	sound_suck;
static int	sound_reelin;
static int	sound_sight;
static int	sound_tap;
static int	sound_scratch;
static int	sound_search;
X
X
void parasite_stand (edict_t *self);
void parasite_start_run (edict_t *self);
void parasite_run (edict_t *self);
void parasite_walk (edict_t *self);
void parasite_start_walk (edict_t *self);
void parasite_end_fidget (edict_t *self);
void parasite_do_fidget (edict_t *self);
void parasite_refidget (edict_t *self);
X
X
void parasite_launch (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_launch, 1, ATTN_NORM, 0);
}
X
void parasite_reel_in (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_reelin, 1, ATTN_NORM, 0);
}
X
void parasite_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_WEAPON, sound_sight, 1, ATTN_NORM, 0);
}
X
void parasite_tap (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_tap, 1, ATTN_IDLE, 0);
}
X
void parasite_scratch (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_scratch, 1, ATTN_IDLE, 0);
}
X
void parasite_search (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_search, 1, ATTN_IDLE, 0);
}
X
X
mframe_t parasite_frames_start_fidget [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t parasite_move_start_fidget = {FRAME_stand18, FRAME_stand21, parasite_frames_start_fidget, parasite_do_fidget};
X
mframe_t parasite_frames_fidget [] =
{	
X	ai_stand, 0, parasite_scratch,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, parasite_scratch,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t parasite_move_fidget = {FRAME_stand22, FRAME_stand27, parasite_frames_fidget, parasite_refidget};
X
mframe_t parasite_frames_end_fidget [] =
{
X	ai_stand, 0, parasite_scratch,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t parasite_move_end_fidget = {FRAME_stand28, FRAME_stand35, parasite_frames_end_fidget, parasite_stand};
X
void parasite_end_fidget (edict_t *self)
{
X	self->monsterinfo.currentmove = &parasite_move_end_fidget;
}
X
void parasite_do_fidget (edict_t *self)
{
X	self->monsterinfo.currentmove = &parasite_move_fidget;
}
X
void parasite_refidget (edict_t *self)
{ 
X	if (random() <= 0.8)
X		self->monsterinfo.currentmove = &parasite_move_fidget;
X	else
X		self->monsterinfo.currentmove = &parasite_move_end_fidget;
}
X
void parasite_idle (edict_t *self)
{ 
X	self->monsterinfo.currentmove = &parasite_move_start_fidget;
}
X
X
mframe_t parasite_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, parasite_tap,
X	ai_stand, 0, NULL,
X	ai_stand, 0, parasite_tap,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, parasite_tap,
X	ai_stand, 0, NULL,
X	ai_stand, 0, parasite_tap,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, parasite_tap,
X	ai_stand, 0, NULL,
X	ai_stand, 0, parasite_tap
};
mmove_t	parasite_move_stand = {FRAME_stand01, FRAME_stand17, parasite_frames_stand, parasite_stand};
X
void parasite_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &parasite_move_stand;
}
X
X
mframe_t parasite_frames_run [] =
{
X	ai_run, 30, NULL,
X	ai_run, 30, NULL,
X	ai_run, 22, NULL,
X	ai_run, 19, NULL,
X	ai_run, 24, NULL,
X	ai_run, 28, NULL,
X	ai_run, 25, NULL
};
mmove_t parasite_move_run = {FRAME_run03, FRAME_run09, parasite_frames_run, NULL};
X
mframe_t parasite_frames_start_run [] =
{
X	ai_run, 0,	NULL,
X	ai_run, 30, NULL,
};
mmove_t parasite_move_start_run = {FRAME_run01, FRAME_run02, parasite_frames_start_run, parasite_run};
X
mframe_t parasite_frames_stop_run [] =
{	
X	ai_run, 20, NULL,
X	ai_run, 20,	NULL,
X	ai_run, 12, NULL,
X	ai_run, 10, NULL,
X	ai_run, 0,  NULL,
X	ai_run, 0,  NULL
};
mmove_t parasite_move_stop_run = {FRAME_run10, FRAME_run15, parasite_frames_stop_run, NULL};
X
void parasite_start_run (edict_t *self)
{	
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &parasite_move_stand;
X	else
X		self->monsterinfo.currentmove = &parasite_move_start_run;
}
X
void parasite_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &parasite_move_stand;
X	else
X		self->monsterinfo.currentmove = &parasite_move_run;
}
X
X
mframe_t parasite_frames_walk [] =
{
X	ai_walk, 30, NULL,
X	ai_walk, 30, NULL,
X	ai_walk, 22, NULL,
X	ai_walk, 19, NULL,
X	ai_walk, 24, NULL,
X	ai_walk, 28, NULL,
X	ai_walk, 25, NULL
};
mmove_t parasite_move_walk = {FRAME_run03, FRAME_run09, parasite_frames_walk, parasite_walk};
X
mframe_t parasite_frames_start_walk [] =
{
X	ai_walk, 0,	NULL,
X	ai_walk, 30, parasite_walk
};
mmove_t parasite_move_start_walk = {FRAME_run01, FRAME_run02, parasite_frames_start_walk, NULL};
X
mframe_t parasite_frames_stop_walk [] =
{	
X	ai_walk, 20, NULL,
X	ai_walk, 20,	NULL,
X	ai_walk, 12, NULL,
X	ai_walk, 10, NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL
};
mmove_t parasite_move_stop_walk = {FRAME_run10, FRAME_run15, parasite_frames_stop_walk, NULL};
X
void parasite_start_walk (edict_t *self)
{	
X	self->monsterinfo.currentmove = &parasite_move_start_walk;
}
X
void parasite_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &parasite_move_walk;
}
X
X
mframe_t parasite_frames_pain1 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0,	NULL,
X	ai_move, 6,	NULL,
X	ai_move, 16, NULL,
X	ai_move, -6, NULL,
X	ai_move, -7, NULL,
X	ai_move, 0, NULL
};
mmove_t parasite_move_pain1 = {FRAME_pain101, FRAME_pain111, parasite_frames_pain1, parasite_start_run};
X
void parasite_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	if (random() < 0.5)
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
X
X	self->monsterinfo.currentmove = &parasite_move_pain1;
}
X
X
//static qboolean parasite_drain_attack_ok (vec3_t start, vec3_t end)
qboolean parasite_drain_attack_ok (vec3_t start, vec3_t end)
{
X	vec3_t	dir, angles;
X
X	// check for max distance
X	VectorSubtract (start, end, dir);
X	if (VectorLength(dir) > 256)
X		return false;
X
X	// check for min/max pitch
X	vectoangles (dir, angles);
X	if (angles[0] < -180)
X		angles[0] += 360;
X	if (fabs(angles[0]) > 30)
X		return false;
X
X	return true;
}
X
void parasite_drain_attack (edict_t *self)
{
X	vec3_t	offset, start, f, r, end, dir;
X	trace_t	tr;
X	int damage;
X
X	AngleVectors (self->s.angles, f, r, NULL);
X	VectorSet (offset, 24, 0, 6);
X	G_ProjectSource (self->s.origin, offset, f, r, start);
X
X	VectorCopy (self->enemy->s.origin, end);
X	if (!parasite_drain_attack_ok(start, end))
X	{
X		end[2] = self->enemy->s.origin[2] + self->enemy->maxs[2] - 8;
X		if (!parasite_drain_attack_ok(start, end))
X		{
X			end[2] = self->enemy->s.origin[2] + self->enemy->mins[2] + 8;
X			if (!parasite_drain_attack_ok(start, end))
X				return;
X		}
X	}
X	VectorCopy (self->enemy->s.origin, end);
X
X	tr = gi.trace (start, NULL, NULL, end, self, MASK_SHOT);
X	if (tr.ent != self->enemy)
X		return;
X
X	if (self->s.frame == FRAME_drain03)
X	{
X		damage = 5;
X		gi.sound (self->enemy, CHAN_AUTO, sound_impact, 1, ATTN_NORM, 0);
X	}
X	else
X	{
X		if (self->s.frame == FRAME_drain04)
X			gi.sound (self, CHAN_WEAPON, sound_suck, 1, ATTN_NORM, 0);
X		damage = 2;
X	}
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_PARASITE_ATTACK);
X	gi.WriteShort (self - g_edicts);
X	gi.WritePosition (start);
X	gi.WritePosition (end);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	VectorSubtract (start, end, dir);
X	T_Damage (self->enemy, self, self, dir, self->enemy->s.origin, vec3_origin, damage, 0, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN);
}
X
mframe_t parasite_frames_drain [] =
{
X	ai_charge, 0,	parasite_launch,
X	ai_charge, 0,	NULL,
X	ai_charge, 15,	parasite_drain_attack,			// Target hits
X	ai_charge, 0,	parasite_drain_attack,			// drain
X	ai_charge, 0,	parasite_drain_attack,			// drain
X	ai_charge, 0,	parasite_drain_attack,			// drain
X	ai_charge, 0,	parasite_drain_attack,			// drain
X	ai_charge, -2,  parasite_drain_attack,			// drain
X	ai_charge, -2,	parasite_drain_attack,			// drain
X	ai_charge, -3,	parasite_drain_attack,			// drain
X	ai_charge, -2,	parasite_drain_attack,			// drain
X	ai_charge, 0,	parasite_drain_attack,			// drain
X	ai_charge, -1,  parasite_drain_attack,			// drain
X	ai_charge, 0,	parasite_reel_in,				// let go
X	ai_charge, -2,	NULL,
X	ai_charge, -2,	NULL,
X	ai_charge, -3,	NULL,
X	ai_charge, 0,	NULL
};
mmove_t parasite_move_drain = {FRAME_drain01, FRAME_drain18, parasite_frames_drain, parasite_start_run};
X
X
mframe_t parasite_frames_break [] =
{
X	ai_charge, 0,	NULL,
X	ai_charge, -3,	NULL,
X	ai_charge, 1,	NULL,
X	ai_charge, 2,	NULL,
X	ai_charge, -3,	NULL,
X	ai_charge, 1,	NULL,
X	ai_charge, 1,	NULL,
X	ai_charge, 3,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, -18,	NULL,
X	ai_charge, 3,	NULL,
X	ai_charge, 9,	NULL,
X	ai_charge, 6,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, -18,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 8,	NULL,
X	ai_charge, 9,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, -18,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,		// airborne
X	ai_charge, 0,	NULL,		// airborne
X	ai_charge, 0,	NULL,		// slides
X	ai_charge, 0,	NULL,		// slides
X	ai_charge, 0,	NULL,		// slides
X	ai_charge, 0,	NULL,		// slides
X	ai_charge, 4,	NULL,
X	ai_charge, 11,	NULL,		
X	ai_charge, -2,	NULL,
X	ai_charge, -5,	NULL,
X	ai_charge, 1,	NULL
};
mmove_t parasite_move_break = {FRAME_break01, FRAME_break32, parasite_frames_break, parasite_start_run};
X
/*
=== 
Break Stuff Ends
===
*/
X
void parasite_attack (edict_t *self)
{
//	if (random() <= 0.2)
//		self->monsterinfo.currentmove = &parasite_move_break;
//	else
X		self->monsterinfo.currentmove = &parasite_move_drain;
}
X
X
//================
//ROGUE
void parasite_jump_down (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 100, forward, self->velocity);
X	VectorMA(self->velocity, 300, up, self->velocity);
}
X
void parasite_jump_up (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 200, forward, self->velocity);
X	VectorMA(self->velocity, 450, up, self->velocity);
}
X
void parasite_jump_wait_land (edict_t *self)
{
X	if(self->groundentity == NULL)
X	{
X		self->monsterinfo.nextframe = self->s.frame;
X
X		if(monster_jump_finished (self))
X			self->monsterinfo.nextframe = self->s.frame + 1;
X	}
X	else 
X		self->monsterinfo.nextframe = self->s.frame + 1;
}
X
mframe_t parasite_frames_jump_up [] =
{
X	ai_move, -8, NULL,
X	ai_move, -8, NULL,
X	ai_move, -8, NULL,
X	ai_move, -8, parasite_jump_up,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, parasite_jump_wait_land,
X	ai_move, 0, NULL
};
mmove_t parasite_move_jump_up = { FRAME_jump01, FRAME_jump08, parasite_frames_jump_up, parasite_run };
X
mframe_t parasite_frames_jump_down [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, parasite_jump_down,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, parasite_jump_wait_land,
X	ai_move, 0, NULL
};
mmove_t parasite_move_jump_down = { FRAME_jump01, FRAME_jump08, parasite_frames_jump_down, parasite_run };
X
void parasite_jump (edict_t *self)
{
X	if(!self->enemy)
X		return;
X
X	if(self->enemy->s.origin[2] > self->s.origin[2])
X		self->monsterinfo.currentmove = &parasite_move_jump_up;
X	else
X		self->monsterinfo.currentmove = &parasite_move_jump_down;
}
X
/*
===
Blocked
===
*/
qboolean parasite_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkjump (self, dist, 256, 68))
X	{
X		parasite_jump (self);
X		return true;
X	}
X
X	if(blocked_checkplat (self, dist))
X		return true;
}
//ROGUE
//================
X
X
qboolean parasite_checkattack (edict_t *self)
{
X	vec3_t	f, r, offset, start, end;
X	trace_t	tr;
X	qboolean retval;
X
X	retval = M_CheckAttack (self);
X
X	if (!retval)
X		return false;
X
X	AngleVectors (self->s.angles, f, r, NULL);
X	VectorSet (offset, 24, 0, 6);
X	G_ProjectSource (self->s.origin, offset, f, r, start);
X
X	VectorCopy (self->enemy->s.origin, end);
X	if (!parasite_drain_attack_ok(start, end))
X	{
X		end[2] = self->enemy->s.origin[2] + self->enemy->maxs[2] - 8;
X		if (!parasite_drain_attack_ok(start, end))
X		{
X			end[2] = self->enemy->s.origin[2] + self->enemy->mins[2] + 8;
X			if (!parasite_drain_attack_ok(start, end))
X				return false;
X		}
X	}
X	VectorCopy (self->enemy->s.origin, end);
X
X	tr = gi.trace (start, NULL, NULL, end, self, MASK_SHOT);
X	if (tr.ent != self->enemy)
X	{
X		self->monsterinfo.aiflags |= AI_BLOCKED;
X		
X		if(self->monsterinfo.attack)
X			self->monsterinfo.attack(self);
X		
X		self->monsterinfo.aiflags &= ~AI_BLOCKED;
X		return true;
X	}
}
X
X
/*
===
Death Stuff Starts
===
*/
X
void parasite_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t parasite_frames_death [] =
{
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL,
X	ai_move, 0,	 NULL
};
mmove_t parasite_move_death = {FRAME_death101, FRAME_death107, parasite_frames_death, parasite_dead};
X
void parasite_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->monsterinfo.currentmove = &parasite_move_death;
}
X
/*
===
End Death Stuff
===
*/
X
/*QUAKED monster_parasite (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
*/
void SP_monster_parasite (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("parasite/parpain1.wav");	
X	sound_pain2 = gi.soundindex ("parasite/parpain2.wav");	
X	sound_die = gi.soundindex ("parasite/pardeth1.wav");	
X	sound_launch = gi.soundindex("parasite/paratck1.wav");
X	sound_impact = gi.soundindex("parasite/paratck2.wav");
X	sound_suck = gi.soundindex("parasite/paratck3.wav");
X	sound_reelin = gi.soundindex("parasite/paratck4.wav");
X	sound_sight = gi.soundindex("parasite/parsght1.wav");
X	sound_tap = gi.soundindex("parasite/paridle1.wav");
X	sound_scratch = gi.soundindex("parasite/paridle2.wav");
X	sound_search = gi.soundindex("parasite/parsrch1.wav");
X
X	self->s.modelindex = gi.modelindex ("models/monsters/parasite/tris.md2");
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 24);
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X
X	self->health = 175;
X	self->gib_health = -50;
X	self->mass = 250;
X
X	self->pain = parasite_pain;
X	self->die = parasite_die;
X
X	self->monsterinfo.stand = parasite_stand;
X	self->monsterinfo.walk = parasite_start_walk;
X	self->monsterinfo.run = parasite_start_run;
X	self->monsterinfo.attack = parasite_attack;
X	self->monsterinfo.sight = parasite_sight;
X	self->monsterinfo.idle = parasite_idle;
X	self->monsterinfo.blocked = parasite_blocked;		// PGM
X	self->monsterinfo.checkattack = parasite_checkattack;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &parasite_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_parasite.c' &&
  chmod 0664 'm_parasite.c' ||
  $echo 'restore of' 'm_parasite.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_parasite.c:' 'MD5 check failed'
dd0c57baa9f1d33c915344f4cb170f96  m_parasite.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_parasite.c'`"
    test 16217 -eq "$shar_count" ||
    $echo 'm_parasite.c:' 'original size' '16217,' 'current size' "$shar_count!"
  fi
fi
# ============= m_parasite.h ==============
if test -f 'm_parasite.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_parasite.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_parasite.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_parasite.h' &&
// G:\quake2\baseq2\models/monsters/parasite
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_break01           0
#define FRAME_break02           1
#define FRAME_break03           2
#define FRAME_break04           3
#define FRAME_break05           4
#define FRAME_break06           5
#define FRAME_break07           6
#define FRAME_break08           7
#define FRAME_break09           8
#define FRAME_break10           9
#define FRAME_break11           10
#define FRAME_break12           11
#define FRAME_break13           12
#define FRAME_break14           13
#define FRAME_break15           14
#define FRAME_break16           15
#define FRAME_break17           16
#define FRAME_break18           17
#define FRAME_break19           18
#define FRAME_break20           19
#define FRAME_break21           20
#define FRAME_break22           21
#define FRAME_break23           22
#define FRAME_break24           23
#define FRAME_break25           24
#define FRAME_break26           25
#define FRAME_break27           26
#define FRAME_break28           27
#define FRAME_break29           28
#define FRAME_break30           29
#define FRAME_break31           30
#define FRAME_break32           31
#define FRAME_death101          32
#define FRAME_death102          33
#define FRAME_death103          34
#define FRAME_death104          35
#define FRAME_death105          36
#define FRAME_death106          37
#define FRAME_death107          38
#define FRAME_drain01           39
#define FRAME_drain02           40
#define FRAME_drain03           41
#define FRAME_drain04           42
#define FRAME_drain05           43
#define FRAME_drain06           44
#define FRAME_drain07           45
#define FRAME_drain08           46
#define FRAME_drain09           47
#define FRAME_drain10           48
#define FRAME_drain11           49
#define FRAME_drain12           50
#define FRAME_drain13           51
#define FRAME_drain14           52
#define FRAME_drain15           53
#define FRAME_drain16           54
#define FRAME_drain17           55
#define FRAME_drain18           56
#define FRAME_pain101           57
#define FRAME_pain102           58
#define FRAME_pain103           59
#define FRAME_pain104           60
#define FRAME_pain105           61
#define FRAME_pain106           62
#define FRAME_pain107           63
#define FRAME_pain108           64
#define FRAME_pain109           65
#define FRAME_pain110           66
#define FRAME_pain111           67
#define FRAME_run01             68
#define FRAME_run02             69
#define FRAME_run03             70
#define FRAME_run04             71
#define FRAME_run05             72
#define FRAME_run06             73
#define FRAME_run07             74
#define FRAME_run08             75
#define FRAME_run09             76
#define FRAME_run10             77
#define FRAME_run11             78
#define FRAME_run12             79
#define FRAME_run13             80
#define FRAME_run14             81
#define FRAME_run15             82
#define FRAME_stand01           83
#define FRAME_stand02           84
#define FRAME_stand03           85
#define FRAME_stand04           86
#define FRAME_stand05           87
#define FRAME_stand06           88
#define FRAME_stand07           89
#define FRAME_stand08           90
#define FRAME_stand09           91
#define FRAME_stand10           92
#define FRAME_stand11           93
#define FRAME_stand12           94
#define FRAME_stand13           95
#define FRAME_stand14           96
#define FRAME_stand15           97
#define FRAME_stand16           98
#define FRAME_stand17           99
#define FRAME_stand18           100
#define FRAME_stand19           101
#define FRAME_stand20           102
#define FRAME_stand21           103
#define FRAME_stand22           104
#define FRAME_stand23           105
#define FRAME_stand24           106
#define FRAME_stand25           107
#define FRAME_stand26           108
#define FRAME_stand27           109
#define FRAME_stand28           110
#define FRAME_stand29           111
#define FRAME_stand30           112
#define FRAME_stand31           113
#define FRAME_stand32           114
#define FRAME_stand33           115
#define FRAME_stand34           116
#define FRAME_stand35           117
X
#define FRAME_jump01			118
#define FRAME_jump02			119
#define FRAME_jump03			120
#define FRAME_jump04			121
#define FRAME_jump05			122
#define FRAME_jump06			123
#define FRAME_jump07			124
#define FRAME_jump08			125
X
#define MODEL_SCALE             1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_parasite.h' &&
  chmod 0664 'm_parasite.h' ||
  $echo 'restore of' 'm_parasite.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_parasite.h:' 'MD5 check failed'
b3d2ab545cc3b5c6a291c604565cf46e  m_parasite.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_parasite.h'`"
    test 4495 -eq "$shar_count" ||
    $echo 'm_parasite.h:' 'original size' '4495,' 'current size' "$shar_count!"
  fi
fi
# ============= m_player.h ==============
if test -f 'm_player.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_player.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_player.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_player.h' &&
// G:\quake2\baseq2\models/player_x/frames
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_stand01         	0
#define FRAME_stand02         	1
#define FRAME_stand03         	2
#define FRAME_stand04         	3
#define FRAME_stand05         	4
#define FRAME_stand06         	5
#define FRAME_stand07         	6
#define FRAME_stand08         	7
#define FRAME_stand09         	8
#define FRAME_stand10         	9
#define FRAME_stand11         	10
#define FRAME_stand12         	11
#define FRAME_stand13         	12
#define FRAME_stand14         	13
#define FRAME_stand15         	14
#define FRAME_stand16         	15
#define FRAME_stand17         	16
#define FRAME_stand18         	17
#define FRAME_stand19         	18
#define FRAME_stand20         	19
#define FRAME_stand21         	20
#define FRAME_stand22         	21
#define FRAME_stand23         	22
#define FRAME_stand24         	23
#define FRAME_stand25         	24
#define FRAME_stand26         	25
#define FRAME_stand27         	26
#define FRAME_stand28         	27
#define FRAME_stand29         	28
#define FRAME_stand30         	29
#define FRAME_stand31         	30
#define FRAME_stand32         	31
#define FRAME_stand33         	32
#define FRAME_stand34         	33
#define FRAME_stand35         	34
#define FRAME_stand36         	35
#define FRAME_stand37         	36
#define FRAME_stand38         	37
#define FRAME_stand39         	38
#define FRAME_stand40         	39
#define FRAME_run1            	40
#define FRAME_run2            	41
#define FRAME_run3            	42
#define FRAME_run4            	43
#define FRAME_run5            	44
#define FRAME_run6            	45
#define FRAME_attack1         	46
#define FRAME_attack2         	47
#define FRAME_attack3         	48
#define FRAME_attack4         	49
#define FRAME_attack5         	50
#define FRAME_attack6         	51
#define FRAME_attack7         	52
#define FRAME_attack8         	53
#define FRAME_pain101         	54
#define FRAME_pain102         	55
#define FRAME_pain103         	56
#define FRAME_pain104         	57
#define FRAME_pain201         	58
#define FRAME_pain202         	59
#define FRAME_pain203         	60
#define FRAME_pain204         	61
#define FRAME_pain301         	62
#define FRAME_pain302         	63
#define FRAME_pain303         	64
#define FRAME_pain304         	65
#define FRAME_jump1           	66
#define FRAME_jump2           	67
#define FRAME_jump3           	68
#define FRAME_jump4           	69
#define FRAME_jump5           	70
#define FRAME_jump6           	71
#define FRAME_flip01          	72
#define FRAME_flip02          	73
#define FRAME_flip03          	74
#define FRAME_flip04          	75
#define FRAME_flip05          	76
#define FRAME_flip06          	77
#define FRAME_flip07          	78
#define FRAME_flip08          	79
#define FRAME_flip09          	80
#define FRAME_flip10          	81
#define FRAME_flip11          	82
#define FRAME_flip12          	83
#define FRAME_salute01        	84
#define FRAME_salute02        	85
#define FRAME_salute03        	86
#define FRAME_salute04        	87
#define FRAME_salute05        	88
#define FRAME_salute06        	89
#define FRAME_salute07        	90
#define FRAME_salute08        	91
#define FRAME_salute09        	92
#define FRAME_salute10        	93
#define FRAME_salute11        	94
#define FRAME_taunt01         	95
#define FRAME_taunt02         	96
#define FRAME_taunt03         	97
#define FRAME_taunt04         	98
#define FRAME_taunt05         	99
#define FRAME_taunt06         	100
#define FRAME_taunt07         	101
#define FRAME_taunt08         	102
#define FRAME_taunt09         	103
#define FRAME_taunt10         	104
#define FRAME_taunt11         	105
#define FRAME_taunt12         	106
#define FRAME_taunt13         	107
#define FRAME_taunt14         	108
#define FRAME_taunt15         	109
#define FRAME_taunt16         	110
#define FRAME_taunt17         	111
#define FRAME_wave01          	112
#define FRAME_wave02          	113
#define FRAME_wave03          	114
#define FRAME_wave04          	115
#define FRAME_wave05          	116
#define FRAME_wave06          	117
#define FRAME_wave07          	118
#define FRAME_wave08          	119
#define FRAME_wave09          	120
#define FRAME_wave10          	121
#define FRAME_wave11          	122
#define FRAME_point01         	123
#define FRAME_point02         	124
#define FRAME_point03         	125
#define FRAME_point04         	126
#define FRAME_point05         	127
#define FRAME_point06         	128
#define FRAME_point07         	129
#define FRAME_point08         	130
#define FRAME_point09         	131
#define FRAME_point10         	132
#define FRAME_point11         	133
#define FRAME_point12         	134
#define FRAME_crstnd01        	135
#define FRAME_crstnd02        	136
#define FRAME_crstnd03        	137
#define FRAME_crstnd04        	138
#define FRAME_crstnd05        	139
#define FRAME_crstnd06        	140
#define FRAME_crstnd07        	141
#define FRAME_crstnd08        	142
#define FRAME_crstnd09        	143
#define FRAME_crstnd10        	144
#define FRAME_crstnd11        	145
#define FRAME_crstnd12        	146
#define FRAME_crstnd13        	147
#define FRAME_crstnd14        	148
#define FRAME_crstnd15        	149
#define FRAME_crstnd16        	150
#define FRAME_crstnd17        	151
#define FRAME_crstnd18        	152
#define FRAME_crstnd19        	153
#define FRAME_crwalk1         	154
#define FRAME_crwalk2         	155
#define FRAME_crwalk3         	156
#define FRAME_crwalk4         	157
#define FRAME_crwalk5         	158
#define FRAME_crwalk6         	159
#define FRAME_crattak1        	160
#define FRAME_crattak2        	161
#define FRAME_crattak3        	162
#define FRAME_crattak4        	163
#define FRAME_crattak5        	164
#define FRAME_crattak6        	165
#define FRAME_crattak7        	166
#define FRAME_crattak8        	167
#define FRAME_crattak9        	168
#define FRAME_crpain1         	169
#define FRAME_crpain2         	170
#define FRAME_crpain3         	171
#define FRAME_crpain4         	172
#define FRAME_crdeath1        	173
#define FRAME_crdeath2        	174
#define FRAME_crdeath3        	175
#define FRAME_crdeath4        	176
#define FRAME_crdeath5        	177
#define FRAME_death101        	178
#define FRAME_death102        	179
#define FRAME_death103        	180
#define FRAME_death104        	181
#define FRAME_death105        	182
#define FRAME_death106        	183
#define FRAME_death201        	184
#define FRAME_death202        	185
#define FRAME_death203        	186
#define FRAME_death204        	187
#define FRAME_death205        	188
#define FRAME_death206        	189
#define FRAME_death301        	190
#define FRAME_death302        	191
#define FRAME_death303        	192
#define FRAME_death304        	193
#define FRAME_death305        	194
#define FRAME_death306        	195
#define FRAME_death307        	196
#define FRAME_death308        	197
X
#define MODEL_SCALE		1.000000
X
SHAR_EOF
  $shar_touch -am 1130175398 'm_player.h' &&
  chmod 0664 'm_player.h' ||
  $echo 'restore of' 'm_player.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_player.h:' 'MD5 check failed'
2a66a5ce429b514f32b5dd0a567929fe  m_player.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_player.h'`"
    test 6945 -eq "$shar_count" ||
    $echo 'm_player.h:' 'original size' '6945,' 'current size' "$shar_count!"
  fi
fi
# ============= m_rider.h ==============
if test -f 'm_rider.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_rider.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_rider.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_rider.h' &&
// G:\quake2\baseq2\models/monsters/boss3/rider
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_stand201        	0
#define FRAME_stand202        	1
#define FRAME_stand203        	2
#define FRAME_stand204        	3
#define FRAME_stand205        	4
#define FRAME_stand206        	5
#define FRAME_stand207        	6
#define FRAME_stand208        	7
#define FRAME_stand209        	8
#define FRAME_stand210        	9
#define FRAME_stand211        	10
#define FRAME_stand212        	11
#define FRAME_stand213        	12
#define FRAME_stand214        	13
#define FRAME_stand215        	14
#define FRAME_stand216        	15
#define FRAME_stand217        	16
#define FRAME_stand218        	17
#define FRAME_stand219        	18
#define FRAME_stand220        	19
#define FRAME_stand221        	20
#define FRAME_stand222        	21
#define FRAME_stand223        	22
#define FRAME_stand224        	23
#define FRAME_stand225        	24
#define FRAME_stand226        	25
#define FRAME_stand227        	26
#define FRAME_stand228        	27
#define FRAME_stand229        	28
#define FRAME_stand230        	29
#define FRAME_stand231        	30
#define FRAME_stand232        	31
#define FRAME_stand233        	32
#define FRAME_stand234        	33
#define FRAME_stand235        	34
#define FRAME_stand236        	35
#define FRAME_stand237        	36
#define FRAME_stand238        	37
#define FRAME_stand239        	38
#define FRAME_stand240        	39
#define FRAME_stand241        	40
#define FRAME_stand242        	41
#define FRAME_stand243        	42
#define FRAME_stand244        	43
#define FRAME_stand245        	44
#define FRAME_stand246        	45
#define FRAME_stand247        	46
#define FRAME_stand248        	47
#define FRAME_stand249        	48
#define FRAME_stand250        	49
#define FRAME_stand251        	50
#define FRAME_stand252        	51
#define FRAME_stand253        	52
#define FRAME_stand254        	53
#define FRAME_stand255        	54
#define FRAME_stand256        	55
#define FRAME_stand257        	56
#define FRAME_stand258        	57
#define FRAME_stand259        	58
#define FRAME_stand260        	59
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_rider.h' &&
  chmod 0664 'm_rider.h' ||
  $echo 'restore of' 'm_rider.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_rider.h:' 'MD5 check failed'
b8048effb4992a822d0ff7b638c93ff3  m_rider.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_rider.h'`"
    test 2162 -eq "$shar_count" ||
    $echo 'm_rider.h:' 'original size' '2162,' 'current size' "$shar_count!"
  fi
fi
# ============= m_soldier.c ==============
if test -f 'm_soldier.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_soldier.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_soldier.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_soldier.c' &&
/*
==============================================================================
X
SOLDIER
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_soldier.h"
X
//ROGUE
#define RUN_SHOOT		1
#define CHECK_TARGET	1
//ROGUE
X
static int	sound_idle;
static int	sound_sight1;
static int	sound_sight2;
static int	sound_pain_light;
static int	sound_pain;
static int	sound_pain_ss;
static int	sound_death_light;
static int	sound_death;
static int	sound_death_ss;
static int	sound_cock;
X
void soldier_duck_up (edict_t *self);
X
void soldier_start_charge (edict_t *self)
{
X	self->monsterinfo.aiflags |= AI_CHARGING;
}
X
void soldier_stop_charge (edict_t *self)
{
X	self->monsterinfo.aiflags &= ~AI_CHARGING;
}
X
void soldier_idle (edict_t *self)
{
X	if (random() > 0.8)
X		gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
void soldier_cock (edict_t *self)
{
X	if (self->s.frame == FRAME_stand322)
X		gi.sound (self, CHAN_WEAPON, sound_cock, 1, ATTN_IDLE, 0);
X	else
X		gi.sound (self, CHAN_WEAPON, sound_cock, 1, ATTN_NORM, 0);
}
X
X
// STAND
X
void soldier_stand (edict_t *self);
X
mframe_t soldier_frames_stand1 [] =
{
X	ai_stand, 0, soldier_idle,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t soldier_move_stand1 = {FRAME_stand101, FRAME_stand130, soldier_frames_stand1, soldier_stand};
X
mframe_t soldier_frames_stand3 [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, soldier_cock,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t soldier_move_stand3 = {FRAME_stand301, FRAME_stand339, soldier_frames_stand3, soldier_stand};
X
#if 0
mframe_t soldier_frames_stand4 [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 4, NULL,
X	ai_stand, 1, NULL,
X	ai_stand, -1, NULL,
X	ai_stand, -2, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t soldier_move_stand4 = {FRAME_stand401, FRAME_stand452, soldier_frames_stand4, NULL};
#endif
X
void soldier_stand (edict_t *self)
{
X	if ((self->monsterinfo.currentmove == &soldier_move_stand3) || (random() < 0.8))
X		self->monsterinfo.currentmove = &soldier_move_stand1;
X	else
X		self->monsterinfo.currentmove = &soldier_move_stand3;
}
X
X
//
// WALK
//
X
void soldier_walk1_random (edict_t *self)
{
X	if (random() > 0.1)
X		self->monsterinfo.nextframe = FRAME_walk101;
}
X
mframe_t soldier_frames_walk1 [] =
{
X	ai_walk, 3,  NULL,
X	ai_walk, 6,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 2,  NULL,
X	ai_walk, 1,  NULL,
X	ai_walk, 6,  NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 3,  NULL,
X	ai_walk, -1, soldier_walk1_random,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL,
X	ai_walk, 0,  NULL
};
mmove_t soldier_move_walk1 = {FRAME_walk101, FRAME_walk133, soldier_frames_walk1, NULL};
X
mframe_t soldier_frames_walk2 [] =
{
X	ai_walk, 4,  NULL,
X	ai_walk, 4,  NULL,
X	ai_walk, 9,  NULL,
X	ai_walk, 8,  NULL,
X	ai_walk, 5,  NULL,
X	ai_walk, 1,  NULL,
X	ai_walk, 3,  NULL,
X	ai_walk, 7,  NULL,
X	ai_walk, 6,  NULL,
X	ai_walk, 7,  NULL
};
mmove_t soldier_move_walk2 = {FRAME_walk209, FRAME_walk218, soldier_frames_walk2, NULL};
X
void soldier_walk (edict_t *self)
{
X	if (random() < 0.5)
X		self->monsterinfo.currentmove = &soldier_move_walk1;
X	else
X		self->monsterinfo.currentmove = &soldier_move_walk2;
}
X
X
//
// RUN
//
X
void soldier_run (edict_t *self);
X
mframe_t soldier_frames_start_run [] =
{
X	ai_run, 7,  NULL,
X	ai_run, 5,  NULL
};
mmove_t soldier_move_start_run = {FRAME_run01, FRAME_run02, soldier_frames_start_run, soldier_run};
X
#ifdef RUN_SHOOT
void soldier_fire (edict_t *self, int);
X
void soldier_fire_run (edict_t *self) {
X	if ((self->s.skinnum <= 1) && (self->enemy) && visible(self, self->enemy)) {
X		soldier_fire(self, 0);
X	}
}
#endif
X
mframe_t soldier_frames_run [] =
{
X	ai_run, 10, NULL,
X	ai_run, 11, monster_done_dodge,
X	ai_run, 11, NULL,
X	ai_run, 16, NULL,
X	ai_run, 10, NULL,
X	ai_run, 15, monster_done_dodge
};
X
mmove_t soldier_move_run = {FRAME_run03, FRAME_run08, soldier_frames_run, NULL};
X
void soldier_run (edict_t *self)
{
X	monster_done_dodge (self);
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		self->monsterinfo.currentmove = &soldier_move_stand1;
X		return;
X	}
X
X	if (self->monsterinfo.currentmove == &soldier_move_walk1 ||
X		self->monsterinfo.currentmove == &soldier_move_walk2 ||
X		self->monsterinfo.currentmove == &soldier_move_start_run)
X	{
X		self->monsterinfo.currentmove = &soldier_move_run;
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &soldier_move_start_run;
X	}
}
X
X
//
// PAIN
//
X
mframe_t soldier_frames_pain1 [] =
{
X	ai_move, -3, NULL,
X	ai_move, 4,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, 0,  NULL
};
mmove_t soldier_move_pain1 = {FRAME_pain101, FRAME_pain105, soldier_frames_pain1, soldier_run};
X
mframe_t soldier_frames_pain2 [] =
{
X	ai_move, -13, NULL,
X	ai_move, -1,  NULL,
X	ai_move, 2,   NULL,
X	ai_move, 4,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, 3,   NULL,
X	ai_move, 2,   NULL
};
mmove_t soldier_move_pain2 = {FRAME_pain201, FRAME_pain207, soldier_frames_pain2, soldier_run};
X
mframe_t soldier_frames_pain3 [] =
{
X	ai_move, -8, NULL,
X	ai_move, 10, NULL,
X	ai_move, -4, NULL,
X	ai_move, -1, NULL,
X	ai_move, -3, NULL,
X	ai_move, 0,  NULL,
X	ai_move, 3,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 1,  NULL,
X	ai_move, 2,  NULL,
X	ai_move, 4,  NULL,
X	ai_move, 3,  NULL,
X	ai_move, 2,  NULL
};
mmove_t soldier_move_pain3 = {FRAME_pain301, FRAME_pain318, soldier_frames_pain3, soldier_run};
X
mframe_t soldier_frames_pain4 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -10, NULL,
X	ai_move, -6,  NULL,
X	ai_move, 8,   NULL,
X	ai_move, 4,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, 5,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, -1,  NULL,
X	ai_move, -1,  NULL,
X	ai_move, 3,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, 0,   NULL
};
mmove_t soldier_move_pain4 = {FRAME_pain401, FRAME_pain417, soldier_frames_pain4, soldier_run};
X
X
void soldier_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	float	r;
X	int		n;
X
X	if (self->health < (self->max_health / 2))
X			self->s.skinnum |= 1;
X
X	monster_done_dodge (self);
X	soldier_stop_charge(self);
X
X	// if we're blind firing, this needs to be turned off here
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X
X	if (level.time < self->pain_debounce_time)
X	{
X		if ((self->velocity[2] > 100) && ( (self->monsterinfo.currentmove == &soldier_move_pain1) || (self->monsterinfo.currentmove == &soldier_move_pain2) || (self->monsterinfo.currentmove == &soldier_move_pain3)))
X		{
X			// PMM - clear duck flag
X			if (self->monsterinfo.aiflags & AI_DUCKED)
X				monster_duck_up(self);
X			self->monsterinfo.currentmove = &soldier_move_pain4;
X		}
X		return;
X	}
X
X	self->pain_debounce_time = level.time + 3;
X
X	n = self->s.skinnum | 1;
X	if (n == 1)
X		gi.sound (self, CHAN_VOICE, sound_pain_light, 1, ATTN_NORM, 0);
X	else if (n == 3)
X		gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_pain_ss, 1, ATTN_NORM, 0);
X
X	if (self->velocity[2] > 100)
X	{
X		// PMM - clear duck flag
X		if (self->monsterinfo.aiflags & AI_DUCKED)
X			monster_duck_up(self);
X		self->monsterinfo.currentmove = &soldier_move_pain4;
//		self->monsterinfo.pausetime = 0;
X		return;
X	}
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	r = random();
X
X	if (r < 0.33)
X		self->monsterinfo.currentmove = &soldier_move_pain1;
X	else if (r < 0.66)
X		self->monsterinfo.currentmove = &soldier_move_pain2;
X	else
X		self->monsterinfo.currentmove = &soldier_move_pain3;
X
X	// PMM - clear duck flag
X	if (self->monsterinfo.aiflags & AI_DUCKED)
X		monster_duck_up(self);
//	self->monsterinfo.pausetime = 0;
X
}
X
X
//
// ATTACK
//
X
static int blaster_flash [] = {MZ2_SOLDIER_BLASTER_1, MZ2_SOLDIER_BLASTER_2, MZ2_SOLDIER_BLASTER_3, MZ2_SOLDIER_BLASTER_4, MZ2_SOLDIER_BLASTER_5, MZ2_SOLDIER_BLASTER_6, MZ2_SOLDIER_BLASTER_7, MZ2_SOLDIER_BLASTER_8};
static int shotgun_flash [] = {MZ2_SOLDIER_SHOTGUN_1, MZ2_SOLDIER_SHOTGUN_2, MZ2_SOLDIER_SHOTGUN_3, MZ2_SOLDIER_SHOTGUN_4, MZ2_SOLDIER_SHOTGUN_5, MZ2_SOLDIER_SHOTGUN_6, MZ2_SOLDIER_SHOTGUN_7, MZ2_SOLDIER_SHOTGUN_8};
static int machinegun_flash [] = {MZ2_SOLDIER_MACHINEGUN_1, MZ2_SOLDIER_MACHINEGUN_2, MZ2_SOLDIER_MACHINEGUN_3, MZ2_SOLDIER_MACHINEGUN_4, MZ2_SOLDIER_MACHINEGUN_5, MZ2_SOLDIER_MACHINEGUN_6, MZ2_SOLDIER_MACHINEGUN_7, MZ2_SOLDIER_MACHINEGUN_8};
X
//void soldier_fire (edict_t *self, int flash_number)  PMM
void soldier_fire (edict_t *self, int in_flash_number)
{
X	vec3_t	start;
X	vec3_t	forward, right, up;
X	vec3_t	aim;
X	vec3_t	dir;
X	vec3_t	end;
X	float	r, u;
X	int		flash_index;
X	int		flash_number;
#ifdef RUN_SHOOT
X	vec3_t	aim_norm;
X	float	angle;
#endif
#ifdef CHECK_TARGET
X	trace_t	tr;
X	vec3_t aim_good;
#endif
X
X	if ((!self->enemy) || (!self->enemy->inuse))
X	{
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X		return;
X	}
X
X	if (in_flash_number < 0)
X	{
X		flash_number = -1 * in_flash_number;
X	}
X	else
X		flash_number = in_flash_number;
X
X	if (self->s.skinnum < 2)
X		flash_index = blaster_flash[flash_number];
X	else if (self->s.skinnum < 4)
X		flash_index = shotgun_flash[flash_number];
X	else
X		flash_index = machinegun_flash[flash_number];
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_index], forward, right, start);
X
X	if (flash_number == 5 || flash_number == 6) // he's dead
X	{
X		VectorCopy (forward, aim);
X	}
X	else
X	{
X		VectorCopy (self->enemy->s.origin, end);
X		end[2] += self->enemy->viewheight;
X		VectorSubtract (end, start, aim);
#ifdef CHECK_TARGET
X		VectorCopy (end, aim_good);
#endif
#ifdef RUN_SHOOT
X		//PMM
X		if (in_flash_number < 0)
X		{
X			VectorCopy (aim, aim_norm);
X			VectorNormalize (aim_norm);
X			angle = DotProduct (aim_norm, forward);
X			//gi.dprintf ("Dot Product:  %f", DotProduct (aim_norm, forward));
X			if (angle < 0.9)  // ~25 degree angle
X			{
//				if(g_showlogic && g_showlogic->value)
//					gi.dprintf (" not firing due to bad dotprod %f\n", angle);
X				return;
X			}
//			else
//			{
//				if(g_showlogic && g_showlogic->value)
//					gi.dprintf (" firing:  dotprod = %f\n", angle);
//			}
X		}
X		//-PMM
#endif
X		vectoangles (aim, dir);
X		AngleVectors (dir, forward, right, up);
X		
X		if (skill->value < 2)
X		{
X			r = crandom()*1000;
X			u = crandom()*500;
X		}
X		else
X		{
X			r = crandom()*500;
X			u = crandom()*250;
X		}
X		VectorMA (start, 8192, forward, end);
X		VectorMA (end, r, right, end);
X		VectorMA (end, u, up, end);
X
X		VectorSubtract (end, start, aim);
X		VectorNormalize (aim);
X	}
#ifdef CHECK_TARGET
X	if (!(flash_number == 5 || flash_number == 6)) // he's dead
X	{
X		tr = gi.trace (start, NULL, NULL, aim_good, self, MASK_SHOT);
X		if ((tr.ent != self->enemy) && (tr.ent != world))
X		{
//			if(g_showlogic && g_showlogic->value)
//				gi.dprintf ("infantry shot aborted due to bad target\n");
X			return;
X		}
X	}
#endif
X	if (self->s.skinnum <= 1)
X	{
X		monster_fire_blaster (self, start, aim, 5, 600, flash_index, EF_BLASTER);
X	}
X	else if (self->s.skinnum <= 3)
X	{
X		monster_fire_shotgun (self, start, aim, 2, 1, DEFAULT_SHOTGUN_HSPREAD, DEFAULT_SHOTGUN_VSPREAD, DEFAULT_SHOTGUN_COUNT, flash_index);
X	}
X	else
X	{
X		// PMM - changed to wait from pausetime to not interfere with dodge code
X		if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
X			self->wait = level.time + (3 + rand() % 8) * FRAMETIME;
X
X		monster_fire_bullet (self, start, aim, 2, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_index);
X
X		if (level.time >= self->wait)
X			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X		else
X			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
X	}
}
X
// ATTACK1 (blaster/shotgun)
X
void soldier_fire1 (edict_t *self)
{
X	soldier_fire (self, 0);
}
X
void soldier_attack1_refire1 (edict_t *self)
{
X	// PMM - blindfire
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X	{
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		return;
X	}
X	// pmm
X
X	if (!self->enemy)
X		return;
X
X	if (self->s.skinnum > 1)
X		return;
X
X	if (self->enemy->health <= 0)
X		return;
X
X	if ( ((skill->value == 3) && (random() < 0.5)) || (range(self, self->enemy) == RANGE_MELEE) )
X		self->monsterinfo.nextframe = FRAME_attak102;
X	else
X		self->monsterinfo.nextframe = FRAME_attak110;
}
X
void soldier_attack1_refire2 (edict_t *self)
{
X	if (!self->enemy)
X		return;
X
X	if (self->s.skinnum < 2)
X		return;
X
X	if (self->enemy->health <= 0)
X		return;
X
X	if ( ((skill->value == 3) && (random() < 0.5)) || (range(self, self->enemy) == RANGE_MELEE) )
X		self->monsterinfo.nextframe = FRAME_attak102;
}
X
mframe_t soldier_frames_attack1 [] =
{
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  soldier_fire1,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  soldier_attack1_refire1,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  soldier_cock,
X	ai_charge, 0,  soldier_attack1_refire2,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL
};
mmove_t soldier_move_attack1 = {FRAME_attak101, FRAME_attak112, soldier_frames_attack1, soldier_run};
X
// ATTACK2 (blaster/shotgun)
X
void soldier_fire2 (edict_t *self)
{
X	soldier_fire (self, 1);
}
X
void soldier_attack2_refire1 (edict_t *self)
{
X	if (!self->enemy)
X		return;
X
X	if (self->s.skinnum > 1)
X		return;
X
X	if (self->enemy->health <= 0)
X		return;
X
X	if ( ((skill->value == 3) && (random() < 0.5)) || (range(self, self->enemy) == RANGE_MELEE) )
X		self->monsterinfo.nextframe = FRAME_attak204;
X	else
X		self->monsterinfo.nextframe = FRAME_attak216;
}
X
void soldier_attack2_refire2 (edict_t *self)
{
X	if (!self->enemy)
X		return;
X
X	if (self->s.skinnum < 2)
X		return;
X
X	if (self->enemy->health <= 0)
X		return;
X
X	if ( ((skill->value == 3) && (random() < 0.5)) || (range(self, self->enemy) == RANGE_MELEE) )
X		self->monsterinfo.nextframe = FRAME_attak204;
}
X
mframe_t soldier_frames_attack2 [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_fire2,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_attack2_refire1,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_cock,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_attack2_refire2,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t soldier_move_attack2 = {FRAME_attak201, FRAME_attak218, soldier_frames_attack2, soldier_run};
X
// ATTACK3 (duck and shoot)
/*
void soldier_duck_down (edict_t *self)
{
X	if ((g_showlogic) && (g_showlogic->value))
X		gi.dprintf ("duck down - %d!\n", self->s.frame);
X
X	self->monsterinfo.aiflags |= AI_DUCKED;
//	self->maxs[2] -= 32;
X	self->maxs[2] =  self->monsterinfo.base_height - 32;
X	self->takedamage = DAMAGE_YES;
X	if (self->monsterinfo.duck_wait_time < level.time)
X	{
X		if ((g_showlogic) && (g_showlogic->value))
X			gi.dprintf ("soldier duck with no time!\n");
X		self->monsterinfo.duck_wait_time = level.time + 1;
X	}
X	gi.linkentity (self);
}
X
void soldier_duck_up (edict_t *self)
{
X	if ((g_showlogic) && (g_showlogic->value))
X		gi.dprintf ("duck up - %d!\n", self->s.frame);
X	self->monsterinfo.aiflags &= ~AI_DUCKED;
//	self->maxs[2] += 32;
X	self->maxs[2] = self->monsterinfo.base_height;
X	self->takedamage = DAMAGE_AIM;
X	gi.linkentity (self);
}
*/
void soldier_fire3 (edict_t *self)
{
X	monster_duck_down (self);
X	soldier_fire (self, 2);
}
X
void soldier_attack3_refire (edict_t *self)
{
X	if ((level.time + 0.4) < self->monsterinfo.duck_wait_time)
X		self->monsterinfo.nextframe = FRAME_attak303;
}
X
mframe_t soldier_frames_attack3 [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_fire3,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_attack3_refire,
X	ai_charge, 0, monster_duck_up,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t soldier_move_attack3 = {FRAME_attak301, FRAME_attak309, soldier_frames_attack3, soldier_run};
X
// ATTACK4 (machinegun)
X
void soldier_fire4 (edict_t *self)
{
X	soldier_fire (self, 3);
//
//	if (self->enemy->health <= 0)
//		return;
//
//	if ( ((skill->value == 3) && (random() < 0.5)) || (range(self, self->enemy) == RANGE_MELEE) )
//		self->monsterinfo.nextframe = FRAME_attak402;
}
X
mframe_t soldier_frames_attack4 [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_fire4,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t soldier_move_attack4 = {FRAME_attak401, FRAME_attak406, soldier_frames_attack4, soldier_run};
X
#if 0
// ATTACK5 (prone)
X
void soldier_fire5 (edict_t *self)
{
X	soldier_fire (self, 4);
}
X
void soldier_attack5_refire (edict_t *self)
{
X	if (!self->enemy)
X		return;
X
X	if (self->enemy->health <= 0)
X		return;
X
X	if ( ((skill->value == 3) && (random() < 0.5)) || (range(self, self->enemy) == RANGE_MELEE) )
X		self->monsterinfo.nextframe = FRAME_attak505;
}
X
mframe_t soldier_frames_attack5 [] =
{
X	ai_charge, 8, NULL,
X	ai_charge, 8, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_fire5,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, soldier_attack5_refire
};
mmove_t soldier_move_attack5 = {FRAME_attak501, FRAME_attak508, soldier_frames_attack5, soldier_run};
#endif
X
// ATTACK6 (run & shoot)
X
void soldier_fire8 (edict_t *self)
{
X	soldier_fire (self, -7);
//	self->monsterinfo.aiflags |= AI_HOLD_FRAME;
//	self->monsterinfo.pausetime = level.time + 1000000;
}
X
void soldier_attack6_refire (edict_t *self)
{
X	// PMM - make sure dodge & charge bits are cleared
X	monster_done_dodge (self);
X	soldier_stop_charge (self);
X
X	if (!self->enemy)
X		return;
X
X	if (self->enemy->health <= 0)
X		return;
X
//	if (range(self, self->enemy) < RANGE_MID)
X	if (range(self, self->enemy) < RANGE_NEAR)
X		return;
X
X	if ((skill->value == 3) || ((random() < (0.25*((float)skill->value)))))
X		self->monsterinfo.nextframe = FRAME_runs03;
}
X
mframe_t soldier_frames_attack6 [] =
{
//	PMM
//	ai_run, 10, NULL,
X	ai_run, 10, soldier_start_charge,
X	ai_run,  4, NULL,
X	ai_run, 12, soldier_fire8,
X	ai_run, 11, NULL,
X	ai_run, 13, monster_done_dodge,
X	ai_run, 18, NULL,
X	ai_run, 15, NULL,
X	ai_run, 14, NULL,
X	ai_run, 11, NULL,
X	ai_run,  8, NULL,
X	ai_run, 11, NULL,
X	ai_run, 12, NULL,
X	ai_run, 12, NULL,
X	ai_run, 17, soldier_attack6_refire
};
mmove_t soldier_move_attack6 = {FRAME_runs01, FRAME_runs14, soldier_frames_attack6, soldier_run};
X
void soldier_attack(edict_t *self)
{
X	float r, chance;
X
X	monster_done_dodge (self);
X
X	// PMM - blindfire!
X	if (self->monsterinfo.attack_state == AS_BLIND)
X	{
X		// setup shot probabilities
X		if (self->monsterinfo.blind_fire_delay < 1.0)
X			chance = 1.0;
X		else if (self->monsterinfo.blind_fire_delay < 7.5)
X			chance = 0.4;
X		else
X			chance = 0.1;
X
X		r = random();
X
X		// minimum of 2 seconds, plus 0-3, after the shots are done
X		self->monsterinfo.blind_fire_delay += 2.1 + 2.0 + random()*3.0;
X
X		// don't shoot at the origin
X		if (VectorCompare (self->monsterinfo.blind_fire_target, vec3_origin))
X			return;
X
X		// don't shoot if the dice say not to
X		if (r > chance)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("blindfire - NO SHOT\n");
X			return;
X		}
X
X		// turn on manual steering to signal both manual steering and blindfire
X		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X		self->monsterinfo.currentmove = &soldier_move_attack1;
X		self->monsterinfo.attack_finished = level.time + 1.5 + random();
X		return;
X	}
X	// pmm
X
// PMM - added this so the soldiers now run toward you and shoot instead of just stopping and shooting
//	if ((range(self, self->enemy) >= RANGE_MID) && (r < (skill->value*0.25) && (self->s.skinnum <= 3)))
X
X	r = random();
X
X	if ((!(self->monsterinfo.aiflags & (AI_BLOCKED|AI_STAND_GROUND))) &&
X		(range(self, self->enemy) >= RANGE_NEAR) && 
X		(r < (skill->value*0.25) && 
X		(self->s.skinnum <= 3)))
X	{
X		self->monsterinfo.currentmove = &soldier_move_attack6;
X	}
X	else
X	{
X		if (self->s.skinnum < 4)
X		{
X			if (random() < 0.5)
X				self->monsterinfo.currentmove = &soldier_move_attack1;
X			else
X				self->monsterinfo.currentmove = &soldier_move_attack2;
X		}
X		else
X		{
X			self->monsterinfo.currentmove = &soldier_move_attack4;
X		}
X	}
}
X
X
//
// SIGHT
//
X
void soldier_sight(edict_t *self, edict_t *other)
{
X	if (random() < 0.5)
X		gi.sound (self, CHAN_VOICE, sound_sight1, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_sight2, 1, ATTN_NORM, 0);
X
//	if ((skill->value > 0) && (self->enemy) && (range(self, self->enemy) >= RANGE_MID))
X	if ((skill->value > 0) && (self->enemy) && (range(self, self->enemy) >= RANGE_NEAR))
X	{
//	PMM - don't let machinegunners run & shoot
X		if ((random() > 0.75) && (self->s.skinnum <= 3))
X			self->monsterinfo.currentmove = &soldier_move_attack6;
X	}
}
X
//
// DUCK
//
/*
void soldier_duck_hold (edict_t *self)
{
X	if (level.time >= self->monsterinfo.duck_wait_time)
X		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X	else
X		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
}
*/
mframe_t soldier_frames_duck [] =
{
X	ai_move, 5, monster_duck_down,
X	ai_move, -1, monster_duck_hold,
X	ai_move, 1,  NULL,
X	ai_move, 0,  monster_duck_up,
X	ai_move, 5,  NULL
};
mmove_t soldier_move_duck = {FRAME_duck01, FRAME_duck05, soldier_frames_duck, soldier_run};
X
/*
void soldier_dodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
//===========
//PMM - rogue rewrite of dodge code.
// lots o' changes in here.  Basically, they now check the tr and see if ducking would help,
// and if it doesn't, they dodge like mad
X	float	r = random();
X	float	height;
X
X	if ((g_showlogic) && (g_showlogic->value))
X	{
X		if (self->monsterinfo.aiflags & AI_DODGING)
X			gi.dprintf ("dodging - ");
X		if (self->monsterinfo.aiflags & AI_DUCKED)
X			gi.dprintf ("ducked - ");
X	}
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget (self);
X	}
X
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X	{
X		if ((g_showlogic) && (g_showlogic->value))
X			gi.dprintf ("timeout\n");
X		return;
X	}
X
X	// skill level determination..
X	if (r > (0.25*((skill->value)+1)))
X	{
X		if ((g_showlogic) && (g_showlogic->value))
X			gi.dprintf ("skillout\n");
X		return;
X	}
X
X	// stop charging, since we're going to dodge (somehow) instead
X	soldier_stop_charge (self);
X
X	height = self->absmax[2]-32-1;  // the -1 is because the absmax is s.origin + maxs + 1
X
X	// if we're ducking already, or the shot is at our knees
X	if ((tr->endpos[2] <= height) || (self->monsterinfo.aiflags & AI_DUCKED))
X	{
X		vec3_t right, diff;
X
X		// if we're already dodging, just finish the sequence, i.e. don't do anything else
X		if (self->monsterinfo.aiflags & AI_DODGING)
X		{
X			if ((g_showlogic) && (g_showlogic->value))
X				gi.dprintf ("already dodging\n");
X			return;
X		}
X
X		AngleVectors (self->s.angles, NULL, right, NULL);
X		VectorSubtract (tr->endpos, self->s.origin, diff);
X
X		if (DotProduct (right, diff) < 0)
X		{
X			self->monsterinfo.lefty = 1;
//			gi.dprintf ("left\n");
X		} else {
//			gi.dprintf ("right\n");
X		}
X		// if it doesn't sense to duck, try to strafe and shoot
X		// we don't want the machine gun guys running & shooting (looks bad)
X
X		// if we are currently ducked, unduck
X		if (self->monsterinfo.aiflags & AI_DUCKED)
X		{
X			if ((g_showlogic) && (g_showlogic->value))
X				gi.dprintf ("unducking - ");
X			soldier_duck_up(self);
X		}
X
X		self->monsterinfo.aiflags |= AI_DODGING;
X		self->monsterinfo.attack_state = AS_SLIDING;
X
X		if (self->s.skinnum <= 3)
X		{
X			if ((g_showlogic) && (g_showlogic->value))
X				gi.dprintf ("shooting back!\n");
X			self->monsterinfo.currentmove = &soldier_move_attack6;
X		}
X		else
X		{
X			if ((g_showlogic) && (g_showlogic->value))
X				gi.dprintf ("strafing away!\n");
X			self->monsterinfo.currentmove = &soldier_move_start_run;
X		}
X		return;
X	}
X
X	// if we're here, we're ducking, so clear the dodge bit if it's set
X
X	if ((g_showlogic) && (g_showlogic->value))
X		gi.dprintf ("ducking!\n");
X	if (skill->value == 0)
X	{
X		// set this prematurely; it doesn't hurt, and prevents extra iterations
X		self->monsterinfo.aiflags |= AI_DUCKED;
X		monster_done_dodge (self);
X		self->monsterinfo.currentmove = &soldier_move_duck;
X		// PMM - stupid dodge
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		return;
X	}
// PMM - since we're only ducking some of the time, this needs to be moved down below
//	self->monsterinfo.duck_wait_time = level.time + eta + 0.3;
X
X	r = random();
X
X	// set this prematurely; it doesn't hurt, and prevents extra iterations
X	self->monsterinfo.aiflags |= AI_DUCKED;
X	monster_done_dodge (self);
X
X	if (r > (skill->value * 0.33))
X	{
X		self->monsterinfo.currentmove = &soldier_move_duck;
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X		// has to be done immediately otherwise he can get stuck
X		soldier_duck_down(self);
X	}
X	else
X	{
X		// has to be done immediately otherwise he can get stuck
X		soldier_duck_down(self);
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		self->monsterinfo.currentmove = &soldier_move_attack3;
X		self->monsterinfo.nextframe = FRAME_attak301;
X	}
X	return;
//PMM
//===========
X
}
*/
// pmm - blocking code
X
qboolean soldier_blocked (edict_t *self, float dist)
{
X	// don't do anything if you're dodging
X	if ((self->monsterinfo.aiflags & AI_DODGING) || (self->monsterinfo.aiflags & AI_DUCKED))
X		return false;
X
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
//	if(blocked_checkjump (self, dist, 192, 40))
//	{
//		soldier_jump(self);
//		return true;
//	}
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
X
//
// DEATH
//
X
void soldier_fire6 (edict_t *self)
{
X	soldier_fire (self, 5);
}
X
void soldier_fire7 (edict_t *self)
{
X	soldier_fire (self, 6);
}
X
void soldier_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, -8);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
// pmm - this quickie does a location trace to try to grow the bounding box
//
// this is because the frames are off; the origin is at the guy's feet.
void soldier_dead2 (edict_t *self)
{
X	vec3_t	tempmins, tempmaxs, temporg;
X	trace_t	tr;
X
X	VectorCopy (self->s.origin, temporg);
X	// this is because location traces done at the floor are guaranteed to hit the floor
X	// (inside the sv_trace code it grows the bbox by 1 in all directions)
X	temporg[2] += 1;
X
X	VectorSet (tempmins, -32, -32, -24);
X	VectorSet (tempmaxs, 32, 32, -8);
X
X	tr = gi.trace (temporg, tempmins, tempmaxs, temporg, self, MASK_SOLID);
X	if (tr.startsolid || tr.allsolid)
X	{
X		VectorSet (self->mins, -16, -16, -24);
X		VectorSet (self->maxs, 16, 16, -8);
X	}
X	else
X	{
X		VectorCopy (tempmins, self->mins);
X		VectorCopy (tempmaxs, self->maxs);
X	}
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t soldier_frames_death1 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, -10, NULL,
X	ai_move, -10, NULL,
X	ai_move, -10, NULL,
X	ai_move, -5,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   soldier_fire6,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   soldier_fire7,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL
};
mmove_t soldier_move_death1 = {FRAME_death101, FRAME_death136, soldier_frames_death1, soldier_dead};
X
mframe_t soldier_frames_death2 [] =
{
X	ai_move, -5,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL
};
mmove_t soldier_move_death2 = {FRAME_death201, FRAME_death235, soldier_frames_death2, soldier_dead};
X
mframe_t soldier_frames_death3 [] =
{
X	ai_move, -5,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
};
mmove_t soldier_move_death3 = {FRAME_death301, FRAME_death345, soldier_frames_death3, soldier_dead};
X
mframe_t soldier_frames_death4 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL
};
// PMM -changed to soldier_dead2 to get a larger bounding box
mmove_t soldier_move_death4 = {FRAME_death401, FRAME_death453, soldier_frames_death4, soldier_dead2};
X
mframe_t soldier_frames_death5 [] =
{
X	ai_move, -5,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL
};
mmove_t soldier_move_death5 = {FRAME_death501, FRAME_death524, soldier_frames_death5, soldier_dead};
X
mframe_t soldier_frames_death6 [] =
{
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL
};
mmove_t soldier_move_death6 = {FRAME_death601, FRAME_death610, soldier_frames_death6, soldier_dead};
X
void soldier_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 3; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowGib (self, "models/objects/gibs/chest/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->s.skinnum |= 1;
X
X	if (self->s.skinnum == 1)
X		gi.sound (self, CHAN_VOICE, sound_death_light, 1, ATTN_NORM, 0);
X	else if (self->s.skinnum == 3)
X		gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
X	else // (self->s.skinnum == 5)
X		gi.sound (self, CHAN_VOICE, sound_death_ss, 1, ATTN_NORM, 0);
X
X	if (fabs((self->s.origin[2] + self->viewheight) - point[2]) <= 4)
X	{
X		// head shot
X		self->monsterinfo.currentmove = &soldier_move_death3;
X		return;
X	}
X
X	n = rand() % 5;
X	if (n == 0)
X		self->monsterinfo.currentmove = &soldier_move_death1;
X	else if (n == 1)
X		self->monsterinfo.currentmove = &soldier_move_death2;
X	else if (n == 2)
X		self->monsterinfo.currentmove = &soldier_move_death4;
X	else if (n == 3)
X		self->monsterinfo.currentmove = &soldier_move_death5;
X	else
X		self->monsterinfo.currentmove = &soldier_move_death6;
}
X
//
// NEW DODGE CODE
//
X
void soldier_sidestep (edict_t *self)
{
X	if (self->s.skinnum <= 3)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("shooting back!\n");
X		if (self->monsterinfo.currentmove != &soldier_move_attack6)
X			self->monsterinfo.currentmove = &soldier_move_attack6;
X	}
X	else
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("strafing away!\n");
X		if (self->monsterinfo.currentmove != &soldier_move_start_run)
X			self->monsterinfo.currentmove = &soldier_move_start_run;
X	}
}
X
void soldier_duck (edict_t *self, float eta)
{
X	float r;
X
X	// has to be done immediately otherwise he can get stuck
X	monster_duck_down(self);
X
X	if (skill->value == 0)
X	{
X		// PMM - stupid dodge
X		self->monsterinfo.nextframe = FRAME_duck01;
X		self->monsterinfo.currentmove = &soldier_move_duck;
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X		return;
X	}
X
X	r = random();
X
X	if (r > (skill->value * 0.3))
X	{
X		self->monsterinfo.nextframe = FRAME_duck01;
X		self->monsterinfo.currentmove = &soldier_move_duck;
X		self->monsterinfo.duck_wait_time = level.time + eta + (0.1 * (3 - skill->value));
X	}
X	else
X	{
X		self->monsterinfo.nextframe = FRAME_attak301;
X		self->monsterinfo.currentmove = &soldier_move_attack3;
X		self->monsterinfo.duck_wait_time = level.time + eta + 1;
X	}
X	return;
}
X
//=========
//ROGUE
void soldier_blind (edict_t *self);
X
mframe_t soldier_frames_blind [] =
{
X	ai_move, 0, soldier_idle,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t soldier_move_blind = {FRAME_stand101, FRAME_stand130, soldier_frames_blind, soldier_blind};
X
void soldier_blind (edict_t *self)
{
X	self->monsterinfo.currentmove = &soldier_move_blind;
}
//ROGUE
//=========
X
//
// SPAWN
//
X
void SP_monster_soldier_x (edict_t *self)
{
X
X	self->s.modelindex = gi.modelindex ("models/monsters/soldier/tris.md2");
X	//PMM
//	self->s.effects |= EF_SPLATTER;
X	//PMM
X	self->monsterinfo.scale = MODEL_SCALE;
X	VectorSet (self->mins, -16, -16, -24);
X	VectorSet (self->maxs, 16, 16, 32);
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X
X	sound_idle =	gi.soundindex ("soldier/solidle1.wav");
X	sound_sight1 =	gi.soundindex ("soldier/solsght1.wav");
X	sound_sight2 =	gi.soundindex ("soldier/solsrch1.wav");
X	sound_cock =	gi.soundindex ("infantry/infatck3.wav");
X
X	self->mass = 100;
X
X	self->pain = soldier_pain;
X	self->die = soldier_die;
X
X	self->monsterinfo.stand = soldier_stand;
X	self->monsterinfo.walk = soldier_walk;
X	self->monsterinfo.run = soldier_run;
X	self->monsterinfo.dodge = M_MonsterDodge;
X	self->monsterinfo.attack = soldier_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = soldier_sight;
X
//=====
//ROGUE
X	self->monsterinfo.blocked = soldier_blocked;
X	self->monsterinfo.duck = soldier_duck;
X	self->monsterinfo.unduck = monster_duck_up;
X	self->monsterinfo.sidestep = soldier_sidestep;
X
X	if(self->spawnflags & 8)	// blind
X		self->monsterinfo.stand = soldier_blind;
//ROGUE
//=====
X
X	gi.linkentity (self);
X
X	self->monsterinfo.stand (self);
X
X	walkmonster_start (self);
}
X
X
/*QUAKED monster_soldier_light (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight Blind
X
Blind - monster will just stand there until triggered
*/
void SP_monster_soldier_light (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	SP_monster_soldier_x (self);
X
X	sound_pain_light = gi.soundindex ("soldier/solpain2.wav");
X	sound_death_light =	gi.soundindex ("soldier/soldeth2.wav");
X	gi.modelindex ("models/objects/laser/tris.md2");
X	gi.soundindex ("misc/lasfly.wav");
X	gi.soundindex ("soldier/solatck2.wav");
X
X	self->s.skinnum = 0;
X	self->health = 20;
X	self->gib_health = -30;
X
X	// PMM - blindfire
X	self->monsterinfo.blindfire = true;
}
X
/*QUAKED monster_soldier (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight Blind
X
Blind - monster will just stand there until triggered
*/
void SP_monster_soldier (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	SP_monster_soldier_x (self);
X
X	sound_pain = gi.soundindex ("soldier/solpain1.wav");
X	sound_death = gi.soundindex ("soldier/soldeth1.wav");
X	gi.soundindex ("soldier/solatck1.wav");
X
X	self->s.skinnum = 2;
X	self->health = 30;
X	self->gib_health = -30;
}
X
/*QUAKED monster_soldier_ss (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight Blind
X
Blind - monster will just stand there until triggered
*/
void SP_monster_soldier_ss (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	SP_monster_soldier_x (self);
X
X	sound_pain_ss = gi.soundindex ("soldier/solpain3.wav");
X	sound_death_ss = gi.soundindex ("soldier/soldeth3.wav");
X	gi.soundindex ("soldier/solatck3.wav");
X
X	self->s.skinnum = 4;
X	self->health = 40;
X	self->gib_health = -30;
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_soldier.c' &&
  chmod 0664 'm_soldier.c' ||
  $echo 'restore of' 'm_soldier.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_soldier.c:' 'MD5 check failed'
942c239554b937162c2f1f35bbaebc67  m_soldier.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_soldier.c'`"
    test 41093 -eq "$shar_count" ||
    $echo 'm_soldier.c:' 'original size' '41093,' 'current size' "$shar_count!"
  fi
fi
# ============= m_soldier.h ==============
if test -f 'm_soldier.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_soldier.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_soldier.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_soldier.h' &&
// G:\quake2\baseq2\models/monsters/soldier
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_attak101        	0
#define FRAME_attak102        	1
#define FRAME_attak103        	2
#define FRAME_attak104        	3
#define FRAME_attak105        	4
#define FRAME_attak106        	5
#define FRAME_attak107        	6
#define FRAME_attak108        	7
#define FRAME_attak109        	8
#define FRAME_attak110        	9
#define FRAME_attak111        	10
#define FRAME_attak112        	11
#define FRAME_attak201        	12
#define FRAME_attak202        	13
#define FRAME_attak203        	14
#define FRAME_attak204        	15
#define FRAME_attak205        	16
#define FRAME_attak206        	17
#define FRAME_attak207        	18
#define FRAME_attak208        	19
#define FRAME_attak209        	20
#define FRAME_attak210        	21
#define FRAME_attak211        	22
#define FRAME_attak212        	23
#define FRAME_attak213        	24
#define FRAME_attak214        	25
#define FRAME_attak215        	26
#define FRAME_attak216        	27
#define FRAME_attak217        	28
#define FRAME_attak218        	29
#define FRAME_attak301        	30
#define FRAME_attak302        	31
#define FRAME_attak303        	32
#define FRAME_attak304        	33
#define FRAME_attak305        	34
#define FRAME_attak306        	35
#define FRAME_attak307        	36
#define FRAME_attak308        	37
#define FRAME_attak309        	38
#define FRAME_attak401        	39
#define FRAME_attak402        	40
#define FRAME_attak403        	41
#define FRAME_attak404        	42
#define FRAME_attak405        	43
#define FRAME_attak406        	44
#define FRAME_duck01          	45
#define FRAME_duck02          	46
#define FRAME_duck03          	47
#define FRAME_duck04          	48
#define FRAME_duck05          	49
#define FRAME_pain101         	50
#define FRAME_pain102         	51
#define FRAME_pain103         	52
#define FRAME_pain104         	53
#define FRAME_pain105         	54
#define FRAME_pain201         	55
#define FRAME_pain202         	56
#define FRAME_pain203         	57
#define FRAME_pain204         	58
#define FRAME_pain205         	59
#define FRAME_pain206         	60
#define FRAME_pain207         	61
#define FRAME_pain301         	62
#define FRAME_pain302         	63
#define FRAME_pain303         	64
#define FRAME_pain304         	65
#define FRAME_pain305         	66
#define FRAME_pain306         	67
#define FRAME_pain307         	68
#define FRAME_pain308         	69
#define FRAME_pain309         	70
#define FRAME_pain310         	71
#define FRAME_pain311         	72
#define FRAME_pain312         	73
#define FRAME_pain313         	74
#define FRAME_pain314         	75
#define FRAME_pain315         	76
#define FRAME_pain316         	77
#define FRAME_pain317         	78
#define FRAME_pain318         	79
#define FRAME_pain401         	80
#define FRAME_pain402         	81
#define FRAME_pain403         	82
#define FRAME_pain404         	83
#define FRAME_pain405         	84
#define FRAME_pain406         	85
#define FRAME_pain407         	86
#define FRAME_pain408         	87
#define FRAME_pain409         	88
#define FRAME_pain410         	89
#define FRAME_pain411         	90
#define FRAME_pain412         	91
#define FRAME_pain413         	92
#define FRAME_pain414         	93
#define FRAME_pain415         	94
#define FRAME_pain416         	95
#define FRAME_pain417         	96
#define FRAME_run01           	97
#define FRAME_run02           	98
#define FRAME_run03           	99
#define FRAME_run04           	100
#define FRAME_run05           	101
#define FRAME_run06           	102
#define FRAME_run07           	103
#define FRAME_run08           	104
#define FRAME_run09           	105
#define FRAME_run10           	106
#define FRAME_run11           	107
#define FRAME_run12           	108
#define FRAME_runs01          	109
#define FRAME_runs02          	110
#define FRAME_runs03          	111
#define FRAME_runs04          	112
#define FRAME_runs05          	113
#define FRAME_runs06          	114
#define FRAME_runs07          	115
#define FRAME_runs08          	116
#define FRAME_runs09          	117
#define FRAME_runs10          	118
#define FRAME_runs11          	119
#define FRAME_runs12          	120
#define FRAME_runs13          	121
#define FRAME_runs14          	122
#define FRAME_runs15          	123
#define FRAME_runs16          	124
#define FRAME_runs17          	125
#define FRAME_runs18          	126
#define FRAME_runt01          	127
#define FRAME_runt02          	128
#define FRAME_runt03          	129
#define FRAME_runt04          	130
#define FRAME_runt05          	131
#define FRAME_runt06          	132
#define FRAME_runt07          	133
#define FRAME_runt08          	134
#define FRAME_runt09          	135
#define FRAME_runt10          	136
#define FRAME_runt11          	137
#define FRAME_runt12          	138
#define FRAME_runt13          	139
#define FRAME_runt14          	140
#define FRAME_runt15          	141
#define FRAME_runt16          	142
#define FRAME_runt17          	143
#define FRAME_runt18          	144
#define FRAME_runt19          	145
#define FRAME_stand101        	146
#define FRAME_stand102        	147
#define FRAME_stand103        	148
#define FRAME_stand104        	149
#define FRAME_stand105        	150
#define FRAME_stand106        	151
#define FRAME_stand107        	152
#define FRAME_stand108        	153
#define FRAME_stand109        	154
#define FRAME_stand110        	155
#define FRAME_stand111        	156
#define FRAME_stand112        	157
#define FRAME_stand113        	158
#define FRAME_stand114        	159
#define FRAME_stand115        	160
#define FRAME_stand116        	161
#define FRAME_stand117        	162
#define FRAME_stand118        	163
#define FRAME_stand119        	164
#define FRAME_stand120        	165
#define FRAME_stand121        	166
#define FRAME_stand122        	167
#define FRAME_stand123        	168
#define FRAME_stand124        	169
#define FRAME_stand125        	170
#define FRAME_stand126        	171
#define FRAME_stand127        	172
#define FRAME_stand128        	173
#define FRAME_stand129        	174
#define FRAME_stand130        	175
#define FRAME_stand301        	176
#define FRAME_stand302        	177
#define FRAME_stand303        	178
#define FRAME_stand304        	179
#define FRAME_stand305        	180
#define FRAME_stand306        	181
#define FRAME_stand307        	182
#define FRAME_stand308        	183
#define FRAME_stand309        	184
#define FRAME_stand310        	185
#define FRAME_stand311        	186
#define FRAME_stand312        	187
#define FRAME_stand313        	188
#define FRAME_stand314        	189
#define FRAME_stand315        	190
#define FRAME_stand316        	191
#define FRAME_stand317        	192
#define FRAME_stand318        	193
#define FRAME_stand319        	194
#define FRAME_stand320        	195
#define FRAME_stand321        	196
#define FRAME_stand322        	197
#define FRAME_stand323        	198
#define FRAME_stand324        	199
#define FRAME_stand325        	200
#define FRAME_stand326        	201
#define FRAME_stand327        	202
#define FRAME_stand328        	203
#define FRAME_stand329        	204
#define FRAME_stand330        	205
#define FRAME_stand331        	206
#define FRAME_stand332        	207
#define FRAME_stand333        	208
#define FRAME_stand334        	209
#define FRAME_stand335        	210
#define FRAME_stand336        	211
#define FRAME_stand337        	212
#define FRAME_stand338        	213
#define FRAME_stand339        	214
#define FRAME_walk101         	215
#define FRAME_walk102         	216
#define FRAME_walk103         	217
#define FRAME_walk104         	218
#define FRAME_walk105         	219
#define FRAME_walk106         	220
#define FRAME_walk107         	221
#define FRAME_walk108         	222
#define FRAME_walk109         	223
#define FRAME_walk110         	224
#define FRAME_walk111         	225
#define FRAME_walk112         	226
#define FRAME_walk113         	227
#define FRAME_walk114         	228
#define FRAME_walk115         	229
#define FRAME_walk116         	230
#define FRAME_walk117         	231
#define FRAME_walk118         	232
#define FRAME_walk119         	233
#define FRAME_walk120         	234
#define FRAME_walk121         	235
#define FRAME_walk122         	236
#define FRAME_walk123         	237
#define FRAME_walk124         	238
#define FRAME_walk125         	239
#define FRAME_walk126         	240
#define FRAME_walk127         	241
#define FRAME_walk128         	242
#define FRAME_walk129         	243
#define FRAME_walk130         	244
#define FRAME_walk131         	245
#define FRAME_walk132         	246
#define FRAME_walk133         	247
#define FRAME_walk201         	248
#define FRAME_walk202         	249
#define FRAME_walk203         	250
#define FRAME_walk204         	251
#define FRAME_walk205         	252
#define FRAME_walk206         	253
#define FRAME_walk207         	254
#define FRAME_walk208         	255
#define FRAME_walk209         	256
#define FRAME_walk210         	257
#define FRAME_walk211         	258
#define FRAME_walk212         	259
#define FRAME_walk213         	260
#define FRAME_walk214         	261
#define FRAME_walk215         	262
#define FRAME_walk216         	263
#define FRAME_walk217         	264
#define FRAME_walk218         	265
#define FRAME_walk219         	266
#define FRAME_walk220         	267
#define FRAME_walk221         	268
#define FRAME_walk222         	269
#define FRAME_walk223         	270
#define FRAME_walk224         	271
#define FRAME_death101        	272
#define FRAME_death102        	273
#define FRAME_death103        	274
#define FRAME_death104        	275
#define FRAME_death105        	276
#define FRAME_death106        	277
#define FRAME_death107        	278
#define FRAME_death108        	279
#define FRAME_death109        	280
#define FRAME_death110        	281
#define FRAME_death111        	282
#define FRAME_death112        	283
#define FRAME_death113        	284
#define FRAME_death114        	285
#define FRAME_death115        	286
#define FRAME_death116        	287
#define FRAME_death117        	288
#define FRAME_death118        	289
#define FRAME_death119        	290
#define FRAME_death120        	291
#define FRAME_death121        	292
#define FRAME_death122        	293
#define FRAME_death123        	294
#define FRAME_death124        	295
#define FRAME_death125        	296
#define FRAME_death126        	297
#define FRAME_death127        	298
#define FRAME_death128        	299
#define FRAME_death129        	300
#define FRAME_death130        	301
#define FRAME_death131        	302
#define FRAME_death132        	303
#define FRAME_death133        	304
#define FRAME_death134        	305
#define FRAME_death135        	306
#define FRAME_death136        	307
#define FRAME_death201        	308
#define FRAME_death202        	309
#define FRAME_death203        	310
#define FRAME_death204        	311
#define FRAME_death205        	312
#define FRAME_death206        	313
#define FRAME_death207        	314
#define FRAME_death208        	315
#define FRAME_death209        	316
#define FRAME_death210        	317
#define FRAME_death211        	318
#define FRAME_death212        	319
#define FRAME_death213        	320
#define FRAME_death214        	321
#define FRAME_death215        	322
#define FRAME_death216        	323
#define FRAME_death217        	324
#define FRAME_death218        	325
#define FRAME_death219        	326
#define FRAME_death220        	327
#define FRAME_death221        	328
#define FRAME_death222        	329
#define FRAME_death223        	330
#define FRAME_death224        	331
#define FRAME_death225        	332
#define FRAME_death226        	333
#define FRAME_death227        	334
#define FRAME_death228        	335
#define FRAME_death229        	336
#define FRAME_death230        	337
#define FRAME_death231        	338
#define FRAME_death232        	339
#define FRAME_death233        	340
#define FRAME_death234        	341
#define FRAME_death235        	342
#define FRAME_death301        	343
#define FRAME_death302        	344
#define FRAME_death303        	345
#define FRAME_death304        	346
#define FRAME_death305        	347
#define FRAME_death306        	348
#define FRAME_death307        	349
#define FRAME_death308        	350
#define FRAME_death309        	351
#define FRAME_death310        	352
#define FRAME_death311        	353
#define FRAME_death312        	354
#define FRAME_death313        	355
#define FRAME_death314        	356
#define FRAME_death315        	357
#define FRAME_death316        	358
#define FRAME_death317        	359
#define FRAME_death318        	360
#define FRAME_death319        	361
#define FRAME_death320        	362
#define FRAME_death321        	363
#define FRAME_death322        	364
#define FRAME_death323        	365
#define FRAME_death324        	366
#define FRAME_death325        	367
#define FRAME_death326        	368
#define FRAME_death327        	369
#define FRAME_death328        	370
#define FRAME_death329        	371
#define FRAME_death330        	372
#define FRAME_death331        	373
#define FRAME_death332        	374
#define FRAME_death333        	375
#define FRAME_death334        	376
#define FRAME_death335        	377
#define FRAME_death336        	378
#define FRAME_death337        	379
#define FRAME_death338        	380
#define FRAME_death339        	381
#define FRAME_death340        	382
#define FRAME_death341        	383
#define FRAME_death342        	384
#define FRAME_death343        	385
#define FRAME_death344        	386
#define FRAME_death345        	387
#define FRAME_death401        	388
#define FRAME_death402        	389
#define FRAME_death403        	390
#define FRAME_death404        	391
#define FRAME_death405        	392
#define FRAME_death406        	393
#define FRAME_death407        	394
#define FRAME_death408        	395
#define FRAME_death409        	396
#define FRAME_death410        	397
#define FRAME_death411        	398
#define FRAME_death412        	399
#define FRAME_death413        	400
#define FRAME_death414        	401
#define FRAME_death415        	402
#define FRAME_death416        	403
#define FRAME_death417        	404
#define FRAME_death418        	405
#define FRAME_death419        	406
#define FRAME_death420        	407
#define FRAME_death421        	408
#define FRAME_death422        	409
#define FRAME_death423        	410
#define FRAME_death424        	411
#define FRAME_death425        	412
#define FRAME_death426        	413
#define FRAME_death427        	414
#define FRAME_death428        	415
#define FRAME_death429        	416
#define FRAME_death430        	417
#define FRAME_death431        	418
#define FRAME_death432        	419
#define FRAME_death433        	420
#define FRAME_death434        	421
#define FRAME_death435        	422
#define FRAME_death436        	423
#define FRAME_death437        	424
#define FRAME_death438        	425
#define FRAME_death439        	426
#define FRAME_death440        	427
#define FRAME_death441        	428
#define FRAME_death442        	429
#define FRAME_death443        	430
#define FRAME_death444        	431
#define FRAME_death445        	432
#define FRAME_death446        	433
#define FRAME_death447        	434
#define FRAME_death448        	435
#define FRAME_death449        	436
#define FRAME_death450        	437
#define FRAME_death451        	438
#define FRAME_death452        	439
#define FRAME_death453        	440
#define FRAME_death501        	441
#define FRAME_death502        	442
#define FRAME_death503        	443
#define FRAME_death504        	444
#define FRAME_death505        	445
#define FRAME_death506        	446
#define FRAME_death507        	447
#define FRAME_death508        	448
#define FRAME_death509        	449
#define FRAME_death510        	450
#define FRAME_death511        	451
#define FRAME_death512        	452
#define FRAME_death513        	453
#define FRAME_death514        	454
#define FRAME_death515        	455
#define FRAME_death516        	456
#define FRAME_death517        	457
#define FRAME_death518        	458
#define FRAME_death519        	459
#define FRAME_death520        	460
#define FRAME_death521        	461
#define FRAME_death522        	462
#define FRAME_death523        	463
#define FRAME_death524        	464
#define FRAME_death601        	465
#define FRAME_death602        	466
#define FRAME_death603        	467
#define FRAME_death604        	468
#define FRAME_death605        	469
#define FRAME_death606        	470
#define FRAME_death607        	471
#define FRAME_death608        	472
#define FRAME_death609        	473
#define FRAME_death610        	474
X
#define MODEL_SCALE		1.200000
SHAR_EOF
  $shar_touch -am 1130175398 'm_soldier.h' &&
  chmod 0664 'm_soldier.h' ||
  $echo 'restore of' 'm_soldier.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_soldier.h:' 'MD5 check failed'
dcbb27342d78dc777f5715fbf6e05b9a  m_soldier.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_soldier.h'`"
    test 16643 -eq "$shar_count" ||
    $echo 'm_soldier.h:' 'original size' '16643,' 'current size' "$shar_count!"
  fi
fi
# ============= m_stalker.c ==============
if test -f 'm_stalker.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_stalker.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_stalker.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_stalker.c' &&
/*
==============================================================================
X
stalker
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_stalker.h"
#include <float.h>
X
static int	sound_pain;
static int	sound_die;
static int	sound_sight;
static int  sound_punch_hit1;
static int  sound_punch_hit2;
static int	sound_idle;
X
int stalker_do_pounce(edict_t *self, vec3_t dest);
void stalker_stand (edict_t *self);
void stalker_run (edict_t *self);
void stalker_walk (edict_t *self);
void stalker_jump (edict_t *self);
void stalker_dodge_jump (edict_t *self);
void stalker_swing_check_l (edict_t *self);
void stalker_swing_check_r (edict_t *self);
void stalker_swing_attack (edict_t *self);
void stalker_jump_straightup (edict_t *self);
void stalker_jump_wait_land (edict_t *self);
void stalker_false_death (edict_t *self);
void stalker_false_death_start (edict_t *self);
qboolean stalker_ok_to_transition (edict_t *self);
X
#define STALKER_ON_CEILING(ent)  ( ent->gravityVector[2] > 0 ? 1 : 0 )
X
//extern qboolean SV_StepDirection (edict_t *ent, float yaw, float dist);
extern qboolean SV_PointCloseEnough (edict_t *ent, vec3_t goal, float dist);
extern void drawbbox(edict_t *self);
X
//=========================
//=========================
qboolean stalker_ok_to_transition (edict_t *self)
{
X	trace_t		trace;
X	vec3_t		pt, start;
X	float		max_dist;
X	float		margin;
X	float		end_height;
X
X	if(STALKER_ON_CEILING(self))
X	{
X		max_dist = -384;
X		margin = self->mins[2] - 8;
X	}	
X	else
X	{
X		// her stalkers are just better
X		if (self->monsterinfo.aiflags & AI_SPAWNED_WIDOW)
X			max_dist = 256;
X		else
X			max_dist = 180;
X		margin = self->maxs[2] + 8;
X	}
X
X	VectorCopy(self->s.origin, pt);
X	pt[2] += max_dist;
X	trace = gi.trace (self->s.origin, self->mins, self->maxs, pt, self, MASK_MONSTERSOLID);
X
X	if(trace.fraction == 1.0 || 
X	   !(trace.contents & CONTENTS_SOLID) ||
X	   (trace.ent != world))
X	{
X		if(STALKER_ON_CEILING(self))
X		{
X			if(trace.plane.normal[2] < 0.9)
X				return false;
X		}
X		else
X		{
X			if(trace.plane.normal[2] > -0.9)
X				return false;
X		}
X	}
//	gi.dprintf("stalker_check_pt: main check ok\n");
X
X	end_height = trace.endpos[2];
X
X	// check the four corners, tracing only to the endpoint of the center trace (vertically).
X	pt[0] = self->absmin[0];
X	pt[1] = self->absmin[1];
X	pt[2] = trace.endpos[2] + margin;	// give a little margin of error to allow slight inclines
X	VectorCopy(pt, start);
X	start[2] = self->s.origin[2];
X	trace = gi.trace( start, vec3_origin, vec3_origin, pt, self, MASK_MONSTERSOLID);
X	if(trace.fraction == 1.0 || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
X	{
//		gi.dprintf("stalker_check_pt: absmin/absmin failed\n");
X		return false;
X	}
X	if(abs(end_height + margin - trace.endpos[2]) > 8)
X		return false;
X
X	pt[0] = self->absmax[0];
X	pt[1] = self->absmin[1];
X	VectorCopy(pt, start);
X	start[2] = self->s.origin[2];
X	trace = gi.trace( start, vec3_origin, vec3_origin, pt, self, MASK_MONSTERSOLID);
X	if(trace.fraction == 1.0 || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
X	{
//		gi.dprintf("stalker_check_pt: absmax/absmin failed\n");
X		return false;
X	}
X	if(abs(end_height + margin - trace.endpos[2]) > 8)
X		return false;
X
X	pt[0] = self->absmax[0];
X	pt[1] = self->absmax[1];
X	VectorCopy(pt, start);
X	start[2] = self->s.origin[2];
X	trace = gi.trace( start, vec3_origin, vec3_origin, pt, self, MASK_MONSTERSOLID);
X	if(trace.fraction == 1.0 || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
X	{
//		gi.dprintf("stalker_check_pt: absmax/absmax failed\n");
X		return false;
X	}
X	if(abs(end_height + margin - trace.endpos[2]) > 8)
X		return false;
X
X	pt[0] = self->absmin[0];
X	pt[1] = self->absmax[1];
X	VectorCopy(pt, start);
X	start[2] = self->s.origin[2];
X	trace = gi.trace( start, vec3_origin, vec3_origin, pt, self, MASK_MONSTERSOLID);
X	if(trace.fraction == 1.0 || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
X	{
//		gi.dprintf("stalker_check_pt: absmin/absmax failed\n");
X		return false;
X	}
X	if(abs(end_height + margin - trace.endpos[2]) > 8)
X		return false;
X
X	return true;
}
X
//=========================
//=========================
void stalker_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_WEAPON, sound_sight, 1, ATTN_NORM, 0);
}
X
// ******************
// IDLE
// ******************
X
void stalker_idle_noise (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_idle, 0.5, ATTN_IDLE, 0);
}
X
mframe_t stalker_frames_idle [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, stalker_idle_noise,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL
};
mmove_t stalker_move_idle = {FRAME_idle01, FRAME_idle21, stalker_frames_idle, stalker_stand};
X
mframe_t stalker_frames_idle2 [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t stalker_move_idle2 = {FRAME_idle201, FRAME_idle213, stalker_frames_idle2, stalker_stand};
X
void stalker_idle (edict_t *self)
{ 
X	if (random() < 0.35)
X		self->monsterinfo.currentmove = &stalker_move_idle;
X	else
X		self->monsterinfo.currentmove = &stalker_move_idle2;
}
X
// ******************
// STAND
// ******************
X
mframe_t stalker_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, stalker_idle_noise,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL
};
mmove_t	stalker_move_stand = {FRAME_idle01, FRAME_idle21, stalker_frames_stand, stalker_stand};
X
void stalker_stand (edict_t *self)
{
X	if (random() < 0.25)
X		self->monsterinfo.currentmove = &stalker_move_stand;
X	else
X		self->monsterinfo.currentmove = &stalker_move_idle2;
}
X
// ******************
// RUN
// ******************
X
mframe_t stalker_frames_run [] =
{
X	ai_run, 13, NULL,
X	ai_run, 17, NULL,
X	ai_run, 21, NULL,
X	ai_run, 18, NULL
X
/*	ai_run, 15, NULL,
X	ai_run, 20, NULL,
X	ai_run, 18, NULL,
X	ai_run, 14, NULL*/
};
mmove_t stalker_move_run = {FRAME_run01, FRAME_run04, stalker_frames_run, NULL};
X
void stalker_run (edict_t *self)
{
//	gi.dprintf("stalker_run %5.1f\n", level.time);
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &stalker_move_stand;
X	else
X		self->monsterinfo.currentmove = &stalker_move_run;
}
X
// ******************
// WALK
// ******************
X
mframe_t stalker_frames_walk [] =
{
X	ai_walk, 4, NULL,
X	ai_walk, 6, NULL,
X	ai_walk, 8, NULL,
X	ai_walk, 5, NULL,
X
X	ai_walk, 4, NULL,
X	ai_walk, 6, NULL,
X	ai_walk, 8, NULL,
X	ai_walk, 4, NULL
};
mmove_t stalker_move_walk = {FRAME_walk01, FRAME_walk08, stalker_frames_walk, stalker_walk};
X
void stalker_walk (edict_t *self)
{
//	gi.dprintf("stalker_walk\n");
X	self->monsterinfo.currentmove = &stalker_move_walk;
}
X
// ******************
// false death
// ******************
mframe_t stalker_frames_reactivate [] = 
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t stalker_move_false_death_end = { FRAME_reactive01, FRAME_reactive04, stalker_frames_reactivate, stalker_run };
X
void stalker_reactivate (edict_t *self)
{
X	self->monsterinfo.aiflags &= ~AI_STAND_GROUND;
X	self->monsterinfo.currentmove = &stalker_move_false_death_end;
}
X
void stalker_heal (edict_t *self)
{
X	if(skill->value == 2)
X		self->health+=2;
X	else if(skill->value == 3)
X		self->health+=3;
X	else
X		self->health++;
X
//	gi.dprintf("stalker_heal: %d\n", self->health);
X
X	if(self->health > (self->max_health/2))
X		self->s.skinnum = 0;
X
X	if(self->health >= self->max_health)
X	{
X		self->health = self->max_health;
X		stalker_reactivate(self);
X	}
}
X
mframe_t stalker_frames_false_death [] =
{
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal,
X
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal,
X	ai_move, 0, stalker_heal
};
mmove_t stalker_move_false_death = {FRAME_twitch01, FRAME_twitch10, stalker_frames_false_death, stalker_false_death};
X
void stalker_false_death (edict_t *self)
{
X	self->monsterinfo.currentmove = &stalker_move_false_death;
}
X
mframe_t stalker_frames_false_death_start [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
};
mmove_t stalker_move_false_death_start = {FRAME_death01, FRAME_death09, stalker_frames_false_death_start, stalker_false_death};
X
void stalker_false_death_start (edict_t *self)
{
X	self->s.angles[2] = 0;
X	VectorSet(self->gravityVector, 0, 0, -1);
X
X	self->monsterinfo.aiflags |= AI_STAND_GROUND;
X	self->monsterinfo.currentmove = &stalker_move_false_death_start;
}
X
X
// ******************
// PAIN
// ******************
X
mframe_t stalker_frames_pain [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0,	NULL,
X	ai_move, 0, NULL
};
mmove_t stalker_move_pain = {FRAME_pain01, FRAME_pain04, stalker_frames_pain, stalker_run};
X
void stalker_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
X	if (self->health < (self->max_health / 2)) 
X	{
X		self->s.skinnum = 1;
X	}
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
//	if (self->monsterinfo.aiflags & AI_DODGING)
//		monster_done_dodge (self);
X
X	if (self->groundentity == NULL)
X		return;
X
X	// if we're reactivating or false dying, ignore the pain.
X	if (self->monsterinfo.currentmove == &stalker_move_false_death_end ||
X		self->monsterinfo.currentmove == &stalker_move_false_death_start )
X		return;
X
X	if (self->monsterinfo.currentmove == &stalker_move_false_death)
X	{
X		stalker_reactivate(self);
X		return;
X	}
X
X	if ((self->health > 0) && (self->health < (self->max_health / 4)))
X	{
X		if(random() < (0.2 * skill->value))
X		{
X			if( !STALKER_ON_CEILING(self) || stalker_ok_to_transition(self) )
X			{
//				gi.dprintf("starting false death sequence\n");
X				stalker_false_death_start(self);
X				return;
X			}
X		}	
X	}
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 3;
X
//	gi.dprintf("stalker_pain\n");
X	if (damage > 10)		// don't react unless the damage was significant
X	{
X		// stalker should dodge jump periodically to help avoid damage.
X		if(self->groundentity && (random() < 0.5))
X			stalker_dodge_jump(self);
X		else
X			self->monsterinfo.currentmove = &stalker_move_pain;
X
X		gi.sound (self, CHAN_WEAPON, sound_pain, 1, ATTN_NORM, 0);
X	}
}
X
X
// ******************
// STALKER ATTACK
// ******************
X
//extern qboolean infront (edict_t *self, edict_t *other);
X
void stalker_shoot_attack (edict_t *self)
{
X	vec3_t	offset, start, f, r, dir;
X	vec3_t	end;
X	float	time, dist;
X	trace_t	trace;
X
X	if(!has_valid_enemy(self))
X		return;
X
X	if(self->groundentity && random() < 0.33)
X	{
X		VectorSubtract (self->enemy->s.origin, self->s.origin, dir);
X		dist = VectorLength (dir);
X
X		if((dist > 256) || (random() < 0.5))
X			stalker_do_pounce(self, self->enemy->s.origin);
X		else
X			stalker_jump_straightup (self);
X	}
X
X	// FIXME -- keep this but use a custom one
//	if (!infront(self, self->enemy))
//		return;
X
X	AngleVectors (self->s.angles, f, r, NULL);
X	VectorSet (offset, 24, 0, 6);
X	G_ProjectSource (self->s.origin, offset, f, r, start);
X
X	VectorSubtract(self->enemy->s.origin, start, dir);
X	if(random() < (0.20 + 0.1 * skill->value))
X	{
X		dist = VectorLength(dir);
X		time = dist / 1000;
X		VectorMA(self->enemy->s.origin, time, self->enemy->velocity, end);
X		VectorSubtract(end, start, dir);
X	}
X	else
X		VectorCopy(self->enemy->s.origin, end);
X
X	trace = gi.trace(start, vec3_origin, vec3_origin, end, self, MASK_SHOT);
X	if(trace.ent == self->enemy || trace.ent == world)
X		monster_fire_blaster2(self, start, dir, 15, 800, MZ2_STALKER_BLASTER, EF_BLASTER);
//	else
//		gi.dprintf("blocked by entity %s\n", trace.ent->classname);
}
X
void stalker_shoot_attack2 (edict_t *self)
{
//	if (random() < (0.4+(float)skill->value))
//		stalker_shoot_attack (self);
X
X	if (random() < (0.4 + (0.1 * (float)skill->value)))
X		stalker_shoot_attack (self);
}
X
mframe_t stalker_frames_shoot [] =
{
X	ai_charge, 13, NULL,
X	ai_charge, 17, stalker_shoot_attack,
X	ai_charge, 21, NULL,
X	ai_charge, 18, stalker_shoot_attack2
};
mmove_t stalker_move_shoot = {FRAME_run01, FRAME_run04, stalker_frames_shoot, stalker_run};
X
void stalker_attack_ranged (edict_t *self)
{
X	if(!has_valid_enemy(self))
X		return;
X
X	// PMM - circle strafe stuff
X	if (random() > (1.0 - (0.5/(float)(skill->value))))
X	{
X		self->monsterinfo.attack_state = AS_STRAIGHT;
X	}
X	else
X	{
X		if (random () <= 0.5) // switch directions
X			self->monsterinfo.lefty = 1 - self->monsterinfo.lefty;
X		self->monsterinfo.attack_state = AS_SLIDING;
X	}
X	self->monsterinfo.currentmove = &stalker_move_shoot;
}
X
// ******************
// close combat
// ******************
X
void stalker_swing_attack (edict_t *self)
{
X	vec3_t	aim;
X
X	VectorSet (aim, MELEE_DISTANCE, 0, 0);
X	if (fire_hit (self, aim, (5 + (rand() % 5)), 50))
X		if (self->s.frame < FRAME_attack08)
X			gi.sound (self, CHAN_WEAPON, sound_punch_hit2, 1, ATTN_NORM, 0);
X		else
X			gi.sound (self, CHAN_WEAPON, sound_punch_hit1, 1, ATTN_NORM, 0);
}
X
mframe_t stalker_frames_swing_l [] =
{
X	ai_charge, 2, NULL,
X	ai_charge, 4, NULL,
X	ai_charge, 6, NULL,
X	ai_charge, 10, NULL,
X
X	ai_charge, 5, stalker_swing_attack,
X	ai_charge, 5, NULL,
X	ai_charge, 5, NULL,
X	ai_charge, 5, NULL  // stalker_swing_check_l
};
mmove_t stalker_move_swing_l = {FRAME_attack01, FRAME_attack08, stalker_frames_swing_l, stalker_run};
X
mframe_t stalker_frames_swing_r [] =
{
X	ai_charge, 4, NULL,
X	ai_charge, 6, NULL,
X	ai_charge, 6, stalker_swing_attack,
X	ai_charge, 10, NULL,
X	ai_charge, 5, NULL	// stalker_swing_check_r
};
mmove_t stalker_move_swing_r = {FRAME_attack11, FRAME_attack15, stalker_frames_swing_r, stalker_run};
X
void stalker_attack_melee (edict_t *self)
{
X	if(!has_valid_enemy(self))
X		return;
X
X	if(random() < 0.5)
X	{
X		self->monsterinfo.currentmove = &stalker_move_swing_l;
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &stalker_move_swing_r;
X	}
}
X
X
// ******************
// POUNCE
// ******************
X
#define PI 3.14159
#define RAD2DEG(x)	(x * (float)180.0 / (float)PI)
#define DEG2RAD(x)	(x * (float)PI / (float)180.0)
#define FAUX_GRAVITY	800.0
X
// ====================
// ====================
void calcJumpAngle(vec3_t start, vec3_t end, float velocity, vec3_t angles)
{
X	float	distV, distH;
X	float	one, cosU;
X	float	l, U;
X	vec3_t	dist;
X
X	VectorSubtract(end, start, dist);
X	distH = (float)sqrt(dist[0]*dist[0] + dist[1]*dist[1]);
X	distV = dist[2];
X	if(distV < 0)
X		distV = 0 - distV;
X
X	if(distV)
X	{
X		l = (float) sqrt(distH*distH + distV*distV);
X		U = (float) atan(distV / distH);
X		if(dist[2] > 0)
X			U = (float)0.0 - U;
X
X		angles[2] = 0.0;
X
X		cosU = (float)cos(U);
X		one = l * FAUX_GRAVITY * (cosU * cosU);
X		one = one / (velocity * velocity);
X		one = one - (float)sin(U);
X	//	one = ((l * FAUX_GRAVITY * (cosU * cosU)) / (velocity * velocity)) - (float)sin(U);
X		angles[0] = (float)asin(one);
X		if(_isnan(angles[0]))
X			angles[2] = 1.0;
X		angles[1] = (float)PI - angles[0];
X		if(_isnan(angles[1]))
X			angles[2] = 1.0;
X
X		angles[0] = RAD2DEG ( (angles[0] - U) / 2.0 );
X		angles[1] = RAD2DEG ( (angles[1] - U) / 2.0 );
X	}
X	else
X	{
X		l = (float) sqrt(distH*distH + distV*distV);
X
X		angles[2] = 0.0;
X
X		one = l * FAUX_GRAVITY;
X		one = one / (velocity * velocity);
X		angles[0] = (float)asin(one);
X		if(_isnan(angles[0]))
X			angles[2] = 1.0;
X		angles[1] = (float)PI - angles[0];
X		if(_isnan(angles[1]))
X			angles[2] = 1.0;
X
X		angles[0] = RAD2DEG ( (angles[0]) / 2.0 );
X		angles[1] = RAD2DEG ( (angles[1]) / 2.0 );
X	}
}
X
// ====================
// ====================
int stalker_check_lz (edict_t *self, edict_t *target, vec3_t dest)
{
X	vec3_t	jumpLZ;
X
X	if( (gi.pointcontents (dest) & MASK_WATER) || (target->waterlevel))
X	{
//		gi.dprintf ("you won't make me jump in water!\n");
X		return false;
X	}
X
X	if( !target->groundentity )
X	{
//		gi.dprintf( "I'll wait until you land..\n");
X		return false;
X	}
X
X	// check under the player's four corners
X	// if they're not solid, bail.
X	jumpLZ[0] = self->enemy->mins[0];
X	jumpLZ[1] = self->enemy->mins[1];
X	jumpLZ[2] = self->enemy->mins[2] - 0.25;
X	if( !(gi.pointcontents (jumpLZ) & MASK_SOLID) )
X		return false;
X
X	jumpLZ[0] = self->enemy->maxs[0];
X	jumpLZ[1] = self->enemy->mins[1];
X	if( !(gi.pointcontents (jumpLZ) & MASK_SOLID) )
X		return false;
X
X	jumpLZ[0] = self->enemy->maxs[0];
X	jumpLZ[1] = self->enemy->maxs[1];
X	if( !(gi.pointcontents (jumpLZ) & MASK_SOLID) )
X		return false;
X
X	jumpLZ[0] = self->enemy->mins[0];
X	jumpLZ[1] = self->enemy->maxs[1];
X	if( !(gi.pointcontents (jumpLZ) & MASK_SOLID) )
X		return false;
X
X	return true;
}
X
// ====================
// ====================
int stalker_do_pounce(edict_t *self, vec3_t dest)
{
X	vec3_t	forward, right;
X	vec3_t	dist;
X	vec_t	length;
X	vec3_t	jumpAngles;
X	vec3_t	jumpLZ;
X	float	velocity = 400.1;
X	trace_t	trace;
X	int		preferHighJump;
X
X	// don't pounce when we're on the ceiling
X	if(STALKER_ON_CEILING(self))
X		return false;
X
X	if(!stalker_check_lz (self, self->enemy, dest))
X		return false;
X
X	VectorSubtract(dest, self->s.origin, dist);
X	
X	// make sure we're pointing in that direction 15deg margin of error.
X	vectoangles2 (dist, jumpAngles);
X	if(abs(jumpAngles[YAW] - self->s.angles[YAW]) > 45)
X		return false;			// not facing the player...
X
X	self->ideal_yaw = jumpAngles[YAW];
X	M_ChangeYaw(self);
X
X	length = VectorLength(dist);
X	if(length > 450)
X		return false;			// can't jump that far...
X
X	VectorCopy(dest, jumpLZ);
X
X	preferHighJump = 0;
X
X	// if we're having to jump up a distance, jump a little too high to compensate.
X	if(dist[2] >= 32.0)
X	{
X		preferHighJump = 1;
X		jumpLZ[2] += 32;
X	}
X
X	trace = gi.trace (self->s.origin, vec3_origin, vec3_origin, dest, self, MASK_MONSTERSOLID);
X	if((trace.fraction < 1) && (trace.ent != self->enemy))
X	{
//		gi.dprintf("prefer high jump angle\n");
X		preferHighJump = 1; 
X	}
X
X	// find a valid angle/velocity combination
X	while(velocity <= 800)
X	{
X		calcJumpAngle(self->s.origin, jumpLZ, velocity, jumpAngles);
X		if((!_isnan(jumpAngles[0]))  || (!_isnan(jumpAngles[1])))
X			break;
X		
X		velocity+=200;
X	};
X
X	if(!preferHighJump && (!_isnan(jumpAngles[0])) )
X	{
X		AngleVectors (self->s.angles, forward, right, NULL);
X		VectorNormalize ( forward ) ;
X
X		VectorScale( forward, velocity * cos(DEG2RAD(jumpAngles[0])), self->velocity);
X		self->velocity[2] = velocity * sin(DEG2RAD(jumpAngles[0])) + (0.5 * sv_gravity->value * FRAMETIME);
//		gi.dprintf("  pouncing! %0.1f,%0.1f (%0.1f)  --> %0.1f, %0.1f, %0.1f\n", 
//				jumpAngles[0], jumpAngles[1], jumpAngles[0],
//				self->velocity[0], self->velocity[1], self->velocity[2]);
X		return 1;
X	}
X
X	if(!_isnan(jumpAngles[1]))
X	{
X		AngleVectors (self->s.angles, forward, right, NULL);
X		VectorNormalize ( forward ) ;
X
X		VectorScale( forward, velocity * cos(DEG2RAD(jumpAngles[1])), self->velocity);
X		self->velocity[2] = velocity * sin(DEG2RAD(jumpAngles[1])) + (0.5 * sv_gravity->value * FRAMETIME);
//		gi.dprintf("  pouncing! %0.1f,%0.1f (%0.1f)  --> %0.1f, %0.1f, %0.1f\n", 
//				jumpAngles[0], jumpAngles[1], jumpAngles[1],
//				self->velocity[0], self->velocity[1], self->velocity[2]);
X		return 1;
X	}
X
//	gi.dprintf("  nan\n");
X	return 0;
}
X
// ******************
// DODGE
// ******************
X
//===================
// stalker_jump_straightup
//===================
void stalker_jump_straightup (edict_t *self)
{
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
X	if(STALKER_ON_CEILING(self))
X	{
X		if(stalker_ok_to_transition(self))
X		{
//			gi.dprintf("falling off ceiling %d\n", self->health);
X			self->gravityVector[2] = -1;
X			self->s.angles[2] += 180.0;
X			if(self->s.angles[2] > 360.0)
X				self->s.angles[2] -= 360.0;
X			self->groundentity = NULL;
X		}
X	}
X	else if(self->groundentity)	// make sure we're standing on SOMETHING...
X	{
X		self->velocity[0] += ((random() * 10) - 5);
X		self->velocity[1] += ((random() * 10) - 5);
X		self->velocity[2] += -400 * self->gravityVector[2];
X		if(stalker_ok_to_transition(self))
X		{
//			gi.dprintf("falling TO ceiling %d\n", self->health);
X			self->gravityVector[2] = 1;
X			self->s.angles[2] = 180.0;
X			self->groundentity = NULL;
X		}
X	}
}
X
mframe_t stalker_frames_jump_straightup [] =
{
X	ai_move, 1,  stalker_jump_straightup,
X	ai_move, 1,  stalker_jump_wait_land,
X	ai_move, -1, NULL,
X	ai_move, -1, NULL
};
X
mmove_t	stalker_move_jump_straightup = {FRAME_jump04, FRAME_jump07, stalker_frames_jump_straightup, stalker_run};
X
//===================
// stalker_dodge_jump - abstraction so pain function can trigger a dodge jump too without
//		faking the inputs to stalker_dodge
//===================
void stalker_dodge_jump (edict_t *self)
{
X	self->monsterinfo.currentmove = &stalker_move_jump_straightup;
}
X
mframe_t stalker_frames_dodge_run [] =
{
X	ai_run, 13, NULL,
X	ai_run, 17, NULL,
X	ai_run, 21, NULL,
X	ai_run, 18, monster_done_dodge
};
mmove_t stalker_move_dodge_run = {FRAME_run01, FRAME_run04, stalker_frames_dodge_run, NULL};
X
void stalker_dodge (edict_t *self, edict_t *attacker, float eta, trace_t *tr)
{
X	if (!self->groundentity || self->health <= 0)
X		return;
X
X	if (!self->enemy)
X	{
X		self->enemy = attacker;
X		FoundTarget(self);
X		return;
X	}
X	
X	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
X	// seeing numbers like 13 and 14)
X	if ((eta < 0.1) || (eta > 5))
X		return;
X
X	// this will override the foundtarget call of stalker_run
X	stalker_dodge_jump(self);
}
X
X
// ******************
// Jump onto / off of things
// ******************
X
//===================
//===================
void stalker_jump_down (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 100, forward, self->velocity);
X	VectorMA(self->velocity, 300, up, self->velocity);
}
X
//===================
//===================
void stalker_jump_up (edict_t *self)
{
X	vec3_t	forward,up;
X
X	monster_jump_start (self);
X
X	AngleVectors (self->s.angles, forward, NULL, up);
X	VectorMA(self->velocity, 200, forward, self->velocity);
X	VectorMA(self->velocity, 450, up, self->velocity);
}
X
//===================
//===================
void stalker_jump_wait_land (edict_t *self)
{
X	if ((random() < (0.3 + (0.1*(float)(skill->value)))) && (level.time >= self->monsterinfo.attack_finished))
X	{
X		self->monsterinfo.attack_finished = level.time + 0.3;
X		stalker_shoot_attack(self);
X	}
X
X	if(self->groundentity == NULL)
X	{
X		self->gravity = 1.3;
X		self->monsterinfo.nextframe = self->s.frame;
X
X		if(monster_jump_finished (self))
X		{
X			self->gravity = 1;
X			self->monsterinfo.nextframe = self->s.frame + 1;
X		}
X	}
X	else 
X	{
X		self->gravity = 1;
X		self->monsterinfo.nextframe = self->s.frame + 1;
X	}
}
X
mframe_t stalker_frames_jump_up [] =
{
X	ai_move, -8, NULL,
X	ai_move, -8, NULL,
X	ai_move, -8, NULL,
X	ai_move, -8, NULL,
X
X	ai_move, 0, stalker_jump_up,
X	ai_move, 0, stalker_jump_wait_land,
X	ai_move, 0, NULL
};
mmove_t stalker_move_jump_up = { FRAME_jump01, FRAME_jump07, stalker_frames_jump_up, stalker_run };
X
mframe_t stalker_frames_jump_down [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	
X	ai_move, 0, stalker_jump_down,
X	ai_move, 0, stalker_jump_wait_land,
X	ai_move, 0, NULL
};
mmove_t stalker_move_jump_down = { FRAME_jump01, FRAME_jump07, stalker_frames_jump_down, stalker_run };
X
//============
// stalker_jump - this is only used for jumping onto or off of things. for dodge jumping,
//		use stalker_dodge_jump
//============
void stalker_jump (edict_t *self)
{
X	if(!self->enemy)
X		return;
X
X	if(self->enemy->s.origin[2] >= self->s.origin[2])
X	{
//		gi.dprintf("stalker_jump_up\n");
X		self->monsterinfo.currentmove = &stalker_move_jump_up;
X	}
X	else
X	{
//		gi.dprintf("stalker_jump_down\n");
X		self->monsterinfo.currentmove = &stalker_move_jump_down;
X	}
}
X
X
// ******************
// Blocked
// ******************
X
qboolean stalker_blocked (edict_t *self, float dist)
{
X	qboolean	onCeiling;
X
//	gi.dprintf("stalker_blocked\n");
X	if(!has_valid_enemy(self))
X		return false;
X
X	onCeiling = false;
X	if(self->gravityVector[2] > 0)
X		onCeiling = true;
X
X	if(!onCeiling)
X	{
X		if(blocked_checkshot(self, 0.25 + (0.05 * skill->value) ))
X		{
//			gi.dprintf("blocked: shooting\n");
X			return true;
X		}
X
X		if(visible (self, self->enemy))
X		{
//			gi.dprintf("blocked: jumping at player!\n");
X			stalker_do_pounce(self, self->enemy->s.origin);
X			return true;
X		}
X
X		if(blocked_checkjump (self, dist, 256, 68))
X		{
//			gi.dprintf("blocked: jumping up/down\n");
X			stalker_jump (self);
X			return true;
X		}
X
X		if(blocked_checkplat (self, dist))
X			return true;
X	}
X	else
X	{
X		if(blocked_checkshot(self, 0.25 + (0.05 * skill->value) ))
X		{
//			gi.dprintf("blocked: shooting\n");
X			return true;
X		}	
X		else if(stalker_ok_to_transition(self))
X		{
X			self->gravityVector[2] = -1;
X			self->s.angles[2] += 180.0;
X			if(self->s.angles[2] > 360.0)
X				self->s.angles[2] -= 360.0;
X			self->groundentity = NULL;
X			
//			gi.dprintf("falling off ceiling\n");
X			return true;
X		}
//		else
//			gi.dprintf("Not OK to fall!\n");
X	}
X
X	return false;
}
X
// ******************
// Death
// ******************
X
void stalker_dead (edict_t *self)
{
X	VectorSet (self->mins, -28, -28, -18);
X	VectorSet (self->maxs, 28, 28, -4);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
//	drawbbox(self);
}
X
mframe_t stalker_frames_death [] =
{
X	ai_move, 0,	 NULL,
X	ai_move, -5,	 NULL,
X	ai_move, -10,	 NULL,
X	ai_move, -20,	 NULL,
X	
X	ai_move, -10,	 NULL,
X	ai_move, -10,	 NULL,
X	ai_move, -5,	 NULL,
X	ai_move, -5,	 NULL,
X
X	ai_move, 0,	 NULL
};
mmove_t stalker_move_death = {FRAME_death01, FRAME_death09, stalker_frames_death, stalker_dead};
X
void stalker_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
//	gi.dprintf("stalker_die: %d\n", self->health);
X
// dude bit it, make him fall!
X	self->movetype = MOVETYPE_TOSS;
X	self->s.angles[2] = 0;
X	VectorSet(self->gravityVector, 0, 0, -1);
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowGib (self, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X	self->monsterinfo.currentmove = &stalker_move_death;
}
X
X
// ******************
// SPAWN
// ******************
X
/*QUAKED monster_stalker (1 .5 0) (-28 -28 -18) (28 28 18) Ambush Trigger_Spawn Sight OnRoof
Spider Monster
X
X  ONROOF - Monster starts sticking to the roof.
*/
void SP_monster_stalker (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain = gi.soundindex ("stalker/pain.wav");	
X	sound_die = gi.soundindex ("stalker/death.wav");	
X	sound_sight = gi.soundindex("stalker/sight.wav");
X	sound_punch_hit1 = gi.soundindex ("stalker/melee1.wav");
X	sound_punch_hit2 = gi.soundindex ("stalker/melee2.wav");
X	sound_idle = gi.soundindex ("stalker/idle.wav");
X
X	// PMM - precache bolt2
X	gi.modelindex ("models/proj/laser2/tris.md2");
X
X	self->s.modelindex = gi.modelindex ("models/monsters/stalker/tris.md2");
X	VectorSet (self->mins, -28, -28, -18);
X	VectorSet (self->maxs, 28, 28, 18);
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X
X	self->health = 250;
X	self->gib_health = -50;		// FIXME 
X	self->mass = 250;
X
X	self->pain = stalker_pain;
X	self->die = stalker_die;
X
X	self->monsterinfo.stand = stalker_stand;
X	self->monsterinfo.walk = stalker_walk;
X	self->monsterinfo.run = stalker_run;
X	self->monsterinfo.attack = stalker_attack_ranged;
X	self->monsterinfo.sight = stalker_sight;
X	self->monsterinfo.idle = stalker_idle;
X	self->monsterinfo.dodge = stalker_dodge;
X	self->monsterinfo.blocked = stalker_blocked;
X	self->monsterinfo.melee = stalker_attack_melee;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &stalker_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	self->monsterinfo.aiflags |= AI_WALK_WALLS;
X
X	if(self->spawnflags & 8)
X	{
X		self->s.angles[2] = 180;
X		self->gravityVector[2] = 1;
X	}
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_stalker.c' &&
  chmod 0664 'm_stalker.c' ||
  $echo 'restore of' 'm_stalker.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_stalker.c:' 'MD5 check failed'
23ba142f0f66251ce8431a23e0c98f59  m_stalker.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_stalker.c'`"
    test 29112 -eq "$shar_count" ||
    $echo 'm_stalker.c:' 'original size' '29112,' 'current size' "$shar_count!"
  fi
fi
# ============= m_stalker.h ==============
if test -f 'm_stalker.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_stalker.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_stalker.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_stalker.h' &&
// /expanse/quake2/xpack/models/monsters/stalker
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_idle01          	0
#define FRAME_idle02          	1
#define FRAME_idle03          	2
#define FRAME_idle04          	3
#define FRAME_idle05          	4
#define FRAME_idle06          	5
#define FRAME_idle07          	6
#define FRAME_idle08          	7
#define FRAME_idle09          	8
#define FRAME_idle10          	9
#define FRAME_idle11          	10
#define FRAME_idle12          	11
#define FRAME_idle13          	12
#define FRAME_idle14          	13
#define FRAME_idle15          	14
#define FRAME_idle16          	15
#define FRAME_idle17          	16
#define FRAME_idle18          	17
#define FRAME_idle19          	18
#define FRAME_idle20          	19
#define FRAME_idle21          	20
#define FRAME_idle201         	21
#define FRAME_idle202         	22
#define FRAME_idle203         	23
#define FRAME_idle204         	24
#define FRAME_idle205         	25
#define FRAME_idle206         	26
#define FRAME_idle207         	27
#define FRAME_idle208         	28
#define FRAME_idle209         	29
#define FRAME_idle210         	30
#define FRAME_idle211         	31
#define FRAME_idle212         	32
#define FRAME_idle213         	33
#define FRAME_walk01          	34
#define FRAME_walk02          	35
#define FRAME_walk03          	36
#define FRAME_walk04          	37
#define FRAME_walk05          	38
#define FRAME_walk06          	39
#define FRAME_walk07          	40
#define FRAME_walk08          	41
#define FRAME_jump01          	42
#define FRAME_jump02          	43
#define FRAME_jump03          	44
#define FRAME_jump04          	45
#define FRAME_jump05          	46
#define FRAME_jump06          	47
#define FRAME_jump07          	48
#define FRAME_run01           	49
#define FRAME_run02           	50
#define FRAME_run03           	51
#define FRAME_run04           	52
#define FRAME_attack01        	53
#define FRAME_attack02        	54
#define FRAME_attack03        	55
#define FRAME_attack04        	56
#define FRAME_attack05        	57
#define FRAME_attack06        	58
#define FRAME_attack07        	59
#define FRAME_attack08        	60
#define FRAME_attack11        	61
#define FRAME_attack12        	62
#define FRAME_attack13        	63
#define FRAME_attack14        	64
#define FRAME_attack15        	65
#define FRAME_pain01          	66
#define FRAME_pain02          	67
#define FRAME_pain03          	68
#define FRAME_pain04          	69
#define FRAME_death01         	70
#define FRAME_death02         	71
#define FRAME_death03         	72
#define FRAME_death04         	73
#define FRAME_death05         	74
#define FRAME_death06         	75
#define FRAME_death07         	76
#define FRAME_death08         	77
#define FRAME_death09         	78
#define FRAME_twitch01        	79
#define FRAME_twitch02        	80
#define FRAME_twitch03        	81
#define FRAME_twitch04        	82
#define FRAME_twitch05        	83
#define FRAME_twitch06        	84
#define FRAME_twitch07        	85
#define FRAME_twitch08        	86
#define FRAME_twitch09        	87
#define FRAME_twitch10        	88
#define FRAME_reactive01      	89
#define FRAME_reactive02      	90
#define FRAME_reactive03      	91
#define FRAME_reactive04      	92
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_stalker.h' &&
  chmod 0664 'm_stalker.h' ||
  $echo 'restore of' 'm_stalker.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_stalker.h:' 'MD5 check failed'
20d30e0e017933ff6a1c0aacf82585eb  m_stalker.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_stalker.h'`"
    test 3282 -eq "$shar_count" ||
    $echo 'm_stalker.h:' 'original size' '3282,' 'current size' "$shar_count!"
  fi
fi
# ============= m_supertank.c ==============
if test -f 'm_supertank.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_supertank.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_supertank.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_supertank.c' &&
/*
==============================================================================
X
SUPERTANK
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_supertank.h"
X
qboolean visible (edict_t *self, edict_t *other);
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_pain3;
static int	sound_death;
static int	sound_search1;
static int	sound_search2;
X
static	int	tread_sound;
X
void BossExplode (edict_t *self);
X
void TreadSound (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, tread_sound, 1, ATTN_NORM, 0);
}
X
void supertank_search (edict_t *self)
{
X	if (random() < 0.5)
X		gi.sound (self, CHAN_VOICE, sound_search1, 1, ATTN_NORM, 0);
X	else
X		gi.sound (self, CHAN_VOICE, sound_search2, 1, ATTN_NORM, 0);
}
X
X
void supertank_dead (edict_t *self);
void supertankRocket (edict_t *self);
void supertankMachineGun (edict_t *self);
void supertank_reattack1(edict_t *self);
X
X
//
// stand
//
X
mframe_t supertank_frames_stand []=
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	supertank_move_stand = {FRAME_stand_1, FRAME_stand_60, supertank_frames_stand, NULL};
X	
void supertank_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &supertank_move_stand;
}
X
X
mframe_t supertank_frames_run [] =
{
X	ai_run, 12,	TreadSound,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL,
X	ai_run, 12,	NULL
};
mmove_t	supertank_move_run = {FRAME_forwrd_1, FRAME_forwrd_18, supertank_frames_run, NULL};
X
//
// walk
//
X
X
mframe_t supertank_frames_forward [] =
{
X	ai_walk, 4,	TreadSound,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	NULL
};
mmove_t	supertank_move_forward = {FRAME_forwrd_1, FRAME_forwrd_18, supertank_frames_forward, NULL};
X
void supertank_forward (edict_t *self)
{
X		self->monsterinfo.currentmove = &supertank_move_forward;
}
X
void supertank_walk (edict_t *self)
{
X		self->monsterinfo.currentmove = &supertank_move_forward;
}
X
void supertank_run (edict_t *self)
{
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &supertank_move_stand;
X	else
X		self->monsterinfo.currentmove = &supertank_move_run;
}
X
mframe_t supertank_frames_turn_right [] =
{
X	ai_move,	0,	TreadSound,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_turn_right = {FRAME_right_1, FRAME_right_18, supertank_frames_turn_right, supertank_run};
X
mframe_t supertank_frames_turn_left [] =
{
X	ai_move,	0,	TreadSound,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_turn_left = {FRAME_left_1, FRAME_left_18, supertank_frames_turn_left, supertank_run};
X
X
mframe_t supertank_frames_pain3 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_pain3 = {FRAME_pain3_9, FRAME_pain3_12, supertank_frames_pain3, supertank_run};
X
mframe_t supertank_frames_pain2 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_pain2 = {FRAME_pain2_5, FRAME_pain2_8, supertank_frames_pain2, supertank_run};
X
mframe_t supertank_frames_pain1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_pain1 = {FRAME_pain1_1, FRAME_pain1_4, supertank_frames_pain1, supertank_run};
X
mframe_t supertank_frames_death1 [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	BossExplode
};
mmove_t supertank_move_death = {FRAME_death_1, FRAME_death_24, supertank_frames_death1, supertank_dead};
X
mframe_t supertank_frames_backward[] =
{
X	ai_walk, 0,	TreadSound,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL,
X	ai_walk, 0,	NULL
};
mmove_t	supertank_move_backward = {FRAME_backwd_1, FRAME_backwd_18, supertank_frames_backward, NULL};
X
mframe_t supertank_frames_attack4[]=
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_attack4 = {FRAME_attak4_1, FRAME_attak4_6, supertank_frames_attack4, supertank_run};
X
mframe_t supertank_frames_attack3[]=
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_attack3 = {FRAME_attak3_1, FRAME_attak3_27, supertank_frames_attack3, supertank_run};
X
mframe_t supertank_frames_attack2[]=
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	supertankRocket,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	supertankRocket,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	supertankRocket,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_attack2 = {FRAME_attak2_1, FRAME_attak2_27, supertank_frames_attack2, supertank_run};
X
mframe_t supertank_frames_attack1[]=
{
X	ai_charge,	0,	supertankMachineGun,
X	ai_charge,	0,	supertankMachineGun,
X	ai_charge,	0,	supertankMachineGun,
X	ai_charge,	0,	supertankMachineGun,
X	ai_charge,	0,	supertankMachineGun,
X	ai_charge,	0,	supertankMachineGun,
X
};
mmove_t supertank_move_attack1 = {FRAME_attak1_1, FRAME_attak1_6, supertank_frames_attack1, supertank_reattack1};
X
mframe_t supertank_frames_end_attack1[]=
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t supertank_move_end_attack1 = {FRAME_attak1_7, FRAME_attak1_20, supertank_frames_end_attack1, supertank_run};
X
X
void supertank_reattack1(edict_t *self)
{
X	if (visible(self, self->enemy))
X		if (random() < 0.9)
X			self->monsterinfo.currentmove = &supertank_move_attack1;
X		else
X			self->monsterinfo.currentmove = &supertank_move_end_attack1;	
X	else
X		self->monsterinfo.currentmove = &supertank_move_end_attack1;
}
X
void supertank_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X
X	if (self->health < (self->max_health / 2))
X			self->s.skinnum = 1;
X
X	if (level.time < self->pain_debounce_time)
X			return;
X
X	// Lessen the chance of him going into his pain frames
X	if (damage <=25)
X		if (random()<0.2)
X			return;
X
X	// Don't go into pain if he's firing his rockets
X	if (skill->value >= 2)
X		if ( (self->s.frame >= FRAME_attak2_1) && (self->s.frame <= FRAME_attak2_14) )
X			return;
X
X	self->pain_debounce_time = level.time + 3;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	if (damage <= 10)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM,0);
X		self->monsterinfo.currentmove = &supertank_move_pain1;
X	}
X	else if (damage <= 25)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain3, 1, ATTN_NORM,0);
X		self->monsterinfo.currentmove = &supertank_move_pain2;
X	}
X	else
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM,0);
X		self->monsterinfo.currentmove = &supertank_move_pain3;
X	}
};
X
X
void supertankRocket (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X	int		flash_number;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	if (self->s.frame == FRAME_attak2_8)
X		flash_number = MZ2_SUPERTANK_ROCKET_1;
X	else if (self->s.frame == FRAME_attak2_11)
X		flash_number = MZ2_SUPERTANK_ROCKET_2;
X	else // (self->s.frame == FRAME_attak2_14)
X		flash_number = MZ2_SUPERTANK_ROCKET_3;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, vec);
X	vec[2] += self->enemy->viewheight;
X	VectorSubtract (vec, start, dir);
X	VectorNormalize (dir);
X
X	monster_fire_rocket (self, start, dir, 50, 500, flash_number);
}	
X
void supertankMachineGun (edict_t *self)
{
X	vec3_t	dir;
X	vec3_t	vec;
X	vec3_t	start;
X	vec3_t	forward, right;
X	int		flash_number;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	flash_number = MZ2_SUPERTANK_MACHINEGUN_1 + (self->s.frame - FRAME_attak1_1);
X
X	//FIXME!!!
X	dir[0] = 0;
X	dir[1] = self->s.angles[1];
X	dir[2] = 0;
X
X	AngleVectors (dir, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	if (self->enemy)
X	{
X		VectorCopy (self->enemy->s.origin, vec);
X		VectorMA (vec, 0, self->enemy->velocity, vec);
X		vec[2] += self->enemy->viewheight;
X		VectorSubtract (vec, start, forward);
X		VectorNormalize (forward);
X  }
X
X	monster_fire_bullet (self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
}	
X
X
void supertank_attack(edict_t *self)
{
X	vec3_t	vec;
X	float	range;
X	//float	r;
X
X	VectorSubtract (self->enemy->s.origin, self->s.origin, vec);
X	range = VectorLength (vec);
X
X	//r = random();
X
X	// Attack 1 == Chaingun
X	// Attack 2 == Rocket Launcher
X
X	if (range <= 160)
X	{
X		self->monsterinfo.currentmove = &supertank_move_attack1;
X	}
X	else
X	{	// fire rockets more often at distance
X		if (random() < 0.3)
X			self->monsterinfo.currentmove = &supertank_move_attack1;
X		else
X			self->monsterinfo.currentmove = &supertank_move_attack2;
X	}
}
X
X
//
// death
//
X
void supertank_dead (edict_t *self)
{
X	VectorSet (self->mins, -60, -60, 0);
X	VectorSet (self->maxs, 60, 60, 72);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
X
void BossExplode (edict_t *self)
{
X	vec3_t	org;
X	int		n;
X
X	self->think = BossExplode;
X	VectorCopy (self->s.origin, org);
X	org[2] += 24 + (rand()&15);
X	switch (self->count++)
X	{
X	case 0:
X		org[0] -= 24;
X		org[1] -= 24;
X		break;
X	case 1:
X		org[0] += 24;
X		org[1] += 24;
X		break;
X	case 2:
X		org[0] += 24;
X		org[1] -= 24;
X		break;
X	case 3:
X		org[0] -= 24;
X		org[1] += 24;
X		break;
X	case 4:
X		org[0] -= 48;
X		org[1] -= 48;
X		break;
X	case 5:
X		org[0] += 48;
X		org[1] += 48;
X		break;
X	case 6:
X		org[0] -= 48;
X		org[1] += 48;
X		break;
X	case 7:
X		org[0] += 48;
X		org[1] -= 48;
X		break;
X	case 8:
X		self->s.sound = 0;
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", 500, GIB_ORGANIC);
X		for (n= 0; n < 8; n++)
X			ThrowGib (self, "models/objects/gibs/sm_metal/tris.md2", 500, GIB_METALLIC);
X		ThrowGib (self, "models/objects/gibs/chest/tris.md2", 500, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/gear/tris.md2", 500, GIB_METALLIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (org);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	self->nextthink = level.time + 0.1;
}
X
X
void supertank_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_NO;
X	self->count = 0;
X	self->monsterinfo.currentmove = &supertank_move_death;
}
X
X
//===========
//PGM
qboolean supertank_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
//PGM
//===========
X
//
// monster_supertank
//
X
/*QUAKED monster_supertank (1 .5 0) (-64 -64 0) (64 64 72) Ambush Trigger_Spawn Sight
*/
void SP_monster_supertank (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("bosstank/btkpain1.wav");
X	sound_pain2 = gi.soundindex ("bosstank/btkpain2.wav");
X	sound_pain3 = gi.soundindex ("bosstank/btkpain3.wav");
X	sound_death = gi.soundindex ("bosstank/btkdeth1.wav");
X	sound_search1 = gi.soundindex ("bosstank/btkunqv1.wav");
X	sound_search2 = gi.soundindex ("bosstank/btkunqv2.wav");
X
//	self->s.sound = gi.soundindex ("bosstank/btkengn1.wav");
X	tread_sound = gi.soundindex ("bosstank/btkengn1.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/boss1/tris.md2");
X	VectorSet (self->mins, -64, -64, 0);
X	VectorSet (self->maxs, 64, 64, 112);
X
X	self->health = 1500;
X	self->gib_health = -500;
X	self->mass = 800;
X
X	self->pain = supertank_pain;
X	self->die = supertank_die;
X	self->monsterinfo.stand = supertank_stand;
X	self->monsterinfo.walk = supertank_walk;
X	self->monsterinfo.run = supertank_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = supertank_attack;
X	self->monsterinfo.search = supertank_search;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = NULL;
X	self->monsterinfo.blocked = supertank_blocked;		//PGM
X
X	gi.linkentity (self);
X	
X	self->monsterinfo.currentmove = &supertank_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start(self);
X
X	//PMM
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X	//pmm
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_supertank.c' &&
  chmod 0664 'm_supertank.c' ||
  $echo 'restore of' 'm_supertank.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_supertank.c:' 'MD5 check failed'
a9fa308bed5ee7994b8561251a2384b5  m_supertank.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_supertank.c'`"
    test 16071 -eq "$shar_count" ||
    $echo 'm_supertank.c:' 'original size' '16071,' 'current size' "$shar_count!"
  fi
fi
# ============= m_supertank.h ==============
if test -f 'm_supertank.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_supertank.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_supertank.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_supertank.h' &&
// G:\quake2\baseq2\models/monsters/boss1/backup
X
// This file generated by ModelGen - Do NOT Modify
X
#define FRAME_attak1_1        	0
#define FRAME_attak1_2        	1
#define FRAME_attak1_3        	2
#define FRAME_attak1_4        	3
#define FRAME_attak1_5        	4
#define FRAME_attak1_6        	5
#define FRAME_attak1_7        	6
#define FRAME_attak1_8        	7
#define FRAME_attak1_9        	8
#define FRAME_attak1_10       	9
#define FRAME_attak1_11       	10
#define FRAME_attak1_12       	11
#define FRAME_attak1_13       	12
#define FRAME_attak1_14       	13
#define FRAME_attak1_15       	14
#define FRAME_attak1_16       	15
#define FRAME_attak1_17       	16
#define FRAME_attak1_18       	17
#define FRAME_attak1_19       	18
#define FRAME_attak1_20       	19
#define FRAME_attak2_1        	20
#define FRAME_attak2_2        	21
#define FRAME_attak2_3        	22
#define FRAME_attak2_4        	23
#define FRAME_attak2_5        	24
#define FRAME_attak2_6        	25
#define FRAME_attak2_7        	26
#define FRAME_attak2_8        	27
#define FRAME_attak2_9        	28
#define FRAME_attak2_10       	29
#define FRAME_attak2_11       	30
#define FRAME_attak2_12       	31
#define FRAME_attak2_13       	32
#define FRAME_attak2_14       	33
#define FRAME_attak2_15       	34
#define FRAME_attak2_16       	35
#define FRAME_attak2_17       	36
#define FRAME_attak2_18       	37
#define FRAME_attak2_19       	38
#define FRAME_attak2_20       	39
#define FRAME_attak2_21       	40
#define FRAME_attak2_22       	41
#define FRAME_attak2_23       	42
#define FRAME_attak2_24       	43
#define FRAME_attak2_25       	44
#define FRAME_attak2_26       	45
#define FRAME_attak2_27       	46
#define FRAME_attak3_1        	47
#define FRAME_attak3_2        	48
#define FRAME_attak3_3        	49
#define FRAME_attak3_4        	50
#define FRAME_attak3_5        	51
#define FRAME_attak3_6        	52
#define FRAME_attak3_7        	53
#define FRAME_attak3_8        	54
#define FRAME_attak3_9        	55
#define FRAME_attak3_10       	56
#define FRAME_attak3_11       	57
#define FRAME_attak3_12       	58
#define FRAME_attak3_13       	59
#define FRAME_attak3_14       	60
#define FRAME_attak3_15       	61
#define FRAME_attak3_16       	62
#define FRAME_attak3_17       	63
#define FRAME_attak3_18       	64
#define FRAME_attak3_19       	65
#define FRAME_attak3_20       	66
#define FRAME_attak3_21       	67
#define FRAME_attak3_22       	68
#define FRAME_attak3_23       	69
#define FRAME_attak3_24       	70
#define FRAME_attak3_25       	71
#define FRAME_attak3_26       	72
#define FRAME_attak3_27       	73
#define FRAME_attak4_1        	74
#define FRAME_attak4_2        	75
#define FRAME_attak4_3        	76
#define FRAME_attak4_4        	77
#define FRAME_attak4_5        	78
#define FRAME_attak4_6        	79
#define FRAME_backwd_1        	80
#define FRAME_backwd_2        	81
#define FRAME_backwd_3        	82
#define FRAME_backwd_4        	83
#define FRAME_backwd_5        	84
#define FRAME_backwd_6        	85
#define FRAME_backwd_7        	86
#define FRAME_backwd_8        	87
#define FRAME_backwd_9        	88
#define FRAME_backwd_10       	89
#define FRAME_backwd_11       	90
#define FRAME_backwd_12       	91
#define FRAME_backwd_13       	92
#define FRAME_backwd_14       	93
#define FRAME_backwd_15       	94
#define FRAME_backwd_16       	95
#define FRAME_backwd_17       	96
#define FRAME_backwd_18       	97
#define FRAME_death_1         	98
#define FRAME_death_2         	99
#define FRAME_death_3         	100
#define FRAME_death_4         	101
#define FRAME_death_5         	102
#define FRAME_death_6         	103
#define FRAME_death_7         	104
#define FRAME_death_8         	105
#define FRAME_death_9         	106
#define FRAME_death_10        	107
#define FRAME_death_11        	108
#define FRAME_death_12        	109
#define FRAME_death_13        	110
#define FRAME_death_14        	111
#define FRAME_death_15        	112
#define FRAME_death_16        	113
#define FRAME_death_17        	114
#define FRAME_death_18        	115
#define FRAME_death_19        	116
#define FRAME_death_20        	117
#define FRAME_death_21        	118
#define FRAME_death_22        	119
#define FRAME_death_23        	120
#define FRAME_death_24        	121
#define FRAME_death_31        	122
#define FRAME_death_32        	123
#define FRAME_death_33        	124
#define FRAME_death_45        	125
#define FRAME_death_46        	126
#define FRAME_death_47        	127
#define FRAME_forwrd_1        	128
#define FRAME_forwrd_2        	129
#define FRAME_forwrd_3        	130
#define FRAME_forwrd_4        	131
#define FRAME_forwrd_5        	132
#define FRAME_forwrd_6        	133
#define FRAME_forwrd_7        	134
#define FRAME_forwrd_8        	135
#define FRAME_forwrd_9        	136
#define FRAME_forwrd_10       	137
#define FRAME_forwrd_11       	138
#define FRAME_forwrd_12       	139
#define FRAME_forwrd_13       	140
#define FRAME_forwrd_14       	141
#define FRAME_forwrd_15       	142
#define FRAME_forwrd_16       	143
#define FRAME_forwrd_17       	144
#define FRAME_forwrd_18       	145
#define FRAME_left_1          	146
#define FRAME_left_2          	147
#define FRAME_left_3          	148
#define FRAME_left_4          	149
#define FRAME_left_5          	150
#define FRAME_left_6          	151
#define FRAME_left_7          	152
#define FRAME_left_8          	153
#define FRAME_left_9          	154
#define FRAME_left_10         	155
#define FRAME_left_11         	156
#define FRAME_left_12         	157
#define FRAME_left_13         	158
#define FRAME_left_14         	159
#define FRAME_left_15         	160
#define FRAME_left_16         	161
#define FRAME_left_17         	162
#define FRAME_left_18         	163
#define FRAME_pain1_1         	164
#define FRAME_pain1_2         	165
#define FRAME_pain1_3         	166
#define FRAME_pain1_4         	167
#define FRAME_pain2_5         	168
#define FRAME_pain2_6         	169
#define FRAME_pain2_7         	170
#define FRAME_pain2_8         	171
#define FRAME_pain3_9         	172
#define FRAME_pain3_10        	173
#define FRAME_pain3_11        	174
#define FRAME_pain3_12        	175
#define FRAME_right_1         	176
#define FRAME_right_2         	177
#define FRAME_right_3         	178
#define FRAME_right_4         	179
#define FRAME_right_5         	180
#define FRAME_right_6         	181
#define FRAME_right_7         	182
#define FRAME_right_8         	183
#define FRAME_right_9         	184
#define FRAME_right_10        	185
#define FRAME_right_11        	186
#define FRAME_right_12        	187
#define FRAME_right_13        	188
#define FRAME_right_14        	189
#define FRAME_right_15        	190
#define FRAME_right_16        	191
#define FRAME_right_17        	192
#define FRAME_right_18        	193
#define FRAME_stand_1         	194
#define FRAME_stand_2         	195
#define FRAME_stand_3         	196
#define FRAME_stand_4         	197
#define FRAME_stand_5         	198
#define FRAME_stand_6         	199
#define FRAME_stand_7         	200
#define FRAME_stand_8         	201
#define FRAME_stand_9         	202
#define FRAME_stand_10        	203
#define FRAME_stand_11        	204
#define FRAME_stand_12        	205
#define FRAME_stand_13        	206
#define FRAME_stand_14        	207
#define FRAME_stand_15        	208
#define FRAME_stand_16        	209
#define FRAME_stand_17        	210
#define FRAME_stand_18        	211
#define FRAME_stand_19        	212
#define FRAME_stand_20        	213
#define FRAME_stand_21        	214
#define FRAME_stand_22        	215
#define FRAME_stand_23        	216
#define FRAME_stand_24        	217
#define FRAME_stand_25        	218
#define FRAME_stand_26        	219
#define FRAME_stand_27        	220
#define FRAME_stand_28        	221
#define FRAME_stand_29        	222
#define FRAME_stand_30        	223
#define FRAME_stand_31        	224
#define FRAME_stand_32        	225
#define FRAME_stand_33        	226
#define FRAME_stand_34        	227
#define FRAME_stand_35        	228
#define FRAME_stand_36        	229
#define FRAME_stand_37        	230
#define FRAME_stand_38        	231
#define FRAME_stand_39        	232
#define FRAME_stand_40        	233
#define FRAME_stand_41        	234
#define FRAME_stand_42        	235
#define FRAME_stand_43        	236
#define FRAME_stand_44        	237
#define FRAME_stand_45        	238
#define FRAME_stand_46        	239
#define FRAME_stand_47        	240
#define FRAME_stand_48        	241
#define FRAME_stand_49        	242
#define FRAME_stand_50        	243
#define FRAME_stand_51        	244
#define FRAME_stand_52        	245
#define FRAME_stand_53        	246
#define FRAME_stand_54        	247
#define FRAME_stand_55        	248
#define FRAME_stand_56        	249
#define FRAME_stand_57        	250
#define FRAME_stand_58        	251
#define FRAME_stand_59        	252
#define FRAME_stand_60        	253
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_supertank.h' &&
  chmod 0664 'm_supertank.h' ||
  $echo 'restore of' 'm_supertank.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_supertank.h:' 'MD5 check failed'
f3f0bf126d6b4437b58217c0f9868f8b  m_supertank.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_supertank.h'`"
    test 8913 -eq "$shar_count" ||
    $echo 'm_supertank.h:' 'original size' '8913,' 'current size' "$shar_count!"
  fi
fi
# ============= m_tank.c ==============
if test -f 'm_tank.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_tank.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_tank.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_tank.c' &&
/*
==============================================================================
X
TANK
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_tank.h"
X
X
void tank_refire_rocket (edict_t *self);
void tank_doattack_rocket (edict_t *self);
void tank_reattack_blaster (edict_t *self);
X
static int	sound_thud;
static int	sound_pain;
static int	sound_idle;
static int	sound_die;
static int	sound_step;
static int	sound_sight;
static int	sound_windup;
static int	sound_strike;
X
//
// misc
//
X
void tank_sight (edict_t *self, edict_t *other)
{
X	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
}
X
X
void tank_footstep (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_step, 1, ATTN_NORM, 0);
}
X
void tank_thud (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, sound_thud, 1, ATTN_NORM, 0);
}
X
void tank_windup (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_windup, 1, ATTN_NORM, 0);
}
X
void tank_idle (edict_t *self)
{
X	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
}
X
X
//
// stand
//
X
mframe_t tank_frames_stand []=
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	tank_move_stand = {FRAME_stand01, FRAME_stand30, tank_frames_stand, NULL};
X	
void tank_stand (edict_t *self)
{
X	self->monsterinfo.currentmove = &tank_move_stand;
}
X
X
//
// walk
//
X
void tank_walk (edict_t *self);
X
mframe_t tank_frames_start_walk [] =
{
X	ai_walk,  0, NULL,
X	ai_walk,  6, NULL,
X	ai_walk,  6, NULL,
X	ai_walk, 11, tank_footstep
};
mmove_t	tank_move_start_walk = {FRAME_walk01, FRAME_walk04, tank_frames_start_walk, tank_walk};
X
mframe_t tank_frames_walk [] =
{
X	ai_walk, 4,	NULL,
X	ai_walk, 5,	NULL,
X	ai_walk, 3,	NULL,
X	ai_walk, 2,	NULL,
X	ai_walk, 5,	NULL,
X	ai_walk, 5,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 4,	tank_footstep,
X	ai_walk, 3,	NULL,
X	ai_walk, 5,	NULL,
X	ai_walk, 4,	NULL,
X	ai_walk, 5,	NULL,
X	ai_walk, 7,	NULL,
X	ai_walk, 7,	NULL,
X	ai_walk, 6,	NULL,
X	ai_walk, 6,	tank_footstep
};
mmove_t	tank_move_walk = {FRAME_walk05, FRAME_walk20, tank_frames_walk, NULL};
X
mframe_t tank_frames_stop_walk [] =
{
X	ai_walk,  3, NULL,
X	ai_walk,  3, NULL,
X	ai_walk,  2, NULL,
X	ai_walk,  2, NULL,
X	ai_walk,  4, tank_footstep
};
mmove_t	tank_move_stop_walk = {FRAME_walk21, FRAME_walk25, tank_frames_stop_walk, tank_stand};
X
void tank_walk (edict_t *self)
{
X		self->monsterinfo.currentmove = &tank_move_walk;
}
X
X
//
// run
//
X
void tank_run (edict_t *self);
X
mframe_t tank_frames_start_run [] =
{
X	ai_run,  0, NULL,
X	ai_run,  6, NULL,
X	ai_run,  6, NULL,
X	ai_run, 11, tank_footstep
};
mmove_t	tank_move_start_run = {FRAME_walk01, FRAME_walk04, tank_frames_start_run, tank_run};
X
mframe_t tank_frames_run [] =
{
X	ai_run, 4,	NULL,
X	ai_run, 5,	NULL,
X	ai_run, 3,	NULL,
X	ai_run, 2,	NULL,
X	ai_run, 5,	NULL,
X	ai_run, 5,	NULL,
X	ai_run, 4,	NULL,
X	ai_run, 4,	tank_footstep,
X	ai_run, 3,	NULL,
X	ai_run, 5,	NULL,
X	ai_run, 4,	NULL,
X	ai_run, 5,	NULL,
X	ai_run, 7,	NULL,
X	ai_run, 7,	NULL,
X	ai_run, 6,	NULL,
X	ai_run, 6,	tank_footstep
};
mmove_t	tank_move_run = {FRAME_walk05, FRAME_walk20, tank_frames_run, NULL};
X
mframe_t tank_frames_stop_run [] =
{
X	ai_run,  3, NULL,
X	ai_run,  3, NULL,
X	ai_run,  2, NULL,
X	ai_run,  2, NULL,
X	ai_run,  4, tank_footstep
};
mmove_t	tank_move_stop_run = {FRAME_walk21, FRAME_walk25, tank_frames_stop_run, tank_walk};
X
void tank_run (edict_t *self)
{
X	if (self->enemy && self->enemy->client)
X		self->monsterinfo.aiflags |= AI_BRUTAL;
X	else
X		self->monsterinfo.aiflags &= ~AI_BRUTAL;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		self->monsterinfo.currentmove = &tank_move_stand;
X		return;
X	}
X
X	if (self->monsterinfo.currentmove == &tank_move_walk ||
X		self->monsterinfo.currentmove == &tank_move_start_run)
X	{
X		self->monsterinfo.currentmove = &tank_move_run;
X	}
X	else
X	{
X		self->monsterinfo.currentmove = &tank_move_start_run;
X	}
}
X
//
// pain
//
X
mframe_t tank_frames_pain1 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t tank_move_pain1 = {FRAME_pain101, FRAME_pain104, tank_frames_pain1, tank_run};
X
mframe_t tank_frames_pain2 [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
mmove_t tank_move_pain2 = {FRAME_pain201, FRAME_pain205, tank_frames_pain2, tank_run};
X
mframe_t tank_frames_pain3 [] =
{
X	ai_move, -7, NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 2,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 3,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 2,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  NULL,
X	ai_move, 0,  tank_footstep
};
mmove_t	tank_move_pain3 = {FRAME_pain301, FRAME_pain316, tank_frames_pain3, tank_run};
X
X
void tank_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X			self->s.skinnum |= 1;
X
X	if (damage <= 10)
X		return;
X
X	if (level.time < self->pain_debounce_time)
X			return;
X
X	if (damage <= 30)
X		if (random() > 0.2)
X			return;
X	
X	// If hard or nightmare, don't go into pain while attacking
X	if ( skill->value >= 2)
X	{
X		if ( (self->s.frame >= FRAME_attak301) && (self->s.frame <= FRAME_attak330) )
X			return;
X		if ( (self->s.frame >= FRAME_attak101) && (self->s.frame <= FRAME_attak116) )
X			return;
X	}
X
X	self->pain_debounce_time = level.time + 3;
X	gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	// PMM - blindfire cleanup
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X	// pmm
X
X	if (damage <= 30)
X		self->monsterinfo.currentmove = &tank_move_pain1;
X	else if (damage <= 60)
X		self->monsterinfo.currentmove = &tank_move_pain2;
X	else
X		self->monsterinfo.currentmove = &tank_move_pain3;
};
X
X
//
// attacks
//
X
void TankBlaster (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	end;
X	vec3_t	dir;
X	int		flash_number;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	if (self->s.frame == FRAME_attak110)
X		flash_number = MZ2_TANK_BLASTER_1;
X	else if (self->s.frame == FRAME_attak113)
X		flash_number = MZ2_TANK_BLASTER_2;
X	else // (self->s.frame == FRAME_attak116)
X		flash_number = MZ2_TANK_BLASTER_3;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	VectorCopy (self->enemy->s.origin, end);
X	end[2] += self->enemy->viewheight;
X	VectorSubtract (end, start, dir);
X
X	monster_fire_blaster (self, start, dir, 30, 800, flash_number, EF_BLASTER);
}	
X
void TankStrike (edict_t *self)
{
X	gi.sound (self, CHAN_WEAPON, sound_strike, 1, ATTN_NORM, 0);
}	
X
void TankRocket (edict_t *self)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	vec;
X	int		flash_number;
X	trace_t	trace;				// PGM
X	int		rocketSpeed;		// PGM
X	// pmm - blindfire support
X	vec3_t	target;
X	qboolean blindfire = false;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	// pmm - blindfire check
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X		blindfire = true;
X	else
X		blindfire = false;
X
X	if (self->s.frame == FRAME_attak324)
X		flash_number = MZ2_TANK_ROCKET_1;
X	else if (self->s.frame == FRAME_attak327)
X		flash_number = MZ2_TANK_ROCKET_2;
X	else // (self->s.frame == FRAME_attak330)
X		flash_number = MZ2_TANK_ROCKET_3;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	rocketSpeed = 500 + (100 * skill->value);	// PGM rock & roll.... :)
X
X		// PMM
X	if (blindfire)
X		VectorCopy (self->monsterinfo.blind_fire_target, target);
X	else
X		VectorCopy (self->enemy->s.origin, target);
X	// pmm
X
//	VectorCopy (self->enemy->s.origin, vec);
//	vec[2] += self->enemy->viewheight;
//	VectorSubtract (vec, start, dir);
X
//PGM
X	// PMM - blindfire shooting
X	if (blindfire)
X	{
X		VectorCopy (target, vec);
X		VectorSubtract (vec, start, dir);
X	}
X	// pmm
X	// don't shoot at feet if they're above me.
X	else if(random() < 0.66 || (start[2] < self->enemy->absmin[2]))
X	{
//		gi.dprintf("normal shot\n");
X		VectorCopy (self->enemy->s.origin, vec);
X		vec[2] += self->enemy->viewheight;
X		VectorSubtract (vec, start, dir);
X	}
X	else
X	{
//		gi.dprintf("shooting at feet!\n");
X		VectorCopy (self->enemy->s.origin, vec);
X		vec[2] = self->enemy->absmin[2];
X		VectorSubtract (vec, start, dir);
X	}
//PGM
X	
//======
//PMM - lead target  (not when blindfiring)
X	// 20, 35, 50, 65 chance of leading
X	if((!blindfire) && ((random() < (0.2 + ((3 - skill->value) * 0.15)))))
X	{
X		float	dist;
X		float	time;
X
//		gi.dprintf ("leading target\n");
X		dist = VectorLength (dir);
X		time = dist/rocketSpeed;
X		VectorMA(vec, time, self->enemy->velocity, vec);
X		VectorSubtract(vec, start, dir);
X	}
//PMM - lead target
//======
X
X	VectorNormalize (dir);
X
//			gi.WriteByte (svc_temp_entity);
//			gi.WriteByte (TE_DEBUGTRAIL);
//			gi.WritePosition (start);
//			gi.WritePosition (vec);
//			gi.multicast (start, MULTICAST_ALL);
X
X	// pmm blindfire doesn't check target (done in checkattack)
X	// paranoia, make sure we're not shooting a target right next to us
X	trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X	if (blindfire)
X	{
X		// blindfire has different fail criteria for the trace
X		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5)))
X			monster_fire_rocket (self, start, dir, 50, rocketSpeed, flash_number);
X		else 
X		{
X			// try shifting the target to the left a little (to help counter large offset)
X			VectorCopy (target, vec);
X			VectorMA (vec, -20, right, vec);
X			VectorSubtract(vec, start, dir);
X			VectorNormalize (dir);
X			trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5)))
X				monster_fire_rocket (self, start, dir, 50, rocketSpeed, flash_number);
X			else 
X			{
X				// ok, that failed.  try to the right
X				VectorCopy (target, vec);
X				VectorMA (vec, 20, right, vec);
X				VectorSubtract(vec, start, dir);
X				VectorNormalize (dir);
X				trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5)))
X					monster_fire_rocket (self, start, dir, 50, rocketSpeed, flash_number);
X				else if ((g_showlogic) && (g_showlogic->value))
X					// ok, I give up
X					gi.dprintf ("tank avoiding blindfire shot\n");
X			}
X		}
X	}
X	else
X	{
X		trace = gi.trace(start, vec3_origin, vec3_origin, vec, self, MASK_SHOT);
X		if(trace.ent == self->enemy || trace.ent == world)
X		{
X			if(trace.fraction > 0.5 || (trace.ent && trace.ent->client))
X				monster_fire_rocket (self, start, dir, 50, rocketSpeed, MZ2_CHICK_ROCKET_1);
X	//		else
X	//			gi.dprintf("didn't make it halfway to target...aborting\n");
X		}
X	}
}	
X
void TankMachineGun (edict_t *self)
{
X	vec3_t	dir;
X	vec3_t	vec;
X	vec3_t	start;
X	vec3_t	forward, right;
X	int		flash_number;
X
X	if(!self->enemy || !self->enemy->inuse)		//PGM
X		return;									//PGM
X
X	flash_number = MZ2_TANK_MACHINEGUN_1 + (self->s.frame - FRAME_attak406);
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash_number], forward, right, start);
X
X	if (self->enemy)
X	{
X		VectorCopy (self->enemy->s.origin, vec);
X		vec[2] += self->enemy->viewheight;
X		VectorSubtract (vec, start, vec);
X		vectoangles (vec, vec);
X		dir[0] = vec[0];
X	}
X	else
X	{
X		dir[0] = 0;
X	}
X	if (self->s.frame <= FRAME_attak415)
X		dir[1] = self->s.angles[1] - 8 * (self->s.frame - FRAME_attak411);
X	else
X		dir[1] = self->s.angles[1] + 8 * (self->s.frame - FRAME_attak419);
X	dir[2] = 0;
X
X	AngleVectors (dir, forward, NULL, NULL);
X
X	monster_fire_bullet (self, start, forward, 20, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
}	
X
X
mframe_t tank_frames_attack_blast [] =
{
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, -1,	NULL,
X	ai_charge, -2,	NULL,
X	ai_charge, -1,	NULL,
X	ai_charge, -1,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	TankBlaster,		// 10
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	TankBlaster,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	TankBlaster			// 16
};
mmove_t tank_move_attack_blast = {FRAME_attak101, FRAME_attak116, tank_frames_attack_blast, tank_reattack_blaster};
X
mframe_t tank_frames_reattack_blast [] =
{
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	TankBlaster,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	NULL,
X	ai_charge, 0,	TankBlaster			// 16
};
mmove_t tank_move_reattack_blast = {FRAME_attak111, FRAME_attak116, tank_frames_reattack_blast, tank_reattack_blaster};
X
mframe_t tank_frames_attack_post_blast [] =	
{
X	ai_move, 0,		NULL,				// 17
X	ai_move, 0,		NULL,
X	ai_move, 2,		NULL,
X	ai_move, 3,		NULL,
X	ai_move, 2,		NULL,
X	ai_move, -2,	tank_footstep		// 22
};
mmove_t tank_move_attack_post_blast = {FRAME_attak117, FRAME_attak122, tank_frames_attack_post_blast, tank_run};
X
void tank_reattack_blaster (edict_t *self)
{
X	if (skill->value >= 2)
X		if (visible (self, self->enemy))
X			if (self->enemy->health > 0)
X				if (random() <= 0.6)
X				{
X					self->monsterinfo.currentmove = &tank_move_reattack_blast;
X					return;
X				}
X	self->monsterinfo.currentmove = &tank_move_attack_post_blast;
}
X
X
void tank_poststrike (edict_t *self)
{
X	self->enemy = NULL;
X	tank_run (self);
}
X
mframe_t tank_frames_attack_strike [] =
{
X	ai_move, 3,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 6,   NULL,
X	ai_move, 7,   NULL,
X	ai_move, 9,   tank_footstep,
X	ai_move, 2,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, 2,   tank_footstep,
X	ai_move, 2,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -2,  NULL,
X	ai_move, -2,  NULL,
X	ai_move, 0,   tank_windup,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   TankStrike,
X	ai_move, 0,   NULL,
X	ai_move, -1,  NULL,
X	ai_move, -1,  NULL,
X	ai_move, -1,  NULL,
X	ai_move, -1,  NULL,
X	ai_move, -1,  NULL,
X	ai_move, -3,  NULL,
X	ai_move, -10, NULL,
X	ai_move, -10, NULL,
X	ai_move, -2,  NULL,
X	ai_move, -3,  NULL,
X	ai_move, -2,  tank_footstep
};
mmove_t tank_move_attack_strike = {FRAME_attak201, FRAME_attak238, tank_frames_attack_strike, tank_poststrike};
X
mframe_t tank_frames_attack_pre_rocket [] =
{
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,			// 10
X
X	ai_charge, 0,  NULL,
X	ai_charge, 1,  NULL,
X	ai_charge, 2,  NULL,
X	ai_charge, 7,  NULL,
X	ai_charge, 7,  NULL,
X	ai_charge, 7,  tank_footstep,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,			// 20
X
X	ai_charge, -3, NULL
};
mmove_t tank_move_attack_pre_rocket = {FRAME_attak301, FRAME_attak321, tank_frames_attack_pre_rocket, tank_doattack_rocket};
X
mframe_t tank_frames_attack_fire_rocket [] =
{
X	ai_charge, -3, NULL,			// Loop Start	22 
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  TankRocket,		// 24
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  TankRocket,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, -1, TankRocket		// 30	Loop End
};
mmove_t tank_move_attack_fire_rocket = {FRAME_attak322, FRAME_attak330, tank_frames_attack_fire_rocket, tank_refire_rocket};
X
mframe_t tank_frames_attack_post_rocket [] =
{	
X	ai_charge, 0,  NULL,			// 31
X	ai_charge, -1, NULL,
X	ai_charge, -1, NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 2,  NULL,
X	ai_charge, 3,  NULL,
X	ai_charge, 4,  NULL,
X	ai_charge, 2,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,			// 40
X
X	ai_charge, 0,  NULL,
X	ai_charge, -9, NULL,
X	ai_charge, -8, NULL,
X	ai_charge, -7, NULL,
X	ai_charge, -1, NULL,
X	ai_charge, -1, tank_footstep,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,			// 50
X
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL,
X	ai_charge, 0,  NULL
};
mmove_t tank_move_attack_post_rocket = {FRAME_attak331, FRAME_attak353, tank_frames_attack_post_rocket, tank_run};
X
mframe_t tank_frames_attack_chain [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	NULL,      0, TankMachineGun,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL
};
mmove_t tank_move_attack_chain = {FRAME_attak401, FRAME_attak429, tank_frames_attack_chain, tank_run};
X
void tank_refire_rocket (edict_t *self)
{
X	// PMM - blindfire cleanup
X	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
X	{
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		self->monsterinfo.currentmove = &tank_move_attack_post_rocket;
X		return;
X	}
X	// pmm
X
X	// Only on hard or nightmare
X	if ( skill->value >= 2 )
X		if (self->enemy->health > 0)
X			if (visible(self, self->enemy) )
X				if (random() <= 0.4)
X				{
X					self->monsterinfo.currentmove = &tank_move_attack_fire_rocket;
X					return;
X				}
X	self->monsterinfo.currentmove = &tank_move_attack_post_rocket;
}
X
void tank_doattack_rocket (edict_t *self)
{
X	self->monsterinfo.currentmove = &tank_move_attack_fire_rocket;
}
X
void tank_attack(edict_t *self)
{
X	vec3_t	vec;
X	float	range;
X	float	r;
X	// PMM
X	float	chance;
X
X	// PMM
X	if (!self->enemy || !self->enemy->inuse)
X		return;
X
X	if (self->enemy->health < 0)
X	{
X		self->monsterinfo.currentmove = &tank_move_attack_strike;
X		self->monsterinfo.aiflags &= ~AI_BRUTAL;
X		return;
X	}
X
X	// PMM 
X	if (self->monsterinfo.attack_state == AS_BLIND)
X	{
X		// setup shot probabilities
X		if (self->monsterinfo.blind_fire_delay < 1.0)
X			chance = 1.0;
X		else if (self->monsterinfo.blind_fire_delay < 7.5)
X			chance = 0.4;
X		else
X			chance = 0.1;
X
X		r = random();
X
X		self->monsterinfo.blind_fire_delay += 3.2 + 2.0 + random()*3.0;
X
X		// don't shoot at the origin
X		if (VectorCompare (self->monsterinfo.blind_fire_target, vec3_origin))
X			return;
X
X		// don't shoot if the dice say not to
X		if (r > chance)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("blindfire - NO SHOT\n");
X			return;
X		}
X
X		// turn on manual steering to signal both manual steering and blindfire
X		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X		self->monsterinfo.currentmove = &tank_move_attack_fire_rocket;
X		self->monsterinfo.attack_finished = level.time + 3.0 + 2*random();
X		self->pain_debounce_time = level.time + 5.0;	// no pain for a while
X		return;
X	}
X	// pmm
X
X	VectorSubtract (self->enemy->s.origin, self->s.origin, vec);
X	range = VectorLength (vec);
X
X	r = random();
X
X	if (range <= 125)
X	{
X		if (r < 0.4)
X			self->monsterinfo.currentmove = &tank_move_attack_chain;
X		else 
X			self->monsterinfo.currentmove = &tank_move_attack_blast;
X	}
X	else if (range <= 250)
X	{
X		if (r < 0.5)
X			self->monsterinfo.currentmove = &tank_move_attack_chain;
X		else
X			self->monsterinfo.currentmove = &tank_move_attack_blast;
X	}
X	else
X	{
X		if (r < 0.33)
X			self->monsterinfo.currentmove = &tank_move_attack_chain;
X		else if (r < 0.66)
X		{
X			self->monsterinfo.currentmove = &tank_move_attack_pre_rocket;
X			self->pain_debounce_time = level.time + 5.0;	// no pain for a while
X		}
X		else
X			self->monsterinfo.currentmove = &tank_move_attack_blast;
X	}
}
X
X
//
// death
//
X
void tank_dead (edict_t *self)
{
X	VectorSet (self->mins, -16, -16, -16);
X	VectorSet (self->maxs, 16, 16, -0);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
mframe_t tank_frames_death1 [] =
{
X	ai_move, -7,  NULL,
X	ai_move, -2,  NULL,
X	ai_move, -2,  NULL,
X	ai_move, 1,   NULL,
X	ai_move, 3,   NULL,
X	ai_move, 6,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 1,   NULL,
X	ai_move, 2,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -2,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -3,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, -4,  NULL,
X	ai_move, -6,  NULL,
X	ai_move, -4,  NULL,
X	ai_move, -5,  NULL,
X	ai_move, -7,  NULL,
X	ai_move, -15, tank_thud,
X	ai_move, -5,  NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL,
X	ai_move, 0,   NULL
};
mmove_t	tank_move_death = {FRAME_death101, FRAME_death132, tank_frames_death1, tank_dead};
X
void tank_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 1 /*4*/; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_metal/tris.md2", damage, GIB_METALLIC);
X		ThrowGib (self, "models/objects/gibs/chest/tris.md2", damage, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/gear/tris.md2", damage, GIB_METALLIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
// regular death
X	gi.sound (self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_YES;
X
X	self->monsterinfo.currentmove = &tank_move_death;
X	
}
X
//===========
//PGM
qboolean tank_blocked (edict_t *self, float dist)
{
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
X	if(blocked_checkplat (self, dist))
X		return true;
X
X	return false;
}
//PGM
//===========
X
//
// monster_tank
//
X
/*QUAKED monster_tank (1 .5 0) (-32 -32 -16) (32 32 72) Ambush Trigger_Spawn Sight
*/
/*QUAKED monster_tank_commander (1 .5 0) (-32 -32 -16) (32 32 72) Ambush Trigger_Spawn Sight
*/
void SP_monster_tank (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	self->s.modelindex = gi.modelindex ("models/monsters/tank/tris.md2");
X	VectorSet (self->mins, -32, -32, -16);
X	VectorSet (self->maxs, 32, 32, 72);
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X
X	sound_pain = gi.soundindex ("tank/tnkpain2.wav");
X	sound_thud = gi.soundindex ("tank/tnkdeth2.wav");
X	sound_idle = gi.soundindex ("tank/tnkidle1.wav");
X	sound_die = gi.soundindex ("tank/death.wav");
X	sound_step = gi.soundindex ("tank/step.wav");
X	sound_windup = gi.soundindex ("tank/tnkatck4.wav");
X	sound_strike = gi.soundindex ("tank/tnkatck5.wav");
X	sound_sight = gi.soundindex ("tank/sight1.wav");
X
X	gi.soundindex ("tank/tnkatck1.wav");
X	gi.soundindex ("tank/tnkatk2a.wav");
X	gi.soundindex ("tank/tnkatk2b.wav");
X	gi.soundindex ("tank/tnkatk2c.wav");
X	gi.soundindex ("tank/tnkatk2d.wav");
X	gi.soundindex ("tank/tnkatk2e.wav");
X	gi.soundindex ("tank/tnkatck3.wav");
X
X	if (strcmp(self->classname, "monster_tank_commander") == 0)
X	{
X		self->health = 1000;
X		self->gib_health = -225;
X	}
X	else
X	{
X		self->health = 750;
X		self->gib_health = -200;
X	}
X
X	self->mass = 500;
X
X	self->pain = tank_pain;
X	self->die = tank_die;
X	self->monsterinfo.stand = tank_stand;
X	self->monsterinfo.walk = tank_walk;
X	self->monsterinfo.run = tank_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = tank_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = tank_sight;
X	self->monsterinfo.idle = tank_idle;
X	self->monsterinfo.blocked = tank_blocked;		// PGM
X
X	gi.linkentity (self);
X	
X	self->monsterinfo.currentmove = &tank_move_stand;
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	walkmonster_start(self);
X
X	// PMM
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X	self->monsterinfo.blindfire = true;
X	//pmm
X	if (strcmp(self->classname, "monster_tank_commander") == 0)
X		self->s.skinnum = 2;
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_tank.c' &&
  chmod 0664 'm_tank.c' ||
  $echo 'restore of' 'm_tank.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_tank.c:' 'MD5 check failed'
90ee67715d1a6e00b2f3b027b95ecdb8  m_tank.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_tank.c'`"
    test 24628 -eq "$shar_count" ||
    $echo 'm_tank.c:' 'original size' '24628,' 'current size' "$shar_count!"
  fi
fi
# ============= m_tank.h ==============
if test -f 'm_tank.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_tank.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_tank.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_tank.h' &&
// G:\quake2\baseq2\models/monsters/tank
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_stand01         	0
#define FRAME_stand02         	1
#define FRAME_stand03         	2
#define FRAME_stand04         	3
#define FRAME_stand05         	4
#define FRAME_stand06         	5
#define FRAME_stand07         	6
#define FRAME_stand08         	7
#define FRAME_stand09         	8
#define FRAME_stand10         	9
#define FRAME_stand11         	10
#define FRAME_stand12         	11
#define FRAME_stand13         	12
#define FRAME_stand14         	13
#define FRAME_stand15         	14
#define FRAME_stand16         	15
#define FRAME_stand17         	16
#define FRAME_stand18         	17
#define FRAME_stand19         	18
#define FRAME_stand20         	19
#define FRAME_stand21         	20
#define FRAME_stand22         	21
#define FRAME_stand23         	22
#define FRAME_stand24         	23
#define FRAME_stand25         	24
#define FRAME_stand26         	25
#define FRAME_stand27         	26
#define FRAME_stand28         	27
#define FRAME_stand29         	28
#define FRAME_stand30         	29
#define FRAME_walk01          	30
#define FRAME_walk02          	31
#define FRAME_walk03          	32
#define FRAME_walk04          	33
#define FRAME_walk05          	34
#define FRAME_walk06          	35
#define FRAME_walk07          	36
#define FRAME_walk08          	37
#define FRAME_walk09          	38
#define FRAME_walk10          	39
#define FRAME_walk11          	40
#define FRAME_walk12          	41
#define FRAME_walk13          	42
#define FRAME_walk14          	43
#define FRAME_walk15          	44
#define FRAME_walk16          	45
#define FRAME_walk17          	46
#define FRAME_walk18          	47
#define FRAME_walk19          	48
#define FRAME_walk20          	49
#define FRAME_walk21          	50
#define FRAME_walk22          	51
#define FRAME_walk23          	52
#define FRAME_walk24          	53
#define FRAME_walk25          	54
#define FRAME_attak101        	55
#define FRAME_attak102        	56
#define FRAME_attak103        	57
#define FRAME_attak104        	58
#define FRAME_attak105        	59
#define FRAME_attak106        	60
#define FRAME_attak107        	61
#define FRAME_attak108        	62
#define FRAME_attak109        	63
#define FRAME_attak110        	64
#define FRAME_attak111        	65
#define FRAME_attak112        	66
#define FRAME_attak113        	67
#define FRAME_attak114        	68
#define FRAME_attak115        	69
#define FRAME_attak116        	70
#define FRAME_attak117        	71
#define FRAME_attak118        	72
#define FRAME_attak119        	73
#define FRAME_attak120        	74
#define FRAME_attak121        	75
#define FRAME_attak122        	76
#define FRAME_attak201        	77
#define FRAME_attak202        	78
#define FRAME_attak203        	79
#define FRAME_attak204        	80
#define FRAME_attak205        	81
#define FRAME_attak206        	82
#define FRAME_attak207        	83
#define FRAME_attak208        	84
#define FRAME_attak209        	85
#define FRAME_attak210        	86
#define FRAME_attak211        	87
#define FRAME_attak212        	88
#define FRAME_attak213        	89
#define FRAME_attak214        	90
#define FRAME_attak215        	91
#define FRAME_attak216        	92
#define FRAME_attak217        	93
#define FRAME_attak218        	94
#define FRAME_attak219        	95
#define FRAME_attak220        	96
#define FRAME_attak221        	97
#define FRAME_attak222        	98
#define FRAME_attak223        	99
#define FRAME_attak224        	100
#define FRAME_attak225        	101
#define FRAME_attak226        	102
#define FRAME_attak227        	103
#define FRAME_attak228        	104
#define FRAME_attak229        	105
#define FRAME_attak230        	106
#define FRAME_attak231        	107
#define FRAME_attak232        	108
#define FRAME_attak233        	109
#define FRAME_attak234        	110
#define FRAME_attak235        	111
#define FRAME_attak236        	112
#define FRAME_attak237        	113
#define FRAME_attak238        	114
#define FRAME_attak301        	115
#define FRAME_attak302        	116
#define FRAME_attak303        	117
#define FRAME_attak304        	118
#define FRAME_attak305        	119
#define FRAME_attak306        	120
#define FRAME_attak307        	121
#define FRAME_attak308        	122
#define FRAME_attak309        	123
#define FRAME_attak310        	124
#define FRAME_attak311        	125
#define FRAME_attak312        	126
#define FRAME_attak313        	127
#define FRAME_attak314        	128
#define FRAME_attak315        	129
#define FRAME_attak316        	130
#define FRAME_attak317        	131
#define FRAME_attak318        	132
#define FRAME_attak319        	133
#define FRAME_attak320        	134
#define FRAME_attak321        	135
#define FRAME_attak322        	136
#define FRAME_attak323        	137
#define FRAME_attak324        	138
#define FRAME_attak325        	139
#define FRAME_attak326        	140
#define FRAME_attak327        	141
#define FRAME_attak328        	142
#define FRAME_attak329        	143
#define FRAME_attak330        	144
#define FRAME_attak331        	145
#define FRAME_attak332        	146
#define FRAME_attak333        	147
#define FRAME_attak334        	148
#define FRAME_attak335        	149
#define FRAME_attak336        	150
#define FRAME_attak337        	151
#define FRAME_attak338        	152
#define FRAME_attak339        	153
#define FRAME_attak340        	154
#define FRAME_attak341        	155
#define FRAME_attak342        	156
#define FRAME_attak343        	157
#define FRAME_attak344        	158
#define FRAME_attak345        	159
#define FRAME_attak346        	160
#define FRAME_attak347        	161
#define FRAME_attak348        	162
#define FRAME_attak349        	163
#define FRAME_attak350        	164
#define FRAME_attak351        	165
#define FRAME_attak352        	166
#define FRAME_attak353        	167
#define FRAME_attak401        	168
#define FRAME_attak402        	169
#define FRAME_attak403        	170
#define FRAME_attak404        	171
#define FRAME_attak405        	172
#define FRAME_attak406        	173
#define FRAME_attak407        	174
#define FRAME_attak408        	175
#define FRAME_attak409        	176
#define FRAME_attak410        	177
#define FRAME_attak411        	178
#define FRAME_attak412        	179
#define FRAME_attak413        	180
#define FRAME_attak414        	181
#define FRAME_attak415        	182
#define FRAME_attak416        	183
#define FRAME_attak417        	184
#define FRAME_attak418        	185
#define FRAME_attak419        	186
#define FRAME_attak420        	187
#define FRAME_attak421        	188
#define FRAME_attak422        	189
#define FRAME_attak423        	190
#define FRAME_attak424        	191
#define FRAME_attak425        	192
#define FRAME_attak426        	193
#define FRAME_attak427        	194
#define FRAME_attak428        	195
#define FRAME_attak429        	196
#define FRAME_pain101         	197
#define FRAME_pain102         	198
#define FRAME_pain103         	199
#define FRAME_pain104         	200
#define FRAME_pain201         	201
#define FRAME_pain202         	202
#define FRAME_pain203         	203
#define FRAME_pain204         	204
#define FRAME_pain205         	205
#define FRAME_pain301         	206
#define FRAME_pain302         	207
#define FRAME_pain303         	208
#define FRAME_pain304         	209
#define FRAME_pain305         	210
#define FRAME_pain306         	211
#define FRAME_pain307         	212
#define FRAME_pain308         	213
#define FRAME_pain309         	214
#define FRAME_pain310         	215
#define FRAME_pain311         	216
#define FRAME_pain312         	217
#define FRAME_pain313         	218
#define FRAME_pain314         	219
#define FRAME_pain315         	220
#define FRAME_pain316         	221
#define FRAME_death101        	222
#define FRAME_death102        	223
#define FRAME_death103        	224
#define FRAME_death104        	225
#define FRAME_death105        	226
#define FRAME_death106        	227
#define FRAME_death107        	228
#define FRAME_death108        	229
#define FRAME_death109        	230
#define FRAME_death110        	231
#define FRAME_death111        	232
#define FRAME_death112        	233
#define FRAME_death113        	234
#define FRAME_death114        	235
#define FRAME_death115        	236
#define FRAME_death116        	237
#define FRAME_death117        	238
#define FRAME_death118        	239
#define FRAME_death119        	240
#define FRAME_death120        	241
#define FRAME_death121        	242
#define FRAME_death122        	243
#define FRAME_death123        	244
#define FRAME_death124        	245
#define FRAME_death125        	246
#define FRAME_death126        	247
#define FRAME_death127        	248
#define FRAME_death128        	249
#define FRAME_death129        	250
#define FRAME_death130        	251
#define FRAME_death131        	252
#define FRAME_death132        	253
#define FRAME_recln101        	254
#define FRAME_recln102        	255
#define FRAME_recln103        	256
#define FRAME_recln104        	257
#define FRAME_recln105        	258
#define FRAME_recln106        	259
#define FRAME_recln107        	260
#define FRAME_recln108        	261
#define FRAME_recln109        	262
#define FRAME_recln110        	263
#define FRAME_recln111        	264
#define FRAME_recln112        	265
#define FRAME_recln113        	266
#define FRAME_recln114        	267
#define FRAME_recln115        	268
#define FRAME_recln116        	269
#define FRAME_recln117        	270
#define FRAME_recln118        	271
#define FRAME_recln119        	272
#define FRAME_recln120        	273
#define FRAME_recln121        	274
#define FRAME_recln122        	275
#define FRAME_recln123        	276
#define FRAME_recln124        	277
#define FRAME_recln125        	278
#define FRAME_recln126        	279
#define FRAME_recln127        	280
#define FRAME_recln128        	281
#define FRAME_recln129        	282
#define FRAME_recln130        	283
#define FRAME_recln131        	284
#define FRAME_recln132        	285
#define FRAME_recln133        	286
#define FRAME_recln134        	287
#define FRAME_recln135        	288
#define FRAME_recln136        	289
#define FRAME_recln137        	290
#define FRAME_recln138        	291
#define FRAME_recln139        	292
#define FRAME_recln140        	293
X
#define MODEL_SCALE		1.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_tank.h' &&
  chmod 0664 'm_tank.h' ||
  $echo 'restore of' 'm_tank.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_tank.h:' 'MD5 check failed'
556abdd778e6e3717167cd925b5ad9a7  m_tank.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_tank.h'`"
    test 10302 -eq "$shar_count" ||
    $echo 'm_tank.h:' 'original size' '10302,' 'current size' "$shar_count!"
  fi
fi
# ============= m_turret.c ==============
if test -f 'm_turret.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_turret.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_turret.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_turret.c' &&
/*
==============================================================================
X
TURRET
X
==============================================================================
*/
X
#include "g_local.h"
#include "m_turret.h"
X
#define SPAWN_BLASTER			0x0008
#define SPAWN_MACHINEGUN		0x0010
#define SPAWN_ROCKET			0x0020
#define SPAWN_HEATBEAM			0x0040
#define SPAWN_WEAPONCHOICE		0x0078
#define SPAWN_INSTANT_WEAPON	0x0050
#define SPAWN_WALL_UNIT			0x0080
X
extern qboolean FindTarget (edict_t *self);
X
void turret_run (edict_t *self);
void TurretAim (edict_t *self);
void turret_sight (edict_t *self, edict_t *other);
void turret_search (edict_t *self);
void turret_stand (edict_t *self);
void turret_wake (edict_t *self);
void turret_ready_gun (edict_t *self);
void turret_run (edict_t *self);
X
void turret_attack (edict_t *self);
mmove_t turret_move_fire;
mmove_t turret_move_fire_blind;
X
X
void TurretAim(edict_t *self)
{
X	vec3_t	end, dir;
X	vec3_t	ang;
X	float	move, idealPitch, idealYaw, current, speed;
X	int		orientation;
X
// gi.dprintf("turret_aim: %d %d\n", self->s.frame, self->monsterinfo.nextframe);
X
X	if(!self->enemy || self->enemy == world)
X	{
X		if(!FindTarget (self))
X			return;
X	}
X
X	// if turret is still in inactive mode, ready the gun, but don't aim
X	if(self->s.frame < FRAME_active01)
X	{
X		turret_ready_gun(self);
X		return;
X	}
X	// if turret is still readying, don't aim.
X	if(self->s.frame < FRAME_run01)
X		return;
X
X	// PMM - blindfire aiming here
X	if (self->monsterinfo.currentmove == &turret_move_fire_blind)
X	{
X		VectorCopy(self->monsterinfo.blind_fire_target, end);
X		if (self->enemy->s.origin[2] < self->monsterinfo.blind_fire_target[2])
X			end[2] += self->enemy->viewheight + 10;
X		else
X			end[2] += self->enemy->mins[2] - 10;
X	}
X	else
X	{
X		VectorCopy(self->enemy->s.origin, end);
X		if (self->enemy->client)
X			end[2] += self->enemy->viewheight;
X	}
X
X	VectorSubtract(end, self->s.origin, dir);
X	vectoangles2(dir, ang);
X
X	//
X	// Clamp first
X	//
X
X	idealPitch = ang[PITCH];
X	idealYaw = ang[YAW];
X
X	orientation = self->offset[1];
X	switch(orientation)
X	{
X		case -1:			// up		pitch: 0 to 90
X			if(idealPitch < -90)
X				idealPitch += 360;
X			if(idealPitch > -5)
X				idealPitch = -5;
X			break;
X		case -2:			// down		pitch: -180 to -360
X			if(idealPitch > -90)
X				idealPitch -= 360;
X			if(idealPitch < -355)
X				idealPitch = -355;
X			else if(idealPitch > -185)
X				idealPitch = -185;
X			break;
X		case 0:				// +X		pitch: 0 to -90, -270 to -360 (or 0 to 90)
//gi.dprintf("idealpitch %0.1f  idealyaw %0.1f\n", idealPitch, idealYaw);
X			if(idealPitch < -180)
X				idealPitch += 360;
X
X			if(idealPitch > 85)
X				idealPitch = 85;
X			else if(idealPitch < -85)
X				idealPitch = -85;
X
//gi.dprintf("idealpitch %0.1f  idealyaw %0.1f\n", idealPitch, idealYaw);
X							//			yaw: 270 to 360, 0 to 90
X							//			yaw: -90 to 90 (270-360 == -90-0)
X			if(idealYaw > 180)
X				idealYaw -= 360;
X			if(idealYaw > 85)
X				idealYaw = 85;
X			else if(idealYaw < -85)
X				idealYaw = -85;
//gi.dprintf("idealpitch %0.1f  idealyaw %0.1f\n", idealPitch, idealYaw);
X			break;
X		case 90:			// +Y	pitch: 0 to 90, -270 to -360 (or 0 to 90)
X			if(idealPitch < -180)
X				idealPitch += 360;
X
X			if(idealPitch > 85)
X				idealPitch = 85;
X			else if(idealPitch < -85)
X				idealPitch = -85;
X
X							//			yaw: 0 to 180
X			if(idealYaw > 270)
X				idealYaw -= 360;
X			if(idealYaw > 175)	idealYaw = 175;
X			else if(idealYaw < 5)	idealYaw = 5;
X
X			break;
X		case 180:			// -X	pitch: 0 to 90, -270 to -360 (or 0 to 90)
X			if(idealPitch < -180)
X				idealPitch += 360;
X
X			if(idealPitch > 85)
X				idealPitch = 85;
X			else if(idealPitch < -85)
X				idealPitch = -85;
X
X							//			yaw: 90 to 270
X			if(idealYaw > 265)	idealYaw = 265;
X			else if(idealYaw < 95)	idealYaw = 95;
X
X			break;
X		case 270:			// -Y	pitch: 0 to 90, -270 to -360 (or 0 to 90)
X			if(idealPitch < -180)
X				idealPitch += 360;
X
X			if(idealPitch > 85)
X				idealPitch = 85;
X			else if(idealPitch < -85)
X				idealPitch = -85;
X
X							//			yaw: 180 to 360
X			if(idealYaw < 90)
X				idealYaw += 360;
X			if(idealYaw > 355)	idealYaw = 355;
X			else if(idealYaw < 185)	idealYaw = 185;
X			break;
X	}
X
X	//
X	// adjust pitch
X	//
X	current = self->s.angles[PITCH];
X	speed = self->yaw_speed;
X
X	if(idealPitch != current)
X	{
X		move = idealPitch - current;
X
X		while(move >= 360)
X			move -= 360;
X		if (move >= 90)
X		{
X			move = move - 360;
X		}
X
X		while(move <= -360)
X			move += 360;
X		if (move <= -90)
X		{
X			move = move + 360;
X		}
X
X		if (move > 0)
X		{
X			if (move > speed)
X				move = speed;
X		}
X		else
X		{
X			if (move < -speed)
X				move = -speed;
X		}
X
X		self->s.angles[PITCH] = anglemod (current + move);
X	}
X
X	//
X	// adjust yaw
X	//
X	current = self->s.angles[YAW];
X	speed = self->yaw_speed;
X
X	if(idealYaw != current)
X	{
X		move = idealYaw - current;
X
//		while(move >= 360)
//			move -= 360;
X		if (move >= 180)
X		{
X			move = move - 360;
X		}
X
//		while(move <= -360)
//			move += 360;
X		if (move <= -180)
X		{
X			move = move + 360;
X		}
X
X		if (move > 0)
X		{
X			if (move > speed)
X				move = speed;
X		}
X		else
X		{
X			if (move < -speed)
X				move = -speed;
X		}
X
X		self->s.angles[YAW] = anglemod (current + move);
X	}
X
}
X
void turret_sight (edict_t *self, edict_t *other)
{
}
X
void turret_search (edict_t *self)
{
}
X
mframe_t turret_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t turret_move_stand = {FRAME_stand01, FRAME_stand02, turret_frames_stand, NULL};
X
void turret_stand (edict_t *self)
{
//gi.dprintf("turret_stand\n");
X	self->monsterinfo.currentmove = &turret_move_stand;
}
X
mframe_t turret_frames_ready_gun [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	
X	ai_stand, 0, NULL
};
mmove_t turret_move_ready_gun = { FRAME_active01, FRAME_run01, turret_frames_ready_gun, turret_run };
X
void turret_ready_gun (edict_t *self)
{
X	self->monsterinfo.currentmove = &turret_move_ready_gun;
}
X
mframe_t turret_frames_seek [] =
{
X	ai_walk, 0, TurretAim,
X	ai_walk, 0, TurretAim
};
mmove_t turret_move_seek = {FRAME_run01, FRAME_run02, turret_frames_seek, NULL};
X
void turret_walk (edict_t *self)
{
X	if(self->s.frame < FRAME_run01)
X		turret_ready_gun(self);
X	else
X		self->monsterinfo.currentmove = &turret_move_seek;
}
X
X
mframe_t turret_frames_run [] =
{
X	ai_run, 0, TurretAim,
X	ai_run, 0, TurretAim
};
mmove_t turret_move_run = {FRAME_run01, FRAME_run02, turret_frames_run, turret_run};
X
void turret_run (edict_t *self)
{
X	if(self->s.frame < FRAME_run01)
X		turret_ready_gun(self);
X	else
X		self->monsterinfo.currentmove = &turret_move_run;
}
X
// **********************
//  ATTACK
// **********************
X
#define TURRET_BULLET_DAMAGE	4
#define TURRET_HEAT_DAMAGE		4
X
void TurretFire (edict_t *self)
{
X	vec3_t	forward;
X	vec3_t	start, end, dir;
X	float	time, dist, chance;
X	trace_t	trace;
X	int		rocketSpeed;
X
X	TurretAim(self);
X
X	if(!self->enemy || !self->enemy->inuse)
X		return;
X
X	VectorSubtract(self->enemy->s.origin, self->s.origin, dir);
X	VectorNormalize(dir);
X	AngleVectors(self->s.angles, forward, NULL, NULL);
X	chance = DotProduct(dir, forward);
X	if(chance < 0.98)
X	{
//		gi.dprintf("off-angle\n");
X		return;
X	}
X
X	chance = random();
X
X	// rockets fire less often than the others do.
X	if (self->spawnflags & SPAWN_ROCKET)
X	{
X		chance = chance * 3;
X
X		rocketSpeed = 550;
X		if (skill->value == 2)
X		{
X			rocketSpeed += 200 * random();
X		}
X		else if (skill->value == 3)
X		{
X			rocketSpeed += 100 + (200 * random());
X		}
X	}
X	else if (self->spawnflags & SPAWN_BLASTER)
X	{
X		if (skill->value == 0)
X			rocketSpeed = 600;
X		else if (skill->value == 1)
X			rocketSpeed = 800;
X		else
X			rocketSpeed = 1000;
X		chance = chance * 2;
X	}
X	
X	// up the fire chance 20% per skill level.
X	chance = chance - (0.2 * skill->value);
X
X	if(/*chance < 0.5 && */visible(self, self->enemy))
X	{
X		VectorCopy(self->s.origin, start);
X		VectorCopy(self->enemy->s.origin, end);
X		
X		// aim for the head.
X		if ((self->enemy) && (self->enemy->client))
X			end[2]+=self->enemy->viewheight;
X		else
X			end[2]+=22;
X
X		VectorSubtract(end, start, dir);
X		dist = VectorLength(dir);
X		
X		// check for predictive fire if distance less than 512
X		if(!(self->spawnflags & SPAWN_INSTANT_WEAPON) && (dist<512))
X		{
X			chance = random();
X			// ramp chance. easy - 50%, avg - 60%, hard - 70%, nightmare - 80%
X			chance += (3 - skill->value) * 0.1;
X			if(chance < 0.8)
X			{
X				// lead the target....
X				time = dist / 1000;
X				VectorMA(end, time, self->enemy->velocity, end);
X				VectorSubtract(end, start, dir);
X			}
X		}
X
X		VectorNormalize(dir);
X		trace = gi.trace(start, vec3_origin, vec3_origin, end, self, MASK_SHOT);
X		if(trace.ent == self->enemy || trace.ent == world)
X		{
X			if(self->spawnflags & SPAWN_BLASTER)
X				monster_fire_blaster(self, start, dir, 20, rocketSpeed, MZ2_TURRET_BLASTER, EF_BLASTER);
X			else if(self->spawnflags & SPAWN_MACHINEGUN)
X				monster_fire_bullet (self, start, dir, TURRET_BULLET_DAMAGE, 0, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_TURRET_MACHINEGUN);
X			else if(self->spawnflags & SPAWN_ROCKET)
X			{
X				if(dist * trace.fraction > 72)
X					monster_fire_rocket (self, start, dir, 50, rocketSpeed, MZ2_TURRET_ROCKET);
X			}
X		}	
X	}
}
X
// PMM
void TurretFireBlind (edict_t *self)
{
X	vec3_t	forward;
X	vec3_t	start, end, dir;
X	float	dist, chance;
X	int		rocketSpeed;
X
X	TurretAim(self);
X
X	if(!self->enemy || !self->enemy->inuse)
X		return;
X
X	VectorSubtract(self->monsterinfo.blind_fire_target, self->s.origin, dir);
X	VectorNormalize(dir);
X	AngleVectors(self->s.angles, forward, NULL, NULL);
X	chance = DotProduct(dir, forward);
X	if(chance < 0.98)
X	{
//		gi.dprintf("off-angle\n");
X		return;
X	}
X
X	if (self->spawnflags & SPAWN_ROCKET)
X	{
X		rocketSpeed = 550;
X		if (skill->value == 2)
X		{
X			rocketSpeed += 200 * random();
X		}
X		else if (skill->value == 3)
X		{
X			rocketSpeed += 100 + (200 * random());
X		}
X	}
X
X	VectorCopy(self->s.origin, start);
X	VectorCopy(self->monsterinfo.blind_fire_target, end);
X		
X	if (self->enemy->s.origin[2] < self->monsterinfo.blind_fire_target[2])
X		end[2] += self->enemy->viewheight + 10;
X	else
X		end[2] += self->enemy->mins[2] - 10;
X
X	VectorSubtract(end, start, dir);
X	dist = VectorLength(dir);
X		
X	VectorNormalize(dir);
X
X	if(self->spawnflags & SPAWN_BLASTER)
X		monster_fire_blaster(self, start, dir, 20, 1000, MZ2_TURRET_BLASTER, EF_BLASTER);
X	else if(self->spawnflags & SPAWN_ROCKET)
X		monster_fire_rocket (self, start, dir, 50, rocketSpeed, MZ2_TURRET_ROCKET);
}
//pmm
X
mframe_t turret_frames_fire [] =
{
X	ai_run,   0, TurretFire,
X	ai_run,   0, TurretAim,
X	ai_run,   0, TurretAim,
X	ai_run,   0, TurretAim
};
mmove_t turret_move_fire = {FRAME_pow01, FRAME_pow04, turret_frames_fire, turret_run};
X
//PMM
X
// the blind frames need to aim first
mframe_t turret_frames_fire_blind [] =
{
X	ai_run,   0, TurretAim,
X	ai_run,   0, TurretAim,
X	ai_run,   0, TurretAim,
X	ai_run,   0, TurretFireBlind
};
mmove_t turret_move_fire_blind = {FRAME_pow01, FRAME_pow04, turret_frames_fire_blind, turret_run};
//pmm
X
void turret_attack(edict_t *self)
{
X	float r, chance;
X
X	if(self->s.frame < FRAME_run01)
X		turret_ready_gun(self);
X	// PMM
X	else if (self->monsterinfo.attack_state != AS_BLIND)
X	{
X		self->monsterinfo.nextframe = FRAME_pow01;
X		self->monsterinfo.currentmove = &turret_move_fire;
X	}
X	else
X	{
X		// setup shot probabilities
X		if (self->monsterinfo.blind_fire_delay < 1.0)
X			chance = 1.0;
X		else if (self->monsterinfo.blind_fire_delay < 7.5)
X			chance = 0.4;
X		else
X			chance = 0.1;
X
X		r = random();
X
X		// minimum of 3 seconds, plus 0-4, after the shots are done - total time should be max less than 7.5
X		self->monsterinfo.blind_fire_delay += 0.4 + 3.0 + random()*4.0;
X		// don't shoot at the origin
X		if (VectorCompare (self->monsterinfo.blind_fire_target, vec3_origin))
X			return;
X
X		// don't shoot if the dice say not to
X		if (r > chance)
X			return;
X
X		self->monsterinfo.nextframe = FRAME_pow01;
X		self->monsterinfo.currentmove = &turret_move_fire_blind;
X	}
X	// pmm
}
X
// **********************
//  PAIN
// **********************
X
void turret_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	return;
}
X
// **********************
//  DEATH
// **********************
X
void turret_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	vec3_t		forward;
X	vec3_t		start;
X	edict_t		*base;
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_PLAIN_EXPLOSION);
X	gi.WritePosition (self->s.origin);
X	gi.multicast (self->s.origin, MULTICAST_PHS);
X
X	AngleVectors(self->s.angles, forward, NULL, NULL);
X	VectorMA(self->s.origin, 1, forward, start);
X
X	ThrowDebris (self, "models/objects/debris1/tris.md2", 1, start);
X	ThrowDebris (self, "models/objects/debris1/tris.md2", 2, start);
X	ThrowDebris (self, "models/objects/debris1/tris.md2", 1, start);
X	ThrowDebris (self, "models/objects/debris1/tris.md2", 2, start);
X
X	if(self->teamchain)
X	{
X		base = self->teamchain;
X		base->solid = SOLID_BBOX;
X		base->takedamage = DAMAGE_NO;
X		base->movetype = MOVETYPE_NONE;
X		gi.linkentity (base);
X	}
X
X	if(self->target)
X	{
X		if(self->enemy && self->enemy->inuse)
X			G_UseTargets (self, self->enemy);
X		else
X			G_UseTargets (self, self);
X	}
X
X	G_FreeEdict(self);
}
X
// **********************
//  WALL SPAWN
// **********************
X
void turret_wall_spawn (edict_t *turret)
{
X	edict_t		*ent;
X	int			angle;
X
X	ent = G_Spawn();
X	VectorCopy(turret->s.origin, ent->s.origin);
X	VectorCopy(turret->s.angles, ent->s.angles);
X	
X	angle = ent->s.angles[1];
X	if(ent->s.angles[0] == 90)
X		angle = -1;
X	else if(ent->s.angles[0] == 270)
X		angle = -2;
X	switch (angle)
X	{
X		case -1:
X			VectorSet(ent->mins, -16, -16, -8);
X			VectorSet(ent->maxs, 16, 16, 0);
X			break;
X		case -2:
X			VectorSet(ent->mins, -16, -16, 0);
X			VectorSet(ent->maxs, 16, 16, 8);
X			break;
X		case 0:
X			VectorSet(ent->mins, -8, -16, -16);
X			VectorSet(ent->maxs, 0, 16, 16);
X			break;
X		case 90:
X			VectorSet(ent->mins, -16, -8, -16);
X			VectorSet(ent->maxs, 16, 0, 16);
X			break;
X		case 180:
X			VectorSet(ent->mins, 0, -16, -16);
X			VectorSet(ent->maxs, 8, 16, 16);
X			break;
X		case 270:
X			VectorSet(ent->mins, -16, 0, -16);
X			VectorSet(ent->maxs, 16, 8, 16);
X			break;
X
X	}
X
X	ent->movetype = MOVETYPE_PUSH;
X	ent->solid = SOLID_NOT;
X
X	ent->teammaster = turret;
X	turret->teammaster = turret;
X	turret->teamchain = ent;
X	ent->teamchain = NULL;
X	ent->flags |= FL_TEAMSLAVE;
X	ent->owner = turret;
X
X	ent->s.modelindex = gi.modelindex("models/monsters/turretbase/tris.md2");
X
X	gi.linkentity (ent);
}
X
void turret_wake (edict_t *self)
{
X	// the wall section will call this when it stops moving.
X	// just return without doing anything. easiest way to have a null function.
X	if(self->flags & FL_TEAMSLAVE)
X	{
X		return;
X	}
X
X	self->monsterinfo.stand = turret_stand;
X	self->monsterinfo.walk = turret_walk;
X	self->monsterinfo.run = turret_run;
X	self->monsterinfo.dodge = NULL;
X	self->monsterinfo.attack = turret_attack;
X	self->monsterinfo.melee = NULL;
X	self->monsterinfo.sight = turret_sight;
X	self->monsterinfo.search = turret_search;
X	self->monsterinfo.currentmove = &turret_move_stand;
X	self->takedamage = DAMAGE_AIM;
X	self->movetype = MOVETYPE_NONE;
X	// prevent counting twice
X	self->monsterinfo.aiflags |= AI_DO_NOT_COUNT;
X
X	gi.linkentity (self);
X
X	stationarymonster_start (self);
X	
X	if(self->spawnflags & SPAWN_MACHINEGUN)
X	{
X		self->s.skinnum = 1;
X	}
X	else if(self->spawnflags & SPAWN_ROCKET)
X	{
X		self->s.skinnum = 2;
X	}
X
X	// but we do want the death to count
X	self->monsterinfo.aiflags &= ~AI_DO_NOT_COUNT;
}
X
extern void Move_Calc (edict_t *ent, vec3_t dest, void(*func)(edict_t*));
X
void turret_activate (edict_t *self, edict_t *other, edict_t *activator)
{
X	vec3_t		endpos;
X	vec3_t		forward;
X	edict_t		*base;
X
X	self->movetype = MOVETYPE_PUSH;
X	if(!self->speed)
X		self->speed = 15;
X	self->moveinfo.speed = self->speed;
X	self->moveinfo.accel = self->speed;
X	self->moveinfo.decel = self->speed;
X
X	if(self->s.angles[0] == 270)
X	{
X		VectorSet (forward, 0,0,1);
X	}
X	else if(self->s.angles[0] == 90)
X	{
X		VectorSet (forward, 0,0,-1);
X	}
X	else if(self->s.angles[1] == 0)
X	{
X		VectorSet (forward, 1,0,0);
X	}
X	else if(self->s.angles[1] == 90)
X	{
X		VectorSet (forward, 0,1,0);
X	}
X	else if(self->s.angles[1] == 180)
X	{
X		VectorSet (forward, -1,0,0);
X	}
X	else if(self->s.angles[1] == 270)
X	{
X		VectorSet (forward, 0,-1,0);
X	}
X	
X	// start up the turret
X	VectorMA(self->s.origin, 32, forward, endpos);
X	Move_Calc(self, endpos, turret_wake);
X
X	base = self->teamchain;
X	if(base)
X	{
X		base->movetype = MOVETYPE_PUSH;
X		base->speed = self->speed;
X		base->moveinfo.speed = base->speed;
X		base->moveinfo.accel = base->speed;
X		base->moveinfo.decel = base->speed;
X
X		// start up the wall section
X		VectorMA(self->teamchain->s.origin, 32, forward, endpos);
X		Move_Calc(self->teamchain, endpos, turret_wake);
X	}
X
X	gi.sound (self, CHAN_VOICE, gi.soundindex ("world/dr_short.wav"), 1, ATTN_NORM, 0);
}
X
// PMM
// checkattack .. ignore range, just attack if available
qboolean turret_checkattack (edict_t *self)
{
X	vec3_t	spot1, spot2;
X	float	chance, nexttime;
X	trace_t	tr;
X	int		enemy_range;
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA|CONTENTS_WINDOW);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X		{	
X			// PGM - we want them to go ahead and shoot at info_notnulls if they can.
X			if(self->enemy->solid != SOLID_NOT || tr.fraction < 1.0)		//PGM
X			{
X				// PMM - if we can't see our target, and we're not blocked by a monster, go into blind fire if available
X				if ((!(tr.ent->svflags & SVF_MONSTER)) && (!visible(self, self->enemy)))
X				{
X					if ((self->monsterinfo.blindfire) && (self->monsterinfo.blind_fire_delay <= 10.0))
X					{
X						if (level.time < self->monsterinfo.attack_finished)
X						{
X							return false;
X						}
X						if (level.time < (self->monsterinfo.trail_time + self->monsterinfo.blind_fire_delay))
X						{
X							// wait for our time
X							return false;
X						}
X						else
X						{
X							// make sure we're not going to shoot something we don't want to shoot
X							tr = gi.trace (spot1, NULL, NULL, self->monsterinfo.blind_fire_target, self, CONTENTS_MONSTER);
X							if (tr.allsolid || tr.startsolid || ((tr.fraction < 1.0) && (tr.ent != self->enemy)))
X							{
X								return false;
X							}
X
X							self->monsterinfo.attack_state = AS_BLIND;
X							self->monsterinfo.attack_finished = level.time + 0.5 + 2*random();
X							return true;
X						}
X					}
X				}
X				// pmm
X				return false;
X			}
X		}
X	}
X	
X	if (level.time < self->monsterinfo.attack_finished)
X		return false;
X
X	enemy_range = range(self, self->enemy);
X
X	if (enemy_range == RANGE_MELEE)
X	{
X		// don't always melee in easy mode
X		if (skill->value == 0 && (rand()&3) )
X			return false;
X		self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X	
X	if (self->spawnflags & SPAWN_ROCKET)
X	{
X		chance = 0.10;
X		nexttime = (1.8 - (0.2 * skill->value));
X	}
X	else if(self->spawnflags & SPAWN_BLASTER)
X	{
X		chance = 0.35;
X		nexttime = (1.2 - (0.2 * skill->value));
X	}
X	else
X	{
X		chance = 0.50;
X		nexttime = (0.8 - (0.1 * skill->value));
X	}
X
X	if (skill->value == 0)
X		chance *= 0.5;
X	else if (skill->value > 1)
X		chance *= 2;
X
X	// PGM - go ahead and shoot every time if it's a info_notnull
X	// PMM - added visibility check
X	if ( ((random () < chance) && (visible(self, self->enemy))) || (self->enemy->solid == SOLID_NOT))
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
//		self->monsterinfo.attack_finished = level.time + 0.3 + 2*random();
X		self->monsterinfo.attack_finished = level.time + nexttime;
X		return true;
X	}
X
X	self->monsterinfo.attack_state = AS_STRAIGHT;
X
X	return false;
}
X
X
// **********************
//  SPAWN
// **********************
X
/*QUAKED monster_turret (1 .5 0) (-16 -16 -16) (16 16 16) Ambush Trigger_Spawn Sight Blaster MachineGun Rocket Heatbeam WallUnit
X
The automated defense turret that mounts on walls. 
Check the weapon you want it to use: blaster, machinegun, rocket, heatbeam.
Default weapon is blaster.
When activated, wall units move 32 units in the direction they're facing.
*/
void SP_monster_turret (edict_t *self)
{
X	int		angle;
X
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	// VERSIONING
//	if (g_showlogic && g_showlogic->value)
//		gi.dprintf ("%s\n", ROGUE_VERSION_STRING);
X
//	self->plat2flags = ROGUE_VERSION_ID;
X	// versions
X
X	// pre-caches
X	gi.soundindex ("world/dr_short.wav");
X	gi.modelindex ("models/objects/debris1/tris.md2");
X
X	self->s.modelindex = gi.modelindex("models/monsters/turret/tris.md2");
X
X	VectorSet (self->mins, -12, -12, -12);
X	VectorSet (self->maxs, 12, 12, 12);
X	self->movetype = MOVETYPE_NONE;
X	self->solid = SOLID_BBOX;
X
X	self->health = 240;
X	self->gib_health = -100;
X	self->mass = 250;
X	self->yaw_speed = 45;
X
X	self->flags |= FL_MECHANICAL;
X
X	self->pain = turret_pain;
X	self->die = turret_die;
X
X	// map designer didn't specify weapon type. set it now.
X	if(!(self->spawnflags & SPAWN_WEAPONCHOICE))
X	{
X		self->spawnflags |= SPAWN_BLASTER;
//		self->spawnflags |= SPAWN_MACHINEGUN;
//		self->spawnflags |= SPAWN_ROCKET;
//		self->spawnflags |= SPAWN_HEATBEAM;
X	}
X
X	if(self->spawnflags & SPAWN_HEATBEAM)
X	{
X		self->spawnflags &= ~SPAWN_HEATBEAM;
X		self->spawnflags |= SPAWN_BLASTER;
X	}
X
X	if(!(self->spawnflags & SPAWN_WALL_UNIT))
X	{
X		self->monsterinfo.stand = turret_stand;
X		self->monsterinfo.walk = turret_walk;
X		self->monsterinfo.run = turret_run;
X		self->monsterinfo.dodge = NULL;
X		self->monsterinfo.attack = turret_attack;
X		self->monsterinfo.melee = NULL;
X		self->monsterinfo.sight = turret_sight;
X		self->monsterinfo.search = turret_search;
X		self->monsterinfo.currentmove = &turret_move_stand;
X	}
X
X	// PMM
X	self->monsterinfo.checkattack = turret_checkattack;
X
X	self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X	self->monsterinfo.scale = MODEL_SCALE;
X	self->gravity = 0;
X
X	VectorCopy(self->s.angles, self->offset);
X	angle=(int)self->s.angles[1];
X	switch(angle)
X	{
X		case -1:					// up
X			self->s.angles[0] = 270;
X			self->s.angles[1] = 0;
X			self->s.origin[2] += 2;
X			break;
X		case -2:					// down
X			self->s.angles[0] = 90;
X			self->s.angles[1] = 0;
X			self->s.origin[2] -= 2;
X			break;
X		case 0:
X			self->s.origin[0] += 2;
X			break;
X		case 90:
X			self->s.origin[1] += 2;
X			break;
X		case 180:
X			self->s.origin[0] -= 2;
X			break;
X		case 270:
X			self->s.origin[1] -= 2;
X			break;
X		default:
X			break;
X	}
X
X	gi.linkentity (self);
X
X
X	if(self->spawnflags & SPAWN_WALL_UNIT)
X	{
X		if(!self->targetname)
X		{
//			gi.dprintf("Wall Unit Turret without targetname! %s\n", vtos(self->s.origin));
X			G_FreeEdict(self);
X			return;
X		}
X
X		self->takedamage = DAMAGE_NO;
X		self->use = turret_activate;
X		turret_wall_spawn(self);
X		if ((!(self->monsterinfo.aiflags & AI_GOOD_GUY)) && (!(self->monsterinfo.aiflags & AI_DO_NOT_COUNT)))
X			level.total_monsters++;
X
X	}
X	else
X	{
X		stationarymonster_start (self);
X	}
X
X	if(self->spawnflags & SPAWN_MACHINEGUN)
X	{
X		gi.soundindex ("infantry/infatck1.wav");
X		self->s.skinnum = 1;
X	}
X	else if(self->spawnflags & SPAWN_ROCKET)
X	{
X		gi.soundindex ("weapons/rockfly.wav");
X		gi.modelindex ("models/objects/rocket/tris.md2");
X		gi.soundindex ("chick/chkatck2.wav");
X		self->s.skinnum = 2;
X	}
X	else
X	{
X		if (!(self->spawnflags & SPAWN_BLASTER))
X		{
X			self->spawnflags |= SPAWN_BLASTER;
X		}
X		gi.modelindex ("models/objects/laser/tris.md2");
X		gi.soundindex ("misc/lasfly.wav");
X		gi.soundindex ("soldier/solatck2.wav");
X	}
X	
X	// PMM  - turrets don't get mad at monsters, and visa versa
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X	// PMM - blindfire
X	if(self->spawnflags & (SPAWN_ROCKET|SPAWN_BLASTER))
X		self->monsterinfo.blindfire = true;
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_turret.c' &&
  chmod 0664 'm_turret.c' ||
  $echo 'restore of' 'm_turret.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_turret.c:' 'MD5 check failed'
326d683f7eb8b2f509b84ce1e63db27d  m_turret.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_turret.c'`"
    test 23725 -eq "$shar_count" ||
    $echo 'm_turret.c:' 'original size' '23725,' 'current size' "$shar_count!"
  fi
fi
# ============= m_turret.h ==============
if test -f 'm_turret.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_turret.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_turret.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_turret.h' &&
// G:\quake2\xpack\models/monsters/turret
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_stand01         	0
#define FRAME_stand02         	1
#define FRAME_active01        	2
#define FRAME_active02        	3
#define FRAME_active03        	4
#define FRAME_active04        	5
#define FRAME_active05        	6
#define FRAME_active06        	7
#define FRAME_run01           	8
#define FRAME_run02           	9
#define FRAME_pow01           	10
#define FRAME_pow02           	11
#define FRAME_pow03           	12
#define FRAME_pow04           	13
#define FRAME_death01         	14
#define FRAME_death02         	15
X
#define MODEL_SCALE		3.500000
SHAR_EOF
  $shar_touch -am 1130175398 'm_turret.h' &&
  chmod 0664 'm_turret.h' ||
  $echo 'restore of' 'm_turret.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_turret.h:' 'MD5 check failed'
593f254f55615bd4d7063a53ca7ef587  m_turret.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_turret.h'`"
    test 657 -eq "$shar_count" ||
    $echo 'm_turret.h:' 'original size' '657,' 'current size' "$shar_count!"
  fi
fi
# ============= m_widow.c ==============
if test -f 'm_widow.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_widow.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_widow.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_widow.c' &&
/*
==============================================================================
X
black widow
X
==============================================================================
*/
X
// self->timestamp used to prevent rapid fire of railgun
// self->plat2flags used for fire count (flashes)
// self->monsterinfo.pausetime used for timing of blaster shots
X
#include "g_local.h"
#include "m_widow.h"
X
#define	NUM_STALKERS_SPAWNED		6		// max # of stalkers she can spawn
X
#define	RAIL_TIME					3
#define	BLASTER_TIME				2
#define	BLASTER2_DAMAGE				10
#define	WIDOW_RAIL_DAMAGE			50
X
#define	DRAWBBOX					NULL
#define	SHOWME						NULL	// showme
X
void BossExplode (edict_t *self);
X
qboolean infront (edict_t *self, edict_t *other);
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_pain3;
static int	sound_search1;
static int	sound_rail;
static int	sound_sight;
X
static unsigned long shotsfired;
X
static vec3_t spawnpoints[] = {
X	{30,  100, 16},
X	{30, -100, 16}
};
X
static vec3_t beameffects[] = {
X	{12.58, -43.71, 68.88},
X	{3.43, 58.72, 68.41}
};
X
static float sweep_angles[] = {
//	32.0, 26.0, 20.0, 11.5, 3.0, -8.0, -13.0, -27.0, -41.0
X	32.0, 26.0, 20.0, 10.0, 0.0, -6.5, -13.0, -27.0, -41.0
};
X
vec3_t stalker_mins = {-28, -28, -18};
vec3_t stalker_maxs = {28, 28, 18};
X
unsigned int	widow_damage_multiplier;
X
void widow_run (edict_t *self);
void widow_stand (edict_t *self);
void widow_dead (edict_t *self);
void widow_attack (edict_t *self);
void widow_attack_blaster (edict_t *self);
void widow_reattack_blaster (edict_t *self);
void widow_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
X
void widow_start_spawn (edict_t *self);
void widow_done_spawn (edict_t *self);
void widow_spawn_check (edict_t *self);
void widow_prep_spawn (edict_t *self);
void widow_attack_rail (edict_t *self);
X
void widow_start_run_5 (edict_t *self);
void widow_start_run_10 (edict_t *self);
void widow_start_run_12 (edict_t *self);
X
void WidowCalcSlots (edict_t *self);
X
void drawbbox (edict_t *self);
X
void showme (edict_t *self)
{
X	gi.dprintf ("frame %d\n", self->s.frame);
}
X
void widow_search (edict_t *self)
{
//	if (random() < 0.5)
//		gi.sound (self, CHAN_VOICE, sound_search1, 1, ATTN_NONE, 0);
}
X
void widow_sight (edict_t *self, edict_t *other)
{
X	self->monsterinfo.pausetime = 0;
//	gi.sound (self, CHAN_WEAPON, sound_sight, 1, ATTN_NORM, 0);
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("widow: found target!\n");
}
X
mmove_t widow_move_attack_post_blaster;
mmove_t widow_move_attack_post_blaster_r;
mmove_t widow_move_attack_post_blaster_l;
mmove_t widow_move_attack_blaster;
X
float target_angle (edict_t *self)
{
X	vec3_t target;
X	float enemy_yaw;
X
X	VectorSubtract (self->s.origin, self->enemy->s.origin, target);
X	enemy_yaw = self->s.angles[YAW] - vectoyaw2(target);
X	if (enemy_yaw < 0)
X		enemy_yaw += 360.0;
X
X	// this gets me 0 degrees = forward
X	enemy_yaw -= 180.0;
X	// positive is to right, negative to left
X
X	return enemy_yaw;
}
X
int WidowTorso (edict_t *self)
{
X	float enemy_yaw;
X
X	enemy_yaw = target_angle (self);
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("%2.2f -> ", enemy_yaw);
X
X	if (enemy_yaw >= 105)
X	{
X		self->monsterinfo.currentmove = &widow_move_attack_post_blaster_r;
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		return 0;
X	}
X
X	if (enemy_yaw <= -75.0)
X	{
X		self->monsterinfo.currentmove = &widow_move_attack_post_blaster_l;
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		return 0;
X	}
X
X	if (enemy_yaw >= 95)
X		return FRAME_fired03;
X	else if (enemy_yaw >= 85)
X		return FRAME_fired04;
X	else if (enemy_yaw >= 75)
X		return FRAME_fired05;
X	else if (enemy_yaw >= 65)
X		return FRAME_fired06;
X	else if (enemy_yaw >= 55)
X		return FRAME_fired07;
X	else if (enemy_yaw >= 45)
X		return FRAME_fired08;
X	else if (enemy_yaw >= 35)
X		return FRAME_fired09;
X	else if (enemy_yaw >= 25)
X		return FRAME_fired10;
X	else if (enemy_yaw >= 15)
X		return FRAME_fired11;
X	else if (enemy_yaw >= 5)
X		return FRAME_fired12;
X	else if (enemy_yaw >= -5)
X		return FRAME_fired13;
X	else if (enemy_yaw >= -15)
X		return FRAME_fired14;
X	else if (enemy_yaw >= -25)
X		return FRAME_fired15;
X	else if (enemy_yaw >= -35)
X		return FRAME_fired16;
X	else if (enemy_yaw >= -45)
X		return FRAME_fired17;
X	else if (enemy_yaw >= -55)
X		return FRAME_fired18;
X	else if (enemy_yaw >= -65)
X		return FRAME_fired19;
X	else if (enemy_yaw >= -75)
X		return FRAME_fired20;
/*
X	if (fabs(enemy_yaw) < 11.25)
X		return FRAME_fired03;
X	else if (fabs(enemy_yaw) > 56.25)
X	{
X		self->monsterinfo.currentmove = &widow_move_attack_post_blaster;
X		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		return;
X	}
X	else if ((enemy_yaw >= 11.25) && (enemy_yaw < 33.75))
X		return FRAME_fired04;
X	else if (enemy_yaw >= 33.75)
X		return FRAME_fired05;
X	else if ((enemy_yaw <= -11.25) && (enemy_yaw > -33.75))
X		return FRAME_fired06;
X	else if (enemy_yaw <= -33.75)
X		return FRAME_fired07;
*/
}
X
#define	VARIANCE 15.0
X
void WidowBlaster (edict_t *self)
{
X	vec3_t	forward, right, target, vec, targ_angles;
X	vec3_t	start;
X	int		flashnum;
X	int		effect;
X
X	if (!self->enemy)
X		return;
X
X	shotsfired++;
X	if (!(shotsfired % 4))
X		effect = EF_BLASTER;
X	else
X		effect = 0;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	if ((self->s.frame >= FRAME_spawn05) && (self->s.frame <= FRAME_spawn13))
X	{
X		// sweep
X		flashnum = MZ2_WIDOW_BLASTER_SWEEP1 + self->s.frame - FRAME_spawn05;
X		G_ProjectSource (self->s.origin, monster_flash_offset[flashnum], forward, right, start);
X		VectorSubtract (self->enemy->s.origin, start, target);
X		vectoangles2 (target, targ_angles);
X		
X		VectorCopy (self->s.angles, vec);
X
X		vec[PITCH] += targ_angles[PITCH];
X		vec[YAW] -= sweep_angles[flashnum-MZ2_WIDOW_BLASTER_SWEEP1];
X
X		AngleVectors (vec, forward, NULL, NULL);
X		monster_fire_blaster2 (self, start, forward, BLASTER2_DAMAGE*widow_damage_multiplier, 1000, flashnum, effect);
X
/*		if (self->s.frame == FRAME_spawn13)
X		{
X			VectorMA (start, 1024, forward, debugend);
X
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_DEBUGTRAIL);
X			gi.WritePosition (start);
X			gi.WritePosition (debugend);
X			gi.multicast (start, MULTICAST_ALL);
X
X			drawbbox (self);
X			self->monsterinfo.aiflags |= AI_HOLD_FRAME|AI_MANUAL_STEERING;
X		}
*/
X	}
X	else if ((self->s.frame >= FRAME_fired02a) && (self->s.frame <= FRAME_fired20))
X	{
X		vec3_t angles;
X		float aim_angle, target_angle;
X		float error;
X
X		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X
X		self->monsterinfo.nextframe = WidowTorso (self);
X
X		if (!self->monsterinfo.nextframe)
X			self->monsterinfo.nextframe = self->s.frame;
X
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("%d\n", self->monsterinfo.nextframe);
X
X		if (self->s.frame == FRAME_fired02a)
X			flashnum = MZ2_WIDOW_BLASTER_0;
X		else
X			flashnum = MZ2_WIDOW_BLASTER_100 + self->s.frame - FRAME_fired03;
X
X		G_ProjectSource (self->s.origin, monster_flash_offset[flashnum], forward, right, start);
X
X		PredictAim (self->enemy, start, 1000, true, ((random()*0.1)-0.05), forward, NULL);
X
X		// clamp it to within 10 degrees of the aiming angle (where she's facing)
X		vectoangles2 (forward, angles);
X		// give me 100 -> -70
X		aim_angle = 100 - (10*(flashnum-MZ2_WIDOW_BLASTER_100));
X		if (aim_angle <= 0)
X			aim_angle += 360;
X		target_angle = self->s.angles[YAW] - angles[YAW];
X		if (target_angle <= 0)
X			target_angle += 360;
X
X		error = aim_angle - target_angle;
X
X		// positive error is to entity's left, aka positive direction in engine
X		// unfortunately, I decided that for the aim_angle, positive was right.  *sigh*
X		if (error > VARIANCE)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("angle %2.2f (really %2.2f) (%2.2f off of %2.2f) corrected to", target_angle, angles[YAW], error, aim_angle);
X			angles[YAW] = (self->s.angles[YAW] - aim_angle) + VARIANCE;
//			if ((g_showlogic) && (g_showlogic->value))
//			{
//				if (angles[YAW] <= 0)
//					angles[YAW] += 360;
//				gi.dprintf (" %2.2f\n", angles[YAW]);
//			}
X			AngleVectors (angles, forward, NULL, NULL);
X		}
X		else if (error < -VARIANCE)
X		{
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("angle %2.2f (really %2.2f) (%2.2f off of %2.2f) corrected to", target_angle, angles[YAW], error, aim_angle);
X			angles[YAW] = (self->s.angles[YAW] - aim_angle) - VARIANCE;
//			if ((g_showlogic) && (g_showlogic->value))
//			{
//				if (angles[YAW] <= 0)
//					angles[YAW] += 360;
//				gi.dprintf (" %2.2f\n", angles[YAW]);
//			}
X			AngleVectors (angles, forward, NULL, NULL);
X		}
//		gi.dprintf ("%2.2f - %2.2f - %2.2f - %2.2f\n", aim_angle, self->s.angles[YAW] - angles[YAW], target_angle, error);
//		gi.dprintf ("%2.2f - %2.2f - %2.2f\n", angles[YAW], aim_angle, self->s.angles[YAW]);
X
/*
X		if (self->s.frame == FRAME_fired20)
X		{
X			VectorMA (start, 512, forward, debugend);
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_DEBUGTRAIL);
X			gi.WritePosition (start);
X			gi.WritePosition (forward);
X			gi.multicast (start, MULTICAST_ALL);
X
X			drawbbox (self);
X			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
X			self->monsterinfo.nextframe = FRAME_fired20;
X			self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
X		}
*/
/*
X		if (!(self->plat2flags % 3))
X			effect = EF_HYPERBLASTER;
X		else
X			effect = 0;
X		self->plat2flags ++;
*/
X		monster_fire_blaster2 (self, start, forward, BLASTER2_DAMAGE*widow_damage_multiplier, 1000, flashnum, effect);
X	}
X	else if ((self->s.frame >= FRAME_run01) && (self->s.frame <= FRAME_run08))
X	{
X		flashnum = MZ2_WIDOW_RUN_1 + self->s.frame - FRAME_run01;
X		G_ProjectSource (self->s.origin, monster_flash_offset[flashnum], forward, right, start);
X		
X		VectorSubtract (self->enemy->s.origin, start, target);
X		target[2] += self->enemy->viewheight;
X
X		monster_fire_blaster2 (self, start, target, BLASTER2_DAMAGE*widow_damage_multiplier, 1000, flashnum, effect);
X	}
//	else
//	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("widow: firing on non-fire frame!\n");
//	}
}	
X
void WidowSpawn (edict_t *self)
{
X	vec3_t	f, r, u, offset, startpoint, spawnpoint;
X	edict_t	*ent, *designated_enemy;
X	int		i;
X
X	AngleVectors (self->s.angles, f, r, u);
X
X	for (i=0; i < 2; i++)
X	{
X		VectorCopy (spawnpoints[i], offset);
X
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X		if (FindSpawnPoint (startpoint, stalker_mins, stalker_maxs, spawnpoint, 64))
X		{
X			ent = CreateGroundMonster (spawnpoint, self->s.angles, stalker_mins, stalker_maxs, "monster_stalker", 256);
X
X			if (!ent)
X				continue;
X			
X			self->monsterinfo.monster_used++;
X			ent->monsterinfo.commander = self;
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("widow: post-spawn : %d slots left out of %d\n", SELF_SLOTS_LEFT, self->monsterinfo.monster_slots);
X
X			ent->nextthink = level.time;
X			ent->think (ent);
X			
X			ent->monsterinfo.aiflags |= AI_SPAWNED_WIDOW|AI_DO_NOT_COUNT|AI_IGNORE_SHOTS;
X
X			if (!(coop && coop->value))
X			{
X				designated_enemy = self->enemy;
X			}
X			else
X			{
X				designated_enemy = PickCoopTarget(ent);
X				if (designated_enemy)
X				{
X					// try to avoid using my enemy
X					if (designated_enemy == self->enemy)
X					{
X						designated_enemy = PickCoopTarget(ent);
X						if (designated_enemy)
X						{
//							if ((g_showlogic) && (g_showlogic->value))
//							{
//								gi.dprintf ("PickCoopTarget returned a %s - ", designated_enemy->classname);
//								if (designated_enemy->client)
//									gi.dprintf ("with name %s\n", designated_enemy->client->pers.netname);
//								else
//									gi.dprintf ("NOT A CLIENT\n");
//							}
X						}
X						else
X						{
//							if ((g_showlogic) && (g_showlogic->value))
//								gi.dprintf ("pick coop failed, using my current enemy\n");
X							designated_enemy = self->enemy;
X						}
X					}
X				}
X				else
X				{
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("pick coop failed, using my current enemy\n");
X					designated_enemy = self->enemy;
X				}
X			}
X
X			if ((designated_enemy->inuse) && (designated_enemy->health > 0))
X			{
X				ent->enemy = designated_enemy;
X				FoundTarget (ent);
X				ent->monsterinfo.attack(ent);
X			}
X		}
X	}
}
X
void widow_spawn_check (edict_t *self)
{
X	WidowBlaster(self);
X	WidowSpawn (self);
}
X
void widow_ready_spawn (edict_t *self)
{
X	vec3_t	f, r, u, offset, startpoint, spawnpoint;
X	int		i;
X
X	WidowBlaster(self);
X	AngleVectors (self->s.angles, f, r, u);
X
X	for (i=0; i < 2; i++)
X	{
X		VectorCopy (spawnpoints[i], offset);
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X		if (FindSpawnPoint (startpoint, stalker_mins, stalker_maxs, spawnpoint, 64))
X		{
X			SpawnGrow_Spawn (spawnpoint, 1);
X		}
X	}
}
X
void widow_step (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, gi.soundindex("widow/bwstep3.wav"), 1, ATTN_NORM, 0);
}
X
mframe_t widow_frames_stand [] =
{
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL,
X	ai_stand, 0, NULL
};
mmove_t	widow_move_stand = {FRAME_idle01, FRAME_idle11, widow_frames_stand, NULL};
X
mframe_t widow_frames_walk [] =
{
X	// hand generated numbers
/*
X	ai_run,	6,	NULL,
X	ai_run,	3,	NULL,
X	ai_run,	3,	NULL,
X	ai_run,	3,	NULL,
X	ai_run,	4,	NULL,			//5
X	ai_run,	4,	NULL,
X	ai_run,	4,	NULL,
X	ai_run,	4.5,	NULL,
X	ai_run,	3,	NULL,
X	ai_run,	5,	NULL,			//10
X	ai_run,	8,	NULL,
X	ai_run,	8,	NULL,
X	ai_run,	6.5,	NULL
*/
X	// auto generated numbers
X	ai_walk,	2.79,	widow_step,
X	ai_walk,	2.77,	NULL,
X	ai_walk,	3.53,	NULL,
X	ai_walk,	3.97,	NULL,
X	ai_walk,	4.13,	NULL,			//5
X	ai_walk,	4.09,	NULL,
X	ai_walk,	3.84,	NULL,
X	ai_walk,	3.62,	widow_step,
X	ai_walk,	3.29,	NULL,
X	ai_walk,	6.08,	NULL,			//10
X	ai_walk,	6.94,	NULL,
X	ai_walk,	5.73,	NULL,
X	ai_walk,	2.85,	NULL
};
mmove_t widow_move_walk = {FRAME_walk01, FRAME_walk13, widow_frames_walk, NULL};
X
X
mframe_t widow_frames_run [] =
{
X	ai_run,	2.79,	widow_step,
X	ai_run,	2.77,	NULL,
X	ai_run,	3.53,	NULL,
X	ai_run,	3.97,	NULL,
X	ai_run,	4.13,	NULL,			//5
X	ai_run,	4.09,	NULL,
X	ai_run,	3.84,	NULL,
X	ai_run,	3.62,	widow_step,
X	ai_run,	3.29,	NULL,
X	ai_run,	6.08,	NULL,			//10
X	ai_run,	6.94,	NULL,
X	ai_run,	5.73,	NULL,
X	ai_run,	2.85,	NULL
};
mmove_t widow_move_run = {FRAME_walk01, FRAME_walk13, widow_frames_run, NULL};
X
void widow_stepshoot (edict_t *self)
{
X	gi.sound (self, CHAN_BODY, gi.soundindex("widow/bwstep2.wav"), 1, ATTN_NORM,0);
X	WidowBlaster (self);
}
X
mframe_t widow_frames_run_attack [] =
{
X	ai_charge,	13,	widow_stepshoot,
X	ai_charge,	11.72,	WidowBlaster,
X	ai_charge,	18.04,	WidowBlaster,
X	ai_charge,	14.58,	WidowBlaster,
X	ai_charge,	13,	widow_stepshoot,			//5
X	ai_charge,	12.12,	WidowBlaster,
X	ai_charge,	19.63,	WidowBlaster,
X	ai_charge,	11.37,	WidowBlaster
};
mmove_t widow_move_run_attack = {FRAME_run01, FRAME_run08, widow_frames_run_attack, widow_run};
X
X
//
// These three allow specific entry into the run sequence
//
X
void widow_start_run_5 (edict_t *self)
{
X	self->monsterinfo.currentmove = &widow_move_run;
X	self->monsterinfo.nextframe = FRAME_walk05;
}
X
void widow_start_run_10 (edict_t *self)
{
X	self->monsterinfo.currentmove = &widow_move_run;
X	self->monsterinfo.nextframe = FRAME_walk10;
}
X
void widow_start_run_12 (edict_t *self)
{
X	self->monsterinfo.currentmove = &widow_move_run;
X	self->monsterinfo.nextframe = FRAME_walk12;
}
X
X
mframe_t widow_frames_attack_pre_blaster [] =
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	widow_attack_blaster
};
mmove_t widow_move_attack_pre_blaster = {FRAME_fired01, FRAME_fired02a, widow_frames_attack_pre_blaster, NULL};
X
// Loop this
mframe_t widow_frames_attack_blaster [] =
{
X	ai_charge,	0,	widow_reattack_blaster,		// straight ahead
X	ai_charge,	0,	widow_reattack_blaster,		// 100 degrees right
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,		// 50 degrees right
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,		// straight
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster,		// 50 degrees left
X	ai_charge,	0,	widow_reattack_blaster,
X	ai_charge,	0,	widow_reattack_blaster		// 70 degrees left
};
mmove_t widow_move_attack_blaster = {FRAME_fired02a, FRAME_fired20, widow_frames_attack_blaster, NULL};
X
mframe_t widow_frames_attack_post_blaster [] =
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL
};
mmove_t widow_move_attack_post_blaster = {FRAME_fired21, FRAME_fired22, widow_frames_attack_post_blaster, widow_run};
X
mframe_t widow_frames_attack_post_blaster_r [] =
{
X	ai_charge,	-2,	NULL,
X	ai_charge,	-10,	NULL,
X	ai_charge,	-2,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	widow_start_run_12
};
mmove_t widow_move_attack_post_blaster_r = {FRAME_transa01, FRAME_transa05, widow_frames_attack_post_blaster_r, NULL};
X
mframe_t widow_frames_attack_post_blaster_l [] =
{
X	ai_charge,	0,	NULL,
X	ai_charge,	14,	NULL,
X	ai_charge,	-2,	NULL,
X	ai_charge,	10,	NULL,
X	ai_charge,	10,	widow_start_run_12
};
mmove_t widow_move_attack_post_blaster_l = {FRAME_transb01, FRAME_transb05, widow_frames_attack_post_blaster_l, NULL};
X
mmove_t widow_move_attack_rail;
mmove_t widow_move_attack_rail_l;
mmove_t widow_move_attack_rail_r;
X
void WidowRail (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	forward, right;
X	int		flash;
X
//	gi.dprintf ("railing!\n");
X	AngleVectors (self->s.angles, forward, right, NULL);
X
X	if (self->monsterinfo.currentmove == &widow_move_attack_rail)
X		flash = MZ2_WIDOW_RAIL;
X	else if (self->monsterinfo.currentmove == &widow_move_attack_rail_l)
X	{
X		flash = MZ2_WIDOW_RAIL_LEFT;
X	}
X	else if (self->monsterinfo.currentmove == &widow_move_attack_rail_r)
X	{
X		flash = MZ2_WIDOW_RAIL_RIGHT;
X	}
X
X	G_ProjectSource (self->s.origin, monster_flash_offset[flash], forward, right, start);
X
X	// calc direction to where we targeted
X	VectorSubtract (self->pos1, start, dir);
X	VectorNormalize (dir);
X
X	monster_fire_railgun (self, start, dir, WIDOW_RAIL_DAMAGE*widow_damage_multiplier, 100, flash);
X	self->timestamp = level.time + RAIL_TIME;
}
X
void WidowSaveLoc (edict_t *self)
{
X	VectorCopy (self->enemy->s.origin, self->pos1);	//save for aiming the shot
X	self->pos1[2] += self->enemy->viewheight;
};
X
void widow_start_rail (edict_t *self)
{
X	self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
}
X
void widow_rail_done (edict_t *self)
{
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
}
X
mframe_t widow_frames_attack_pre_rail [] =
{
X	ai_charge,	0,	widow_start_rail,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	widow_attack_rail
};
mmove_t widow_move_attack_pre_rail = {FRAME_transc01, FRAME_transc04, widow_frames_attack_pre_rail, NULL};
X
mframe_t widow_frames_attack_rail [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, WidowSaveLoc,
X	ai_charge, -10, WidowRail,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, widow_rail_done
};
mmove_t widow_move_attack_rail = {FRAME_firea01, FRAME_firea09, widow_frames_attack_rail, widow_run};
X
mframe_t widow_frames_attack_rail_r [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, WidowSaveLoc,
X	ai_charge, -10, WidowRail,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, widow_rail_done
};
mmove_t widow_move_attack_rail_r = {FRAME_fireb01, FRAME_fireb09, widow_frames_attack_rail_r, widow_run};
X
mframe_t widow_frames_attack_rail_l [] =
{
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, WidowSaveLoc,
X	ai_charge, -10, WidowRail,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, NULL,
X	ai_charge, 0, widow_rail_done
};
mmove_t widow_move_attack_rail_l = {FRAME_firec01, FRAME_firec09, widow_frames_attack_rail_l, widow_run};
X
void widow_attack_rail (edict_t *self)
{
X	float	enemy_angle;
//	gi.dprintf ("going to the rail!\n");
X
X	enemy_angle = target_angle (self);
X
X	if (enemy_angle < -15)
X		self->monsterinfo.currentmove = &widow_move_attack_rail_l;
X	else if (enemy_angle > 15)
X		self->monsterinfo.currentmove = &widow_move_attack_rail_r;
X	else
X		self->monsterinfo.currentmove = &widow_move_attack_rail;
}
X
void widow_start_spawn (edict_t *self)
{
X	self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
}
X
void widow_done_spawn (edict_t *self)
{
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
}
X
mframe_t widow_frames_spawn [] =
{
X	ai_charge,	0,	NULL,						//1
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	widow_start_spawn,
X	ai_charge,	0,	NULL,						//5
X	ai_charge,	0,	WidowBlaster,				//6
X	ai_charge,	0,	widow_ready_spawn,			//7
X	ai_charge,	0,	WidowBlaster,
X	ai_charge,	0,	WidowBlaster,				//9
X	ai_charge,	0,	widow_spawn_check,
X	ai_charge,	0,	WidowBlaster,				//11
X	ai_charge,	0,	WidowBlaster,
X	ai_charge,	0,	WidowBlaster,				//13
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	widow_done_spawn
};
mmove_t widow_move_spawn = {FRAME_spawn01, FRAME_spawn18, widow_frames_spawn, widow_run};
X
mframe_t widow_frames_pain_heavy [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t widow_move_pain_heavy = {FRAME_pain01, FRAME_pain13, widow_frames_pain_heavy, widow_run};
X
mframe_t widow_frames_pain_light [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t widow_move_pain_light = {FRAME_pain201, FRAME_pain203, widow_frames_pain_light, widow_run};
X
void spawn_out_start (edict_t *self)
{
X	vec3_t startpoint,f,r,u;
X	self->wait = level.time + 2.0;
X
//	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NONE, 0);
X	AngleVectors (self->s.angles, f, r, u);
X
X	G_ProjectSource2 (self->s.origin, beameffects[0], f, r, u, startpoint);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_WIDOWBEAMOUT);
X	gi.WriteShort (20001);
X	gi.WritePosition (startpoint);
X	gi.multicast (startpoint, MULTICAST_ALL);
X
X	G_ProjectSource2 (self->s.origin, beameffects[1], f, r, u, startpoint);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_WIDOWBEAMOUT);
X	gi.WriteShort (20002);
X	gi.WritePosition (startpoint);
X	gi.multicast (startpoint, MULTICAST_ALL);
X
X	gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/bwidowbeamout.wav"), 1, ATTN_NORM, 0);
}
X
void spawn_out_do (edict_t *self)
{
X	vec3_t startpoint,f,r,u;
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, beameffects[0], f, r, u, startpoint);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_WIDOWSPLASH);
X	gi.WritePosition (startpoint);
X	gi.multicast (startpoint, MULTICAST_ALL);
X
X	G_ProjectSource2 (self->s.origin, beameffects[1], f, r, u, startpoint);
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_WIDOWSPLASH);
X	gi.WritePosition (startpoint);
X	gi.multicast (startpoint, MULTICAST_ALL);
X
X	VectorCopy (self->s.origin, startpoint);
X	startpoint[2] += 36;
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_BOSSTPORT);
X	gi.WritePosition (startpoint);
X	gi.multicast (startpoint, MULTICAST_PVS);
X
X	Widowlegs_Spawn (self->s.origin, self->s.angles);
X	
X	G_FreeEdict (self);
}
X
mframe_t widow_frames_death [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,		//5
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	spawn_out_start,	//10
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,				//15	
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,				//20	
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,				//25
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,		
X	ai_move,	0,	NULL,				//30	
X	ai_move,	0,	spawn_out_do
};
mmove_t widow_move_death = {FRAME_death01, FRAME_death31, widow_frames_death, NULL};
X
void widow_attack_kick (edict_t *self)
{
X	vec3_t	aim;
X
//	VectorSet (aim, MELEE_DISTANCE, 0, 4);
X	VectorSet (aim, 100, 0, 4);
X	if (self->enemy->groundentity)
X		fire_hit (self, aim, (50 + (rand() % 6)), 500);
X	else	// not as much kick if they're in the air .. makes it harder to land on her head
X		fire_hit (self, aim, (50 + (rand() % 6)), 250);
X
}
X
mframe_t widow_frames_attack_kick [] =
{
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, widow_attack_kick,
X	ai_move, 0, NULL,				// 5
X	ai_move, 0, NULL,
X	ai_move, 0, NULL,
X	ai_move, 0, NULL
};
X
mmove_t widow_move_attack_kick = {FRAME_kick01, FRAME_kick08, widow_frames_attack_kick, widow_run};
X
void widow_stand (edict_t *self)
{
//	gi.dprintf ("widow stand\n");
X	gi.sound (self, CHAN_WEAPON, gi.soundindex ("widow/laugh.wav"), 1, ATTN_NORM, 0);
X	self->monsterinfo.currentmove = &widow_move_stand;
}
X
void widow_run (edict_t *self)
{
X	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &widow_move_stand;
X	else
X		self->monsterinfo.currentmove = &widow_move_run;
}
X
void widow_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &widow_move_walk;
}
X
void widow_attack (edict_t *self)
{
X	float	luck;
X	qboolean rail_frames = false, blaster_frames = false, blocked = false, anger = false;
X
X	self->movetarget = NULL;
X
X	if (self->monsterinfo.aiflags & AI_BLOCKED)
X	{
X		blocked = true;
X		self->monsterinfo.aiflags &= ~AI_BLOCKED;
X	}
X	
X	if (self->monsterinfo.aiflags & AI_TARGET_ANGER)
X	{
X		anger = true;
X		self->monsterinfo.aiflags &= ~AI_TARGET_ANGER;
X	}
X
X	if ((!self->enemy) || (!self->enemy->inuse))
X		return;
X
X	if (self->bad_area)
X	{
X		if ((random() < 0.1) || (level.time < self->timestamp))
X			self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X		else
X		{
X			gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X		}
X		return;
X	}
X
X	// frames FRAME_walk13, FRAME_walk01, FRAME_walk02, FRAME_walk03 are rail gun start frames
X	// frames FRAME_walk09, FRAME_walk10, FRAME_walk11, FRAME_walk12 are spawn & blaster start frames
X
X	if ((self->s.frame == FRAME_walk13) || ((self->s.frame >= FRAME_walk01) && (self->s.frame <= FRAME_walk03)))
X		rail_frames = true;
X
X	if ((self->s.frame >= FRAME_walk09) && (self->s.frame <= FRAME_walk12))
X		blaster_frames = true;
X
X	WidowCalcSlots(self);
X
X	// if we can't see the target, spawn stuff regardless of frame
X	if ((self->monsterinfo.attack_state == AS_BLIND) && (SELF_SLOTS_LEFT >= 2))
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("attacking blind!\n");
X		self->monsterinfo.currentmove = &widow_move_spawn;
X		return;
X	}
X
X	// accept bias towards spawning regardless of frame
X	if (blocked && (SELF_SLOTS_LEFT >= 2))
X	{
X		self->monsterinfo.currentmove = &widow_move_spawn;
X		return;
X	}
X
X	if ((realrange(self, self->enemy) > 300) && (!anger) && (random() < 0.5)  && (!blocked))
X	{
X		self->monsterinfo.currentmove = &widow_move_run_attack;
X		return;
X	}
X
X	if (blaster_frames)
X	{
//		gi.dprintf ("blaster frame %2.2f <= %2.2f\n", self->monsterinfo.pausetime + BLASTER_TIME, level.time);
X		if (SELF_SLOTS_LEFT >= 2)
X		{
X			self->monsterinfo.currentmove = &widow_move_spawn;
X			return;
X		}
X		else if (self->monsterinfo.pausetime + BLASTER_TIME <= level.time)
X		{
X			self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X			return;
X		}
X	}
X
X	if (rail_frames)
X	{
//		gi.dprintf ("rail frame %2.2f - %2.2f\n", level.time, self->timestamp);
X		if (!(level.time < self->timestamp))
X		{
X			gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X		}
X	}
X
X	if ((rail_frames) || (blaster_frames))
X		return;
X
//	if ((g_showlogic) && (g_showlogic->value))
//		gi.dprintf ("widow: unknown start frame, picking randomly\n");
X
X	luck = random();
X	if (SELF_SLOTS_LEFT >= 2)
X	{
X		if ((luck <= 0.40) && (self->monsterinfo.pausetime + BLASTER_TIME <= level.time))
X			self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X		else if ((luck <= 0.7) && !(level.time < self->timestamp))
X		{
X			gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X		}
X		else
X			self->monsterinfo.currentmove = &widow_move_spawn;
X	}
X	else
X	{
X		if (level.time < self->timestamp)
X			self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X		else if ((luck <= 0.50) || (level.time + BLASTER_TIME >= self->monsterinfo.pausetime))
X		{
X			gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X		}
X		else // holdout to blaster
X			self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X	}
}
/*
void widow_attack (edict_t *self)
{
X	float	range, luck;
X
//	gi.dprintf ("widow attack\n");
X	
X	if ((!self->enemy) || (!self->enemy->inuse))
X		return;
X
X	if (self->bad_area)
X	{
X		if ((random() < 0.1) || (level.time < self->timestamp))
X			self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X		else
X		{
X			gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X			self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X		}
X		return;
X	}
X
X	// if we can't see the target, spawn stuff
X	if ((self->monsterinfo.attack_state == AS_BLIND) && (blaster_frames))
X	{
X		self->monsterinfo.currentmove = &widow_move_spawn;
X		return;
X	}
X
X	range = realrange (self, self->enemy);
X
X	if (range < 600)
X	{
X		luck = random();
X		if (SLOTS_LEFT >= 2)
X		{
X			if (luck <= 0.40)
X				self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X			else if ((luck <= 0.7) && !(level.time < self->timestamp))
X			{
X				gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X			}
X			else
X				self->monsterinfo.currentmove = &widow_move_spawn;
X		}
X		else
X		{
X			if ((luck <= 0.50) || (level.time < self->timestamp))
X				self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X			else
X			{
X				gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X			}
X		}
X	}
X	else
X	{
X		luck = random();
X		if (SLOTS_LEFT >= 2)
X		{
X			if (luck < 0.3)
X				self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X			else if ((luck < 0.65) || (level.time < self->timestamp))
X				self->monsterinfo.currentmove = &widow_move_spawn;
X			else
X			{
X				gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X			}
X		}
X		else
X		{
X			if ((luck < 0.45) || (level.time < self->timestamp))
X				self->monsterinfo.currentmove = &widow_move_attack_pre_blaster;
X			else
X			{
X				gi.sound (self, CHAN_WEAPON, sound_rail, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow_move_attack_pre_rail;
X			}
X		}
X	}
}
*/
void widow_attack_blaster (edict_t *self)
{
X	self->monsterinfo.pausetime = level.time + 1.0 + (2.0*random());
//	self->monsterinfo.pausetime = level.time + 100;
//	self->plat2flags = 0;
X	self->monsterinfo.currentmove = &widow_move_attack_blaster;
X	self->monsterinfo.nextframe = WidowTorso (self);
}
X
void widow_reattack_blaster (edict_t *self)
{
X	WidowBlaster(self);
X
//	if ((g_showlogic) && (g_showlogic->value))
//	{
//		if (self->monsterinfo.currentmove == &widow_move_attack_post_blaster_l)
//			gi.dprintf ("pulling left!\n");
//		if (self->monsterinfo.currentmove == &widow_move_attack_post_blaster_r)
//			gi.dprintf ("pulling right!\n");
//	}
X
//	self->monsterinfo.currentmove = &widow_move_attack_blaster;
//		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
//	return;
X	// if WidowBlaster bailed us out of the frames, just bail
X	if ((self->monsterinfo.currentmove == &widow_move_attack_post_blaster_l) ||
X		(self->monsterinfo.currentmove == &widow_move_attack_post_blaster_r))
X		return;
X
X	// if we're not done with the attack, don't leave the sequence
X	if (self->monsterinfo.pausetime >= level.time)
X		return;
X
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X
X	self->monsterinfo.currentmove = &widow_move_attack_post_blaster;
}
/*
X	if ( infront(self, self->enemy) )
X		if (random() <= 0.5)
X			if ((random() < 0.7) || (SLOTS_LEFT <= 1))
X				self->monsterinfo.currentmove = &widow_move_attack_blaster;
X			else
X				self->monsterinfo.currentmove = &widow_move_spawn;
X		else
X			self->monsterinfo.currentmove = &widow_move_attack_post_blaster;
X	else
X		self->monsterinfo.currentmove = &widow_move_attack_post_blaster;
}
*/
X
X
void widow_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	if (self->monsterinfo.pausetime == 100000000)
X		self->monsterinfo.pausetime = 0;
X
X	self->pain_debounce_time = level.time + 5;
X
X	if (damage < 15)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NONE, 0);
X	}
X	else if (damage < 75)
X	{
X		if ((skill->value < 3) && (random() < (0.6 - (0.2*((float)skill->value)))))
X		{
X			self->monsterinfo.currentmove = &widow_move_pain_light;
X			self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		}
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NONE, 0);
X	}
X	else 
X	{
X		if ((skill->value < 3) && (random() < (0.75 - (0.1*((float)skill->value)))))
X		{
X			self->monsterinfo.currentmove = &widow_move_pain_heavy;
X			self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X		}
X		gi.sound (self, CHAN_VOICE, sound_pain3, 1, ATTN_NONE, 0);
X	}
}
X
void widow_dead (edict_t *self)
{
X	VectorSet (self->mins, -56, -56, 0);
X	VectorSet (self->maxs, 56, 56, 80);
X	self->movetype = MOVETYPE_TOSS;
X	self->svflags |= SVF_DEADMONSTER;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
void widow_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_NO;
X	self->count = 0;
X	self->monsterinfo.quad_framenum = 0;
X	self->monsterinfo.double_framenum = 0;
X	self->monsterinfo.invincible_framenum = 0;
X	self->monsterinfo.currentmove = &widow_move_death;
}
X
void widow_melee (edict_t *self)
{
//	monster_done_dodge (self);
X	self->monsterinfo.currentmove = &widow_move_attack_kick;
}
X
void WidowGoinQuad (edict_t *self, float framenum)
{
X	self->monsterinfo.quad_framenum = framenum;
X	widow_damage_multiplier = 4;
}
X
void WidowDouble (edict_t *self, float framenum)
{
X	self->monsterinfo.double_framenum = framenum;
X	widow_damage_multiplier = 2;
}
X
void WidowPent (edict_t *self, float framenum)
{
X	self->monsterinfo.invincible_framenum = framenum;
}
X
void WidowPowerArmor (edict_t *self)
{
X	self->monsterinfo.power_armor_type = POWER_ARMOR_SHIELD;
X	// I don't like this, but it works
X	if (self->monsterinfo.power_armor_power <= 0)
X		self->monsterinfo.power_armor_power += 250 * skill->value;
}
X
void WidowRespondPowerup (edict_t *self, edict_t *other)
{
X	if (other->s.effects & EF_QUAD)
X	{
X		if (skill->value == 1)
X			WidowDouble (self, other->client->quad_framenum);
X		else if (skill->value == 2)
X			WidowGoinQuad (self, other->client->quad_framenum);
X		else if (skill->value == 3)
X		{
X			WidowGoinQuad (self, other->client->quad_framenum);
X			WidowPowerArmor (self);
X		}
X	}
X	else if (other->s.effects & EF_DOUBLE)
X	{
X		if (skill->value == 2)
X			WidowDouble (self, other->client->double_framenum);
X		else if (skill->value == 3)
X		{
X			WidowDouble (self, other->client->double_framenum);
X			WidowPowerArmor (self);
X		}
X	}
X	else
X		widow_damage_multiplier = 1;
X
X	if (other->s.effects & EF_PENT)
X	{
X		if (skill->value == 1)
X			WidowPowerArmor (self);
X		else if (skill->value == 2)
X			WidowPent (self, other->client->invincible_framenum);
X		else if (skill->value == 3)
X		{
X			WidowPent (self, other->client->invincible_framenum);
X			WidowPowerArmor (self);
X		}
X	}
}
X
void WidowPowerups (edict_t *self)
{
X	int player;
X	edict_t *ent;
X
X	if (!(coop && coop->value))
X	{
X		WidowRespondPowerup (self, self->enemy);
X	}
X	else
X	{
X		// in coop, check for pents, then quads, then doubles
X		for (player = 1; player <= game.maxclients; player++)
X		{
X			ent = &g_edicts[player];
X			if (!ent->inuse)
X				continue;
X			if (!ent->client)
X				continue;
X			if (ent->s.effects & EF_PENT)
X			{
X				WidowRespondPowerup (self, ent);
X				return;
X			}
X		}
X
X		for (player = 1; player <= game.maxclients; player++)
X		{
X			ent = &g_edicts[player];
X			if (!ent->inuse)
X				continue;
X			if (!ent->client)
X				continue;
X			if (ent->s.effects & EF_QUAD)
X			{
X				WidowRespondPowerup (self, ent);
X				return;
X			}
X		}
X
X		for (player = 1; player <= game.maxclients; player++)
X		{
X			ent = &g_edicts[player];
X			if (!ent->inuse)
X				continue;
X			if (!ent->client)
X				continue;
X			if (ent->s.effects & EF_DOUBLE)
X			{
X				WidowRespondPowerup (self, ent);
X				return;
X			}
X		}
X	}
}
X
qboolean Widow_CheckAttack (edict_t *self)
{
X	vec3_t	spot1, spot2;
X	vec3_t	temp;
X	float	chance;
X	trace_t	tr;
X	qboolean	enemy_infront;
X	int			enemy_range;
X	float		enemy_yaw;
X	float		real_enemy_range;
X
X	if (!self->enemy)
X		return false;
X
X	WidowPowerups(self);
X
X	if (self->monsterinfo.currentmove == &widow_move_run)
X	{
X		// if we're in run, make sure we're in a good frame for attacking before doing anything else
X		// frames 1,2,3,9,10,11,13 good to fire
X		switch (self->s.frame)
X		{
X			case FRAME_walk04:
X			case FRAME_walk05:
X			case FRAME_walk06:
X			case FRAME_walk07:
X			case FRAME_walk08:
X			case FRAME_walk12:
X				{
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("Not in good walk frame (%d), not attacking\n", (self->s.frame - FRAME_walk01+1));
X					return false;
X				}
X			default:
X				break;
X		}
X	}
X
X	// give a LARGE bias to spawning things when we have room
X	// use AI_BLOCKED as a signal to attack to spawn
X	if ((random() < 0.8) && (SELF_SLOTS_LEFT >= 2) && (realrange(self, self->enemy) > 150))
X	{
X		self->monsterinfo.aiflags |= AI_BLOCKED;
X		self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X		{	
X			// go ahead and spawn stuff if we're mad a a client
X			if (self->enemy->client && SELF_SLOTS_LEFT >= 2)
X			{
X				self->monsterinfo.attack_state = AS_BLIND;
X				return true;
X			}
X				
X			// PGM - we want them to go ahead and shoot at info_notnulls if they can.
X			if(self->enemy->solid != SOLID_NOT || tr.fraction < 1.0)		//PGM
X				return false;
X		}
X	}
X	
X	enemy_infront = infront(self, self->enemy);
X
X	enemy_range = range(self, self->enemy);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw2(temp);
X
X	self->ideal_yaw = enemy_yaw;
X
X	real_enemy_range = realrange (self, self->enemy);
X
//	if (g_showlogic->value)
//		gi.dprintf ("range = %2.2f\n", real_enemy_range);
X
X	// melee attack
//	if (enemy_range == RANGE_MELEE)
X	if (real_enemy_range <= (MELEE_DISTANCE+20))
X	{
X		// don't always melee in easy mode
X		if (skill->value == 0 && (rand()&3) )
X			return false;
X		if (self->monsterinfo.melee)
X			self->monsterinfo.attack_state = AS_MELEE;
X		else
X			self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X
X	if (level.time < self->monsterinfo.attack_finished)
X		return false;
X		
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_MELEE)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_NEAR)
X	{
X		chance = 0.7;
X	}
X	else if (enemy_range == RANGE_MID)
X	{
X		chance = 0.6;
X	}
X	else if (enemy_range == RANGE_FAR)
X	{
X		chance = 0.5;
X	}
X
X	// PGM - go ahead and shoot every time if it's a info_notnull
X	if ((random () < chance) || (self->enemy->solid == SOLID_NOT))
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X
X	return false;
}
X
qboolean widow_blocked (edict_t *self, float dist)
{
X	// if we get blocked while we're in our run/attack mode, turn on a meaningless (in this context)AI flag, 
X	// and call attack to get a new attack sequence.  make sure to turn it off when we're done.
X	//
X	// I'm using AI_TARGET_ANGER for this purpose
X
X	if (self->monsterinfo.currentmove == &widow_move_run_attack)
X	{
X		self->monsterinfo.aiflags |= AI_TARGET_ANGER;
X		if (self->monsterinfo.checkattack(self))
X			self->monsterinfo.attack(self);
X		else
X			self->monsterinfo.run(self);
X		return true;
X	}
X
X	if(blocked_checkshot (self, 0.25 + (0.05 * skill->value) ))
X		return true;
X
/*
X	if(blocked_checkjump (self, dist, 192, 40))
X	{
X		infantry_jump(self);
X		return true;
X	}
X
X	if(blocked_checkplat (self, dist))
X		return true;
*/
X	return false;
}
X
void WidowCalcSlots (edict_t *self)
{
X	int old_slots;
X
X	old_slots = self->monsterinfo.monster_slots;
X
X	switch ((int)skill->value)
X	{
X		case 0:
X		case 1:
X			self->monsterinfo.monster_slots = 3;
X			break;
X		case 2:
X			self->monsterinfo.monster_slots = 4;
X			break;
X		case 3:
X			self->monsterinfo.monster_slots = 6;
X			break;
X		default:
X			self->monsterinfo.monster_slots = 3;
X			break;
X	}
X	if (coop->value)
X	{
X		self->monsterinfo.monster_slots = min (6, self->monsterinfo.monster_slots + ((skill->value)*(CountPlayers()-1)));
X	}
//	if ((g_showlogic) && (g_showlogic->value) && (old_slots != self->monsterinfo.monster_slots))
//		gi.dprintf ("number of slots changed from %d to %d\n", old_slots, self->monsterinfo.monster_slots);
}
X
void WidowPrecache ()
{
X	// cache in all of the stalker stuff, widow stuff, spawngro stuff, gibs
X	gi.soundindex ("stalker/pain.wav");	
X	gi.soundindex ("stalker/death.wav");	
X	gi.soundindex ("stalker/sight.wav");
X	gi.soundindex ("stalker/melee1.wav");
X	gi.soundindex ("stalker/melee2.wav");
X	gi.soundindex ("stalker/idle.wav");
X
X	gi.soundindex ("tank/tnkatck3.wav");
X	gi.modelindex ("models/proj/laser2/tris.md2");
X
X	gi.modelindex ("models/monsters/stalker/tris.md2");
X	gi.modelindex ("models/items/spawngro2/tris.md2");
X	gi.modelindex ("models/objects/gibs/sm_metal/tris.md2");
X	gi.modelindex ("models/objects/gibs/gear/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow/gib1/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow/gib2/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow/gib3/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow/gib4/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib1/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib2/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib3/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib4/tris.md2");
X	gi.modelindex ("models/monsters/legs/tris.md2");
X	gi.soundindex ("misc/bwidowbeamout.wav");
X
X	gi.soundindex ("misc/bigtele.wav");
X	gi.soundindex ("widow/bwstep3.wav");
X	gi.soundindex ("widow/bwstep2.wav");
}
X
X
/*QUAKED monster_widow (1 .5 0) (-40 -40 0) (40 40 144) Ambush Trigger_Spawn Sight
*/
void SP_monster_widow (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("widow/bw1pain1.wav");
X	sound_pain2 = gi.soundindex ("widow/bw1pain2.wav");
X	sound_pain3 = gi.soundindex ("widow/bw1pain3.wav");
X	sound_search1 = gi.soundindex ("bosshovr/bhvunqv1.wav");
//	sound_sight	= gi.soundindex ("widow/sight.wav");
X	sound_rail = gi.soundindex ("gladiator/railgun.wav");
X
//	self->s.sound = gi.soundindex ("bosshovr/bhvengn1.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/blackwidow/tris.md2");
X	VectorSet (self->mins, -40, -40, 0);
X	VectorSet (self->maxs, 40, 40, 144);
X
X	self->health = 2000 + 1000*(skill->value);
X	if (coop->value)
X		self->health += 500*(skill->value);
//	self->health = 1;
X	self->gib_health = -5000;
X	self->mass = 1500;
/*
X	if (skill->value == 2)
X	{
X		self->monsterinfo.power_armor_type = POWER_ARMOR_SHIELD;
X		self->monsterinfo.power_armor_power = 250;
X	}
X	else */if (skill->value == 3)
X	{
X		self->monsterinfo.power_armor_type = POWER_ARMOR_SHIELD;
X		self->monsterinfo.power_armor_power = 500;
X	}
X
X	self->yaw_speed = 30;
X	
X	self->flags |= FL_IMMUNE_LASER;
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X
X	self->pain = widow_pain;
X	self->die = widow_die;
X
X	self->monsterinfo.melee = widow_melee;
X	self->monsterinfo.stand = widow_stand;
X	self->monsterinfo.walk = widow_walk;
X	self->monsterinfo.run = widow_run;
X	self->monsterinfo.attack = widow_attack;
X	self->monsterinfo.search = widow_search;
X	self->monsterinfo.checkattack = Widow_CheckAttack;
X	self->monsterinfo.sight = widow_sight;
X	
X	self->monsterinfo.blocked = widow_blocked;
X
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &widow_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	WidowPrecache();
X	WidowCalcSlots(self);
X	widow_damage_multiplier = 1;
X
X	walkmonster_start (self);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_widow.c' &&
  chmod 0664 'm_widow.c' ||
  $echo 'restore of' 'm_widow.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_widow.c:' 'MD5 check failed'
a671b92c46389c52d9937527d18a9cf7  m_widow.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_widow.c'`"
    test 45002 -eq "$shar_count" ||
    $echo 'm_widow.c:' 'original size' '45002,' 'current size' "$shar_count!"
  fi
fi
# ============= m_widow.h ==============
if test -f 'm_widow.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_widow.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_widow.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_widow.h' &&
// G:\quake2\xpack\models/monsters/blackwidow
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_idle01          	0
#define FRAME_idle02          	1
#define FRAME_idle03          	2
#define FRAME_idle04          	3
#define FRAME_idle05          	4
#define FRAME_idle06          	5
#define FRAME_idle07          	6
#define FRAME_idle08          	7
#define FRAME_idle09          	8
#define FRAME_idle10          	9
#define FRAME_idle11          	10
#define FRAME_walk01          	11
#define FRAME_walk02          	12
#define FRAME_walk03          	13
#define FRAME_walk04          	14
#define FRAME_walk05          	15
#define FRAME_walk06          	16
#define FRAME_walk07          	17
#define FRAME_walk08          	18
#define FRAME_walk09          	19
#define FRAME_walk10          	20
#define FRAME_walk11          	21
#define FRAME_walk12          	22
#define FRAME_walk13          	23
#define FRAME_run01           	24
#define FRAME_run02           	25
#define FRAME_run03           	26
#define FRAME_run04           	27
#define FRAME_run05           	28
#define FRAME_run06           	29
#define FRAME_run07           	30
#define FRAME_run08           	31
#define FRAME_firea01         	32
#define FRAME_firea02         	33
#define FRAME_firea03         	34
#define FRAME_firea04         	35
#define FRAME_firea05         	36
#define FRAME_firea06         	37
#define FRAME_firea07         	38
#define FRAME_firea08         	39
#define FRAME_firea09         	40
#define FRAME_fireb01         	41
#define FRAME_fireb02         	42
#define FRAME_fireb03         	43
#define FRAME_fireb04         	44
#define FRAME_fireb05         	45
#define FRAME_fireb06         	46
#define FRAME_fireb07         	47
#define FRAME_fireb08         	48
#define FRAME_fireb09         	49
#define FRAME_firec01         	50
#define FRAME_firec02         	51
#define FRAME_firec03         	52
#define FRAME_firec04         	53
#define FRAME_firec05         	54
#define FRAME_firec06         	55
#define FRAME_firec07         	56
#define FRAME_firec08         	57
#define FRAME_firec09         	58
#define FRAME_fired01         	59
#define FRAME_fired02         	60
#define FRAME_fired02a        	61
#define FRAME_fired03         	62
#define FRAME_fired04         	63
#define FRAME_fired05         	64
#define FRAME_fired06         	65
#define FRAME_fired07         	66
#define FRAME_fired08         	67
#define FRAME_fired09         	68
#define FRAME_fired10         	69
#define FRAME_fired11         	70
#define FRAME_fired12         	71
#define FRAME_fired13         	72
#define FRAME_fired14         	73
#define FRAME_fired15         	74
#define FRAME_fired16         	75
#define FRAME_fired17         	76
#define FRAME_fired18         	77
#define FRAME_fired19         	78
#define FRAME_fired20         	79
#define FRAME_fired21         	80
#define FRAME_fired22         	81
#define FRAME_spawn01         	82
#define FRAME_spawn02         	83
#define FRAME_spawn03         	84
#define FRAME_spawn04         	85
#define FRAME_spawn05         	86
#define FRAME_spawn06         	87
#define FRAME_spawn07         	88
#define FRAME_spawn08         	89
#define FRAME_spawn09         	90
#define FRAME_spawn10         	91
#define FRAME_spawn11         	92
#define FRAME_spawn12         	93
#define FRAME_spawn13         	94
#define FRAME_spawn14         	95
#define FRAME_spawn15         	96
#define FRAME_spawn16         	97
#define FRAME_spawn17         	98
#define FRAME_spawn18         	99
#define FRAME_pain01          	100
#define FRAME_pain02          	101
#define FRAME_pain03          	102
#define FRAME_pain04          	103
#define FRAME_pain05          	104
#define FRAME_pain06          	105
#define FRAME_pain07          	106
#define FRAME_pain08          	107
#define FRAME_pain09          	108
#define FRAME_pain10          	109
#define FRAME_pain11          	110
#define FRAME_pain12          	111
#define FRAME_pain13          	112
#define FRAME_pain201         	113
#define FRAME_pain202         	114
#define FRAME_pain203         	115
#define FRAME_transa01        	116
#define FRAME_transa02        	117
#define FRAME_transa03        	118
#define FRAME_transa04        	119
#define FRAME_transa05        	120
#define FRAME_transb01        	121
#define FRAME_transb02        	122
#define FRAME_transb03        	123
#define FRAME_transb04        	124
#define FRAME_transb05        	125
#define FRAME_transc01        	126
#define FRAME_transc02        	127
#define FRAME_transc03        	128
#define FRAME_transc04        	129
#define FRAME_death01         	130
#define FRAME_death02         	131
#define FRAME_death03         	132
#define FRAME_death04         	133
#define FRAME_death05         	134
#define FRAME_death06         	135
#define FRAME_death07         	136
#define FRAME_death08         	137
#define FRAME_death09         	138
#define FRAME_death10         	139
#define FRAME_death11         	140
#define FRAME_death12         	141
#define FRAME_death13         	142
#define FRAME_death14         	143
#define FRAME_death15         	144
#define FRAME_death16         	145
#define FRAME_death17         	146
#define FRAME_death18         	147
#define FRAME_death19         	148
#define FRAME_death20         	149
#define FRAME_death21         	150
#define FRAME_death22         	151
#define FRAME_death23         	152
#define FRAME_death24         	153
#define FRAME_death25         	154
#define FRAME_death26         	155
#define FRAME_death27         	156
#define FRAME_death28         	157
#define FRAME_death29         	158
#define FRAME_death30         	159
#define FRAME_death31         	160
#define FRAME_kick01          	161
#define FRAME_kick02          	162
#define FRAME_kick03          	163
#define FRAME_kick04          	164
#define FRAME_kick05          	165
#define FRAME_kick06          	166
#define FRAME_kick07          	167
#define FRAME_kick08          	168
X
#define MODEL_SCALE		2.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_widow.h' &&
  chmod 0664 'm_widow.h' ||
  $echo 'restore of' 'm_widow.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_widow.h:' 'MD5 check failed'
60a1c13de492e2bbde8a29e8adce2701  m_widow.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_widow.h'`"
    test 5932 -eq "$shar_count" ||
    $echo 'm_widow.h:' 'original size' '5932,' 'current size' "$shar_count!"
  fi
fi
# ============= m_widow2.c ==============
if test -f 'm_widow2.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_widow2.c' '(file already exists)'
else
  $echo 'x -' extracting 'm_widow2.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_widow2.c' &&
/*
==============================================================================
X
black widow, part 2
X
==============================================================================
*/
X
// timestamp used to prevent rapid fire of melee attack
X
#include "g_local.h"
#include "m_widow2.h"
X
#define	NUM_STALKERS_SPAWNED		6		// max # of stalkers she can spawn
X
#define	DISRUPT_TIME					3
X
static int	sound_pain1;
static int	sound_pain2;
static int	sound_pain3;
static int	sound_death;
static int	sound_search1;
static int	sound_disrupt;
static int	sound_tentacles_retract;
X
// sqrt(64*64*2) + sqrt(28*28*2) => 130.1
static vec3_t spawnpoints[] = {
X	{30,  135, 0},
X	{30, -135, 0}
};
X
static float sweep_angles[] = {
X	-40.0, -32.0, -24.0, -16.0, -8.0, 0.0, 8.0, 16.0, 24.0, 32.0, 40.0
};
X
extern vec3_t	stalker_mins, stalker_maxs;
X
qboolean infront (edict_t *self, edict_t *other);
void WidowCalcSlots (edict_t *self);
void WidowPowerups (edict_t *self);
X
void widow2_run (edict_t *self);
void widow2_stand (edict_t *self);
void widow2_dead (edict_t *self);
void widow2_attack (edict_t *self);
void widow2_attack_beam (edict_t *self);
void widow2_reattack_beam (edict_t *self);
void widow2_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
void widow_start_spawn (edict_t *self);
void widow_done_spawn (edict_t *self);
void widow2_spawn_check (edict_t *self);
void widow2_prep_spawn (edict_t *self);
void Widow2SaveBeamTarget(edict_t *self);
X
// death stuff
void WidowExplode (edict_t *self);
void gib_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point);
void gib_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf);
void ThrowWidowGibReal (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, qboolean large, int hitsound, qboolean fade);
void ThrowWidowGibSized (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, int hitsound, qboolean fade);
void ThrowWidowGibLoc (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, qboolean fade);
void WidowExplosion1 (edict_t *self);
void WidowExplosion2 (edict_t *self);
void WidowExplosion3 (edict_t *self);
void WidowExplosion4 (edict_t *self);
void WidowExplosion5 (edict_t *self);
void WidowExplosion6 (edict_t *self);
void WidowExplosion7 (edict_t *self);
void WidowExplosionLeg (edict_t *self);
void ThrowArm1 (edict_t *self);
void ThrowArm2 (edict_t *self);
void ClipGibVelocity (edict_t *ent);
// end of death stuff
X
// these offsets used by the tongue
static vec3_t offsets[] = {
X	{17.48, 0.10, 68.92},
X	{17.47, 0.29, 68.91},
X	{17.45, 0.53, 68.87},
X	{17.42, 0.78, 68.81},
X	{17.39, 1.02, 68.75},
X	{17.37, 1.20, 68.70},
X	{17.36, 1.24, 68.71},
X	{17.37, 1.21, 68.72},
};
X
void showme (edict_t *self);
X
void pauseme (edict_t *self)
{
X	self->monsterinfo.aiflags |= AI_HOLD_FRAME;
}
X
void widow2_search (edict_t *self)
{
X	if (random() < 0.5)
X		gi.sound (self, CHAN_VOICE, sound_search1, 1, ATTN_NONE, 0);
}
X
void Widow2Beam (edict_t *self)
{
X	vec3_t	forward, right, target;
X	vec3_t	start, targ_angles, vec;
X	int		flashnum;
X
X	if ((!self->enemy) || (!self->enemy->inuse))
X		return;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	
X	if ((self->s.frame >= FRAME_fireb05) && (self->s.frame <= FRAME_fireb09))
X	{
X		// regular beam attack
X		Widow2SaveBeamTarget(self);
X		flashnum = MZ2_WIDOW2_BEAMER_1 + self->s.frame - FRAME_fireb05;
X		G_ProjectSource (self->s.origin, monster_flash_offset[flashnum], forward, right, start);
X		VectorCopy (self->pos2, target);
X		target[2] += self->enemy->viewheight-10;
X		VectorSubtract (target, start, forward);
X		VectorNormalize (forward);
X		monster_fire_heat (self, start, forward, vec3_origin, 10, 50, flashnum);
X	}
X	else if ((self->s.frame >= FRAME_spawn04) && (self->s.frame <= FRAME_spawn14))
X	{
X		// sweep
X		flashnum = MZ2_WIDOW2_BEAM_SWEEP_1 + self->s.frame - FRAME_spawn04;
X		G_ProjectSource (self->s.origin, monster_flash_offset[flashnum], forward, right, start);
X		VectorSubtract (self->enemy->s.origin, start, target);
X		vectoangles2 (target, targ_angles);
X		
X		VectorCopy (self->s.angles, vec);
X
X		vec[PITCH] += targ_angles[PITCH];
X		vec[YAW] -= sweep_angles[flashnum-MZ2_WIDOW2_BEAM_SWEEP_1];
X
X		AngleVectors (vec, forward, NULL, NULL);
X		monster_fire_heat (self, start, forward, vec3_origin, 10, 50, flashnum);
/*
X		if (self->s.frame == FRAME_spawn04)
X		{
X			VectorMA (start, 1024, forward, debugend);
X
X			gi.WriteByte (svc_temp_entity);
X			gi.WriteByte (TE_DEBUGTRAIL);
X			gi.WritePosition (start);
X			gi.WritePosition (debugend);
X			gi.multicast (start, MULTICAST_ALL);
X
X			drawbbox (self);
X			self->monsterinfo.aiflags |= AI_HOLD_FRAME|AI_MANUAL_STEERING;
X		}
*/
X	}
X	else
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("bad fire frame for widow2 beam -- tell me you saw this!\n");
X
X		Widow2SaveBeamTarget(self);
X		G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_WIDOW2_BEAMER_1], forward, right, start);
X
X		VectorCopy (self->pos2, target);
X		target[2] += self->enemy->viewheight-10;
X		
X		VectorSubtract (target, start, forward);
X		VectorNormalize (forward);
X
X		monster_fire_heat (self, start, forward, vec3_origin, 10, 50, 0);
X	}	
}
X
void Widow2Spawn (edict_t *self)
{
X	vec3_t	f, r, u, offset, startpoint, spawnpoint;
X	edict_t	*ent, *designated_enemy;
X	int		i;
X
X	AngleVectors (self->s.angles, f, r, u);
X
X	for (i=0; i < 2; i++)
X	{
X		VectorCopy (spawnpoints[i], offset);
X
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X		if (FindSpawnPoint (startpoint, stalker_mins, stalker_maxs, spawnpoint, 64))
X		{
X			ent = CreateGroundMonster (spawnpoint, self->s.angles, stalker_mins, stalker_maxs, "monster_stalker", 256);
X
X			if (!ent)
X				continue;
X
X			self->monsterinfo.monster_used++;
X			ent->monsterinfo.commander = self;
//			if ((g_showlogic) && (g_showlogic->value))
//				gi.dprintf ("widow: post-spawn : %d slots left\n", SELF_SLOTS_LEFT);
X
X			ent->nextthink = level.time;
X			ent->think (ent);
X			
X			ent->monsterinfo.aiflags |= AI_SPAWNED_WIDOW|AI_DO_NOT_COUNT|AI_IGNORE_SHOTS;
X
X			if (!(coop && coop->value))
X			{
X				designated_enemy = self->enemy;
X			}
X			else
X			{
X				designated_enemy = PickCoopTarget(ent);
X				if (designated_enemy)
X				{
X					// try to avoid using my enemy
X					if (designated_enemy == self->enemy)
X					{
X						designated_enemy = PickCoopTarget(ent);
X						if (designated_enemy)
X						{
//							if ((g_showlogic) && (g_showlogic->value))
//							{
//								gi.dprintf ("PickCoopTarget returned a %s - ", designated_enemy->classname);
//								if (designated_enemy->client)
//									gi.dprintf ("with name %s\n", designated_enemy->client->pers.netname);
//								else
//									gi.dprintf ("NOT A CLIENT\n");
//							}
X						}
X						else
X						{
//							if ((g_showlogic) && (g_showlogic->value))
//								gi.dprintf ("pick coop failed, using my current enemy\n");
X							designated_enemy = self->enemy;
X						}
X					}
X				}
X				else
X				{
//					if ((g_showlogic) && (g_showlogic->value))
//						gi.dprintf ("pick coop failed, using my current enemy\n");
X					designated_enemy = self->enemy;
X				}
X			}
X
X			if ((designated_enemy->inuse) && (designated_enemy->health > 0))
X			{
X				ent->enemy = designated_enemy;
X				FoundTarget (ent);
X				ent->monsterinfo.attack(ent);
X			}
X		}
X	}
}
X
void widow2_spawn_check (edict_t *self)
{
X	Widow2Beam(self);
X	Widow2Spawn (self);
}
X
void widow2_ready_spawn (edict_t *self)
{
X	vec3_t	f, r, u, offset, startpoint, spawnpoint;
X	int		i;
X
X	Widow2Beam(self);
X	AngleVectors (self->s.angles, f, r, u);
X
X	for (i=0; i < 2; i++)
X	{
X		VectorCopy (spawnpoints[i], offset);
X		G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X		if (FindSpawnPoint (startpoint, stalker_mins, stalker_maxs, spawnpoint, 64))
X		{
X			SpawnGrow_Spawn (spawnpoint, 1);
X		}
X	}
}
X
mframe_t widow2_frames_stand [] =
{
//	ai_stand, 0, drawbbox
X	ai_stand, 0, NULL
};
mmove_t	widow2_move_stand = {FRAME_blackwidow3, FRAME_blackwidow3, widow2_frames_stand, NULL};
X
mframe_t widow2_frames_walk [] =
{
//	ai_walk,	9.01,	drawbbox,
X	ai_walk,	9.01,	NULL,
X	ai_walk,	7.55,	NULL,
X	ai_walk,	7.01,	NULL,
X	ai_walk,	6.66,	NULL,
X	ai_walk,	6.20,	NULL,
X	ai_walk,	5.78,	NULL,
X	ai_walk,	7.25,	NULL,
X	ai_walk,	8.37,	NULL,
X	ai_walk,	10.41,	NULL
};
mmove_t widow2_move_walk = {FRAME_walk01, FRAME_walk09, widow2_frames_walk, NULL};
X
X
mframe_t widow2_frames_run [] =
{
//	ai_run,	9.01,	drawbbox,
X	ai_run,	9.01,	NULL,
X	ai_run,	7.55,	NULL,
X	ai_run,	7.01,	NULL,
X	ai_run,	6.66,	NULL,
X	ai_run,	6.20,	NULL,
X	ai_run,	5.78,	NULL,
X	ai_run,	7.25,	NULL,
X	ai_run,	8.37,	NULL,
X	ai_run,	10.41,	NULL
};
mmove_t widow2_move_run = {FRAME_walk01, FRAME_walk09, widow2_frames_run, NULL};
X
mframe_t widow2_frames_attack_pre_beam [] =
{
X	ai_charge,	4,	NULL,
X	ai_charge,	4,	NULL,
X	ai_charge,	4,	NULL,
X	ai_charge,	4,	widow2_attack_beam
};
mmove_t widow2_move_attack_pre_beam = {FRAME_fireb01, FRAME_fireb04, widow2_frames_attack_pre_beam, NULL};
X
X
// Loop this
mframe_t widow2_frames_attack_beam [] =
{
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	widow2_reattack_beam
};
mmove_t widow2_move_attack_beam = {FRAME_fireb05, FRAME_fireb09, widow2_frames_attack_beam, NULL};
X
mframe_t widow2_frames_attack_post_beam [] =
{
X	ai_charge,	4,	NULL,
X	ai_charge,	4,	NULL,
X	ai_charge,	4,	NULL
};
mmove_t widow2_move_attack_post_beam = {FRAME_fireb06, FRAME_fireb07, widow2_frames_attack_post_beam, widow2_run};
X
X
void WidowDisrupt (edict_t *self)
{
X	vec3_t	start;
X	vec3_t	dir;
X	vec3_t	forward, right;
X	float	len;
X
X	AngleVectors (self->s.angles, forward, right, NULL);
X	G_ProjectSource (self->s.origin, monster_flash_offset[MZ2_WIDOW_DISRUPTOR], forward, right, start);
X
X	VectorSubtract (self->pos1, self->enemy->s.origin, dir);
X	len = VectorLength (dir);
X
X	if (len < 30)
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("target locked - dist %2.2f\n", len);
X		// calc direction to where we targeted
X		VectorSubtract (self->pos1, start, dir);
X		VectorNormalize (dir);
X
X		monster_fire_tracker(self, start, dir, 20, 500, self->enemy, MZ2_WIDOW_DISRUPTOR);
X	}
X	else
X	{
//		if ((g_showlogic) && (g_showlogic->value))
//			gi.dprintf ("target missed - dist %2.2f\n", len);
X
X		PredictAim (self->enemy, start, 1200, true, 0, dir, NULL);
X
//		VectorSubtract (self->enemy->s.origin, start, dir);
//		VectorNormalize (dir);
X		monster_fire_tracker(self, start, dir, 20, 1200, NULL, MZ2_WIDOW_DISRUPTOR);
X	}
}
X
void Widow2SaveDisruptLoc (edict_t *self)
{
X	if (self->enemy && self->enemy->inuse)
X	{
X		VectorCopy (self->enemy->s.origin, self->pos1);	//save for aiming the shot
X		self->pos1[2] += self->enemy->viewheight;
X	}
X	else
X		VectorCopy (vec3_origin, self->pos1);
};
X
void widow2_disrupt_reattack (edict_t *self)
{
X	float luck;
X	
X	luck = random();
X
X	if (luck < (0.25 + ((float)(skill->value))*0.15))
X		self->monsterinfo.nextframe = FRAME_firea01;
}
X
mframe_t widow2_frames_attack_disrupt [] =
{
X	ai_charge, 2, NULL,
X	ai_charge, 2, NULL,
X	ai_charge, 2, Widow2SaveDisruptLoc,
X	ai_charge, -20, WidowDisrupt,
X	ai_charge, 2, NULL,
X	ai_charge, 2, NULL,
X	ai_charge, 2, widow2_disrupt_reattack
};
mmove_t widow2_move_attack_disrupt = {FRAME_firea01, FRAME_firea07, widow2_frames_attack_disrupt, widow2_run};
X
void Widow2SaveBeamTarget (edict_t *self)
{
X	if (self->enemy && self->enemy->inuse)
X	{
X		VectorCopy (self->pos1, self->pos2);
X		VectorCopy (self->enemy->s.origin, self->pos1);	//save for aiming the shot
X	}
X	else
X	{
X		VectorCopy (vec3_origin, self->pos1);
X		VectorCopy (vec3_origin, self->pos2);
X	}
}
X
void Widow2BeamTargetRemove (edict_t *self)
{
X	VectorCopy (vec3_origin, self->pos1);
X	VectorCopy (vec3_origin, self->pos2);
}
X
void Widow2StartSweep (edict_t *self)
{
X	Widow2SaveBeamTarget (self);
}
X
mframe_t widow2_frames_spawn [] =
{
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	widow_start_spawn,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,				//5
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	widow2_ready_spawn,				//10
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	Widow2Beam,
X	ai_charge,	0,	widow2_spawn_check,
X	ai_charge,	0,	NULL,				//15
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	NULL,
X	ai_charge,	0,	widow2_reattack_beam
};
mmove_t widow2_move_spawn = {FRAME_spawn01, FRAME_spawn18, widow2_frames_spawn, NULL};
X
static qboolean widow2_tongue_attack_ok (vec3_t start, vec3_t end, float range)
{
X	vec3_t	dir, angles;
X
X	// check for max distance
X	VectorSubtract (start, end, dir);
X	if (VectorLength(dir) > range)
X		return false;
X
X	// check for min/max pitch
X	vectoangles (dir, angles);
X	if (angles[0] < -180)
X		angles[0] += 360;
X	if (fabs(angles[0]) > 30)
X		return false;
X
X	return true;
}
X
void Widow2Tongue (edict_t *self)
{
X	vec3_t	f, r, u;
X	vec3_t	start, end, dir;
X	trace_t	tr;
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offsets[self->s.frame - FRAME_tongs01], f, r, u, start);
X	VectorCopy (self->enemy->s.origin, end);
X	if (!widow2_tongue_attack_ok(start, end, 256))
X	{
X		end[2] = self->enemy->s.origin[2] + self->enemy->maxs[2] - 8;
X		if (!widow2_tongue_attack_ok(start, end, 256))
X		{
X			end[2] = self->enemy->s.origin[2] + self->enemy->mins[2] + 8;
X			if (!widow2_tongue_attack_ok(start, end, 256))
X				return;
X		}
X	}
X	VectorCopy (self->enemy->s.origin, end);
X
X	tr = gi.trace (start, NULL, NULL, end, self, MASK_SHOT);
X	if (tr.ent != self->enemy)
X		return;
X
X	gi.sound (self, CHAN_WEAPON, sound_tentacles_retract, 1, ATTN_NORM, 0);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_PARASITE_ATTACK);
X	gi.WriteShort (self - g_edicts);
X	gi.WritePosition (start);
X	gi.WritePosition (end);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	VectorSubtract (start, end, dir);
X	T_Damage (self->enemy, self, self, dir, self->enemy->s.origin, vec3_origin, 2, 0, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN);
}
X
void Widow2TonguePull (edict_t *self)
{
X	vec3_t	vec;
X	float	len;
X	vec3_t	f, r, u;
X	vec3_t	start, end;
X
X	if ((!self->enemy) || (!self->enemy->inuse))
X	{
X		self->monsterinfo.run (self);
X		return;
X	}
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offsets[self->s.frame - FRAME_tongs01], f, r, u, start);
X	VectorCopy (self->enemy->s.origin, end);
X
X	if (!widow2_tongue_attack_ok(start, end, 256))
X	{
X		return;
X	}
X
X	if (self->enemy->groundentity)
X	{
X		self->enemy->s.origin[2] += 1;
X		self->enemy->groundentity = NULL;
X		// interesting, you don't have to relink the player
X	}
X	
X	VectorSubtract (self->s.origin, self->enemy->s.origin, vec);
X	len = VectorLength (vec);
X	if (self->enemy->client)
X	{
X		VectorNormalize (vec);
X		VectorMA (self->enemy->velocity, 1000, vec, self->enemy->velocity);
X	}
X	else
X	{
X		self->enemy->ideal_yaw = vectoyaw(vec);	
X		M_ChangeYaw (self->enemy);
X		VectorScale (f, 1000, self->enemy->velocity);
X	}
}
X
void Widow2Crunch (edict_t *self)
{
X	vec3_t	aim;
X
X	if ((!self->enemy) || (!self->enemy->inuse))
X	{
X		self->monsterinfo.run (self);
X		return;
X	}
X
X	Widow2TonguePull (self);
X
X	// 70 + 32
X	VectorSet (aim, 150, 0, 4);
X	if (self->s.frame != FRAME_tongs07)
X		fire_hit (self, aim, 20 + (rand() % 6), 0);
X	else
X	{
X		if (self->enemy->groundentity)
X			fire_hit (self, aim, (20 + (rand() % 6)), 500);
X		else	// not as much kick if they're in the air .. makes it harder to land on her head
X			fire_hit (self, aim, (20 + (rand() % 6)), 250);
X	}
}
X
void Widow2Toss (edict_t *self)
{
X	self->timestamp = level.time + 3;
X	return;
}
X
mframe_t widow2_frames_tongs [] =
{
X	ai_charge,	0,	Widow2Tongue,
X	ai_charge,	0,	Widow2Tongue,
X	ai_charge,	0,	Widow2Tongue,
X	ai_charge,	0,	Widow2TonguePull,
X	ai_charge,	0,	Widow2TonguePull,				//5
X	ai_charge,	0,	Widow2TonguePull,
X	ai_charge,	0,	Widow2Crunch,
X	ai_charge,	0,	Widow2Toss
};
mmove_t widow2_move_tongs = {FRAME_tongs01, FRAME_tongs08, widow2_frames_tongs, widow2_run};
X
mframe_t widow2_frames_pain [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL
};
mmove_t widow2_move_pain = {FRAME_pain01, FRAME_pain05, widow2_frames_pain, widow2_run};
X
mframe_t widow2_frames_death [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	WidowExplosion1,	// 3 boom
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,				// 5
X
X	ai_move,	0,	WidowExplosion2,	// 6 boom
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,				// 10
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,				// 12
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,				// 15
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	WidowExplosion3,	// 18
X	ai_move,	0,	NULL,				// 19
X	ai_move,	0,	NULL,				// 20
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	WidowExplosion4,	// 25
X
X	ai_move,	0,	NULL,				// 26
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	WidowExplosion5,
X	ai_move,	0,	WidowExplosionLeg,	// 30
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	WidowExplosion6,
X	ai_move,	0,	NULL,				// 35
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	WidowExplosion7,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,				// 40
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	WidowExplode		// 44
};
mmove_t widow2_move_death = {FRAME_death01, FRAME_death44, widow2_frames_death, NULL};
X
void widow2_start_searching (edict_t *self);
void widow2_keep_searching (edict_t *self);
void widow2_finaldeath (edict_t *self);
X
mframe_t widow2_frames_dead [] =
{
X	ai_move,	0,	widow2_start_searching,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	widow2_keep_searching
};
mmove_t widow2_move_dead = {FRAME_dthsrh01, FRAME_dthsrh15, widow2_frames_dead, NULL};
X
mframe_t widow2_frames_really_dead [] =
{
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X	ai_move,	0,	NULL,
X
X	ai_move,	0,	NULL,
X	ai_move,	0,	widow2_finaldeath
};
mmove_t widow2_move_really_dead = {FRAME_dthsrh16, FRAME_dthsrh22, widow2_frames_really_dead, NULL};
X
void widow2_start_searching (edict_t *self)
{
X	self->count = 0;
}
X
void widow2_keep_searching (edict_t *self)
{
X	if (self->count <= 2)
X	{
X		self->monsterinfo.currentmove = &widow2_move_dead;
X		self->s.frame = FRAME_dthsrh01;
X		self->count++;
X		return;
X	}
X
X	self->monsterinfo.currentmove = &widow2_move_really_dead;
}
X
void widow2_finaldeath (edict_t *self)
{
X	VectorSet (self->mins, -70, -70, 0);
X	VectorSet (self->maxs, 70, 70, 80);
X	self->movetype = MOVETYPE_TOSS;
//	self->svflags |= SVF_DEADMONSTER;
X	self->takedamage = DAMAGE_YES;
X	self->nextthink = 0;
X	gi.linkentity (self);
}
X
void widow2_stand (edict_t *self)
{
//	gi.dprintf ("widow2 stand\n");
X	self->monsterinfo.currentmove = &widow2_move_stand;
}
X
void widow2_run (edict_t *self)
{
X
//	gi.dprintf ("widow2 run - %2.2f - %s \n", level.time, self->enemy->classname);
X	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
X
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X		self->monsterinfo.currentmove = &widow2_move_stand;
X	else
X		self->monsterinfo.currentmove = &widow2_move_run;
}
X
void widow2_walk (edict_t *self)
{
X	self->monsterinfo.currentmove = &widow2_move_walk;
}
X
void widow2_melee (edict_t *self)
{
X	self->monsterinfo.currentmove = &widow2_move_tongs;
}
X
void widow2_attack (edict_t *self)
{
X	float	range, luck;
X	qboolean blocked = false;
X
X	if (self->monsterinfo.aiflags & AI_BLOCKED)
X	{
X		blocked = true;
X		self->monsterinfo.aiflags &= ~AI_BLOCKED;
X	}
X
//	gi.dprintf ("widow2 attack\n");
X	
X	if (!self->enemy)
X		return;
X
X	if (self->bad_area)
X	{
X		if ((random() < 0.75) || (level.time < self->monsterinfo.attack_finished))
X			self->monsterinfo.currentmove = &widow2_move_attack_pre_beam;
X		else
X		{
X			self->monsterinfo.currentmove = &widow2_move_attack_disrupt;
X		}
X		return;
X	}
X
X	WidowCalcSlots(self);
X
X	// if we can't see the target, spawn stuff
X	if ((self->monsterinfo.attack_state == AS_BLIND) && (SELF_SLOTS_LEFT >= 2))
X	{
X		self->monsterinfo.currentmove = &widow2_move_spawn;
X		return;
X	}
X
X	// accept bias towards spawning
X	if (blocked  && (SELF_SLOTS_LEFT >= 2))
X	{
X		self->monsterinfo.currentmove = &widow2_move_spawn;
X		return;
X	}
X
X	range = realrange (self, self->enemy);
X
X	if (range < 600)
X	{
X		luck = random();
X		if (SELF_SLOTS_LEFT >= 2)
X		{
X			if (luck <= 0.40)
X				self->monsterinfo.currentmove = &widow2_move_attack_pre_beam;
X			else if ((luck <= 0.7) && !(level.time < self->monsterinfo.attack_finished))
X			{
//				gi.sound (self, CHAN_WEAPON, sound_disrupt, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow2_move_attack_disrupt;
X			}
X			else
X				self->monsterinfo.currentmove = &widow2_move_spawn;
X		}
X		else
X		{
X			if ((luck <= 0.50) || (level.time < self->monsterinfo.attack_finished))
X				self->monsterinfo.currentmove = &widow2_move_attack_pre_beam;
X			else
X			{
//				gi.sound (self, CHAN_WEAPON, sound_disrupt, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow2_move_attack_disrupt;
X			}
X		}
X	}
X	else
X	{
X		luck = random();
X		if (SELF_SLOTS_LEFT >= 2)
X		{
X			if (luck < 0.3)
X				self->monsterinfo.currentmove = &widow2_move_attack_pre_beam;
X			else if ((luck < 0.65) || (level.time < self->monsterinfo.attack_finished))
X				self->monsterinfo.currentmove = &widow2_move_spawn;
X			else
X			{
//				gi.sound (self, CHAN_WEAPON, sound_disrupt, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow2_move_attack_disrupt;
X			}
X		}
X		else
X		{
X			if ((luck < 0.45) || (level.time < self->monsterinfo.attack_finished))
X				self->monsterinfo.currentmove = &widow2_move_attack_pre_beam;
X			else
X			{
//				gi.sound (self, CHAN_WEAPON, sound_disrupt, 1, ATTN_NORM, 0);
X				self->monsterinfo.currentmove = &widow2_move_attack_disrupt;
X			}
X		}
X	}
}
X
void widow2_attack_beam (edict_t *self)
{
X	self->monsterinfo.currentmove = &widow2_move_attack_beam;
}
X
void widow2_reattack_beam (edict_t *self)
{
X	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X
X	if ( infront(self, self->enemy) )
X		if (random() <= 0.5)
X			if ((random() < 0.7) || (SELF_SLOTS_LEFT < 2))
X				self->monsterinfo.currentmove = &widow2_move_attack_beam;
X			else
X				self->monsterinfo.currentmove = &widow2_move_spawn;
X		else
X			self->monsterinfo.currentmove = &widow2_move_attack_post_beam;
X	else
X		self->monsterinfo.currentmove = &widow2_move_attack_post_beam;
}
X
X
X
void widow2_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	if (self->health < (self->max_health / 2))
X		self->s.skinnum = 1;
X
X	if (skill->value == 3)
X		return;		// no pain anims in nightmare
X
//	gi.dprintf ("widow2 pain\n");
X	if (level.time < self->pain_debounce_time)
X		return;
X
X	self->pain_debounce_time = level.time + 5;
X
X	if (damage < 15)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NONE, 0);
X	}
X	else if (damage < 75)
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NONE, 0);
X		if ((skill->value < 3) && (random() < (0.6 - (0.2*((float)skill->value)))))
X		{
X			self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X			self->monsterinfo.currentmove = &widow2_move_pain;
X		}
X	}
X	else 
X	{
X		gi.sound (self, CHAN_VOICE, sound_pain3, 1, ATTN_NONE, 0);
X		if ((skill->value < 3) && (random() < (0.75 - (0.1*((float)skill->value)))))
X		{
X			self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
X			self->monsterinfo.currentmove = &widow2_move_pain;
X		}
X	}
}
X
void widow2_dead (edict_t *self)
{
}
X
void KillChildren (edict_t *self)
{
X	edict_t *ent;
X	int		field;
X
X	ent = NULL;
X	field = FOFS(classname);
X	while (1)
X	{
X		ent = G_Find (ent, field, "monster_stalker");
X		if(!ent)
X			return;
X		
X		// FIXME - may need to stagger
X		if ((ent->inuse) && (ent->health > 0))
X			T_Damage (ent, self, self, vec3_origin, self->enemy->s.origin, vec3_origin, (ent->health + 1), 0, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN);
X	}
}
X
void widow2_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int n;
X	int	clipped;
X
// check for gib
X	if (self->health <= self->gib_health)
X	{
X		clipped = min (damage, 100);
X
X		gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 2; n++)
X			ThrowWidowGibLoc (self, "models/objects/gibs/bone/tris.md2", clipped, GIB_ORGANIC, NULL, false);
X		for (n= 0; n < 3; n++)
X			ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", clipped, GIB_ORGANIC, NULL, false);
X		for (n= 0; n < 3; n++)
X		{
X			ThrowWidowGibSized (self, "models/monsters/blackwidow2/gib1/tris.md2", clipped, GIB_METALLIC, NULL,
X				0, false);
X			ThrowWidowGibSized (self, "models/monsters/blackwidow2/gib2/tris.md2", clipped, GIB_METALLIC, NULL, 
X				gi.soundindex ("misc/fhit3.wav"), false);
X		}
X		for (n= 0; n < 2; n++)
X		{
X			ThrowWidowGibSized (self, "models/monsters/blackwidow2/gib3/tris.md2", clipped, GIB_METALLIC, NULL, 
X				0, false);
X			ThrowWidowGibSized (self, "models/monsters/blackwidow/gib3/tris.md2", clipped, GIB_METALLIC, NULL, 
X				0, false);
X		}
X		ThrowGib (self, "models/objects/gibs/chest/tris.md2", clipped, GIB_ORGANIC);
X		ThrowHead (self, "models/objects/gibs/head2/tris.md2", clipped, GIB_ORGANIC);
X		self->deadflag = DEAD_DEAD;
X		return;
X	}
X
X	if (self->deadflag == DEAD_DEAD)
X		return;
X
X	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NONE, 0);
X	self->deadflag = DEAD_DEAD;
X	self->takedamage = DAMAGE_NO;
X	self->count = 0;
X	KillChildren (self);
X	self->monsterinfo.quad_framenum = 0;
X	self->monsterinfo.double_framenum = 0;
X	self->monsterinfo.invincible_framenum = 0;
X	self->monsterinfo.currentmove = &widow2_move_death;
}
X
qboolean Widow2_CheckAttack (edict_t *self)
{
X	vec3_t		spot1, spot2;
X	vec3_t		temp;
X	float		chance;
X	trace_t		tr;
X	qboolean	enemy_infront;
X	int			enemy_range;
X	float		enemy_yaw;
X	float		real_enemy_range;
X	vec3_t		f, r, u;
X
X	if (!self->enemy)
X		return false;
X
X	WidowPowerups(self);
X
X	if ((random() < 0.8) && (SELF_SLOTS_LEFT >= 2) && (realrange(self, self->enemy) > 150))
X	{
X		self->monsterinfo.aiflags |= AI_BLOCKED;
X		self->monsterinfo.attack_state = AS_MISSILE;
X		return true;
X	}
X
X	if (self->enemy->health > 0)
X	{
X	// see if any entities are in the way of the shot
X		VectorCopy (self->s.origin, spot1);
X		spot1[2] += self->viewheight;
X		VectorCopy (self->enemy->s.origin, spot2);
X		spot2[2] += self->enemy->viewheight;
X
X		tr = gi.trace (spot1, NULL, NULL, spot2, self, CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_SLIME|CONTENTS_LAVA);
X
X		// do we have a clear shot?
X		if (tr.ent != self->enemy)
X		{	
X			// go ahead and spawn stuff if we're mad a a client
X			if (self->enemy->client && SELF_SLOTS_LEFT >= 2)
X			{
X				self->monsterinfo.attack_state = AS_BLIND;
X				return true;
X			}
X				
X			// PGM - we want them to go ahead and shoot at info_notnulls if they can.
X			if(self->enemy->solid != SOLID_NOT || tr.fraction < 1.0)		//PGM
X				return false;
X		}
X	}
X	
X	enemy_infront = infront(self, self->enemy);
X
X	enemy_range = range(self, self->enemy);
X	VectorSubtract (self->enemy->s.origin, self->s.origin, temp);
X	enemy_yaw = vectoyaw2(temp);
X
X	self->ideal_yaw = enemy_yaw;
X
X	// melee attack
X	if (self->timestamp < level.time)
X	{
X		real_enemy_range = realrange (self, self->enemy);
X		if (real_enemy_range < 300)
X		{
X			AngleVectors (self->s.angles, f, r, u);
X			G_ProjectSource2 (self->s.origin, offsets[0], f, r, u, spot1);
X			VectorCopy (self->enemy->s.origin, spot2);
X			if (widow2_tongue_attack_ok(spot1, spot2, 256))
X			{
X				// melee attack ok
X
X				// be nice in easy mode
X				if (skill->value == 0 && (rand()&3) )
X					return false;
X
X				if (self->monsterinfo.melee)
X					self->monsterinfo.attack_state = AS_MELEE;
X				else
X					self->monsterinfo.attack_state = AS_MISSILE;
X				return true;
X			}
X		}
X	}
X	
X	if (level.time < self->monsterinfo.attack_finished)
X		return false;
X		
X	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
X	{
X		chance = 0.4;
X	}
X	else if (enemy_range == RANGE_NEAR)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_MID)
X	{
X		chance = 0.8;
X	}
X	else if (enemy_range == RANGE_FAR)
X	{
X		chance = 0.5;
X	}
X
X	// PGM - go ahead and shoot every time if it's a info_notnull
X	if ((random () < chance) || (self->enemy->solid == SOLID_NOT))
X	{
X		self->monsterinfo.attack_state = AS_MISSILE;
//		self->monsterinfo.attack_finished = level.time + 1.0 + 2*random();
X		return true;
X	}
X
X	return false;
}
X
void Widow2Precache ()
{
X	// cache in all of the stalker stuff, widow stuff, spawngro stuff, gibs
X	gi.soundindex ("parasite/parpain1.wav");	
X	gi.soundindex ("parasite/parpain2.wav");	
X	gi.soundindex ("parasite/pardeth1.wav");	
X	gi.soundindex ("parasite/paratck1.wav");
X	gi.soundindex ("parasite/parsght1.wav");
X	gi.soundindex ("infantry/melee2.wav");
X	gi.soundindex ("misc/fhit3.wav");
X
X	gi.soundindex ("tank/tnkatck3.wav");
X	gi.soundindex ("weapons/disrupt.wav");
X	gi.soundindex ("weapons/disint2.wav");
X
X	gi.modelindex ("models/monsters/stalker/tris.md2");
X	gi.modelindex ("models/items/spawngro2/tris.md2");
X	gi.modelindex ("models/objects/gibs/sm_metal/tris.md2");
X	gi.modelindex ("models/proj/laser2/tris.md2");
X	gi.modelindex ("models/proj/disintegrator/tris.md2");
X
X	gi.modelindex ("models/monsters/blackwidow/gib1/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow/gib2/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow/gib3/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow/gib4/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib1/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib2/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib3/tris.md2");
X	gi.modelindex ("models/monsters/blackwidow2/gib4/tris.md2");
}
X
/*QUAKED monster_widow2 (1 .5 0) (-70 -70 0) (70 70 144) Ambush Trigger_Spawn Sight
*/
void SP_monster_widow2 (edict_t *self)
{
X	if (deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	sound_pain1 = gi.soundindex ("widow/bw2pain1.wav");
X	sound_pain2 = gi.soundindex ("widow/bw2pain2.wav");
X	sound_pain3 = gi.soundindex ("widow/bw2pain3.wav");
X	sound_death = gi.soundindex ("widow/death.wav");
X	sound_search1 = gi.soundindex ("bosshovr/bhvunqv1.wav");
//	sound_disrupt = gi.soundindex ("gladiator/railgun.wav");
X	sound_tentacles_retract = gi.soundindex ("brain/brnatck3.wav");
X
//	self->s.sound = gi.soundindex ("bosshovr/bhvengn1.wav");
X
X	self->movetype = MOVETYPE_STEP;
X	self->solid = SOLID_BBOX;
X	self->s.modelindex = gi.modelindex ("models/monsters/blackwidow2/tris.md2");
X	VectorSet (self->mins, -70, -70, 0);
X	VectorSet (self->maxs, 70, 70, 144);
X
X	self->health = 2000 + 800 + 1000*(skill->value);
X	if (coop->value)
X		self->health += 500*(skill->value);
//	self->health = 1;
X	self->gib_health = -900;
X	self->mass = 2500;
X
/*	if (skill->value == 2)
X	{
X		self->monsterinfo.power_armor_type = POWER_ARMOR_SHIELD;
X		self->monsterinfo.power_armor_power = 500;
X	}
X	else */if (skill->value == 3)
X	{
X		self->monsterinfo.power_armor_type = POWER_ARMOR_SHIELD;
X		self->monsterinfo.power_armor_power = 750;
X	}
X
X	self->yaw_speed = 30;
X	
X	self->flags |= FL_IMMUNE_LASER;
X	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
X
X	self->pain = widow2_pain;
X	self->die = widow2_die;
X
X	self->monsterinfo.melee = widow2_melee;
X	self->monsterinfo.stand = widow2_stand;
X	self->monsterinfo.walk = widow2_walk;
X	self->monsterinfo.run = widow2_run;
X	self->monsterinfo.attack = widow2_attack;
X	self->monsterinfo.search = widow2_search;
X	self->monsterinfo.checkattack = Widow2_CheckAttack;
X	gi.linkentity (self);
X
X	self->monsterinfo.currentmove = &widow2_move_stand;	
X	self->monsterinfo.scale = MODEL_SCALE;
X
X	Widow2Precache();
X	WidowCalcSlots(self);
X	walkmonster_start (self);
}
X
//
// Death sequence stuff
//
X
void WidowVelocityForDamage (int damage, vec3_t v)
{
X	v[0] = damage * crandom();
X	v[1] = damage * crandom();
X	v[2] = damage * crandom() + 200.0;
}
X
void widow_gib_touch (edict_t *self, edict_t *other, cplane_t *plane, csurface_t *surf)
{
X
X	self->solid = SOLID_NOT;
X	self->touch = NULL;
X	self->s.angles[PITCH] = 0;
X	self->s.angles[ROLL] = 0;
X	VectorClear (self->avelocity);
X
X	if (self->plat2flags)
X		gi.sound (self, CHAN_VOICE, self->plat2flags, 1, ATTN_NORM, 0);
/*
X	if (plane)
X	{
X		if (plane->normal[2] < -0.8)
X		{
X			gi.sound (self, CHAN_VOICE, gi.soundindex ("misc/fhit3.wav"), 1, ATTN_NORM, 0);
X		}
X		
X		//vectoangles (plane->normal, normal_angles);
X		//AngleVectors (normal_angles, NULL, right, NULL);
X		//vectoangles (right, self->s.angles);
X		//VectorClear (self->avelocity);
X	}
*/
}
X
void ThrowWidowGib (edict_t *self, char *gibname, int damage, int type)
{
X	ThrowWidowGibReal (self, gibname, damage, type, NULL, false, 0, true);
}
X
void ThrowWidowGibLoc (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, qboolean fade)
{
X	ThrowWidowGibReal (self, gibname, damage, type, startpos, false, 0, fade);
}
X
void ThrowWidowGibSized (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, int hitsound, qboolean fade)
{
X	ThrowWidowGibReal (self, gibname, damage, type, startpos, true, hitsound, fade);
}
X
void ThrowWidowGibReal (edict_t *self, char *gibname, int damage, int type, vec3_t startpos, qboolean sized, int hitsound, qboolean fade)
{
X	edict_t *gib;
X	vec3_t	vd;
X	vec3_t	origin;
X	vec3_t	size;
X	float	vscale;
X
X	if (!gibname)
X		return;
X
X	gib = G_Spawn();
X
X	if (startpos)
X		VectorCopy (startpos, gib->s.origin);
X	else
X	{
X		VectorScale (self->size, 0.5, size);
X		VectorAdd (self->absmin, size, origin);
X		gib->s.origin[0] = origin[0] + crandom() * size[0];
X		gib->s.origin[1] = origin[1] + crandom() * size[1];
X		gib->s.origin[2] = origin[2] + crandom() * size[2];
X	}
X
X	gib->solid = SOLID_NOT;
X	gib->s.effects |= EF_GIB;
X	gib->flags |= FL_NO_KNOCKBACK;
X	gib->takedamage = DAMAGE_YES;
X	gib->die = gib_die;
X	gib->s.renderfx |= RF_IR_VISIBLE;
X
X	if (fade)
X	{
X		gib->think = G_FreeEdict;
X		// sized gibs last longer
X		if (sized)
X			gib->nextthink = level.time + 20 + random()*15;
X		else
X			gib->nextthink = level.time + 5 + random()*10;
X	}
X	else
X	{
X		gib->think = G_FreeEdict;
X		// sized gibs last longer
X		if (sized)
X			gib->nextthink = level.time + 60 + random()*15;
X		else
X			gib->nextthink = level.time + 25 + random()*10;
X	}
X
X	if (type == GIB_ORGANIC)
X	{
X		gib->movetype = MOVETYPE_TOSS;
X		gib->touch = gib_touch;
X		vscale = 0.5;
X	}
X	else
X	{
X		gib->movetype = MOVETYPE_BOUNCE;
X		vscale = 1.0;
X	}
X
X	WidowVelocityForDamage (damage, vd);
X	VectorMA (self->velocity, vscale, vd, gib->velocity);
X	ClipGibVelocity (gib);
X
X	gi.setmodel (gib, gibname);
X
X	if (sized)
X	{
X		gib->plat2flags = hitsound;
X		gib->solid = SOLID_BBOX;
X		gib->avelocity[0] = random()*400;
X		gib->avelocity[1] = random()*400;
X		gib->avelocity[2] = random()*200;
X		if (gib->velocity[2] < 0)
X			gib->velocity[2] *= -1;
X		gib->velocity[0] *= 2;
X		gib->velocity[1] *= 2;
X		ClipGibVelocity (gib);
X		gib->velocity[2] = max((350 + (random()*100.0)), gib->velocity[2]);
X		gib->gravity = 0.25;
X		gib->touch = widow_gib_touch;
X		gib->owner = self;
X		if (gib->s.modelindex == gi.modelindex ("models/monsters/blackwidow2/gib2/tris.md2"))
X		{
X			VectorSet (gib->mins, -10, -10, 0);
X			VectorSet (gib->maxs, 10, 10, 10);
X		}
X		else
X		{
X			VectorSet (gib->mins, -5, -5, 0);
X			VectorSet (gib->maxs, 5, 5, 5);
X		}
X	}
X	else
X	{
X		gib->velocity[0] *= 2;
X		gib->velocity[1] *= 2;
X		gib->avelocity[0] = random()*600;
X		gib->avelocity[1] = random()*600;
X		gib->avelocity[2] = random()*600;
X	}
X
//	gib->think = G_FreeEdict;
//	gib->nextthink = level.time + 10 + random()*10;
X
X	gi.linkentity (gib);
}
X
void BloodFountain (edict_t *self, int number, vec3_t startpos, int damage)
{
X	int n;
X	vec3_t	vd;
X	vec3_t	origin, size, velocity;
X
X	return;
X
X	for (n= 0; n < number; n++)
X	{
X		if (startpos)
X			VectorCopy (startpos, origin);
X		else
X		{
X			VectorScale (self->size, 0.5, size);
X			VectorAdd (self->absmin, size, origin);
X			origin[0] = origin[0] + crandom() * size[0];
X			origin[1] = origin[1] + crandom() * size[1];
X			origin[2] = origin[2] + crandom() * size[2];
X		}
X
X		WidowVelocityForDamage (damage, vd);
X		VectorMA (self->velocity, 1.0, vd, velocity);
X		velocity[0] *= 2;
X		velocity[1] *= 2;
X
//		gi.WriteByte (svc_temp_entity);
//		gi.WriteByte (TE_BLOOD_FOUNTAIN);
//		gi.WritePosition (origin);
//		gi.WritePosition (velocity);
//		gi.WriteShort (50);
//		gi.multicast (self->s.origin, MULTICAST_ALL);
X	}
}
X
void ThrowSmallStuff (edict_t *self, vec3_t point)
{
X	int n;
X
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, point, false);
X	ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, point, false);
X	ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, point, false);
X
}
X
void ThrowMoreStuff (edict_t *self, vec3_t point)
{
X	int n;
X
X	if (coop && coop->value)
X	{
X		ThrowSmallStuff (self, point);
X		return;
X	}
X
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, point, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, point, false);
X	for (n= 0; n < 3; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, point, false);
X
}
X
void WidowExplode (edict_t *self)
{
X	vec3_t	org;
X	int		n;
X
X	self->think = WidowExplode;
//	gi.dprintf ("count = %d\n");
X
//redo:
X	VectorCopy (self->s.origin, org);
X	org[2] += 24 + (rand()&15);
X	if (self->count < 8)
X		org[2] += 24 + (rand()&31);
X	switch (self->count)
X	{
X	case 0:
X		org[0] -= 24;
X		org[1] -= 24;
X		break;
X	case 1:
X		org[0] += 24;
X		org[1] += 24;
X		ThrowSmallStuff(self, org);
X		break;
X	case 2:
X		org[0] += 24;
X		org[1] -= 24;
X		break;
X	case 3:
X		org[0] -= 24;
X		org[1] += 24;
X		ThrowMoreStuff(self, org);
X		break;
X	case 4:
X		org[0] -= 48;
X		org[1] -= 48;
X		break;
X	case 5:
X		org[0] += 48;
X		org[1] += 48;
X		ThrowArm1 (self);
X		break;
X	case 6:
X		org[0] -= 48;
X		org[1] += 48;
X		ThrowArm2 (self);
X		break;
X	case 7:
X		org[0] += 48;
X		org[1] -= 48;
X		ThrowSmallStuff(self, org);
X		break;
X	case 8:
X		org[0] += 18;
X		org[1] += 18;
X		org[2] = self->s.origin[2] + 48;
X		ThrowMoreStuff(self, org);
X		break;
X	case 9:
X		org[0] -= 18;
X		org[1] += 18;
X		org[2] = self->s.origin[2] + 48;
X		break;
X	case 10:
X		org[0] += 18;
X		org[1] -= 18;
X		org[2] = self->s.origin[2] + 48;
X		break;
X	case 11:
X		org[0] -= 18;
X		org[1] -= 18;
X		org[2] = self->s.origin[2] + 48;
X		break;
X	case 12:
X		self->s.sound = 0;
X		for (n= 0; n < 1; n++)
X			ThrowWidowGib (self, "models/objects/gibs/sm_meat/tris.md2", 400, GIB_ORGANIC);
X		for (n= 0; n < 2; n++)
X			ThrowWidowGib (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC);
X		for (n= 0; n < 2; n++)
X			ThrowWidowGib (self, "models/objects/gibs/sm_metal/tris.md2", 400, GIB_METALLIC);
//		ThrowGib (self, "models/objects/gibs/chest/tris.md2", 1000, GIB_ORGANIC);
//		ThrowHead (self, "models/objects/gibs/gear/tris.md2", 1000, GIB_METALLIC);
X		self->deadflag = DEAD_DEAD;
X		self->think = monster_think;
X		self->nextthink = level.time + 0.1;
X		self->monsterinfo.currentmove = &widow2_move_dead;
X		return;
X	}
X
X	self->count++;
X	if (self->count >=9 && self->count <=12)
X	{
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_EXPLOSION1_BIG);
X		gi.WritePosition (org);
X		gi.multicast (self->s.origin, MULTICAST_ALL);
//		goto redo;
X	} 
X	else
X	{
X		// else
X		gi.WriteByte (svc_temp_entity);
X		if (self->count %2)
X			gi.WriteByte (TE_EXPLOSION1);
X		else
X			gi.WriteByte (TE_EXPLOSION1_NP);
X		gi.WritePosition (org);
X		gi.multicast (self->s.origin, MULTICAST_ALL);
X	}
X
X	self->nextthink = level.time + 0.1;
}
X
void WidowExplosion1 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset = {23.74, -37.67, 76.96};
X
//	gi.dprintf ("1\n");
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X	
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, startpoint, false);
}
X
void WidowExplosion2 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset = {-20.49, 36.92, 73.52};
X
//	gi.dprintf ("2\n");
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X	
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, startpoint, false);
}
X
void WidowExplosion3 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset = {2.11, 0.05, 92.20};
X
//	gi.dprintf ("3\n");
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X	
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, startpoint, false);
}
X
void WidowExplosion4 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset = {-28.04, -35.57, -77.56};
X
//	gi.dprintf ("4\n");
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X	
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, startpoint, false);
}
X
void WidowExplosion5 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset = {-20.11, -1.11, 40.76};
X
//	gi.dprintf ("5\n");
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X	
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, startpoint, false);
}
X
void WidowExplosion6 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset = {-20.11, -1.11, 40.76};
X
X	//gi.dprintf ("6\n");
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X	
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, startpoint, false);
}
X
void WidowExplosion7 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset = {-20.11, -1.11, 40.76};
X
X	//gi.dprintf ("7\n");
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X	
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	for (n= 0; n < 1; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 300, GIB_METALLIC, startpoint, false);
}
X
void WidowExplosionLeg (edict_t *self)
{
//	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset1 = {-31.89, -47.86, 67.02};
X	vec3_t	offset2 = {-44.9, -82.14, 54.72};
X
X	//gi.dprintf ("Leg\n");
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset1, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1_BIG);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X
X	ThrowWidowGibSized (self, "models/monsters/blackwidow2/gib2/tris.md2", 200, GIB_METALLIC, startpoint, 
X		gi.soundindex ("misc/fhit3.wav"), false);
X	ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
X
X	G_ProjectSource2 (self->s.origin, offset2, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X
X	ThrowWidowGibSized (self, "models/monsters/blackwidow2/gib1/tris.md2", 300, GIB_METALLIC, startpoint,
X		gi.soundindex ("misc/fhit3.wav"), false);
X	ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
X	ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
}
X
void ThrowArm1 (edict_t *self)
{
X	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset1 = {65.76, 17.52, 7.56};
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset1, f, r, u, startpoint);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_EXPLOSION1_BIG);
X	gi.WritePosition (startpoint);
X	gi.multicast (self->s.origin, MULTICAST_ALL);
X
X	for (n= 0; n < 2; n++)
X		ThrowWidowGibLoc (self, "models/objects/gibs/sm_metal/tris.md2", 100, GIB_METALLIC, startpoint, false);
}
X
void ThrowArm2 (edict_t *self)
{
//	int		n;
X	vec3_t	f,r,u, startpoint;
X	vec3_t	offset1 = {65.76, 17.52, 7.56};
X
X	AngleVectors (self->s.angles, f, r, u);
X	G_ProjectSource2 (self->s.origin, offset1, f, r, u, startpoint);
X
X	ThrowWidowGibSized (self, "models/monsters/blackwidow2/gib4/tris.md2", 200, GIB_METALLIC, startpoint, 
X		gi.soundindex ("misc/fhit3.wav"), false);
X	ThrowWidowGibLoc (self, "models/objects/gibs/sm_meat/tris.md2", 300, GIB_ORGANIC, startpoint, false);
}
SHAR_EOF
  $shar_touch -am 1130175398 'm_widow2.c' &&
  chmod 0664 'm_widow2.c' ||
  $echo 'restore of' 'm_widow2.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_widow2.c:' 'MD5 check failed'
b9570d03548737747365441551ef570a  m_widow2.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_widow2.c'`"
    test 47155 -eq "$shar_count" ||
    $echo 'm_widow2.c:' 'original size' '47155,' 'current size' "$shar_count!"
  fi
fi
# ============= m_widow2.h ==============
if test -f 'm_widow2.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'm_widow2.h' '(file already exists)'
else
  $echo 'x -' extracting 'm_widow2.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'm_widow2.h' &&
// G:\quake2\xpack\models/monsters/blackwidow2
X
// This file generated by qdata - Do NOT Modify
X
#define FRAME_blackwidow3     	0
#define FRAME_walk01          	1
#define FRAME_walk02          	2
#define FRAME_walk03          	3
#define FRAME_walk04          	4
#define FRAME_walk05          	5
#define FRAME_walk06          	6
#define FRAME_walk07          	7
#define FRAME_walk08          	8
#define FRAME_walk09          	9
#define FRAME_spawn01         	10
#define FRAME_spawn02         	11
#define FRAME_spawn03         	12
#define FRAME_spawn04         	13
#define FRAME_spawn05         	14
#define FRAME_spawn06         	15
#define FRAME_spawn07         	16
#define FRAME_spawn08         	17
#define FRAME_spawn09         	18
#define FRAME_spawn10         	19
#define FRAME_spawn11         	20
#define FRAME_spawn12         	21
#define FRAME_spawn13         	22
#define FRAME_spawn14         	23
#define FRAME_spawn15         	24
#define FRAME_spawn16         	25
#define FRAME_spawn17         	26
#define FRAME_spawn18         	27
#define FRAME_firea01         	28
#define FRAME_firea02         	29
#define FRAME_firea03         	30
#define FRAME_firea04         	31
#define FRAME_firea05         	32
#define FRAME_firea06         	33
#define FRAME_firea07         	34
#define FRAME_fireb01         	35
#define FRAME_fireb02         	36
#define FRAME_fireb03         	37
#define FRAME_fireb04         	38
#define FRAME_fireb05         	39
#define FRAME_fireb06         	40
#define FRAME_fireb07         	41
#define FRAME_fireb08         	42
#define FRAME_fireb09         	43
#define FRAME_fireb10         	44
#define FRAME_fireb11         	45
#define FRAME_fireb12         	46
#define FRAME_tongs01         	47
#define FRAME_tongs02         	48
#define FRAME_tongs03         	49
#define FRAME_tongs04         	50
#define FRAME_tongs05         	51
#define FRAME_tongs06         	52
#define FRAME_tongs07         	53
#define FRAME_tongs08         	54
#define FRAME_pain01          	55
#define FRAME_pain02          	56
#define FRAME_pain03          	57
#define FRAME_pain04          	58
#define FRAME_pain05          	59
#define FRAME_death01         	60
#define FRAME_death02         	61
#define FRAME_death03         	62
#define FRAME_death04         	63
#define FRAME_death05         	64
#define FRAME_death06         	65
#define FRAME_death07         	66
#define FRAME_death08         	67
#define FRAME_death09         	68
#define FRAME_death10         	69
#define FRAME_death11         	70
#define FRAME_death12         	71
#define FRAME_death13         	72
#define FRAME_death14         	73
#define FRAME_death15         	74
#define FRAME_death16         	75
#define FRAME_death17         	76
#define FRAME_death18         	77
#define FRAME_death19         	78
#define FRAME_death20         	79
#define FRAME_death21         	80
#define FRAME_death22         	81
#define FRAME_death23         	82
#define FRAME_death24         	83
#define FRAME_death25         	84
#define FRAME_death26         	85
#define FRAME_death27         	86
#define FRAME_death28         	87
#define FRAME_death29         	88
#define FRAME_death30         	89
#define FRAME_death31         	90
#define FRAME_death32         	91
#define FRAME_death33         	92
#define FRAME_death34         	93
#define FRAME_death35         	94
#define FRAME_death36         	95
#define FRAME_death37         	96
#define FRAME_death38         	97
#define FRAME_death39         	98
#define FRAME_death40         	99
#define FRAME_death41         	100
#define FRAME_death42         	101
#define FRAME_death43         	102
#define FRAME_death44         	103
#define FRAME_dthsrh01        	104
#define FRAME_dthsrh02        	105
#define FRAME_dthsrh03        	106
#define FRAME_dthsrh04        	107
#define FRAME_dthsrh05        	108
#define FRAME_dthsrh06        	109
#define FRAME_dthsrh07        	110
#define FRAME_dthsrh08        	111
#define FRAME_dthsrh09        	112
#define FRAME_dthsrh10        	113
#define FRAME_dthsrh11        	114
#define FRAME_dthsrh12        	115
#define FRAME_dthsrh13        	116
#define FRAME_dthsrh14        	117
#define FRAME_dthsrh15        	118
#define FRAME_dthsrh16        	119
#define FRAME_dthsrh17        	120
#define FRAME_dthsrh18        	121
#define FRAME_dthsrh19        	122
#define FRAME_dthsrh20        	123
#define FRAME_dthsrh21        	124
#define FRAME_dthsrh22        	125
X
#define MODEL_SCALE		2.000000
SHAR_EOF
  $shar_touch -am 1130175398 'm_widow2.h' &&
  chmod 0664 'm_widow2.h' ||
  $echo 'restore of' 'm_widow2.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'm_widow2.h:' 'MD5 check failed'
b51a39b8dbee362cb3e73dedce1813dc  m_widow2.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'm_widow2.h'`"
    test 4428 -eq "$shar_count" ||
    $echo 'm_widow2.h:' 'original size' '4428,' 'current size' "$shar_count!"
  fi
fi
# ============= p_client.c ==============
if test -f 'p_client.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'p_client.c' '(file already exists)'
else
  $echo 'x -' extracting 'p_client.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'p_client.c' &&
#include "g_local.h"
#include "m_player.h"
X
void ClientUserinfoChanged (edict_t *ent, char *userinfo);
X
void SP_misc_teleporter_dest (edict_t *ent);
X
//
// Gross, ugly, disgustuing hack section
//
X
// this function is an ugly as hell hack to fix some map flaws
//
// the coop spawn spots on some maps are SNAFU.  There are coop spots
// with the wrong targetname as well as spots with no name at all
//
// we use carnal knowledge of the maps to fix the coop spot targetnames to match
// that of the nearest named single player spot
X
static void SP_FixCoopSpots (edict_t *self)
{
X	edict_t	*spot;
X	vec3_t	d;
X
X	spot = NULL;
X
X	while(1)
X	{
X		spot = G_Find(spot, FOFS(classname), "info_player_start");
X		if (!spot)
X			return;
X		if (!spot->targetname)
X			continue;
X		VectorSubtract(self->s.origin, spot->s.origin, d);
X		if (VectorLength(d) < 384)
X		{
X			if ((!self->targetname) || Q_stricmp(self->targetname, spot->targetname) != 0)
X			{
//				gi.dprintf("FixCoopSpots changed %s at %s targetname from %s to %s\n", self->classname, vtos(self->s.origin), self->targetname, spot->targetname);
X				self->targetname = spot->targetname;
X			}
X			return;
X		}
X	}
}
X
// now if that one wasn't ugly enough for you then try this one on for size
// some maps don't have any coop spots at all, so we need to create them
// where they should have been
X
static void SP_CreateCoopSpots (edict_t *self)
{
X	edict_t	*spot;
X
X	if(Q_stricmp(level.mapname, "security") == 0)
X	{
X		spot = G_Spawn();
X		spot->classname = "info_player_coop";
X		spot->s.origin[0] = 188 - 64;
X		spot->s.origin[1] = -164;
X		spot->s.origin[2] = 80;
X		spot->targetname = "jail3";
X		spot->s.angles[1] = 90;
X
X		spot = G_Spawn();
X		spot->classname = "info_player_coop";
X		spot->s.origin[0] = 188 + 64;
X		spot->s.origin[1] = -164;
X		spot->s.origin[2] = 80;
X		spot->targetname = "jail3";
X		spot->s.angles[1] = 90;
X
X		spot = G_Spawn();
X		spot->classname = "info_player_coop";
X		spot->s.origin[0] = 188 + 128;
X		spot->s.origin[1] = -164;
X		spot->s.origin[2] = 80;
X		spot->targetname = "jail3";
X		spot->s.angles[1] = 90;
X
X		return;
X	}
}
X
X
/*QUAKED info_player_start (1 0 0) (-16 -16 -24) (16 16 32)
The normal starting point for a level.
*/
void SP_info_player_start(edict_t *self)
{
X	if (!coop->value)
X		return;
X	if(Q_stricmp(level.mapname, "security") == 0)
X	{
X		// invoke one of our gross, ugly, disgusting hacks
X		self->think = SP_CreateCoopSpots;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
/*QUAKED info_player_deathmatch (1 0 1) (-16 -16 -24) (16 16 32)
potential spawning position for deathmatch games
*/
void SP_info_player_deathmatch(edict_t *self)
{
X	if (!deathmatch->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X	SP_misc_teleporter_dest (self);
}
X
/*QUAKED info_player_coop (1 0 1) (-16 -16 -24) (16 16 32)
potential spawning position for coop games
*/
X
void SP_info_player_coop(edict_t *self)
{
X	if (!coop->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
X
X	if((Q_stricmp(level.mapname, "jail2") == 0)   ||
X	   (Q_stricmp(level.mapname, "jail4") == 0)   ||
X	   (Q_stricmp(level.mapname, "mine1") == 0)   ||
X	   (Q_stricmp(level.mapname, "mine2") == 0)   ||
X	   (Q_stricmp(level.mapname, "mine3") == 0)   ||
X	   (Q_stricmp(level.mapname, "mine4") == 0)   ||
X	   (Q_stricmp(level.mapname, "lab") == 0)     ||
X	   (Q_stricmp(level.mapname, "boss1") == 0)   ||
X	   (Q_stricmp(level.mapname, "fact3") == 0)   ||
X	   (Q_stricmp(level.mapname, "biggun") == 0)  ||
X	   (Q_stricmp(level.mapname, "space") == 0)   ||
X	   (Q_stricmp(level.mapname, "command") == 0) ||
X	   (Q_stricmp(level.mapname, "power2") == 0) ||
X	   (Q_stricmp(level.mapname, "strike") == 0))
X	{
X		// invoke one of our gross, ugly, disgusting hacks
X		self->think = SP_FixCoopSpots;
X		self->nextthink = level.time + FRAMETIME;
X	}
}
X
/*QUAKED info_player_coop_lava (1 0 1) (-16 -16 -24) (16 16 32)
potential spawning position for coop games on rmine2 where lava level
needs to be checked
*/
void SP_info_player_coop_lava(edict_t *self)
{
X	if (!coop->value)
X	{
X		G_FreeEdict (self);
X		return;
X	}
}
X
/*QUAKED info_player_intermission (1 0 1) (-16 -16 -24) (16 16 32)
The deathmatch intermission point will be at one of these
Use 'angles' instead of 'angle', so you can set pitch or roll as well as yaw.  'pitch yaw roll'
*/
void SP_info_player_intermission(void)
{
}
X
X
//=======================================================================
X
X
void player_pain (edict_t *self, edict_t *other, float kick, int damage)
{
X	// player pain is handled at the end of the frame in P_DamageFeedback
}
X
X
qboolean IsFemale (edict_t *ent)
{
X	char		*info;
X
X	if (!ent->client)
X		return false;
X
X	info = Info_ValueForKey (ent->client->pers.userinfo, "gender");
X	if (info[0] == 'f' || info[0] == 'F')
X		return true;
X	return false;
}
X
qboolean IsNeutral (edict_t *ent)
{
X	char		*info;
X
X	if (!ent->client)
X		return false;
X
X	info = Info_ValueForKey (ent->client->pers.userinfo, "gender");
X	if (info[0] != 'f' && info[0] != 'F' && info[0] != 'm' && info[0] != 'M')
X		return true;
X	return false;
}
X
void ClientObituary (edict_t *self, edict_t *inflictor, edict_t *attacker)
{
X	int			mod;
X	char		*message;
X	char		*message2;
X	qboolean	ff;
X
X	if (coop->value && attacker->client)
X		meansOfDeath |= MOD_FRIENDLY_FIRE;
X
X	if (deathmatch->value || coop->value)
X	{
X		ff = meansOfDeath & MOD_FRIENDLY_FIRE;
X		mod = meansOfDeath & ~MOD_FRIENDLY_FIRE;
X		message = NULL;
X		message2 = "";
X
X		switch (mod)
X		{
X			case MOD_SUICIDE:
X				message = "suicides";
X				break;
X			case MOD_FALLING:
X				message = "cratered";
X				break;
X			case MOD_CRUSH:
X				message = "was squished";
X				break;
X			case MOD_WATER:
X				message = "sank like a rock";
X				break;
X			case MOD_SLIME:
X				message = "melted";
X				break;
X			case MOD_LAVA:
X				message = "does a back flip into the lava";
X				break;
X			case MOD_EXPLOSIVE:
X			case MOD_BARREL:
X				message = "blew up";
X				break;
X			case MOD_EXIT:
X				message = "found a way out";
X				break;
X			case MOD_TARGET_LASER:
X				message = "saw the light";
X				break;
X			case MOD_TARGET_BLASTER:
X				message = "got blasted";
X				break;
X			case MOD_BOMB:
X			case MOD_SPLASH:
X			case MOD_TRIGGER_HURT:
X				message = "was in the wrong place";
X				break;
X		}
X		if (attacker == self)
X		{
X			switch (mod)
X			{
X				case MOD_HELD_GRENADE:
X					message = "tried to put the pin back in";
X					break;
X				case MOD_HG_SPLASH:
X				case MOD_G_SPLASH:
X					if (IsNeutral(self))
X						message = "tripped on its own grenade";
X					else if (IsFemale(self))
X						message = "tripped on her own grenade";
X					else
X						message = "tripped on his own grenade";
X					break;
X				case MOD_R_SPLASH:
X					if (IsNeutral(self))
X						message = "blew itself up";
X					else if (IsFemale(self))
X						message = "blew herself up";
X					else
X						message = "blew himself up";
X					break;
X				case MOD_BFG_BLAST:
X					message = "should have used a smaller gun";
X					break;
//ROGUE
X				case MOD_DOPPLE_EXPLODE:
X					if (IsNeutral(self))
X						message = "got caught in it's own trap";
X					else if (IsFemale(self))
X						message = "got caught in her own trap";
X					else
X						message = "got caught in his own trap";
X					break;
//ROGUE
X				default:
X					if (IsNeutral(self))
X						message = "killed itself";
X					else if (IsFemale(self))
X						message = "killed herself";
X					else
X						message = "killed himself";
X					break;
X			}
X		}
X		if (message)
X		{
X			gi.bprintf (PRINT_MEDIUM, "%s %s.\n", self->client->pers.netname, message);
X			if (deathmatch->value)
X				self->client->resp.score--;
X			self->enemy = NULL;
X			return;
X		}
X
X		self->enemy = attacker;
X		if (attacker && attacker->client)
X		{
X			switch (mod)
X			{
X			case MOD_BLASTER:
X				message = "was blasted by";
X				break;
X			case MOD_SHOTGUN:
X				message = "was gunned down by";
X				break;
X			case MOD_SSHOTGUN:
X				message = "was blown away by";
X				message2 = "'s super shotgun";
X				break;
X			case MOD_MACHINEGUN:
X				message = "was machinegunned by";
X				break;
X			case MOD_CHAINGUN:
X				message = "was cut in half by";
X				message2 = "'s chaingun";
X				break;
X			case MOD_GRENADE:
X				message = "was popped by";
X				message2 = "'s grenade";
X				break;
X			case MOD_G_SPLASH:
X				message = "was shredded by";
X				message2 = "'s shrapnel";
X				break;
X			case MOD_ROCKET:
X				message = "ate";
X				message2 = "'s rocket";
X				break;
X			case MOD_R_SPLASH:
X				message = "almost dodged";
X				message2 = "'s rocket";
X				break;
X			case MOD_HYPERBLASTER:
X				message = "was melted by";
X				message2 = "'s hyperblaster";
X				break;
X			case MOD_RAILGUN:
X				message = "was railed by";
X				break;
X			case MOD_BFG_LASER:
X				message = "saw the pretty lights from";
X				message2 = "'s BFG";
X				break;
X			case MOD_BFG_BLAST:
X				message = "was disintegrated by";
X				message2 = "'s BFG blast";
X				break;
X			case MOD_BFG_EFFECT:
X				message = "couldn't hide from";
X				message2 = "'s BFG";
X				break;
X			case MOD_HANDGRENADE:
X				message = "caught";
X				message2 = "'s handgrenade";
X				break;
X			case MOD_HG_SPLASH:
X				message = "didn't see";
X				message2 = "'s handgrenade";
X				break;
X			case MOD_HELD_GRENADE:
X				message = "feels";
X				message2 = "'s pain";
X				break;
X			case MOD_TELEFRAG:
X				message = "tried to invade";
X				message2 = "'s personal space";
X				break;
X
//===============
//ROGUE
X			case MOD_CHAINFIST:
X				message = "was shredded by";
X				message2 = "'s ripsaw";
X				break;
X			case MOD_DISINTEGRATOR:
X				message = "lost his grip courtesy of";
X				message2 = "'s disintegrator";
X				break;
X			case MOD_ETF_RIFLE:
X				message = "was perforated by";
X				break;
X			case MOD_HEATBEAM:
X				message = "was scorched by";
X				message2 = "'s plasma beam";
X				break;
X			case MOD_TESLA:
X				message = "was enlightened by";
X				message2 = "'s tesla mine";
X				break;
X			case MOD_PROX:
X				message = "got too close to";
X				message2 = "'s proximity mine";
X				break;
X			case MOD_NUKE:
X				message = "was nuked by";
X				message2 = "'s antimatter bomb";
X				break;
X			case MOD_VENGEANCE_SPHERE:
X				message = "was purged by";
X				message2 = "'s vengeance sphere";
X				break;
X			case MOD_DEFENDER_SPHERE:
X				message = "had a blast with";
X				message2 = "'s defender sphere";
X				break;
X			case MOD_HUNTER_SPHERE:
X				message = "was killed like a dog by";
X				message2 = "'s hunter sphere";
X				break;
X			case MOD_TRACKER:
X				message = "was annihilated by";
X				message2 = "'s disruptor";
X				break;
X			case MOD_DOPPLE_EXPLODE:
X				message = "was blown up by";
X				message2 = "'s doppleganger";
X				break;
X			case MOD_DOPPLE_VENGEANCE:
X				message = "was purged by";
X				message2 = "'s doppleganger";
X				break;
X			case MOD_DOPPLE_HUNTER:
X				message = "was hunted down by";
X				message2 = "'s doppleganger";
X				break;
//ROGUE
//===============
X			}
X			if (message)
X			{
X				gi.bprintf (PRINT_MEDIUM,"%s %s %s%s\n", self->client->pers.netname, message, attacker->client->pers.netname, message2);
//ROGUE
X				if (gamerules && gamerules->value)
X				{
X					if(DMGame.Score)
X					{
X						if(ff)		
X							DMGame.Score(attacker, self, -1);
X						else
X							DMGame.Score(attacker, self, 1);
X					}
X					return;
X				}
//ROGUE
X
X				if (deathmatch->value)
X				{
X					if (ff)
X						attacker->client->resp.score--;
X					else
X						attacker->client->resp.score++;
X				}
X				return;
X			}
X		}
X	}
X
X	gi.bprintf (PRINT_MEDIUM,"%s died.\n", self->client->pers.netname);
X
//ROGUE
//	if (g_showlogic && g_showlogic->value)
//	{
//		if (mod == MOD_UNKNOWN)
//			gi.dprintf ("Player killed by MOD_UNKNOWN\n");
//		else
//			gi.dprintf ("Player killed by undefined mod %d\n", mod);
//	}
//ROGUE
X
X	if (deathmatch->value)
//ROGUE
X	{
X		if (gamerules && gamerules->value)
X		{
X			if(DMGame.Score)
X			{
X				DMGame.Score(self, self, -1);
X			}
X			return;
X		}
X		else
X			self->client->resp.score--;
X	}
//ROGUE
X
}
X
X
void Touch_Item (edict_t *ent, edict_t *other, cplane_t *plane, csurface_t *surf);
X
void TossClientWeapon (edict_t *self)
{
X	gitem_t		*item;
X	edict_t		*drop;
X	qboolean	quad;
X	float		spread;
X
X	if (!deathmatch->value)
X		return;
X
X	item = self->client->pers.weapon;
X	if (! self->client->pers.inventory[self->client->ammo_index] )
X		item = NULL;
X	if (item && (strcmp (item->pickup_name, "Blaster") == 0))
X		item = NULL;
X
X	if (!((int)(dmflags->value) & DF_QUAD_DROP))
X		quad = false;
X	else
X		quad = (self->client->quad_framenum > (level.framenum + 10));
X
X	if (item && quad)
X		spread = 22.5;
X	else
X		spread = 0.0;
X
X	if (item)
X	{
X		self->client->v_angle[YAW] -= spread;
X		drop = Drop_Item (self, item);
X		self->client->v_angle[YAW] += spread;
X		drop->spawnflags = DROPPED_PLAYER_ITEM;
X	}
X
X	if (quad)
X	{
X		self->client->v_angle[YAW] += spread;
X		drop = Drop_Item (self, FindItemByClassname ("item_quad"));
X		self->client->v_angle[YAW] -= spread;
X		drop->spawnflags |= DROPPED_PLAYER_ITEM;
X
X		drop->touch = Touch_Item;
X		drop->nextthink = level.time + (self->client->quad_framenum - level.framenum) * FRAMETIME;
X		drop->think = G_FreeEdict;
X	}
}
X
X
/*
==================
LookAtKiller
==================
*/
void LookAtKiller (edict_t *self, edict_t *inflictor, edict_t *attacker)
{
X	vec3_t		dir;
X
X	if (attacker && attacker != world && attacker != self)
X	{
X		VectorSubtract (attacker->s.origin, self->s.origin, dir);
X	}
X	else if (inflictor && inflictor != world && inflictor != self)
X	{
X		VectorSubtract (inflictor->s.origin, self->s.origin, dir);
X	}
X	else
X	{
X		self->client->killer_yaw = self->s.angles[YAW];
X		return;
X	}
X	// PMM - fixed to correct for pitch of 0
X	if (dir[0])
X		self->client->killer_yaw = 180/M_PI*atan2(dir[1], dir[0]);
X	else if (dir[1] > 0)
X		self->client->killer_yaw = 90;
X	else if (dir[1] < 0)
X		self->client->killer_yaw = 270;
X	else
X		self->client->killer_yaw = 0;
}
X
/*
==================
player_die
==================
*/
void player_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int		n;
X
X	VectorClear (self->avelocity);
X
X	self->takedamage = DAMAGE_YES;
X	self->movetype = MOVETYPE_TOSS;
X
X	self->s.modelindex2 = 0;	// remove linked weapon model
X
X	self->s.angles[0] = 0;
X	self->s.angles[2] = 0;
X
X	self->s.sound = 0;
X	self->client->weapon_sound = 0;
X
X	self->maxs[2] = -8;
X
//	self->solid = SOLID_NOT;
X	self->svflags |= SVF_DEADMONSTER;
X
X	if (!self->deadflag)
X	{
X		self->client->respawn_time = level.time + 1.0;
X		LookAtKiller (self, inflictor, attacker);
X		self->client->ps.pmove.pm_type = PM_DEAD;
X		ClientObituary (self, inflictor, attacker);
X		TossClientWeapon (self);
X		if (deathmatch->value)
X			Cmd_Help_f (self);		// show scores
X
X		// clear inventory
X		// this is kind of ugly, but it's how we want to handle keys in coop
X		for (n = 0; n < game.num_items; n++)
X		{
X			if (coop->value && itemlist[n].flags & IT_KEY)
X				self->client->resp.coop_respawn.inventory[n] = self->client->pers.inventory[n];
X			self->client->pers.inventory[n] = 0;
X		}
X	}
X
X	if(gamerules && gamerules->value)	// if we're in a dm game, alert the game
X	{
X		if(DMGame.PlayerDeath)
X			DMGame.PlayerDeath(self, inflictor, attacker);
X	}
X
X	// remove powerups
X	self->client->quad_framenum = 0;
X	self->client->invincible_framenum = 0;
X	self->client->breather_framenum = 0;
X	self->client->enviro_framenum = 0;
X	self->flags &= ~FL_POWER_ARMOR;
X
//==============
// ROGUE stuff
X	self->client->double_framenum = 0;
X
X	// if there's a sphere around, let it know the player died.
X	// vengeance and hunter will die if they're not attacking,
X	// defender should always die
X	if(self->client->owned_sphere)
X	{
X		edict_t *sphere;
X
X		sphere = self->client->owned_sphere;
X		sphere->die(sphere, self, self, 0, vec3_origin);
X	}
X
X	// if we've been killed by the tracker, GIB!
X	if((meansOfDeath & ~MOD_FRIENDLY_FIRE) == MOD_TRACKER)
X	{
X		self->health = -100;
X		damage = 400;
X	}
X
X	// make sure no trackers are still hurting us.
X	if(self->client->tracker_pain_framenum)
X	{
X		RemoveAttackingPainDaemons (self);
X	}
X	
X	// if we got obliterated by the nuke, don't gib
X	if ((self->health < -80) && (meansOfDeath == MOD_NUKE))
X		self->flags |= FL_NOGIB;
X
// ROGUE
//==============
X
X	if (self->health < -40)
X	{
X		// PMM
X		// don't toss gibs if we got vaped by the nuke
X		if (!(self->flags & FL_NOGIB))
X		{
X		// pmm
X			// gib
X			gi.sound (self, CHAN_BODY, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X			
X			// more meaty gibs for your dollar!
X			if((deathmatch->value) && (self->health < -80))
X			{
X				for (n= 0; n < 4; n++)
X					ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X			}
X
X			for (n= 0; n < 4; n++)
X				ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		// PMM	
X		}
X		self->flags &= ~FL_NOGIB;
X		// pmm
X
X		ThrowClientHead (self, damage);
X
X		self->takedamage = DAMAGE_NO;
X	}
X	else
X	{	// normal death
X		if (!self->deadflag)
X		{
X			static int i;
X
X			i = (i+1)%3;
X			// start a death animation
X			self->client->anim_priority = ANIM_DEATH;
X			if (self->client->ps.pmove.pm_flags & PMF_DUCKED)
X			{
X				self->s.frame = FRAME_crdeath1-1;
X				self->client->anim_end = FRAME_crdeath5;
X			}
X			else switch (i)
X			{
X			case 0:
X				self->s.frame = FRAME_death101-1;
X				self->client->anim_end = FRAME_death106;
X				break;
X			case 1:
X				self->s.frame = FRAME_death201-1;
X				self->client->anim_end = FRAME_death206;
X				break;
X			case 2:
X				self->s.frame = FRAME_death301-1;
X				self->client->anim_end = FRAME_death308;
X				break;
X			}
X			gi.sound (self, CHAN_VOICE, gi.soundindex(va("*death%i.wav", (rand()%4)+1)), 1, ATTN_NORM, 0);
X		}
X	}
X
X	self->deadflag = DEAD_DEAD;
X
X	gi.linkentity (self);
}
X
//=======================================================================
X
/*
==============
InitClientPersistant
X
This is only called when the game first initializes in single player,
but is called after each death and level change in deathmatch
==============
*/
void InitClientPersistant (gclient_t *client)
{
X	gitem_t		*item;
X
X	memset (&client->pers, 0, sizeof(client->pers));
X
X	item = FindItem("Blaster");
X	client->pers.selected_item = ITEM_INDEX(item);
X	client->pers.inventory[client->pers.selected_item] = 1;
X
X	client->pers.weapon = item;
X
X	client->pers.health			= 100;
X	client->pers.max_health		= 100;
X
X	client->pers.max_bullets	= 200;
X	client->pers.max_shells		= 100;
X	client->pers.max_rockets	= 50;
X	client->pers.max_grenades	= 50;
X	client->pers.max_cells		= 200;
X	client->pers.max_slugs		= 50;
X
//ROGUE
X	// FIXME - give these real numbers....
X	client->pers.max_prox		= 50;
X	client->pers.max_tesla		= 50;
X	client->pers.max_flechettes = 200;
#ifndef KILL_DISRUPTOR
X	client->pers.max_rounds     = 100;
#endif
//ROGUE
X
X	client->pers.connected = true;
}
X
X
void InitClientResp (gclient_t *client)
{
X	memset (&client->resp, 0, sizeof(client->resp));
X	client->resp.enterframe = level.framenum;
X	client->resp.coop_respawn = client->pers;
}
X
/*
==================
SaveClientData
X
Some information that should be persistant, like health, 
is still stored in the edict structure, so it needs to
be mirrored out to the client structure before all the
edicts are wiped.
==================
*/
void SaveClientData (void)
{
X	int		i;
X	edict_t	*ent;
X
X	for (i=0 ; i<game.maxclients ; i++)
X	{
X		ent = &g_edicts[1+i];
X		if (!ent->inuse)
X			continue;
X		game.clients[i].pers.health = ent->health;
X		game.clients[i].pers.max_health = ent->max_health;
X		game.clients[i].pers.savedFlags = (ent->flags & (FL_GODMODE|FL_NOTARGET|FL_POWER_ARMOR));
X		if (coop->value)
X			game.clients[i].pers.score = ent->client->resp.score;
X	}
}
X
void FetchClientEntData (edict_t *ent)
{
X	ent->health = ent->client->pers.health;
X	ent->max_health = ent->client->pers.max_health;
X	ent->flags |= ent->client->pers.savedFlags;
X	if (coop->value)
X		ent->client->resp.score = ent->client->pers.score;
}
X
X
X
/*
=======================================================================
X
X  SelectSpawnPoint
X
=======================================================================
*/
X
/*
================
PlayersRangeFromSpot
X
Returns the distance to the nearest player from the given spot
================
*/
float	PlayersRangeFromSpot (edict_t *spot)
{
X	edict_t	*player;
X	float	bestplayerdistance;
X	vec3_t	v;
X	int		n;
X	float	playerdistance;
X
X
X	bestplayerdistance = 9999999;
X
X	for (n = 1; n <= maxclients->value; n++)
X	{
X		player = &g_edicts[n];
X
X		if (!player->inuse)
X			continue;
X
X		if (player->health <= 0)
X			continue;
X
X		VectorSubtract (spot->s.origin, player->s.origin, v);
X		playerdistance = VectorLength (v);
X
X		if (playerdistance < bestplayerdistance)
X			bestplayerdistance = playerdistance;
X	}
X
X	return bestplayerdistance;
}
X
/*
================
SelectRandomDeathmatchSpawnPoint
X
go to a random point, but NOT the two points closest
to other players
================
*/
edict_t *SelectRandomDeathmatchSpawnPoint (void)
{
X	edict_t	*spot, *spot1, *spot2;
X	int		count = 0;
X	int		selection;
X	float	range, range1, range2;
X
X	spot = NULL;
X	range1 = range2 = 99999;
X	spot1 = spot2 = NULL;
X
X	while ((spot = G_Find (spot, FOFS(classname), "info_player_deathmatch")) != NULL)
X	{
X		count++;
X		range = PlayersRangeFromSpot(spot);
X		if (range < range1)
X		{
X			range1 = range;
X			spot1 = spot;
X		}
X		else if (range < range2)
X		{
X			range2 = range;
X			spot2 = spot;
X		}
X	}
X
X	if (!count)
X		return NULL;
X
X	if (count <= 2)
X	{
X		spot1 = spot2 = NULL;
X	}
X	else
X		count -= 2;
X
X	selection = rand() % count;
X
X	spot = NULL;
X	do
X	{
X		spot = G_Find (spot, FOFS(classname), "info_player_deathmatch");
X		if (spot == spot1 || spot == spot2)
X			selection++;
X	} while(selection--);
X
X	return spot;
}
X
/*
================
SelectFarthestDeathmatchSpawnPoint
X
================
*/
edict_t *SelectFarthestDeathmatchSpawnPoint (void)
{
X	edict_t	*bestspot;
X	float	bestdistance, bestplayerdistance;
X	edict_t	*spot;
X
X
X	spot = NULL;
X	bestspot = NULL;
X	bestdistance = 0;
X	while ((spot = G_Find (spot, FOFS(classname), "info_player_deathmatch")) != NULL)
X	{
X		bestplayerdistance = PlayersRangeFromSpot (spot);
X
X		if (bestplayerdistance > bestdistance)
X		{
X			bestspot = spot;
X			bestdistance = bestplayerdistance;
X		}
X	}
X
X	if (bestspot)
X	{
X		return bestspot;
X	}
X
X	// if there is a player just spawned on each and every start spot
X	// we have no choice to turn one into a telefrag meltdown
X	spot = G_Find (NULL, FOFS(classname), "info_player_deathmatch");
X
X	return spot;
}
X
edict_t *SelectDeathmatchSpawnPoint (void)
{
X	if ( (int)(dmflags->value) & DF_SPAWN_FARTHEST)
X		return SelectFarthestDeathmatchSpawnPoint ();
X	else
X		return SelectRandomDeathmatchSpawnPoint ();
}
X
//===============
//ROGUE
edict_t *SelectLavaCoopSpawnPoint (edict_t *ent)
{
X	int		index;
X	edict_t	*spot = NULL;
X	float	lavatop;
X	edict_t	*lava;
X	edict_t *pointWithLeastLava;
X	float	lowest;
X	edict_t *spawnPoints [64];
X	vec3_t	center;
X	int		numPoints;
X	edict_t *highestlava;
X
X	lavatop = -99999;
X	highestlava = NULL;
X
X	// first, find the highest lava
X	// remember that some will stop moving when they've filled their
X	// areas...
X	lava = NULL;
X	while (1)
X	{
X		lava = G_Find (lava, FOFS(classname), "func_door");
X		if(!lava)
X			break;
X		
X		VectorAdd (lava->absmax, lava->absmin, center);
X		VectorScale (center, 0.5, center);
X
X		if(lava->spawnflags & 2 && (gi.pointcontents(center) & MASK_WATER))
X		{
X			if (lava->absmax[2] > lavatop)
X			{
X				lavatop = lava->absmax[2];
X				highestlava = lava;
X			}
X		}
X	}
X
X	// if we didn't find ANY lava, then return NULL
X	if (!highestlava)
X		return NULL;
X
X	// find the top of the lava and include a small margin of error (plus bbox size)
X	lavatop = highestlava->absmax[2] + 64;
X
X	// find all the lava spawn points and store them in spawnPoints[]
X	spot = NULL;
X	numPoints = 0;
X	while(spot = G_Find (spot, FOFS(classname), "info_player_coop_lava"))
X	{
X		if(numPoints == 64)
X			break;
X
X		spawnPoints[numPoints++] = spot;
X	}
X
X	if(numPoints < 1)
X		return NULL;
X
X	// walk up the sorted list and return the lowest, open, non-lava spawn point
X	spot = NULL;
X	lowest = 999999;
X	pointWithLeastLava = NULL;
X	for (index = 0; index < numPoints; index++)
X	{
X		if(spawnPoints[index]->s.origin[2] < lavatop)
X			continue;
X
X		if(PlayersRangeFromSpot(spawnPoints[index]) > 32)
X		{
X			if(spawnPoints[index]->s.origin[2] < lowest)
X			{
X				// save the last point
X				pointWithLeastLava = spawnPoints[index];
X				lowest = spawnPoints[index]->s.origin[2];
X			}
X		}
X	}
X
X	// FIXME - better solution????
X	// well, we may telefrag someone, but oh well...
X	if(pointWithLeastLava)
X		return pointWithLeastLava;
X
X	return NULL;
}
//ROGUE
//===============
X
edict_t *SelectCoopSpawnPoint (edict_t *ent)
{
X	int		index;
X	edict_t	*spot = NULL;
X	char	*target;
X
//ROGUE
X	// rogue hack, but not too gross...
X	if (!Q_stricmp(level.mapname, "rmine2p") || !Q_stricmp(level.mapname, "rmine2"))
X		return SelectLavaCoopSpawnPoint (ent);
//ROGUE
X
X	index = ent->client - game.clients;
X
X	// player 0 starts in normal player spawn point
X	if (!index)
X		return NULL;
X
X	spot = NULL;
X
X	// assume there are four coop spots at each spawnpoint
X	while (1)
X	{
X		spot = G_Find (spot, FOFS(classname), "info_player_coop");
X		if (!spot)
X			return NULL;	// we didn't have enough...
X
X		target = spot->targetname;
X		if (!target)
X			target = "";
X		if ( Q_stricmp(game.spawnpoint, target) == 0 )
X		{	// this is a coop spawn point for one of the clients here
X			index--;
X			if (!index)
X				return spot;		// this is it
X		}
X	}
X
X
X	return spot;
}
X
X
/*
===========
SelectSpawnPoint
X
Chooses a player start, deathmatch start, coop start, etc
============
*/
void	SelectSpawnPoint (edict_t *ent, vec3_t origin, vec3_t angles)
{
X	edict_t	*spot = NULL;
X
X	if (deathmatch->value)
X		spot = SelectDeathmatchSpawnPoint ();
X	else if (coop->value)
X		spot = SelectCoopSpawnPoint (ent);
X
X	// find a single player start spot
X	if (!spot)
X	{
X		while ((spot = G_Find (spot, FOFS(classname), "info_player_start")) != NULL)
X		{
X			if (!game.spawnpoint[0] && !spot->targetname)
X				break;
X
X			if (!game.spawnpoint[0] || !spot->targetname)
X				continue;
X
X			if (Q_stricmp(game.spawnpoint, spot->targetname) == 0)
X				break;
X		}
X
X		if (!spot)
X		{
X			if (!game.spawnpoint[0])
X			{	// there wasn't a spawnpoint without a target, so use any
X				spot = G_Find (spot, FOFS(classname), "info_player_start");
X			}
X			if (!spot)
X				gi.error ("Couldn't find spawn point %s\n", game.spawnpoint);
X		}
X	}
X
X	VectorCopy (spot->s.origin, origin);
X	origin[2] += 9;
X	VectorCopy (spot->s.angles, angles);
}
X
//======================================================================
X
X
void InitBodyQue (void)
{
X	int		i;
X	edict_t	*ent;
X
X	level.body_que = 0;
X	for (i=0; i<BODY_QUEUE_SIZE ; i++)
X	{
X		ent = G_Spawn();
X		ent->classname = "bodyque";
X	}
}
X
void body_die (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
X	int	n;
X
X	if (self->health < -40)
X	{
X		gi.sound (self, CHAN_BODY, gi.soundindex ("misc/udeath.wav"), 1, ATTN_NORM, 0);
X		for (n= 0; n < 4; n++)
X			ThrowGib (self, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
X		self->s.origin[2] -= 48;
X		ThrowClientHead (self, damage);
X		self->takedamage = DAMAGE_NO;
X	}
}
X
void CopyToBodyQue (edict_t *ent)
{
X	edict_t		*body;
X
X	// grab a body que and cycle to the next one
X	body = &g_edicts[(int)maxclients->value + level.body_que + 1];
X	level.body_que = (level.body_que + 1) % BODY_QUEUE_SIZE;
X
X	// FIXME: send an effect on the removed body
X
X	gi.unlinkentity (ent);
X
X	gi.unlinkentity (body);
X	body->s = ent->s;
X	body->s.number = body - g_edicts;
X
X	body->svflags = ent->svflags;
X	VectorCopy (ent->mins, body->mins);
X	VectorCopy (ent->maxs, body->maxs);
X	VectorCopy (ent->absmin, body->absmin);
X	VectorCopy (ent->absmax, body->absmax);
X	VectorCopy (ent->size, body->size);
X	body->solid = ent->solid;
X	body->clipmask = ent->clipmask;
X	body->owner = ent->owner;
X	body->movetype = ent->movetype;
X
X	body->die = body_die;
X	body->takedamage = DAMAGE_YES;
X
X	gi.linkentity (body);
}
X
X
void respawn (edict_t *self)
{
X	if (deathmatch->value || coop->value)
X	{
X		// spectators don't leave bodies
X		if (self->movetype != MOVETYPE_NOCLIP)
X			CopyToBodyQue (self);
X		self->svflags &= ~SVF_NOCLIENT;
X		PutClientInServer (self);
X
X		// add a teleportation effect
X		self->s.event = EV_PLAYER_TELEPORT;
X
X		// hold in place briefly
X		self->client->ps.pmove.pm_flags = PMF_TIME_TELEPORT;
X		self->client->ps.pmove.pm_time = 14;
X
X		self->client->respawn_time = level.time;
X
X		return;
X	}
X
X	// restart the entire server
X	gi.AddCommandString ("menu_loadgame\n");
}
X
/* 
X * only called when pers.spectator changes
X * note that resp.spectator should be the opposite of pers.spectator here
X */
void spectator_respawn (edict_t *ent)
{
X	int i, numspec;
X
X	// if the user wants to become a spectator, make sure he doesn't
X	// exceed max_spectators
X
X	if (ent->client->pers.spectator)
X	{
X		char *value = Info_ValueForKey (ent->client->pers.userinfo, "spectator");
X		if (*spectator_password->string && 
X			strcmp(spectator_password->string, "none") && 
X			strcmp(spectator_password->string, value))
X		{
X			gi.cprintf(ent, PRINT_HIGH, "Spectator password incorrect.\n");
X			ent->client->pers.spectator = false;
X			gi.WriteByte (svc_stufftext);
X			gi.WriteString ("spectator 0\n");
X			gi.unicast(ent, true);
X			return;
X		}
X
X		// count spectators
X		for (i = 1, numspec = 0; i <= maxclients->value; i++)
X		{
X			if (g_edicts[i].inuse && g_edicts[i].client->pers.spectator)
X				numspec++;
X		}
X
X		if (numspec >= maxspectators->value)
X		{
X			gi.cprintf(ent, PRINT_HIGH, "Server spectator limit is full.");
X			ent->client->pers.spectator = false;
X			// reset his spectator var
X			gi.WriteByte (svc_stufftext);
X			gi.WriteString ("spectator 0\n");
X			gi.unicast(ent, true);
X			return;
X		}
X	}
X	else
X	{
X		// he was a spectator and wants to join the game
X		// he must have the right password
X		char *value = Info_ValueForKey (ent->client->pers.userinfo, "password");
X		if (*password->string && strcmp(password->string, "none") && 
X			strcmp(password->string, value))
X		{
X			gi.cprintf(ent, PRINT_HIGH, "Password incorrect.\n");
X			ent->client->pers.spectator = true;
X			gi.WriteByte (svc_stufftext);
X			gi.WriteString ("spectator 1\n");
X			gi.unicast(ent, true);
X			return;
X		}
X	}
X
X	// clear score on respawn
X	ent->client->pers.score = ent->client->resp.score = 0;
X
X	ent->svflags &= ~SVF_NOCLIENT;
X	PutClientInServer (ent);
X
X	// add a teleportation effect
X	if (!ent->client->pers.spectator)
X	{
X		// send effect
X		gi.WriteByte (svc_muzzleflash);
X		gi.WriteShort (ent-g_edicts);
X		gi.WriteByte (MZ_LOGIN);
X		gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X		// hold in place briefly
X		ent->client->ps.pmove.pm_flags = PMF_TIME_TELEPORT;
X		ent->client->ps.pmove.pm_time = 14;
X	}
X
X	ent->client->respawn_time = level.time;
X
X	if (ent->client->pers.spectator) 
X		gi.bprintf (PRINT_HIGH, "%s has moved to the sidelines\n", ent->client->pers.netname);
X	else
X		gi.bprintf (PRINT_HIGH, "%s joined the game\n", ent->client->pers.netname);
}
X
//==============================================================
X
X
/*
===========
PutClientInServer
X
Called when a player connects to a server or respawns in
a deathmatch.
============
*/
void PutClientInServer (edict_t *ent)
{
X	vec3_t	mins = {-16, -16, -24};
X	vec3_t	maxs = {16, 16, 32};
X	int		index;
X	vec3_t	spawn_origin, spawn_angles;
X	gclient_t	*client;
X	int		i;
X	client_persistant_t	saved;
X	client_respawn_t	resp;
X
X	// find a spawn point
X	// do it before setting health back up, so farthest
X	// ranging doesn't count this client
X	if(gamerules && gamerules->value && DMGame.SelectSpawnPoint)		// PGM
X		DMGame.SelectSpawnPoint (ent, spawn_origin, spawn_angles);		// PGM
X	else																// PGM
X		SelectSpawnPoint (ent, spawn_origin, spawn_angles);
X
X	index = ent-g_edicts-1;
X	client = ent->client;
X
X	// deathmatch wipes most client data every spawn
X	if (deathmatch->value)
X	{
X		char		userinfo[MAX_INFO_STRING];
X
X		resp = client->resp;
X		memcpy (userinfo, client->pers.userinfo, sizeof(userinfo));
X		InitClientPersistant (client);
X		ClientUserinfoChanged (ent, userinfo);
X	}
X	else if (coop->value)
X	{
//		int			n;
X		char		userinfo[MAX_INFO_STRING];
X
X		resp = client->resp;
X		memcpy (userinfo, client->pers.userinfo, sizeof(userinfo));
X		// this is kind of ugly, but it's how we want to handle keys in coop
//		for (n = 0; n < game.num_items; n++)
//		{
//			if (itemlist[n].flags & IT_KEY)
//				resp.coop_respawn.inventory[n] = client->pers.inventory[n];
//		}
X		resp.coop_respawn.game_helpchanged = client->pers.game_helpchanged;
X		resp.coop_respawn.helpchanged = client->pers.helpchanged;
X		client->pers = resp.coop_respawn;
X		ClientUserinfoChanged (ent, userinfo);
X		if (resp.score > client->pers.score)
X			client->pers.score = resp.score;
X	}
X	else
X	{
X		memset (&resp, 0, sizeof(resp));
X	}
X
X	// clear everything but the persistant data
X	saved = client->pers;
X	memset (client, 0, sizeof(*client));
X	client->pers = saved;
X	if (client->pers.health <= 0)
X		InitClientPersistant(client);
X	client->resp = resp;
X
X	// copy some data from the client to the entity
X	FetchClientEntData (ent);
X
X	// clear entity values
X	ent->groundentity = NULL;
X	ent->client = &game.clients[index];
X	ent->takedamage = DAMAGE_AIM;
X	ent->movetype = MOVETYPE_WALK;
X	ent->viewheight = 22;
X	ent->inuse = true;
X	ent->classname = "player";
X	ent->mass = 200;
X	ent->solid = SOLID_BBOX;
X	ent->deadflag = DEAD_NO;
X	ent->air_finished = level.time + 12;
X	ent->clipmask = MASK_PLAYERSOLID;
X	ent->model = "players/male/tris.md2";
X	ent->pain = player_pain;
X	ent->die = player_die;
X	ent->waterlevel = 0;
X	ent->watertype = 0;
X	ent->flags &= ~FL_NO_KNOCKBACK;
X	ent->svflags &= ~SVF_DEADMONSTER;
X
X	ent->flags &= ~FL_SAM_RAIMI;		// PGM - turn off sam raimi flag
X
X	VectorCopy (mins, ent->mins);
X	VectorCopy (maxs, ent->maxs);
X	VectorClear (ent->velocity);
X
X	// clear playerstate values
X	memset (&ent->client->ps, 0, sizeof(client->ps));
X
X	client->ps.pmove.origin[0] = spawn_origin[0]*8;
X	client->ps.pmove.origin[1] = spawn_origin[1]*8;
X	client->ps.pmove.origin[2] = spawn_origin[2]*8;
X
X	if (deathmatch->value && ((int)dmflags->value & DF_FIXED_FOV))
X	{
X		client->ps.fov = 90;
X	}
X	else
X	{
X		client->ps.fov = atoi(Info_ValueForKey(client->pers.userinfo, "fov"));
X		if (client->ps.fov < 1)
X			client->ps.fov = 90;
X		else if (client->ps.fov > 160)
X			client->ps.fov = 160;
X	}
X
//PGM
X	if (client->pers.weapon)
X		client->ps.gunindex = gi.modelindex(client->pers.weapon->view_model);
X	else 
X		client->ps.gunindex = 0;
//PGM
X
X	// clear entity state values
X	ent->s.effects = 0;
X	ent->s.modelindex = 255;		// will use the skin specified model
X	ent->s.modelindex2 = 255;		// custom gun model
X	// sknum is player num and weapon number
X	// weapon number will be added in changeweapon
X	ent->s.skinnum = ent - g_edicts - 1;
X
X	ent->s.frame = 0;
X	VectorCopy (spawn_origin, ent->s.origin);
X	ent->s.origin[2] += 1;	// make sure off ground
X	VectorCopy (ent->s.origin, ent->s.old_origin);
X
X	// set the delta angle
X	for (i=0 ; i<3 ; i++)
X		client->ps.pmove.delta_angles[i] = ANGLE2SHORT(spawn_angles[i] - client->resp.cmd_angles[i]);
X
X	ent->s.angles[PITCH] = 0;
X	ent->s.angles[YAW] = spawn_angles[YAW];
X	ent->s.angles[ROLL] = 0;
X	VectorCopy (ent->s.angles, client->ps.viewangles);
X	VectorCopy (ent->s.angles, client->v_angle);
X
X	// spawn a spectator
X	if (client->pers.spectator)
X	{
X		client->chase_target = NULL;
X
X		client->resp.spectator = true;
X
X		ent->movetype = MOVETYPE_NOCLIP;
X		ent->solid = SOLID_NOT;
X		ent->svflags |= SVF_NOCLIENT;
X		ent->client->ps.gunindex = 0;
X		gi.linkentity (ent);
X		return;
X	}
X	else
X		client->resp.spectator = false;
X
X	if (!KillBox (ent))
X	{	// could't spawn in?
X	}
X
X	gi.linkentity (ent);
X
X	// my tribute to cash's level-specific hacks. I hope I live
X	// up to his trailblazing cheese.
X	if(Q_stricmp(level.mapname, "rboss") == 0)
X	{
X		// if you get on to rboss in single player or coop, ensure
X		// the player has the nuke key. (not in DM)
X		if(!(deathmatch->value))
X		{
X			gitem_t		*item;
X
X			item = FindItem("Antimatter Bomb");
X			client->pers.selected_item = ITEM_INDEX(item);
X			client->pers.inventory[client->pers.selected_item] = 1;
X		}
X	}
X
X	// force the current weapon up
X	client->newweapon = client->pers.weapon;
X	ChangeWeapon (ent);
}
X
/*
=====================
ClientBeginDeathmatch
X
A client has just connected to the server in 
deathmatch mode, so clear everything out before starting them.
=====================
*/
void ClientBeginDeathmatch (edict_t *ent)
{
X	G_InitEdict (ent);
X
X	InitClientResp (ent->client);
X
X	//PGM
X	if(gamerules && gamerules->value && DMGame.ClientBegin)	
X	{
X		DMGame.ClientBegin (ent);
X	}
X	//PGM
X
X		// locate ent at a spawn point
X	PutClientInServer (ent);
X
X	if (level.intermissiontime)
X	{
X		MoveClientToIntermission (ent);
X	}
X	else
X	{
X		// send effect
X		gi.WriteByte (svc_muzzleflash);
X		gi.WriteShort (ent-g_edicts);
X		gi.WriteByte (MZ_LOGIN);
X		gi.multicast (ent->s.origin, MULTICAST_PVS);
X	}
X
X	gi.bprintf (PRINT_HIGH, "%s entered the game\n", ent->client->pers.netname);
X
X	// make sure all view stuff is valid
X	ClientEndServerFrame (ent);
}
X
X
/*
===========
ClientBegin
X
called when a client has finished connecting, and is ready
to be placed into the game.  This will happen every level load.
============
*/
void ClientBegin (edict_t *ent)
{
X	int		i;
X
X	ent->client = game.clients + (ent - g_edicts - 1);
X
X	if (deathmatch->value)
X	{
X		ClientBeginDeathmatch (ent);
X		return;
X	}
X
X	// if there is already a body waiting for us (a loadgame), just
X	// take it, otherwise spawn one from scratch
X	if (ent->inuse == true)
X	{
X		// the client has cleared the client side viewangles upon
X		// connecting to the server, which is different than the
X		// state when the game is saved, so we need to compensate
X		// with deltaangles
X		for (i=0 ; i<3 ; i++)
X			ent->client->ps.pmove.delta_angles[i] = ANGLE2SHORT(ent->client->ps.viewangles[i]);
X	}
X	else
X	{
X		// a spawn point will completely reinitialize the entity
X		// except for the persistant data that was initialized at
X		// ClientConnect() time
X		G_InitEdict (ent);
X		ent->classname = "player";
X		InitClientResp (ent->client);
X		PutClientInServer (ent);
X	}
X
X	if (level.intermissiontime)
X	{
X		MoveClientToIntermission (ent);
X	}
X	else
X	{
X		// send effect if in a multiplayer game
X		if (game.maxclients > 1)
X		{
X			gi.WriteByte (svc_muzzleflash);
X			gi.WriteShort (ent-g_edicts);
X			gi.WriteByte (MZ_LOGIN);
X			gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X			gi.bprintf (PRINT_HIGH, "%s entered the game\n", ent->client->pers.netname);
X		}
X	}
X
X	// make sure all view stuff is valid
X	ClientEndServerFrame (ent);
}
X
/*
===========
ClientUserInfoChanged
X
called whenever the player updates a userinfo variable.
X
The game can override any of the settings in place
(forcing skins or names, etc) before copying it off.
============
*/
void ClientUserinfoChanged (edict_t *ent, char *userinfo)
{
X	char	*s;
X	int		playernum;
X
X	// check for malformed or illegal info strings
X	if (!Info_Validate(userinfo))
X	{
X		strcpy (userinfo, "\\name\\badinfo\\skin\\male/grunt");
X	}
X
X	// set name
X	s = Info_ValueForKey (userinfo, "name");
X	strncpy (ent->client->pers.netname, s, sizeof(ent->client->pers.netname)-1);
X
X	// set spectator
X	s = Info_ValueForKey (userinfo, "spectator");
X	// spectators are only supported in deathmatch
X	// if (deathmatch->value && strcmp(s, "0"))
X	if (deathmatch->value && *s && strcmp(s, "0"))
X		ent->client->pers.spectator = true;
X	else
X		ent->client->pers.spectator = false;
X
X	// set skin
X	s = Info_ValueForKey (userinfo, "skin");
X
X	playernum = ent-g_edicts-1;
X
X	// combine name and skin into a configstring
X	gi.configstring (CS_PLAYERSKINS+playernum, va("%s\\%s", ent->client->pers.netname, s) );
X
X	// fov
X	if (deathmatch->value && ((int)dmflags->value & DF_FIXED_FOV))
X	{
X		ent->client->ps.fov = 90;
X	}
X	else
X	{
X		ent->client->ps.fov = atoi(Info_ValueForKey(userinfo, "fov"));
X		if (ent->client->ps.fov < 1)
X			ent->client->ps.fov = 90;
X		else if (ent->client->ps.fov > 160)
X			ent->client->ps.fov = 160;
X	}
X
X	// handedness
X	s = Info_ValueForKey (userinfo, "hand");
X	if (strlen(s))
X	{
X		ent->client->pers.hand = atoi(s);
X	}
X
X	// save off the userinfo in case we want to check something later
X	strncpy (ent->client->pers.userinfo, userinfo, sizeof(ent->client->pers.userinfo)-1);
}
X
X
/*
===========
ClientConnect
X
Called when a player begins connecting to the server.
The game can refuse entrance to a client by returning false.
If the client is allowed, the connection process will continue
and eventually get to ClientBegin()
Changing levels will NOT cause this to be called again, but
loadgames will.
============
*/
qboolean ClientConnect (edict_t *ent, char *userinfo)
{
X	char	*value;
X
X	// check to see if they are on the banned IP list
X	value = Info_ValueForKey (userinfo, "ip");
X	if (SV_FilterPacket(value))
X	{
X		Info_SetValueForKey(userinfo, "rejmsg", "Banned.");
X		return false;
X	}
X
X	// check for a spectator
X	value = Info_ValueForKey (userinfo, "spectator");
//	if (deathmatch->value && strcmp(value, "0"))
X	if (deathmatch->value && *value && strcmp(value, "0"))
X	{
X		int i, numspec;
X
X		if (*spectator_password->string && 
X			strcmp(spectator_password->string, "none") && 
X			strcmp(spectator_password->string, value))
X		{
X			Info_SetValueForKey(userinfo, "rejmsg", "Spectator password required or incorrect.");
X			return false;
X		}
X
X		// count spectators
X		for (i = numspec = 0; i < maxclients->value; i++)
X		{
X			if (g_edicts[i+1].inuse && g_edicts[i+1].client->pers.spectator)
X				numspec++;
X		}
X
X		if (numspec >= maxspectators->value)
X		{
X			Info_SetValueForKey(userinfo, "rejmsg", "Server spectator limit is full.");
X			return false;
X		}
X	}
X	else
X	{
X		// check for a password
X		value = Info_ValueForKey (userinfo, "password");
X		if (*password->string && strcmp(password->string, "none") && 
X			strcmp(password->string, value))
X		{
X			Info_SetValueForKey(userinfo, "rejmsg", "Password required or incorrect.");
X			return false;
X		}
X	}
X
X
X	// they can connect
X	ent->client = game.clients + (ent - g_edicts - 1);
X
X	// if there is already a body waiting for us (a loadgame), just
X	// take it, otherwise spawn one from scratch
X	if (ent->inuse == false)
X	{
X		// clear the respawning variables
X		InitClientResp (ent->client);
X		if (!game.autosaved || !ent->client->pers.weapon)
X			InitClientPersistant (ent->client);
X	}
X
X	ClientUserinfoChanged (ent, userinfo);
X
X	if (game.maxclients > 1)
X		gi.dprintf ("%s connected\n", ent->client->pers.netname);
X
X	ent->svflags = 0; // make sure we start with known default
X	ent->client->pers.connected = true;
X	return true;
}
X
/*
===========
ClientDisconnect
X
Called when a player drops from the server.
Will not be called between levels.
============
*/
void ClientDisconnect (edict_t *ent)
{
X	int		playernum;
X
X	if (!ent->client)
X		return;
X
X	gi.bprintf (PRINT_HIGH, "%s disconnected\n", ent->client->pers.netname);
X
//============
//ROGUE
X	// make sure no trackers are still hurting us.
X	if(ent->client->tracker_pain_framenum)
X		RemoveAttackingPainDaemons (ent);
X
X	if (ent->client->owned_sphere)
X	{
X		if(ent->client->owned_sphere->inuse)
X			G_FreeEdict (ent->client->owned_sphere);
X		ent->client->owned_sphere = NULL;
X	}
X
X	if (gamerules && gamerules->value)
X	{
X		if(DMGame.PlayerDisconnect)
X			DMGame.PlayerDisconnect(ent);
X	}
//ROGUE
//============
X
X	// send effect
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_LOGOUT);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	gi.unlinkentity (ent);
X	ent->s.modelindex = 0;
X	ent->solid = SOLID_NOT;
X	ent->inuse = false;
X	ent->classname = "disconnected";
X	ent->client->pers.connected = false;
X
X	playernum = ent-g_edicts-1;
X	gi.configstring (CS_PLAYERSKINS+playernum, "");
}
X
X
//==============================================================
X
X
edict_t	*pm_passent;
X
// pmove doesn't need to know about passent and contentmask
trace_t	PM_trace (vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end)
{
X	if (pm_passent->health > 0)
X		return gi.trace (start, mins, maxs, end, pm_passent, MASK_PLAYERSOLID);
X	else
X		return gi.trace (start, mins, maxs, end, pm_passent, MASK_DEADSOLID);
}
X
unsigned CheckBlock (void *b, int c)
{
X	int	v,i;
X	v = 0;
X	for (i=0 ; i<c ; i++)
X		v+= ((byte *)b)[i];
X	return v;
}
void PrintPmove (pmove_t *pm)
{
X	unsigned	c1, c2;
X
X	c1 = CheckBlock (&pm->s, sizeof(pm->s));
X	c2 = CheckBlock (&pm->cmd, sizeof(pm->cmd));
X	Com_Printf ("sv %3i:%i %i\n", pm->cmd.impulse, c1, c2);
}
X
/*
==============
ClientThink
X
This will be called once for each client frame, which will
usually be a couple times for each server frame.
==============
*/
void ClientThink (edict_t *ent, usercmd_t *ucmd)
{
X	gclient_t	*client;
X	edict_t	*other;
X	int		i, j;
X	pmove_t	pm;
X
X	level.current_entity = ent;
X	client = ent->client;
X
X	if (level.intermissiontime)
X	{
X		client->ps.pmove.pm_type = PM_FREEZE;
X		// can exit intermission after five seconds
X		if (level.time > level.intermissiontime + 5.0 
X			&& (ucmd->buttons & BUTTON_ANY) )
X			level.exitintermission = true;
X		return;
X	}
X
X	pm_passent = ent;
X
X	if (ent->client->chase_target)
X	{
X		client->resp.cmd_angles[0] = SHORT2ANGLE(ucmd->angles[0]);
X		client->resp.cmd_angles[1] = SHORT2ANGLE(ucmd->angles[1]);
X		client->resp.cmd_angles[2] = SHORT2ANGLE(ucmd->angles[2]);
X	}
X	else
X	{
X		// set up for pmove
X		memset (&pm, 0, sizeof(pm));
X
X		if (ent->movetype == MOVETYPE_NOCLIP)
X			client->ps.pmove.pm_type = PM_SPECTATOR;
X		else if (ent->s.modelindex != 255)
X			client->ps.pmove.pm_type = PM_GIB;
X		else if (ent->deadflag)
X			client->ps.pmove.pm_type = PM_DEAD;
X		else
X			client->ps.pmove.pm_type = PM_NORMAL;
X
X	//PGM	trigger_gravity support
X	//	client->ps.pmove.gravity = sv_gravity->value;
X		client->ps.pmove.gravity = sv_gravity->value * ent->gravity;
X	//PGM
X		pm.s = client->ps.pmove;
X
X		for (i=0 ; i<3 ; i++)
X		{
X			pm.s.origin[i] = ent->s.origin[i]*8;
X			pm.s.velocity[i] = ent->velocity[i]*8;
X		}
X
X		if (memcmp(&client->old_pmove, &pm.s, sizeof(pm.s)))
X		{
X			pm.snapinitial = true;
X	//		gi.dprintf ("pmove changed!\n");
X		}
X
X		pm.cmd = *ucmd;
X
X		pm.trace = PM_trace;	// adds default parms
X		pm.pointcontents = gi.pointcontents;
X
X		// perform a pmove
X		gi.Pmove (&pm);
X
X		// save results of pmove
X		client->ps.pmove = pm.s;
X		client->old_pmove = pm.s;
X
X		for (i=0 ; i<3 ; i++)
X		{
X			ent->s.origin[i] = pm.s.origin[i]*0.125;
X			ent->velocity[i] = pm.s.velocity[i]*0.125;
X		}
X
X		VectorCopy (pm.mins, ent->mins);
X		VectorCopy (pm.maxs, ent->maxs);
X
X		client->resp.cmd_angles[0] = SHORT2ANGLE(ucmd->angles[0]);
X		client->resp.cmd_angles[1] = SHORT2ANGLE(ucmd->angles[1]);
X		client->resp.cmd_angles[2] = SHORT2ANGLE(ucmd->angles[2]);
X
X		if (ent->groundentity && !pm.groundentity && (pm.cmd.upmove >= 10) && (pm.waterlevel == 0))
X		{
X			gi.sound(ent, CHAN_VOICE, gi.soundindex("*jump1.wav"), 1, ATTN_NORM, 0);
X			PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
X		}
X
X	//ROGUE sam raimi cam support
X		if(ent->flags & FL_SAM_RAIMI)
X			ent->viewheight = 8;
X		else
X			ent->viewheight = pm.viewheight;
X	//ROGUE
X
X		ent->waterlevel = pm.waterlevel;
X		ent->watertype = pm.watertype;
X		ent->groundentity = pm.groundentity;
X		if (pm.groundentity)
X			ent->groundentity_linkcount = pm.groundentity->linkcount;
X
X		if (ent->deadflag)
X		{
X			client->ps.viewangles[ROLL] = 40;
X			client->ps.viewangles[PITCH] = -15;
X			client->ps.viewangles[YAW] = client->killer_yaw;
X		}
X		else
X		{
X			VectorCopy (pm.viewangles, client->v_angle);
X			VectorCopy (pm.viewangles, client->ps.viewangles);
X		}
X
X		gi.linkentity (ent);
X
X	//PGM trigger_gravity support
X		ent->gravity = 1.0;
X	//PGM
X		if (ent->movetype != MOVETYPE_NOCLIP)
X			G_TouchTriggers (ent);
X
X		// touch other objects
X		for (i=0 ; i<pm.numtouch ; i++)
X		{
X			other = pm.touchents[i];
X			for (j=0 ; j<i ; j++)
X				if (pm.touchents[j] == other)
X					break;
X			if (j != i)
X				continue;	// duplicated
X			if (!other->touch)
X				continue;
X			other->touch (other, ent, NULL, NULL);
X		}
X	}
X
X	client->oldbuttons = client->buttons;
X	client->buttons = ucmd->buttons;
X	client->latched_buttons |= client->buttons & ~client->oldbuttons;
X
X	// save light level the player is standing on for
X	// monster sighting AI
X	ent->light_level = ucmd->lightlevel;
X
X	// fire weapon from final position if needed
X	if (client->latched_buttons & BUTTON_ATTACK)
X	{
X		if (client->resp.spectator)
X		{
X			client->latched_buttons = 0;
X
X			if (client->chase_target)
X			{
X				client->chase_target = NULL;
X				client->ps.pmove.pm_flags &= ~PMF_NO_PREDICTION;
X			}
X			else
X				GetChaseTarget(ent);
X		}
X		else if (!client->weapon_thunk)
X		{
X			client->weapon_thunk = true;
X			Think_Weapon (ent);
X		}
X	}
X
X	if (client->resp.spectator)
X	{
X		if (ucmd->upmove >= 10)
X		{
X			if (!(client->ps.pmove.pm_flags & PMF_JUMP_HELD))
X			{
X				client->ps.pmove.pm_flags |= PMF_JUMP_HELD;
X				if (client->chase_target)
X					ChaseNext(ent);
X				else
X					GetChaseTarget(ent);
X			}
X		}
X		else
X			client->ps.pmove.pm_flags &= ~PMF_JUMP_HELD;
X	}
X
X	// update chase cam if being followed
X	for (i = 1; i <= maxclients->value; i++)
X	{
X		other = g_edicts + i;
X		if (other->inuse && other->client->chase_target == ent)
X			UpdateChaseCam(other);
X	}
}
X
X
/*
==============
ClientBeginServerFrame
X
This will be called once for each server frame, before running
any other entities in the world.
==============
*/
void ClientBeginServerFrame (edict_t *ent)
{
X	gclient_t	*client;
X	int			buttonMask;
X
X	if (level.intermissiontime)
X		return;
X
X	client = ent->client;
X
X	if (deathmatch->value &&
X		client->pers.spectator != client->resp.spectator &&
X		(level.time - client->respawn_time) >= 5)
X	{
X		spectator_respawn(ent);
X		return;
X	}
X
X	// run weapon animations if it hasn't been done by a ucmd_t
X	if (!client->weapon_thunk && !client->resp.spectator)
X		Think_Weapon (ent);
X	else
X		client->weapon_thunk = false;
X
X	if (ent->deadflag)
X	{
X		// wait for any button just going down
X		if ( level.time > client->respawn_time)
X		{
X			// in deathmatch, only wait for attack button
X			if (deathmatch->value)
X				buttonMask = BUTTON_ATTACK;
X			else
X				buttonMask = -1;
X
X			if ( ( client->latched_buttons & buttonMask ) ||
X				(deathmatch->value && ((int)dmflags->value & DF_FORCE_RESPAWN) ) )
X			{
X				respawn(ent);
X				client->latched_buttons = 0;
X			}
X		}
X		return;
X	}
X
X	// add player trail so monsters can follow
X	if (!deathmatch->value)
X		if (!visible (ent, PlayerTrail_LastSpot() ) )
X			PlayerTrail_Add (ent->s.old_origin);
X
X	client->latched_buttons = 0;
}
X
/*
==============
RemoveAttackingPainDaemons
X
This is called to clean up the pain daemons that the disruptor attaches
to clients to damage them.
==============
*/
void RemoveAttackingPainDaemons (edict_t *self)
{
X	edict_t *tracker;
X
X	tracker = G_Find (NULL, FOFS(classname), "pain daemon");
X	while(tracker)
X	{
X		if(tracker->enemy == self)
X			G_FreeEdict(tracker);
X		tracker = G_Find (tracker, FOFS(classname), "pain daemon");
X	}
X
X	if(self->client)
X		self->client->tracker_pain_framenum = 0;
}
SHAR_EOF
  $shar_touch -am 1130175398 'p_client.c' &&
  chmod 0664 'p_client.c' ||
  $echo 'restore of' 'p_client.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'p_client.c:' 'MD5 check failed'
59936855c2392f42e11fff41aae4f92d  p_client.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'p_client.c'`"
    test 50361 -eq "$shar_count" ||
    $echo 'p_client.c:' 'original size' '50361,' 'current size' "$shar_count!"
  fi
fi
# ============= p_hud.c ==============
if test -f 'p_hud.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'p_hud.c' '(file already exists)'
else
  $echo 'x -' extracting 'p_hud.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'p_hud.c' &&
#include "g_local.h"
X
X
X
/*
======================================================================
X
INTERMISSION
X
======================================================================
*/
X
void MoveClientToIntermission (edict_t *ent)
{
X	if (deathmatch->value || coop->value)
X		ent->client->showscores = true;
X	VectorCopy (level.intermission_origin, ent->s.origin);
X	ent->client->ps.pmove.origin[0] = level.intermission_origin[0]*8;
X	ent->client->ps.pmove.origin[1] = level.intermission_origin[1]*8;
X	ent->client->ps.pmove.origin[2] = level.intermission_origin[2]*8;
X	VectorCopy (level.intermission_angle, ent->client->ps.viewangles);
X	ent->client->ps.pmove.pm_type = PM_FREEZE;
X	ent->client->ps.gunindex = 0;
X	ent->client->ps.blend[3] = 0;
X	ent->client->ps.rdflags &= ~RDF_UNDERWATER;
X
X	// clean up powerup info
X	ent->client->quad_framenum = 0;
X	ent->client->invincible_framenum = 0;
X	ent->client->breather_framenum = 0;
X	ent->client->enviro_framenum = 0;
X	ent->client->grenade_blew_up = false;
X	ent->client->grenade_time = 0;
X
X	ent->client->ps.rdflags &= ~RDF_IRGOGGLES;		// PGM
X	ent->client->ir_framenum = 0;					// PGM
X	ent->client->nuke_framenum = 0;					// PMM
X	ent->client->double_framenum = 0;				// PMM
X
X	ent->viewheight = 0;
X	ent->s.modelindex = 0;
X	ent->s.modelindex2 = 0;
X	ent->s.modelindex3 = 0;
X	ent->s.modelindex = 0;
X	ent->s.effects = 0;
X	ent->s.sound = 0;
X	ent->solid = SOLID_NOT;
X
X	// add the layout
X
X	if (deathmatch->value || coop->value)
X	{
X		DeathmatchScoreboardMessage (ent, NULL);
X		gi.unicast (ent, true);
X	}
X
}
X
void BeginIntermission (edict_t *targ)
{
X	int		i, n;
X	edict_t	*ent, *client;
X
X	if (level.intermissiontime)
X		return;		// already activated
X
X	game.autosaved = false;
X
X	// respawn any dead clients
X	for (i=0 ; i<maxclients->value ; i++)
X	{
X		client = g_edicts + 1 + i;
X		if (!client->inuse)
X			continue;
X		if (client->health <= 0)
X			respawn(client);
X	}
X
X	level.intermissiontime = level.time;
X	level.changemap = targ->map;
X
X	if (strstr(level.changemap, "*"))
X	{
X		if (coop->value)
X		{
X			for (i=0 ; i<maxclients->value ; i++)
X			{
X				client = g_edicts + 1 + i;
X				if (!client->inuse)
X					continue;
X				// strip players of all keys between units
X				for (n = 0; n < MAX_ITEMS; n++)
X				{
X					if (itemlist[n].flags & IT_KEY)
X						client->client->pers.inventory[n] = 0;
X				}
X			}
X		}
X	}
X	else
X	{
X		if (!deathmatch->value)
X		{
X			level.exitintermission = 1;		// go immediately to the next level
X			return;
X		}
X	}
X
X	level.exitintermission = 0;
X
X	// find an intermission spot
X	ent = G_Find (NULL, FOFS(classname), "info_player_intermission");
X	if (!ent)
X	{	// the map creator forgot to put in an intermission point...
X		ent = G_Find (NULL, FOFS(classname), "info_player_start");
X		if (!ent)
X			ent = G_Find (NULL, FOFS(classname), "info_player_deathmatch");
X	}
X	else
X	{	// chose one of four spots
X		i = rand() & 3;
X		while (i--)
X		{
X			ent = G_Find (ent, FOFS(classname), "info_player_intermission");
X			if (!ent)	// wrap around the list
X				ent = G_Find (ent, FOFS(classname), "info_player_intermission");
X		}
X	}
X
X	VectorCopy (ent->s.origin, level.intermission_origin);
X	VectorCopy (ent->s.angles, level.intermission_angle);
X
X	// move all clients to the intermission point
X	for (i=0 ; i<maxclients->value ; i++)
X	{
X		client = g_edicts + 1 + i;
X		if (!client->inuse)
X			continue;
X		MoveClientToIntermission (client);
X	}
}
X
X
/*
==================
DeathmatchScoreboardMessage
X
==================
*/
void DeathmatchScoreboardMessage (edict_t *ent, edict_t *killer)
{
X	char	entry[1024];
X	char	string[1400];
X	int		stringlength;
X	int		i, j, k;
X	int		sorted[MAX_CLIENTS];
X	int		sortedscores[MAX_CLIENTS];
X	int		score, total;
X	int		picnum;
X	int		x, y;
X	gclient_t	*cl;
X	edict_t		*cl_ent;
X	char	*tag;
X
X	// sort the clients by score
X	total = 0;
X	for (i=0 ; i<game.maxclients ; i++)
X	{
X		cl_ent = g_edicts + 1 + i;
X		if (!cl_ent->inuse || game.clients[i].resp.spectator)
X			continue;
X		score = game.clients[i].resp.score;
X		for (j=0 ; j<total ; j++)
X		{
X			if (score > sortedscores[j])
X				break;
X		}
X		for (k=total ; k>j ; k--)
X		{
X			sorted[k] = sorted[k-1];
X			sortedscores[k] = sortedscores[k-1];
X		}
X		sorted[j] = i;
X		sortedscores[j] = score;
X		total++;
X	}
X
X	// print level name and exit rules
X	string[0] = 0;
X
X	stringlength = strlen(string);
X
X	// add the clients in sorted order
X	if (total > 12)
X		total = 12;
X
X	for (i=0 ; i<total ; i++)
X	{
X		cl = &game.clients[sorted[i]];
X		cl_ent = g_edicts + 1 + sorted[i];
X
X		picnum = gi.imageindex ("i_fixme");
X		x = (i>=6) ? 160 : 0;
X		y = 32 + 32 * (i%6);
X
X		// add a dogtag
X		if (cl_ent == ent)
X			tag = "tag1";
X		else if (cl_ent == killer)
X			tag = "tag2";
X		else
X			tag = NULL;
X
//===============
//ROGUE
X		// allow new DM games to override the tag picture
X		if (gamerules && gamerules->value)
X		{
X			if(DMGame.DogTag)
X				DMGame.DogTag(cl_ent, killer, &tag);
X		}
//ROGUE
//===============
X
X		if (tag)
X		{
X			Com_sprintf (entry, sizeof(entry),
X				"xv %i yv %i picn %s ",x+32, y, tag);
X			j = strlen(entry);
X			if (stringlength + j > 1024)
X				break;
X			strcpy (string + stringlength, entry);
X			stringlength += j;
X		}
X
X		// send the layout
X		Com_sprintf (entry, sizeof(entry),
X			"client %i %i %i %i %i %i ",
X			x, y, sorted[i], cl->resp.score, cl->ping, (level.framenum - cl->resp.enterframe)/600);
X		j = strlen(entry);
X		if (stringlength + j > 1024)
X			break;
X		strcpy (string + stringlength, entry);
X		stringlength += j;
X	}
X
X	gi.WriteByte (svc_layout);
X	gi.WriteString (string);
}
X
X
/*
==================
DeathmatchScoreboard
X
Draw instead of help message.
Note that it isn't that hard to overflow the 1400 byte message limit!
==================
*/
void DeathmatchScoreboard (edict_t *ent)
{
X	DeathmatchScoreboardMessage (ent, ent->enemy);
X	gi.unicast (ent, true);
}
X
X
/*
==================
Cmd_Score_f
X
Display the scoreboard
==================
*/
void Cmd_Score_f (edict_t *ent)
{
X	ent->client->showinventory = false;
X	ent->client->showhelp = false;
X
X	if (!deathmatch->value && !coop->value)
X		return;
X
X	if (ent->client->showscores)
X	{
X		ent->client->showscores = false;
X		return;
X	}
X
X	ent->client->showscores = true;
X	DeathmatchScoreboard (ent);
}
X
X
/*
==================
HelpComputer
X
Draw help computer.
==================
*/
void HelpComputer (edict_t *ent)
{
X	char	string[1024];
X	char	*sk;
X
X	if (skill->value == 0)
X		sk = "easy";
X	else if (skill->value == 1)
X		sk = "medium";
X	else if (skill->value == 2)
X		sk = "hard";
X	else
X		sk = "hard+";
X
X	// send the layout
X	Com_sprintf (string, sizeof(string),
X		"xv 32 yv 8 picn help "			// background
X		"xv 202 yv 12 string2 \"%s\" "		// skill
X		"xv 0 yv 24 cstring2 \"%s\" "		// level name
X		"xv 0 yv 54 cstring2 \"%s\" "		// help 1
X		"xv 0 yv 110 cstring2 \"%s\" "		// help 2
X		"xv 50 yv 164 string2 \" kills     goals    secrets\" "
X		"xv 50 yv 172 string2 \"%3i/%3i     %i/%i       %i/%i\" ", 
X		sk,
X		level.level_name,
X		game.helpmessage1,
X		game.helpmessage2,
X		level.killed_monsters, level.total_monsters, 
X		level.found_goals, level.total_goals,
X		level.found_secrets, level.total_secrets);
X
X	gi.WriteByte (svc_layout);
X	gi.WriteString (string);
X	gi.unicast (ent, true);
}
X
X
/*
==================
Cmd_Help_f
X
Display the current help message
==================
*/
void Cmd_Help_f (edict_t *ent)
{
X	// this is for backwards compatability
X	if (deathmatch->value)
X	{
X		Cmd_Score_f (ent);
X		return;
X	}
X
X	ent->client->showinventory = false;
X	ent->client->showscores = false;
X
X	if (ent->client->showhelp && (ent->client->pers.game_helpchanged == game.helpchanged))
X	{
X		ent->client->showhelp = false;
X		return;
X	}
X
X	ent->client->showhelp = true;
X	ent->client->pers.helpchanged = 0;
X	HelpComputer (ent);
}
X
X
//=======================================================================
X
/*
===============
G_SetStats
===============
*/
void G_SetStats (edict_t *ent)
{
X	gitem_t		*item;
X	int			index, cells;
X	int			power_armor_type;
X
X	//
X	// health
X	//
X	ent->client->ps.stats[STAT_HEALTH_ICON] = level.pic_health;
X	ent->client->ps.stats[STAT_HEALTH] = ent->health;
X
X	//
X	// ammo
X	//
X	if (!ent->client->ammo_index /* || !ent->client->pers.inventory[ent->client->ammo_index] */)
X	{
X		ent->client->ps.stats[STAT_AMMO_ICON] = 0;
X		ent->client->ps.stats[STAT_AMMO] = 0;
X	}
X	else
X	{
X		item = &itemlist[ent->client->ammo_index];
X		ent->client->ps.stats[STAT_AMMO_ICON] = gi.imageindex (item->icon);
X		ent->client->ps.stats[STAT_AMMO] = ent->client->pers.inventory[ent->client->ammo_index];
X	}
X	
X	//
X	// armor
X	//
X	power_armor_type = PowerArmorType (ent);
X	if (power_armor_type)
X	{
X		cells = ent->client->pers.inventory[ITEM_INDEX(FindItem ("cells"))];
X		if (cells == 0)
X		{	// ran out of cells for power armor
X			ent->flags &= ~FL_POWER_ARMOR;
X			gi.sound(ent, CHAN_ITEM, gi.soundindex("misc/power2.wav"), 1, ATTN_NORM, 0);
X			power_armor_type = 0;;
X		}
X	}
X
X	index = ArmorIndex (ent);
X	if (power_armor_type && (!index || (level.framenum & 8) ) )
X	{	// flash between power armor and other armor icon
X		ent->client->ps.stats[STAT_ARMOR_ICON] = gi.imageindex ("i_powershield");
X		ent->client->ps.stats[STAT_ARMOR] = cells;
X	}
X	else if (index)
X	{
X		item = GetItemByIndex (index);
X		ent->client->ps.stats[STAT_ARMOR_ICON] = gi.imageindex (item->icon);
X		ent->client->ps.stats[STAT_ARMOR] = ent->client->pers.inventory[index];
X	}
X	else
X	{
X		ent->client->ps.stats[STAT_ARMOR_ICON] = 0;
X		ent->client->ps.stats[STAT_ARMOR] = 0;
X	}
X
X	//
X	// pickup message
X	//
X	if (level.time > ent->client->pickup_msg_time)
X	{
X		ent->client->ps.stats[STAT_PICKUP_ICON] = 0;
X		ent->client->ps.stats[STAT_PICKUP_STRING] = 0;
X	}
X
X	//
X	// timers
X	//
X	if (ent->client->quad_framenum > level.framenum)
X	{
X		ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_quad");
X		ent->client->ps.stats[STAT_TIMER] = (ent->client->quad_framenum - level.framenum)/10;
X	}
// PMM
X	else if (ent->client->double_framenum > level.framenum)
X	{
X		ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_double");
X		ent->client->ps.stats[STAT_TIMER] = (ent->client->double_framenum - level.framenum)/10;
X	}
// PMM
X	else if (ent->client->invincible_framenum > level.framenum)
X	{
X		ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_invulnerability");
X		ent->client->ps.stats[STAT_TIMER] = (ent->client->invincible_framenum - level.framenum)/10;
X	}
X	else if (ent->client->enviro_framenum > level.framenum)
X	{
X		ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_envirosuit");
X		ent->client->ps.stats[STAT_TIMER] = (ent->client->enviro_framenum - level.framenum)/10;
X	}
X	else if (ent->client->breather_framenum > level.framenum)
X	{
X		ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_rebreather");
X		ent->client->ps.stats[STAT_TIMER] = (ent->client->breather_framenum - level.framenum)/10;
X	}
// PGM
X	else if (ent->client->owned_sphere)
X	{
X		if(ent->client->owned_sphere->spawnflags == 1)			// defender
X			ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_defender");
X		else if(ent->client->owned_sphere->spawnflags == 2)		// hunter
X			ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_hunter");
X		else if(ent->client->owned_sphere->spawnflags == 4)		// vengeance
X			ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_vengeance");
X		else													// error case
X			ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("i_fixme");
X
X		ent->client->ps.stats[STAT_TIMER] = (int)(ent->client->owned_sphere->wait - level.time);
X	}
X	else if (ent->client->ir_framenum > level.framenum)
X	{
X		ent->client->ps.stats[STAT_TIMER_ICON] = gi.imageindex ("p_ir");
X		ent->client->ps.stats[STAT_TIMER] = (ent->client->ir_framenum - level.framenum)/10;
X	}
// PGM
X	else
X	{
X		ent->client->ps.stats[STAT_TIMER_ICON] = 0;
X		ent->client->ps.stats[STAT_TIMER] = 0;
X	}
X
X	//
X	// selected item
X	//
X	if (ent->client->pers.selected_item == -1)
X		ent->client->ps.stats[STAT_SELECTED_ICON] = 0;
X	else
X		ent->client->ps.stats[STAT_SELECTED_ICON] = gi.imageindex (itemlist[ent->client->pers.selected_item].icon);
X
X	ent->client->ps.stats[STAT_SELECTED_ITEM] = ent->client->pers.selected_item;
X
X	//
X	// layouts
X	//
X	ent->client->ps.stats[STAT_LAYOUTS] = 0;
X
X	if (deathmatch->value)
X	{
X		if (ent->client->pers.health <= 0 || level.intermissiontime
X			|| ent->client->showscores)
X			ent->client->ps.stats[STAT_LAYOUTS] |= 1;
X		if (ent->client->showinventory && ent->client->pers.health > 0)
X			ent->client->ps.stats[STAT_LAYOUTS] |= 2;
X	}
X	else
X	{
X		if (ent->client->showscores || ent->client->showhelp)
X			ent->client->ps.stats[STAT_LAYOUTS] |= 1;
X		if (ent->client->showinventory && ent->client->pers.health > 0)
X			ent->client->ps.stats[STAT_LAYOUTS] |= 2;
X	}
X
X	//
X	// frags
X	//
X	ent->client->ps.stats[STAT_FRAGS] = ent->client->resp.score;
X
X	//
X	// help icon / current weapon if not shown
X	//
X	if (ent->client->pers.helpchanged && (level.framenum&8) )
X		ent->client->ps.stats[STAT_HELPICON] = gi.imageindex ("i_help");
X	else if ( (ent->client->pers.hand == CENTER_HANDED || ent->client->ps.fov > 91)
X		&& ent->client->pers.weapon)
X		ent->client->ps.stats[STAT_HELPICON] = gi.imageindex (ent->client->pers.weapon->icon);
X	else
X		ent->client->ps.stats[STAT_HELPICON] = 0;
X
X	ent->client->ps.stats[STAT_SPECTATOR] = 0;
}
X
/*
===============
G_CheckChaseStats
===============
*/
void G_CheckChaseStats (edict_t *ent)
{
X	int i;
X	gclient_t *cl;
X
X	for (i = 1; i <= maxclients->value; i++)
X	{
X		cl = g_edicts[i].client;
X		if (!g_edicts[i].inuse || cl->chase_target != ent)
X			continue;
X		memcpy(cl->ps.stats, ent->client->ps.stats, sizeof(cl->ps.stats));
X		G_SetSpectatorStats(g_edicts + i);
X	}
}
X
/*
===============
G_SetSpectatorStats
===============
*/
void G_SetSpectatorStats (edict_t *ent)
{
X	gclient_t *cl = ent->client;
X
X	if (!cl->chase_target)
X		G_SetStats (ent);
X
X	cl->ps.stats[STAT_SPECTATOR] = 1;
X
X	// layouts are independant in spectator
X	cl->ps.stats[STAT_LAYOUTS] = 0;
X	if (cl->pers.health <= 0 || level.intermissiontime || cl->showscores)
X		cl->ps.stats[STAT_LAYOUTS] |= 1;
X	if (cl->showinventory && cl->pers.health > 0)
X		cl->ps.stats[STAT_LAYOUTS] |= 2;
X
X	if (cl->chase_target && cl->chase_target->inuse)
X	{
X		cl->ps.stats[STAT_CHASE] = CS_PLAYERSKINS + 
X			(cl->chase_target - g_edicts) - 1;
X	}
X	else
X		cl->ps.stats[STAT_CHASE] = 0;
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'p_hud.c' &&
  chmod 0664 'p_hud.c' ||
  $echo 'restore of' 'p_hud.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'p_hud.c:' 'MD5 check failed'
166d88b1c083b2380290381f035e6076  p_hud.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'p_hud.c'`"
    test 14136 -eq "$shar_count" ||
    $echo 'p_hud.c:' 'original size' '14136,' 'current size' "$shar_count!"
  fi
fi
# ============= p_trail.c ==============
if test -f 'p_trail.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'p_trail.c' '(file already exists)'
else
  $echo 'x -' extracting 'p_trail.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'p_trail.c' &&
#include "g_local.h"
X
X
/*
==============================================================================
X
PLAYER TRAIL
X
==============================================================================
X
This is a circular list containing the a list of points of where
the player has been recently.  It is used by monsters for pursuit.
X
X.origin		the spot
X.owner		forward link
X.aiment		backward link
*/
X
X
#define	TRAIL_LENGTH	8
X
edict_t		*trail[TRAIL_LENGTH];
int			trail_head;
qboolean	trail_active = false;
X
#define NEXT(n)		(((n) + 1) & (TRAIL_LENGTH - 1))
#define PREV(n)		(((n) - 1) & (TRAIL_LENGTH - 1))
X
X
void PlayerTrail_Init (void)
{
X	int		n;
X
X	if (deathmatch->value /* FIXME || coop */)
X		return;
X
X	for (n = 0; n < TRAIL_LENGTH; n++)
X	{
X		trail[n] = G_Spawn();
X		trail[n]->classname = "player_trail";
X	}
X
X	trail_head = 0;
X	trail_active = true;
}
X
X
void PlayerTrail_Add (vec3_t spot)
{
X	vec3_t	temp;
X
X	if (!trail_active)
X		return;
X
X	VectorCopy (spot, trail[trail_head]->s.origin);
X
X	trail[trail_head]->timestamp = level.time;
X
X	VectorSubtract (spot, trail[PREV(trail_head)]->s.origin, temp);
X	trail[trail_head]->s.angles[1] = vectoyaw (temp);
X
X	trail_head = NEXT(trail_head);
}
X
X
void PlayerTrail_New (vec3_t spot)
{
X	if (!trail_active)
X		return;
X
X	PlayerTrail_Init ();
X	PlayerTrail_Add (spot);
}
X
X
edict_t *PlayerTrail_PickFirst (edict_t *self)
{
X	int		marker;
X	int		n;
X
X	if (!trail_active)
X		return NULL;
X
X	for (marker = trail_head, n = TRAIL_LENGTH; n; n--)
X	{
X		if(trail[marker]->timestamp <= self->monsterinfo.trail_time)
X			marker = NEXT(marker);
X		else
X			break;
X	}
X
X	if (visible(self, trail[marker]))
X	{
X		return trail[marker];
X	}
X
X	if (visible(self, trail[PREV(marker)]))
X	{
X		return trail[PREV(marker)];
X	}
X
X	return trail[marker];
}
X
edict_t *PlayerTrail_PickNext (edict_t *self)
{
X	int		marker;
X	int		n;
X
X	if (!trail_active)
X		return NULL;
X
X	for (marker = trail_head, n = TRAIL_LENGTH; n; n--)
X	{
X		if(trail[marker]->timestamp <= self->monsterinfo.trail_time)
X			marker = NEXT(marker);
X		else
X			break;
X	}
X
X	return trail[marker];
}
X
edict_t *PlayerTrail_LastSpot (void)
{
X	return trail[PREV(trail_head)];
}
SHAR_EOF
  $shar_touch -am 1130175398 'p_trail.c' &&
  chmod 0664 'p_trail.c' ||
  $echo 'restore of' 'p_trail.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'p_trail.c:' 'MD5 check failed'
c2d15a30c5dc659407771aae21bd1f65  p_trail.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'p_trail.c'`"
    test 2122 -eq "$shar_count" ||
    $echo 'p_trail.c:' 'original size' '2122,' 'current size' "$shar_count!"
  fi
fi
# ============= p_view.c ==============
if test -f 'p_view.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'p_view.c' '(file already exists)'
else
  $echo 'x -' extracting 'p_view.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'p_view.c' &&
X
#include "g_local.h"
#include "m_player.h"
X
X
X
static	edict_t		*current_player;
static	gclient_t	*current_client;
X
static	vec3_t	forward, right, up;
float	xyspeed;
X
float	bobmove;
int		bobcycle;		// odd cycles are right foot going forward
float	bobfracsin;		// sin(bobfrac*M_PI)
X
/*
===============
SV_CalcRoll
X
===============
*/
float SV_CalcRoll (vec3_t angles, vec3_t velocity)
{
X	float	sign;
X	float	side;
X	float	value;
X	
X	side = DotProduct (velocity, right);
X	sign = side < 0 ? -1 : 1;
X	side = fabs(side);
X	
X	value = sv_rollangle->value;
X
X	if (side < sv_rollspeed->value)
X		side = side * value / sv_rollspeed->value;
X	else
X		side = value;
X	
X	return side*sign;
X	
}
X
X
/*
===============
P_DamageFeedback
X
Handles color blends and view kicks
===============
*/
void P_DamageFeedback (edict_t *player)
{
X	gclient_t	*client;
X	float	side;
X	float	realcount, count, kick;
X	vec3_t	v;
X	int		r, l;
X	static	vec3_t	power_color = {0.0, 1.0, 0.0};
X	static	vec3_t	acolor = {1.0, 1.0, 1.0};
X	static	vec3_t	bcolor = {1.0, 0.0, 0.0};
X
X	client = player->client;
X
X	// flash the backgrounds behind the status numbers
X	client->ps.stats[STAT_FLASHES] = 0;
X	if (client->damage_blood)
X		client->ps.stats[STAT_FLASHES] |= 1;
X	if (client->damage_armor && !(player->flags & FL_GODMODE) && (client->invincible_framenum <= level.framenum))
X		client->ps.stats[STAT_FLASHES] |= 2;
X
X	// total points of damage shot at the player this frame
X	count = (client->damage_blood + client->damage_armor + client->damage_parmor);
X	if (count == 0)
X		return;		// didn't take any damage
X
X	// start a pain animation if still in the player model
X	if (client->anim_priority < ANIM_PAIN && player->s.modelindex == 255)
X	{
X		static int		i;
X
X		client->anim_priority = ANIM_PAIN;
X		if (client->ps.pmove.pm_flags & PMF_DUCKED)
X		{
X			player->s.frame = FRAME_crpain1-1;
X			client->anim_end = FRAME_crpain4;
X		}
X		else
X		{
X			i = (i+1)%3;
X			switch (i)
X			{
X			case 0:
X				player->s.frame = FRAME_pain101-1;
X				client->anim_end = FRAME_pain104;
X				break;
X			case 1:
X				player->s.frame = FRAME_pain201-1;
X				client->anim_end = FRAME_pain204;
X				break;
X			case 2:
X				player->s.frame = FRAME_pain301-1;
X				client->anim_end = FRAME_pain304;
X				break;
X			}
X		}
X	}
X
X	realcount = count;
X	if (count < 10)
X		count = 10;	// always make a visible effect
X
X	// play an apropriate pain sound
X	if ((level.time > player->pain_debounce_time) && !(player->flags & FL_GODMODE) && (client->invincible_framenum <= level.framenum))
X	{
X		r = 1 + (rand()&1);
X		player->pain_debounce_time = level.time + 0.7;
X		if (player->health < 25)
X			l = 25;
X		else if (player->health < 50)
X			l = 50;
X		else if (player->health < 75)
X			l = 75;
X		else
X			l = 100;
X		gi.sound (player, CHAN_VOICE, gi.soundindex(va("*pain%i_%i.wav", l, r)), 1, ATTN_NORM, 0);
X	}
X
X	// the total alpha of the blend is always proportional to count
X	if (client->damage_alpha < 0)
X		client->damage_alpha = 0;
X	client->damage_alpha += count*0.01;
X	if (client->damage_alpha < 0.2)
X		client->damage_alpha = 0.2;
X	if (client->damage_alpha > 0.6)
X		client->damage_alpha = 0.6;		// don't go too saturated
X
X	// the color of the blend will vary based on how much was absorbed
X	// by different armors
X	VectorClear (v);
X	if (client->damage_parmor)
X		VectorMA (v, (float)client->damage_parmor/realcount, power_color, v);
X	if (client->damage_armor)
X		VectorMA (v, (float)client->damage_armor/realcount,  acolor, v);
X	if (client->damage_blood)
X		VectorMA (v, (float)client->damage_blood/realcount,  bcolor, v);
X	VectorCopy (v, client->damage_blend);
X
X
X	//
X	// calculate view angle kicks
X	//
X	kick = abs(client->damage_knockback);
X	if (kick && player->health > 0)	// kick of 0 means no view adjust at all
X	{
X		kick = kick * 100 / player->health;
X
X		if (kick < count*0.5)
X			kick = count*0.5;
X		if (kick > 50)
X			kick = 50;
X
X		VectorSubtract (client->damage_from, player->s.origin, v);
X		VectorNormalize (v);
X		
X		side = DotProduct (v, right);
X		client->v_dmg_roll = kick*side*0.3;
X		
X		side = -DotProduct (v, forward);
X		client->v_dmg_pitch = kick*side*0.3;
X
X		client->v_dmg_time = level.time + DAMAGE_TIME;
X	}
X
X	//
X	// clear totals
X	//
X	client->damage_blood = 0;
X	client->damage_armor = 0;
X	client->damage_parmor = 0;
X	client->damage_knockback = 0;
}
X
X
X
X
/*
===============
SV_CalcViewOffset
X
Auto pitching on slopes?
X
X  fall from 128: 400 = 160000
X  fall from 256: 580 = 336400
X  fall from 384: 720 = 518400
X  fall from 512: 800 = 640000
X  fall from 640: 960 = 
X
X  damage = deltavelocity*deltavelocity  * 0.0001
X
===============
*/
void SV_CalcViewOffset (edict_t *ent)
{
X	float		*angles;
X	float		bob;
X	float		ratio;
X	float		delta;
X	vec3_t		v;
X
X
//===================================
X
X	// base angles
X	angles = ent->client->ps.kick_angles;
X
X	// if dead, fix the angle and don't add any kick
X	if (ent->deadflag)
X	{
X		VectorClear (angles);
X
X		if(ent->flags & FL_SAM_RAIMI)
X		{
X			ent->client->ps.viewangles[ROLL] = 0;
X			ent->client->ps.viewangles[PITCH] = 0;
X		}
X		else
X		{
X			ent->client->ps.viewangles[ROLL] = 40;
X			ent->client->ps.viewangles[PITCH] = -15;
X		}
X		ent->client->ps.viewangles[YAW] = ent->client->killer_yaw;
X	}
X	else
X	{
X		// add angles based on weapon kick
X
X		VectorCopy (ent->client->kick_angles, angles);
X
X		// add angles based on damage kick
X
X		ratio = (ent->client->v_dmg_time - level.time) / DAMAGE_TIME;
X		if (ratio < 0)
X		{
X			ratio = 0;
X			ent->client->v_dmg_pitch = 0;
X			ent->client->v_dmg_roll = 0;
X		}
X		angles[PITCH] += ratio * ent->client->v_dmg_pitch;
X		angles[ROLL] += ratio * ent->client->v_dmg_roll;
X
X		// add pitch based on fall kick
X
X		ratio = (ent->client->fall_time - level.time) / FALL_TIME;
X		if (ratio < 0)
X			ratio = 0;
X		angles[PITCH] += ratio * ent->client->fall_value;
X
X		// add angles based on velocity
X
X		delta = DotProduct (ent->velocity, forward);
X		angles[PITCH] += delta*run_pitch->value;
X		
X		delta = DotProduct (ent->velocity, right);
X		angles[ROLL] += delta*run_roll->value;
X
X		// add angles based on bob
X
X		delta = bobfracsin * bob_pitch->value * xyspeed;
X		if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X			delta *= 6;		// crouching
X		angles[PITCH] += delta;
X		delta = bobfracsin * bob_roll->value * xyspeed;
X		if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X			delta *= 6;		// crouching
X		if (bobcycle & 1)
X			delta = -delta;
X		angles[ROLL] += delta;
X	}
X
//===================================
X
X	// base origin
X
X	VectorClear (v);
X
X	// add view height
X
X	v[2] += ent->viewheight;
X
X	// add fall height
X
X	ratio = (ent->client->fall_time - level.time) / FALL_TIME;
X	if (ratio < 0)
X		ratio = 0;
X	v[2] -= ratio * ent->client->fall_value * 0.4;
X
X	// add bob height
X
X	bob = bobfracsin * xyspeed * bob_up->value;
X	if (bob > 6)
X		bob = 6;
X	//gi.DebugGraph (bob *2, 255);
X	v[2] += bob;
X
X	// add kick offset
X
X	VectorAdd (v, ent->client->kick_origin, v);
X
X	// absolutely bound offsets
X	// so the view can never be outside the player box
X
X	if (v[0] < -14)
X		v[0] = -14;
X	else if (v[0] > 14)
X		v[0] = 14;
X	if (v[1] < -14)
X		v[1] = -14;
X	else if (v[1] > 14)
X		v[1] = 14;
X	if (v[2] < -22)
X		v[2] = -22;
X	else if (v[2] > 30)
X		v[2] = 30;
X
X	VectorCopy (v, ent->client->ps.viewoffset);
}
X
/*
==============
SV_CalcGunOffset
==============
*/
void SV_CalcGunOffset (edict_t *ent)
{
X	int		i;
X	float	delta;
X	//ROGUE
X	static gitem_t	*heatbeam;
X
X	if (!heatbeam)
X		heatbeam = FindItemByClassname ("weapon_plasmabeam");
X
X	//ROGUE - heatbeam shouldn't bob so the beam looks right
X	if (ent->client->pers.weapon != heatbeam)
X	{
X	// ROGUE
X		// gun angles from bobbing
X		ent->client->ps.gunangles[ROLL] = xyspeed * bobfracsin * 0.005;
X		ent->client->ps.gunangles[YAW] = xyspeed * bobfracsin * 0.01;
X		if (bobcycle & 1)
X		{
X			ent->client->ps.gunangles[ROLL] = -ent->client->ps.gunangles[ROLL];
X			ent->client->ps.gunangles[YAW] = -ent->client->ps.gunangles[YAW];
X		}
X
X		ent->client->ps.gunangles[PITCH] = xyspeed * bobfracsin * 0.005;
X
X		// gun angles from delta movement
X		for (i=0 ; i<3 ; i++)
X		{
X			delta = ent->client->oldviewangles[i] - ent->client->ps.viewangles[i];
X			if (delta > 180)
X				delta -= 360;
X			if (delta < -180)
X				delta += 360;
X			if (delta > 45)
X				delta = 45;
X			if (delta < -45)
X				delta = -45;
X			if (i == YAW)
X				ent->client->ps.gunangles[ROLL] += 0.1*delta;
X			ent->client->ps.gunangles[i] += 0.2 * delta;
X		}
X	}
X	// ROGUE
X	else
X	{
X		for (i=0; i<3; i++)
X			ent->client->ps.gunangles[i] = 0;
X	}
X	//ROGUE
X
X	// gun height
X	VectorClear (ent->client->ps.gunoffset);
//	ent->ps->gunorigin[2] += bob;
X
X	// gun_x / gun_y / gun_z are development tools
X	for (i=0 ; i<3 ; i++)
X	{
X		ent->client->ps.gunoffset[i] += forward[i]*(gun_y->value);
X		ent->client->ps.gunoffset[i] += right[i]*gun_x->value;
X		ent->client->ps.gunoffset[i] += up[i]* (-gun_z->value);
X	}
}
X
X
/*
=============
SV_AddBlend
=============
*/
void SV_AddBlend (float r, float g, float b, float a, float *v_blend)
{
X	float	a2, a3;
X
X	if (a <= 0)
X		return;
X	a2 = v_blend[3] + (1-v_blend[3])*a;	// new total alpha
X	a3 = v_blend[3]/a2;		// fraction of color from old
X
X	v_blend[0] = v_blend[0]*a3 + r*(1-a3);
X	v_blend[1] = v_blend[1]*a3 + g*(1-a3);
X	v_blend[2] = v_blend[2]*a3 + b*(1-a3);
X	v_blend[3] = a2;
}
X
X
/*
=============
SV_CalcBlend
=============
*/
void SV_CalcBlend (edict_t *ent)
{
X	int		contents;
X	vec3_t	vieworg;
X	int		remaining;
X
X	ent->client->ps.blend[0] = ent->client->ps.blend[1] = 
X		ent->client->ps.blend[2] = ent->client->ps.blend[3] = 0;
X
X	// add for contents
X	VectorAdd (ent->s.origin, ent->client->ps.viewoffset, vieworg);
X	contents = gi.pointcontents (vieworg);
X	if (contents & (CONTENTS_LAVA|CONTENTS_SLIME|CONTENTS_WATER) )
X		ent->client->ps.rdflags |= RDF_UNDERWATER;
X	else
X		ent->client->ps.rdflags &= ~RDF_UNDERWATER;
X
X	if (contents & (CONTENTS_SOLID|CONTENTS_LAVA))
X		SV_AddBlend (1.0, 0.3, 0.0, 0.6, ent->client->ps.blend);
X	else if (contents & CONTENTS_SLIME)
X		SV_AddBlend (0.0, 0.1, 0.05, 0.6, ent->client->ps.blend);
X	else if (contents & CONTENTS_WATER)
X		SV_AddBlend (0.5, 0.3, 0.2, 0.4, ent->client->ps.blend);
X
X	// add for powerups
X	if (ent->client->quad_framenum > level.framenum)
X	{
X		remaining = ent->client->quad_framenum - level.framenum;
X		if (remaining == 30)	// beginning to fade
X			gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage2.wav"), 1, ATTN_NORM, 0);
X		if (remaining > 30 || (remaining & 4) )
X			SV_AddBlend (0, 0, 1, 0.08, ent->client->ps.blend);
X	}
X	// PMM - double damage
X	else if (ent->client->double_framenum > level.framenum)
X	{
X		remaining = ent->client->double_framenum - level.framenum;
X		if (remaining == 30)	// beginning to fade
X			gi.sound(ent, CHAN_ITEM, gi.soundindex("misc/ddamage2.wav"), 1, ATTN_NORM, 0);
X		if (remaining > 30 || (remaining & 4) )
X			SV_AddBlend (0.9, 0.7, 0, 0.08, ent->client->ps.blend);
X	}
X	// PMM
X	else if (ent->client->invincible_framenum > level.framenum)
X	{
X		remaining = ent->client->invincible_framenum - level.framenum;
X		if (remaining == 30)	// beginning to fade
X			gi.sound(ent, CHAN_ITEM, gi.soundindex("items/protect2.wav"), 1, ATTN_NORM, 0);
X		if (remaining > 30 || (remaining & 4) )
X			SV_AddBlend (1, 1, 0, 0.08, ent->client->ps.blend);
X	}
X	else if (ent->client->enviro_framenum > level.framenum)
X	{
X		remaining = ent->client->enviro_framenum - level.framenum;
X		if (remaining == 30)	// beginning to fade
X			gi.sound(ent, CHAN_ITEM, gi.soundindex("items/airout.wav"), 1, ATTN_NORM, 0);
X		if (remaining > 30 || (remaining & 4) )
X			SV_AddBlend (0, 1, 0, 0.08, ent->client->ps.blend);
X	}
X	else if (ent->client->breather_framenum > level.framenum)
X	{
X		remaining = ent->client->breather_framenum - level.framenum;
X		if (remaining == 30)	// beginning to fade
X			gi.sound(ent, CHAN_ITEM, gi.soundindex("items/airout.wav"), 1, ATTN_NORM, 0);
X		if (remaining > 30 || (remaining & 4) )
X			SV_AddBlend (0.4, 1, 0.4, 0.04, ent->client->ps.blend);
X	}
X
//PGM
X	if(ent->client->nuke_framenum > level.framenum)
X	{
X		float brightness;
X		brightness = (ent->client->nuke_framenum - level.framenum) / 20.0;
X		SV_AddBlend (1, 1, 1, brightness, ent->client->ps.blend);
X	}
X	if (ent->client->ir_framenum > level.framenum)
X	{
X		remaining = ent->client->ir_framenum - level.framenum;
X		if(remaining > 30 || (remaining & 4))
X		{
X			ent->client->ps.rdflags |= RDF_IRGOGGLES;
X			SV_AddBlend (1, 0, 0, 0.2, ent->client->ps.blend);
X		}
X		else
X			ent->client->ps.rdflags &= ~RDF_IRGOGGLES;
X	}
X	else
X	{
X		ent->client->ps.rdflags &= ~RDF_IRGOGGLES;
X	}
//PGM
X
X	// add for damage
X	if (ent->client->damage_alpha > 0)
X		SV_AddBlend (ent->client->damage_blend[0],ent->client->damage_blend[1]
X		,ent->client->damage_blend[2], ent->client->damage_alpha, ent->client->ps.blend);
X
X	if (ent->client->bonus_alpha > 0)
X		SV_AddBlend (0.85, 0.7, 0.3, ent->client->bonus_alpha, ent->client->ps.blend);
X
X	// drop the damage value
X	ent->client->damage_alpha -= 0.06;
X	if (ent->client->damage_alpha < 0)
X		ent->client->damage_alpha = 0;
X
X	// drop the bonus value
X	ent->client->bonus_alpha -= 0.1;
X	if (ent->client->bonus_alpha < 0)
X		ent->client->bonus_alpha = 0;
}
X
X
/*
=================
P_FallingDamage
=================
*/
void P_FallingDamage (edict_t *ent)
{
X	float	delta;
X	int		damage;
X	vec3_t	dir;
X
X	if (ent->s.modelindex != 255)
X		return;		// not in the player model
X
X	if (ent->movetype == MOVETYPE_NOCLIP)
X		return;
X
X	if ((ent->client->oldvelocity[2] < 0) && (ent->velocity[2] > ent->client->oldvelocity[2]) && (!ent->groundentity))
X	{
X		delta = ent->client->oldvelocity[2];
X	}
X	else
X	{
X		if (!ent->groundentity)
X			return;
X		delta = ent->velocity[2] - ent->client->oldvelocity[2];
X	}
X	delta = delta*delta * 0.0001;
X
X	// never take falling damage if completely underwater
X	if (ent->waterlevel == 3)
X		return;
X	if (ent->waterlevel == 2)
X		delta *= 0.25;
X	if (ent->waterlevel == 1)
X		delta *= 0.5;
X
X	if (delta < 1)
X		return;
X
X	if (delta < 15)
X	{
X		ent->s.event = EV_FOOTSTEP;
X		return;
X	}
X
X	ent->client->fall_value = delta*0.5;
X	if (ent->client->fall_value > 40)
X		ent->client->fall_value = 40;
X	ent->client->fall_time = level.time + FALL_TIME;
X
X	if (delta > 30)
X	{
X		if (ent->health > 0)
X		{
X			if (delta >= 55)
X				ent->s.event = EV_FALLFAR;
X			else
X				ent->s.event = EV_FALL;
X		}
X		ent->pain_debounce_time = level.time;	// no normal pain sound
X		damage = (delta-30)/2;
X		if (damage < 1)
X			damage = 1;
X		VectorSet (dir, 0, 0, 1);
X
X		if (!deathmatch->value || !((int)dmflags->value & DF_NO_FALLING) )
X			T_Damage (ent, world, world, dir, ent->s.origin, vec3_origin, damage, 0, 0, MOD_FALLING);
X	}
X	else
X	{
X		ent->s.event = EV_FALLSHORT;
X		return;
X	}
}
X
X
X
/*
=============
P_WorldEffects
=============
*/
void P_WorldEffects (void)
{
X	qboolean	breather;
X	qboolean	envirosuit;
X	int			waterlevel, old_waterlevel;
X
X	if (current_player->movetype == MOVETYPE_NOCLIP)
X	{
X		current_player->air_finished = level.time + 12;	// don't need air
X		return;
X	}
X
X	waterlevel = current_player->waterlevel;
X	old_waterlevel = current_client->old_waterlevel;
X	current_client->old_waterlevel = waterlevel;
X
X	breather = current_client->breather_framenum > level.framenum;
X	envirosuit = current_client->enviro_framenum > level.framenum;
X
X	//
X	// if just entered a water volume, play a sound
X	//
X	if (!old_waterlevel && waterlevel)
X	{
X		PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
X		if (current_player->watertype & CONTENTS_LAVA)
X			gi.sound (current_player, CHAN_BODY, gi.soundindex("player/lava_in.wav"), 1, ATTN_NORM, 0);
X		else if (current_player->watertype & CONTENTS_SLIME)
X			gi.sound (current_player, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
X		else if (current_player->watertype & CONTENTS_WATER)
X			gi.sound (current_player, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
X		current_player->flags |= FL_INWATER;
X
X		// clear damage_debounce, so the pain sound will play immediately
X		current_player->damage_debounce_time = level.time - 1;
X	}
X
X	//
X	// if just completely exited a water volume, play a sound
X	//
X	if (old_waterlevel && ! waterlevel)
X	{
X		PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
X		gi.sound (current_player, CHAN_BODY, gi.soundindex("player/watr_out.wav"), 1, ATTN_NORM, 0);
X		current_player->flags &= ~FL_INWATER;
X	}
X
X	//
X	// check for head just going under water
X	//
X	if (old_waterlevel != 3 && waterlevel == 3)
X	{
X		gi.sound (current_player, CHAN_BODY, gi.soundindex("player/watr_un.wav"), 1, ATTN_NORM, 0);
X	}
X
X	//
X	// check for head just coming out of water
X	//
X	if (old_waterlevel == 3 && waterlevel != 3)
X	{
X		if (current_player->air_finished < level.time)
X		{	// gasp for air
X			gi.sound (current_player, CHAN_VOICE, gi.soundindex("player/gasp1.wav"), 1, ATTN_NORM, 0);
X			PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
X		}
X		else  if (current_player->air_finished < level.time + 11)
X		{	// just break surface
X			gi.sound (current_player, CHAN_VOICE, gi.soundindex("player/gasp2.wav"), 1, ATTN_NORM, 0);
X		}
X	}
X
X	//
X	// check for drowning
X	//
X	if (waterlevel == 3)
X	{
X		// breather or envirosuit give air
X		if (breather || envirosuit)
X		{
X			current_player->air_finished = level.time + 10;
X
X			if (((int)(current_client->breather_framenum - level.framenum) % 25) == 0)
X			{
X				if (!current_client->breather_sound)
X					gi.sound (current_player, CHAN_AUTO, gi.soundindex("player/u_breath1.wav"), 1, ATTN_NORM, 0);
X				else
X					gi.sound (current_player, CHAN_AUTO, gi.soundindex("player/u_breath2.wav"), 1, ATTN_NORM, 0);
X				current_client->breather_sound ^= 1;
X				PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
X				//FIXME: release a bubble?
X			}
X		}
X
X		// if out of air, start drowning
X		if (current_player->air_finished < level.time)
X		{	// drown!
X			if (current_player->client->next_drown_time < level.time 
X				&& current_player->health > 0)
X			{
X				current_player->client->next_drown_time = level.time + 1;
X
X				// take more damage the longer underwater
X				current_player->dmg += 2;
X				if (current_player->dmg > 15)
X					current_player->dmg = 15;
X
X				// play a gurp sound instead of a normal pain sound
X				if (current_player->health <= current_player->dmg)
X					gi.sound (current_player, CHAN_VOICE, gi.soundindex("player/drown1.wav"), 1, ATTN_NORM, 0);
X				else if (rand()&1)
X					gi.sound (current_player, CHAN_VOICE, gi.soundindex("*gurp1.wav"), 1, ATTN_NORM, 0);
X				else
X					gi.sound (current_player, CHAN_VOICE, gi.soundindex("*gurp2.wav"), 1, ATTN_NORM, 0);
X
X				current_player->pain_debounce_time = level.time;
X
X				T_Damage (current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, current_player->dmg, 0, DAMAGE_NO_ARMOR, MOD_WATER);
X			}
X		}
X	}
X	else
X	{
X		current_player->air_finished = level.time + 12;
X		current_player->dmg = 2;
X	}
X
X	//
X	// check for sizzle damage
X	//
X	if (waterlevel && (current_player->watertype&(CONTENTS_LAVA|CONTENTS_SLIME)) )
X	{
X		if (current_player->watertype & CONTENTS_LAVA)
X		{
X			if (current_player->health > 0
X				&& current_player->pain_debounce_time <= level.time
X				&& current_client->invincible_framenum < level.framenum)
X			{
X				if (rand()&1)
X					gi.sound (current_player, CHAN_VOICE, gi.soundindex("player/burn1.wav"), 1, ATTN_NORM, 0);
X				else
X					gi.sound (current_player, CHAN_VOICE, gi.soundindex("player/burn2.wav"), 1, ATTN_NORM, 0);
X				current_player->pain_debounce_time = level.time + 1;
X			}
X
X			if (envirosuit)	// take 1/3 damage with envirosuit
X				T_Damage (current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, 1*waterlevel, 0, 0, MOD_LAVA);
X			else
X				T_Damage (current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, 3*waterlevel, 0, 0, MOD_LAVA);
X		}
X
X		if (current_player->watertype & CONTENTS_SLIME)
X		{
X			if (!envirosuit)
X			{	// no damage from slime with envirosuit
X				T_Damage (current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, 1*waterlevel, 0, 0, MOD_SLIME);
X			}
X		}
X	}
}
X
X
/*
===============
G_SetClientEffects
===============
*/
void G_SetClientEffects (edict_t *ent)
{
X	int		pa_type;
X	int		remaining;
X
X	ent->s.effects = 0;
//	ent->s.renderfx = 0;
X
X	// PGM - player is always ir visible, even dead.
X	ent->s.renderfx = RF_IR_VISIBLE;
X
X	if (ent->health <= 0 || level.intermissiontime)
X		return;
X
//=========
//PGM
X	if(ent->flags & FL_DISGUISED)
X		ent->s.renderfx |= RF_USE_DISGUISE;
X
X	if (gamerules && gamerules->value)
X	{
X		if(DMGame.PlayerEffects)
X			DMGame.PlayerEffects(ent);
X	}
//PGM
//=========
X
X	if (ent->powerarmor_time > level.time)
X	{
X		pa_type = PowerArmorType (ent);
X		if (pa_type == POWER_ARMOR_SCREEN)
X		{
X			ent->s.effects |= EF_POWERSCREEN;
X		}
X		else if (pa_type == POWER_ARMOR_SHIELD)
X		{
X			ent->s.effects |= EF_COLOR_SHELL;
X			ent->s.renderfx |= RF_SHELL_GREEN;
X		}
X	}
X
X	if (ent->client->quad_framenum > level.framenum)
X	{
X		remaining = ent->client->quad_framenum - level.framenum;
X		if (remaining > 30 || (remaining & 4) )
X			ent->s.effects |= EF_QUAD;
X	}
X
//=======
//ROGUE
X	if (ent->client->double_framenum > level.framenum)
X	{
X		remaining = ent->client->double_framenum - level.framenum;
X		if (remaining > 30 || (remaining & 4) )
X			ent->s.effects |= EF_DOUBLE;
X	}
X	if ((ent->client->owned_sphere) && (ent->client->owned_sphere->spawnflags == 1))
X	{
X		ent->s.effects |= EF_HALF_DAMAGE;
X	}
X	if (ent->client->tracker_pain_framenum > level.framenum)
X	{
X		ent->s.effects |= EF_TRACKERTRAIL;
X	}
//ROGUE
//=======
X
X	if (ent->client->invincible_framenum > level.framenum)
X	{
X		remaining = ent->client->invincible_framenum - level.framenum;
X		if (remaining > 30 || (remaining & 4) )
X			ent->s.effects |= EF_PENT;
X	}
X
X	// show cheaters!!!
X	if (ent->flags & FL_GODMODE)
X	{
X		ent->s.effects |= EF_COLOR_SHELL;
X		ent->s.renderfx |= (RF_SHELL_RED|RF_SHELL_GREEN|RF_SHELL_BLUE);
X	}
X
//PGM
/*
X	if (ent->client->torch_framenum > level.framenum)
X	{
X		gi.WriteByte (svc_temp_entity);
X		gi.WriteByte (TE_FLASHLIGHT);
X		gi.WritePosition (ent->s.origin);
X		gi.WriteShort (ent - g_edicts);
X		gi.multicast (ent->s.origin, MULTICAST_PVS);
X	}
*/
//PGM
}
X
X
/*
===============
G_SetClientEvent
===============
*/
void G_SetClientEvent (edict_t *ent)
{
X	if (ent->s.event)
X		return;
X
X	if ( ent->groundentity && xyspeed > 225)
X	{
X		if ( (int)(current_client->bobtime+bobmove) != bobcycle )
X			ent->s.event = EV_FOOTSTEP;
X	}
}
X
/*
===============
G_SetClientSound
===============
*/
void G_SetClientSound (edict_t *ent)
{
X	char	*weap;
X
X	if (ent->client->pers.game_helpchanged != game.helpchanged)
X	{
X		ent->client->pers.game_helpchanged = game.helpchanged;
X		ent->client->pers.helpchanged = 1;
X	}
X
X	// help beep (no more than three times)
X	if (ent->client->pers.helpchanged && ent->client->pers.helpchanged <= 3 && !(level.framenum&63) )
X	{
X		ent->client->pers.helpchanged++;
X		gi.sound (ent, CHAN_VOICE, gi.soundindex ("misc/pc_up.wav"), 1, ATTN_STATIC, 0);
X	}
X
X
X	if (ent->client->pers.weapon)
X		weap = ent->client->pers.weapon->classname;
X	else
X		weap = "";
X
X	if (ent->waterlevel && (ent->watertype&(CONTENTS_LAVA|CONTENTS_SLIME)) )
X		ent->s.sound = snd_fry;
X	else if (strcmp(weap, "weapon_railgun") == 0)
X		ent->s.sound = gi.soundindex("weapons/rg_hum.wav");
X	else if (strcmp(weap, "weapon_bfg") == 0)
X		ent->s.sound = gi.soundindex("weapons/bfg_hum.wav");
X	else if (ent->client->weapon_sound)
X		ent->s.sound = ent->client->weapon_sound;
X	else
X		ent->s.sound = 0;
}
X
/*
===============
G_SetClientFrame
===============
*/
void G_SetClientFrame (edict_t *ent)
{
X	gclient_t	*client;
X	qboolean	duck, run;
X
X	if (ent->s.modelindex != 255)
X		return;		// not in the player model
X
X	client = ent->client;
X
X	if (client->ps.pmove.pm_flags & PMF_DUCKED)
X		duck = true;
X	else
X		duck = false;
X	if (xyspeed)
X		run = true;
X	else
X		run = false;
X
X	// check for stand/duck and stop/go transitions
X	if (duck != client->anim_duck && client->anim_priority < ANIM_DEATH)
X		goto newanim;
X	if (run != client->anim_run && client->anim_priority == ANIM_BASIC)
X		goto newanim;
X	if (!ent->groundentity && client->anim_priority <= ANIM_WAVE)
X		goto newanim;
X
X	if(client->anim_priority == ANIM_REVERSE)
X	{
X		if(ent->s.frame > client->anim_end)
X		{
X			ent->s.frame--;
X			return;
X		}
X	}
X	else if (ent->s.frame < client->anim_end)
X	{	// continue an animation
X		ent->s.frame++;
X		return;
X	}
X
X	if (client->anim_priority == ANIM_DEATH)
X		return;		// stay there
X	if (client->anim_priority == ANIM_JUMP)
X	{
X		if (!ent->groundentity)
X			return;		// stay there
X		ent->client->anim_priority = ANIM_WAVE;
X		ent->s.frame = FRAME_jump3;
X		ent->client->anim_end = FRAME_jump6;
X		return;
X	}
X
newanim:
X	// return to either a running or standing frame
X	client->anim_priority = ANIM_BASIC;
X	client->anim_duck = duck;
X	client->anim_run = run;
X
X	if (!ent->groundentity)
X	{
X		client->anim_priority = ANIM_JUMP;
X		if (ent->s.frame != FRAME_jump2)
X			ent->s.frame = FRAME_jump1;
X		client->anim_end = FRAME_jump2;
X	}
X	else if (run)
X	{	// running
X		if (duck)
X		{
X			ent->s.frame = FRAME_crwalk1;
X			client->anim_end = FRAME_crwalk6;
X		}
X		else
X		{
X			ent->s.frame = FRAME_run1;
X			client->anim_end = FRAME_run6;
X		}
X	}
X	else
X	{	// standing
X		if (duck)
X		{
X			ent->s.frame = FRAME_crstnd01;
X			client->anim_end = FRAME_crstnd19;
X		}
X		else
X		{
X			ent->s.frame = FRAME_stand01;
X			client->anim_end = FRAME_stand40;
X		}
X	}
}
X
X
/*
=================
ClientEndServerFrame
X
Called for each player at the end of the server frame
and right after spawning
=================
*/
void ClientEndServerFrame (edict_t *ent)
{
X	float	bobtime;
X	int		i;
X
X	current_player = ent;
X	current_client = ent->client;
X
X	//
X	// If the origin or velocity have changed since ClientThink(),
X	// update the pmove values.  This will happen when the client
X	// is pushed by a bmodel or kicked by an explosion.
X	// 
X	// If it wasn't updated here, the view position would lag a frame
X	// behind the body position when pushed -- "sinking into plats"
X	//
X	for (i=0 ; i<3 ; i++)
X	{
X		current_client->ps.pmove.origin[i] = ent->s.origin[i]*8.0;
X		current_client->ps.pmove.velocity[i] = ent->velocity[i]*8.0;
X	}
X
X	//
X	// If the end of unit layout is displayed, don't give
X	// the player any normal movement attributes
X	//
X	if (level.intermissiontime)
X	{
X		// FIXME: add view drifting here?
X		current_client->ps.blend[3] = 0;
X		current_client->ps.fov = 90;
X		G_SetStats (ent);
X		return;
X	}
X
X	AngleVectors (ent->client->v_angle, forward, right, up);
X
X	// burn from lava, etc
X	P_WorldEffects ();
X
X	//
X	// set model angles from view angles so other things in
X	// the world can tell which direction you are looking
X	//
X	if (ent->client->v_angle[PITCH] > 180)
X		ent->s.angles[PITCH] = (-360 + ent->client->v_angle[PITCH])/3;
X	else
X		ent->s.angles[PITCH] = ent->client->v_angle[PITCH]/3;
X	ent->s.angles[YAW] = ent->client->v_angle[YAW];
X	ent->s.angles[ROLL] = 0;
X	ent->s.angles[ROLL] = SV_CalcRoll (ent->s.angles, ent->velocity)*4;
X
X	//
X	// calculate speed and cycle to be used for
X	// all cyclic walking effects
X	//
X	xyspeed = sqrt(ent->velocity[0]*ent->velocity[0] + ent->velocity[1]*ent->velocity[1]);
X
X	if (xyspeed < 5)
X	{
X		bobmove = 0;
X		current_client->bobtime = 0;	// start at beginning of cycle again
X	}
X	else if (ent->groundentity)
X	{	// so bobbing only cycles when on ground
X		if (xyspeed > 210)
X			bobmove = 0.25;
X		else if (xyspeed > 100)
X			bobmove = 0.125;
X		else
X			bobmove = 0.0625;
X	}
X	
X	bobtime = (current_client->bobtime += bobmove);
X
X	if (current_client->ps.pmove.pm_flags & PMF_DUCKED)
X		bobtime *= 4;
X
X	bobcycle = (int)bobtime;
X	bobfracsin = fabs(sin(bobtime*M_PI));
X
X	// detect hitting the floor
X	P_FallingDamage (ent);
X
X	// apply all the damage taken this frame
X	P_DamageFeedback (ent);
X
X	// determine the view offsets
X	SV_CalcViewOffset (ent);
X
X	// determine the gun offsets
X	SV_CalcGunOffset (ent);
X
X	// determine the full screen color blend
X	// must be after viewoffset, so eye contents can be
X	// accurately determined
X	// FIXME: with client prediction, the contents
X	// should be determined by the client
X	SV_CalcBlend (ent);
X
X	// chase cam stuff
X	if (ent->client->resp.spectator)
X		G_SetSpectatorStats(ent);
X	else
X		G_SetStats (ent);
X
X	G_CheckChaseStats(ent);
X
X	G_SetClientEvent (ent);
X
X	G_SetClientEffects (ent);
X
X	G_SetClientSound (ent);
X
X	G_SetClientFrame (ent);
X
X	VectorCopy (ent->velocity, ent->client->oldvelocity);
X	VectorCopy (ent->client->ps.viewangles, ent->client->oldviewangles);
X
X	// clear weapon kicks
X	VectorClear (ent->client->kick_origin);
X	VectorClear (ent->client->kick_angles);
X
X	// if the scoreboard is up, update it
X	if (ent->client->showscores && !(level.framenum & 31) )
X	{
X		DeathmatchScoreboardMessage (ent, ent->enemy);
X		gi.unicast (ent, false);
X	}
}
X
SHAR_EOF
  $shar_touch -am 1130175398 'p_view.c' &&
  chmod 0664 'p_view.c' ||
  $echo 'restore of' 'p_view.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'p_view.c:' 'MD5 check failed'
76d6d68e7486ee6ec0a6c15685b47a2f  p_view.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'p_view.c'`"
    test 28402 -eq "$shar_count" ||
    $echo 'p_view.c:' 'original size' '28402,' 'current size' "$shar_count!"
  fi
fi
# ============= p_weapon.c ==============
if test -f 'p_weapon.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'p_weapon.c' '(file already exists)'
else
  $echo 'x -' extracting 'p_weapon.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'p_weapon.c' &&
// g_weapon.c
X
#include "g_local.h"
#include "m_player.h"
X
X
static qboolean	is_quad;
static byte		is_silenced;
X
//PGM
static byte		damage_multiplier;
//PGM
X
void weapon_grenade_fire (edict_t *ent, qboolean held);
X
//========
//ROGUE
byte P_DamageModifier(edict_t *ent)
{
X	is_quad = 0;
X	damage_multiplier = 1;
X
X	if(ent->client->quad_framenum > level.framenum)
X	{
X		damage_multiplier *= 4;
X		is_quad = 1;
X
X		// if we're quad and DF_NO_STACK_DOUBLE is on, return now.
X		if(((int)(dmflags->value) & DF_NO_STACK_DOUBLE))
X			return damage_multiplier;
X	}
X	if(ent->client->double_framenum > level.framenum)
X	{
X		if ((deathmatch->value) || (damage_multiplier == 1))
X		{
X			damage_multiplier *= 2;
X			is_quad = 1;
X		}
X	}
X	
X	return damage_multiplier;
}
//ROGUE
//========
X
static void P_ProjectSource (gclient_t *client, vec3_t point, vec3_t distance, vec3_t forward, vec3_t right, vec3_t result)
{
X	vec3_t	_distance;
X
X	VectorCopy (distance, _distance);
X	if (client->pers.hand == LEFT_HANDED)
X		_distance[1] *= -1;
X	else if (client->pers.hand == CENTER_HANDED)
X		_distance[1] = 0;
X	G_ProjectSource (point, _distance, forward, right, result);
}
X
static void P_ProjectSource2 (gclient_t *client, vec3_t point, vec3_t distance, vec3_t forward, 
X							  vec3_t right, vec3_t up, vec3_t result)
{
X	vec3_t	_distance;
X
X	VectorCopy (distance, _distance);
X	if (client->pers.hand == LEFT_HANDED)
X		_distance[1] *= -1;
X	else if (client->pers.hand == CENTER_HANDED)
X		_distance[1] = 0;
X	G_ProjectSource2 (point, _distance, forward, right, up, result);
}
X
/*
===============
PlayerNoise
X
Each player can have two noise objects associated with it:
a personal noise (jumping, pain, weapon firing), and a weapon
target noise (bullet wall impacts)
X
Monsters that don't directly see the player can move
to a noise in hopes of seeing the player from there.
===============
*/
void PlayerNoise(edict_t *who, vec3_t where, int type)
{
X	edict_t		*noise;
X
X	if (type == PNOISE_WEAPON)
X	{
X		if (who->client->silencer_shots)
X		{
X			who->client->silencer_shots--;
X			return;
X		}
X	}
X
X	if (deathmatch->value)
X		return;
X
X	if (who->flags & FL_NOTARGET)
X		return;
X
X	if (who->flags & FL_DISGUISED)
X	{
X		if (type == PNOISE_WEAPON)
X		{
X			level.disguise_violator = who;
X			level.disguise_violation_framenum = level.framenum + 5;
X		}
X		else
X			return;
X	}
X
X	if (!who->mynoise)
X	{
X		noise = G_Spawn();
X		noise->classname = "player_noise";
X		VectorSet (noise->mins, -8, -8, -8);
X		VectorSet (noise->maxs, 8, 8, 8);
X		noise->owner = who;
X		noise->svflags = SVF_NOCLIENT;
X		who->mynoise = noise;
X
X		noise = G_Spawn();
X		noise->classname = "player_noise";
X		VectorSet (noise->mins, -8, -8, -8);
X		VectorSet (noise->maxs, 8, 8, 8);
X		noise->owner = who;
X		noise->svflags = SVF_NOCLIENT;
X		who->mynoise2 = noise;
X	}
X
X	if (type == PNOISE_SELF || type == PNOISE_WEAPON)
X	{
X		noise = who->mynoise;
X		level.sound_entity = noise;
X		level.sound_entity_framenum = level.framenum;
X	}
X	else // type == PNOISE_IMPACT
X	{
X		noise = who->mynoise2;
X		level.sound2_entity = noise;
X		level.sound2_entity_framenum = level.framenum;
X	}
X
X	VectorCopy (where, noise->s.origin);
X	VectorSubtract (where, noise->maxs, noise->absmin);
X	VectorAdd (where, noise->maxs, noise->absmax);
X	noise->teleport_time = level.time;
X	gi.linkentity (noise);
}
X
X
qboolean Pickup_Weapon (edict_t *ent, edict_t *other)
{
X	int			index;
X	gitem_t		*ammo;
X
X	index = ITEM_INDEX(ent->item);
X
X	if ( ( ((int)(dmflags->value) & DF_WEAPONS_STAY) || coop->value) 
X		&& other->client->pers.inventory[index])
X	{
X		if (!(ent->spawnflags & (DROPPED_ITEM | DROPPED_PLAYER_ITEM) ) )
X			return false;	// leave the weapon for others to pickup
X	}
X
X	other->client->pers.inventory[index]++;
X
X	if (!(ent->spawnflags & DROPPED_ITEM) )
X	{
X		// give them some ammo with it
X		// PGM -- IF APPROPRIATE!
X		if(ent->item->ammo)			//PGM
X		{
X			ammo = FindItem (ent->item->ammo);
X			if ( (int)dmflags->value & DF_INFINITE_AMMO )
X				Add_Ammo (other, ammo, 1000);
X			else
X				Add_Ammo (other, ammo, ammo->quantity);
X		}
X
X		if (! (ent->spawnflags & DROPPED_PLAYER_ITEM) )
X		{
X			if (deathmatch->value)
X			{
X				if ((int)(dmflags->value) & DF_WEAPONS_STAY)
X					ent->flags |= FL_RESPAWN;
X				else
X					SetRespawn (ent, 30);
X			}
X			if (coop->value)
X				ent->flags |= FL_RESPAWN;
X		}
X	}
X
X	if (other->client->pers.weapon != ent->item && 
X		(other->client->pers.inventory[index] == 1) &&
X		( !deathmatch->value || other->client->pers.weapon == FindItem("blaster") ) )
X		other->client->newweapon = ent->item;
X
X	return true;
}
X
X
/*
===============
ChangeWeapon
X
The old weapon has been dropped all the way, so make the new one
current
===============
*/
void ChangeWeapon (edict_t *ent)
{
X	int i;
X
X	if (ent->client->grenade_time)
X	{
X		ent->client->grenade_time = level.time;
X		ent->client->weapon_sound = 0;
X		weapon_grenade_fire (ent, false);
X		ent->client->grenade_time = 0;
X	}
X
X	ent->client->pers.lastweapon = ent->client->pers.weapon;
X	ent->client->pers.weapon = ent->client->newweapon;
X	ent->client->newweapon = NULL;
X	ent->client->machinegun_shots = 0;
X
X	// set visible model
X	if (ent->s.modelindex == 255)
X	{
X		if (ent->client->pers.weapon)
X			i = ((ent->client->pers.weapon->weapmodel & 0xff) << 8);
X		else
X			i = 0;
X		ent->s.skinnum = (ent - g_edicts - 1) | i;
X	}
X
X	if (ent->client->pers.weapon && ent->client->pers.weapon->ammo)
X		ent->client->ammo_index = ITEM_INDEX(FindItem(ent->client->pers.weapon->ammo));
X	else
X		ent->client->ammo_index = 0;
X
X	if (!ent->client->pers.weapon)
X	{	// dead
X		ent->client->ps.gunindex = 0;
X		return;
X	}
X
X	ent->client->weaponstate = WEAPON_ACTIVATING;
X	ent->client->ps.gunframe = 0;
X	ent->client->ps.gunindex = gi.modelindex(ent->client->pers.weapon->view_model);
X
X	ent->client->anim_priority = ANIM_PAIN;
X	if(ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X	{
X			ent->s.frame = FRAME_crpain1;
X			ent->client->anim_end = FRAME_crpain4;
X	}
X	else
X	{
X			ent->s.frame = FRAME_pain301;
X			ent->client->anim_end = FRAME_pain304;
X			
X	}
}
X
/*
=================
NoAmmoWeaponChange
=================
*/
X
// PMM - added rogue weapons to the list
X
void NoAmmoWeaponChange (edict_t *ent)
{
X	if ( ent->client->pers.inventory[ITEM_INDEX(FindItem("slugs"))]
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("railgun"))] )
X	{
X		ent->client->newweapon = FindItem ("railgun");
X		return;
X	}
X	// ROGUE
X	if ( (ent->client->pers.inventory[ITEM_INDEX(FindItem("cells"))] >= 2)
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("Plasma Beam"))] )
X	{
X		ent->client->newweapon = FindItem ("Plasma Beam");
X		return;
X	}
X	// -ROGUE
X	/*
X	if ( ent->client->pers.inventory[ITEM_INDEX(FindItem("cells"))]
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("hyperblaster"))] )
X	{
X		ent->client->newweapon = FindItem ("hyperblaster");
X		return;
X	}
X	*/
X	// ROGUE
X	if ( ent->client->pers.inventory[ITEM_INDEX(FindItem("flechettes"))]
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("etf rifle"))] )
X	{
X		ent->client->newweapon = FindItem ("etf rifle");
X		return;
X	}
X	// -ROGUE
X	if ( ent->client->pers.inventory[ITEM_INDEX(FindItem("bullets"))]
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("chaingun"))] )
X	{
X		ent->client->newweapon = FindItem ("chaingun");
X		return;
X	}
X	if ( ent->client->pers.inventory[ITEM_INDEX(FindItem("bullets"))]
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("machinegun"))] )
X	{
X		ent->client->newweapon = FindItem ("machinegun");
X		return;
X	}
X	if ( ent->client->pers.inventory[ITEM_INDEX(FindItem("shells"))] > 1
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("super shotgun"))] )
X	{
X		ent->client->newweapon = FindItem ("super shotgun");
X		return;
X	}
X	if ( ent->client->pers.inventory[ITEM_INDEX(FindItem("shells"))]
X		&&  ent->client->pers.inventory[ITEM_INDEX(FindItem("shotgun"))] )
X	{
X		ent->client->newweapon = FindItem ("shotgun");
X		return;
X	}
X	ent->client->newweapon = FindItem ("blaster");
}
X
/*
=================
Think_Weapon
X
Called by ClientBeginServerFrame and ClientThink
=================
*/
void Think_Weapon (edict_t *ent)
{
X	// if just died, put the weapon away
X	if (ent->health < 1)
X	{
X		ent->client->newweapon = NULL;
X		ChangeWeapon (ent);
X	}
X
X	// call active weapon think routine
X	if (ent->client->pers.weapon && ent->client->pers.weapon->weaponthink)
X	{
//PGM
X		P_DamageModifier(ent);	
//		is_quad = (ent->client->quad_framenum > level.framenum);
//PGM
X		if (ent->client->silencer_shots)
X			is_silenced = MZ_SILENCED;
X		else
X			is_silenced = 0;
X		ent->client->pers.weapon->weaponthink (ent);
X	}
}
X
X
/*
================
Use_Weapon
X
Make the weapon ready if there is ammo
================
*/
void Use_Weapon (edict_t *ent, gitem_t *item)
{
X	int			ammo_index;
X	gitem_t		*ammo_item;
X
X	// see if we're already using it
X	if (item == ent->client->pers.weapon)
X		return;
X
X	if (item->ammo && !g_select_empty->value && !(item->flags & IT_AMMO))
X	{
X		ammo_item = FindItem(item->ammo);
X		ammo_index = ITEM_INDEX(ammo_item);
X
X		if (!ent->client->pers.inventory[ammo_index])
X		{
X			gi.cprintf (ent, PRINT_HIGH, "No %s for %s.\n", ammo_item->pickup_name, item->pickup_name);
X			return;
X		}
X
X		if (ent->client->pers.inventory[ammo_index] < item->quantity)
X		{
X			gi.cprintf (ent, PRINT_HIGH, "Not enough %s for %s.\n", ammo_item->pickup_name, item->pickup_name);
X			return;
X		}
X	}
X
X	// change to this weapon when down
X	ent->client->newweapon = item;
}
X
X
X
/*
================
Drop_Weapon
================
*/
void Drop_Weapon (edict_t *ent, gitem_t *item)
{
X	int		index;
X
X	if ((int)(dmflags->value) & DF_WEAPONS_STAY)
X		return;
X
X	index = ITEM_INDEX(item);
X	// see if we're already using it
X	if ( ((item == ent->client->pers.weapon) || (item == ent->client->newweapon))&& (ent->client->pers.inventory[index] == 1) )
X	{
X		gi.cprintf (ent, PRINT_HIGH, "Can't drop current weapon\n");
X		return;
X	}
X
X	Drop_Item (ent, item);
X	ent->client->pers.inventory[index]--;
}
X
X
/*
================
Weapon_Generic
X
A generic function to handle the basics of weapon thinking
================
*/
#define FRAME_FIRE_FIRST		(FRAME_ACTIVATE_LAST + 1)
#define FRAME_IDLE_FIRST		(FRAME_FIRE_LAST + 1)
#define FRAME_DEACTIVATE_FIRST	(FRAME_IDLE_LAST + 1)
X
void Weapon_Generic (edict_t *ent, int FRAME_ACTIVATE_LAST, int FRAME_FIRE_LAST, int FRAME_IDLE_LAST, int FRAME_DEACTIVATE_LAST, int *pause_frames, int *fire_frames, void (*fire)(edict_t *ent))
{
X	int		n;
X
X	if(ent->deadflag || ent->s.modelindex != 255) // VWep animations screw up corpses
X	{
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_DROPPING)
X	{
X		if (ent->client->ps.gunframe == FRAME_DEACTIVATE_LAST)
X		{
X			ChangeWeapon (ent);
X			return;
X		}
X		else if ((FRAME_DEACTIVATE_LAST - ent->client->ps.gunframe) == 4)
X		{
X			ent->client->anim_priority = ANIM_REVERSE;
X			if(ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X			{
X				ent->s.frame = FRAME_crpain4+1;
X				ent->client->anim_end = FRAME_crpain1;
X			}
X			else
X			{
X				ent->s.frame = FRAME_pain304+1;
X				ent->client->anim_end = FRAME_pain301;
X				
X			}
X		}
X
X		ent->client->ps.gunframe++;
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_ACTIVATING)
X	{
X		if (ent->client->ps.gunframe == FRAME_ACTIVATE_LAST)
X		{
X			ent->client->weaponstate = WEAPON_READY;
X			ent->client->ps.gunframe = FRAME_IDLE_FIRST;
X			return;
X		}
X
X		ent->client->ps.gunframe++;
X		return;
X	}
X
X	if ((ent->client->newweapon) && (ent->client->weaponstate != WEAPON_FIRING))
X	{
X		ent->client->weaponstate = WEAPON_DROPPING;
X		ent->client->ps.gunframe = FRAME_DEACTIVATE_FIRST;
X
X		if ((FRAME_DEACTIVATE_LAST - FRAME_DEACTIVATE_FIRST) < 4)
X		{
X			ent->client->anim_priority = ANIM_REVERSE;
X			if(ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X			{
X				ent->s.frame = FRAME_crpain4+1;
X				ent->client->anim_end = FRAME_crpain1;
X			}
X			else
X			{
X				ent->s.frame = FRAME_pain304+1;
X				ent->client->anim_end = FRAME_pain301;
X				
X			}
X		}
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_READY)
X	{
X		if ( ((ent->client->latched_buttons|ent->client->buttons) & BUTTON_ATTACK) )
X		{
X			ent->client->latched_buttons &= ~BUTTON_ATTACK;
X			if ((!ent->client->ammo_index) || 
X				( ent->client->pers.inventory[ent->client->ammo_index] >= ent->client->pers.weapon->quantity))
X			{
X				ent->client->ps.gunframe = FRAME_FIRE_FIRST;
X				ent->client->weaponstate = WEAPON_FIRING;
X
X				// start the animation
X				ent->client->anim_priority = ANIM_ATTACK;
X				if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X				{
X					ent->s.frame = FRAME_crattak1-1;
X					ent->client->anim_end = FRAME_crattak9;
X				}
X				else
X				{
X					ent->s.frame = FRAME_attack1-1;
X					ent->client->anim_end = FRAME_attack8;
X				}
X			}
X			else
X			{
X				if (level.time >= ent->pain_debounce_time)
X				{
X					gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/noammo.wav"), 1, ATTN_NORM, 0);
X					ent->pain_debounce_time = level.time + 1;
X				}
X				NoAmmoWeaponChange (ent);
X			}
X		}
X		else
X		{
X			if (ent->client->ps.gunframe == FRAME_IDLE_LAST)
X			{
X				ent->client->ps.gunframe = FRAME_IDLE_FIRST;
X				return;
X			}
X
X			if (pause_frames)
X			{
X				for (n = 0; pause_frames[n]; n++)
X				{
X					if (ent->client->ps.gunframe == pause_frames[n])
X					{
X						if (rand()&15)
X							return;
X					}
X				}
X			}
X
X			ent->client->ps.gunframe++;
X			return;
X		}
X	}
X
X	if (ent->client->weaponstate == WEAPON_FIRING)
X	{
X		for (n = 0; fire_frames[n]; n++)
X		{
X			if (ent->client->ps.gunframe == fire_frames[n])
X			{
X				// FIXME - double should use different sound
X				if (ent->client->quad_framenum > level.framenum)
X					gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
X				else if (ent->client->double_framenum > level.framenum)
X					gi.sound(ent, CHAN_ITEM, gi.soundindex("misc/ddamage3.wav"), 1, ATTN_NORM, 0);
X
X				fire (ent);
X				break;
X			}
X		}
X
X		if (!fire_frames[n])
X			ent->client->ps.gunframe++;
X
X		if (ent->client->ps.gunframe == FRAME_IDLE_FIRST+1)
X			ent->client->weaponstate = WEAPON_READY;
X	}
}
X
X
/*
======================================================================
X
GRENADE
X
======================================================================
*/
X
#define GRENADE_TIMER		3.0
#define GRENADE_MINSPEED	400
#define GRENADE_MAXSPEED	800
X
void weapon_grenade_fire (edict_t *ent, qboolean held)
{
X	vec3_t	offset;
X	vec3_t	forward, right, up;
X	vec3_t	start;
X	int		damage = 125;
X	float	timer;
X	int		speed;
X	float	radius;
X
X	radius = damage+40;
X	if (is_quad)
//		damage *= 4;
X		damage *= damage_multiplier;		// PGM
X
X	AngleVectors (ent->client->v_angle, forward, right, up);
X	if (ent->client->pers.weapon->tag == AMMO_TESLA)
X	{
//		VectorSet(offset, 0, -12, ent->viewheight-26);
X		VectorSet(offset, 0, -4, ent->viewheight-22);
X	}
X	else
X	{
//		VectorSet(offset, 8, 8, ent->viewheight-8);
X		VectorSet(offset, 2, 6, ent->viewheight-14);
X	}
X	P_ProjectSource2 (ent->client, ent->s.origin, offset, forward, right, up, start);
X
X	timer = ent->client->grenade_time - level.time;
X	speed = GRENADE_MINSPEED + (GRENADE_TIMER - timer) * ((GRENADE_MAXSPEED - GRENADE_MINSPEED) / GRENADE_TIMER);
X	if (speed > GRENADE_MAXSPEED)
X		speed = GRENADE_MAXSPEED;
X
//	fire_grenade2 (ent, start, forward, damage, speed, timer, radius, held);
X
// ============
// PGM
X	switch(ent->client->pers.weapon->tag)
X	{
X		case AMMO_GRENADES:
X			fire_grenade2 (ent, start, forward, damage, speed, timer, radius, held);
X			break;
X		case AMMO_TESLA:
X			fire_tesla (ent, start, forward, damage_multiplier, speed);
X			break;
X		default:
X			fire_prox (ent, start, forward, damage_multiplier, speed);
X			break;
X	}
// PGM
// ============
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index]--;
X
X	ent->client->grenade_time = level.time + 1.0;
X
X	if(ent->deadflag || ent->s.modelindex != 255) // VWep animations screw up corpses
X	{
X		return;
X	}
X
X	if (ent->health <= 0)
X		return;
X
X	if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X	{
X		ent->client->anim_priority = ANIM_ATTACK;
X		ent->s.frame = FRAME_crattak1-1;
X		ent->client->anim_end = FRAME_crattak3;
X	}
X	else
X	{
X		ent->client->anim_priority = ANIM_REVERSE;
X		ent->s.frame = FRAME_wave08;
X		ent->client->anim_end = FRAME_wave01;
X	}
}
/*
void Weapon_Grenade (edict_t *ent)
{
X	if ((ent->client->newweapon) && (ent->client->weaponstate == WEAPON_READY))
X	{
X		ChangeWeapon (ent);
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_ACTIVATING)
X	{
X		ent->client->weaponstate = WEAPON_READY;
X		ent->client->ps.gunframe = 16;
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_READY)
X	{
X		if ( ((ent->client->latched_buttons|ent->client->buttons) & BUTTON_ATTACK) )
X		{
X			ent->client->latched_buttons &= ~BUTTON_ATTACK;
X			if (ent->client->pers.inventory[ent->client->ammo_index])
X			{
X				ent->client->ps.gunframe = 1;
X				ent->client->weaponstate = WEAPON_FIRING;
X				ent->client->grenade_time = 0;
X			}
X			else
X			{
X				if (level.time >= ent->pain_debounce_time)
X				{
X					gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/noammo.wav"), 1, ATTN_NORM, 0);
X					ent->pain_debounce_time = level.time + 1;
X				}
X				NoAmmoWeaponChange (ent);
X			}
X			return;
X		}
X
X		if ((ent->client->ps.gunframe == 29) || (ent->client->ps.gunframe == 34) || (ent->client->ps.gunframe == 39) || (ent->client->ps.gunframe == 48))
X		{
X			if (rand()&15)
X				return;
X		}
X
X		if (++ent->client->ps.gunframe > 48)
X			ent->client->ps.gunframe = 16;
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_FIRING)
X	{
X		if (ent->client->ps.gunframe == 5)
X			gi.sound(ent, CHAN_WEAPON, gi.soundindex("weapons/hgrena1b.wav"), 1, ATTN_NORM, 0);
X
X		if (ent->client->ps.gunframe == 11)
X		{
X			if (!ent->client->grenade_time)
X			{
X				ent->client->grenade_time = level.time + GRENADE_TIMER + 0.2;
X				ent->client->weapon_sound = gi.soundindex("weapons/hgrenc1b.wav");
X			}
X
X			// they waited too long, detonate it in their hand
X			if (!ent->client->grenade_blew_up && level.time >= ent->client->grenade_time)
X			{
X				ent->client->weapon_sound = 0;
X				weapon_grenade_fire (ent, true);
X				ent->client->grenade_blew_up = true;
X			}
X
X			if (ent->client->buttons & BUTTON_ATTACK)
X				return;
X
X			if (ent->client->grenade_blew_up)
X			{
X				if (level.time >= ent->client->grenade_time)
X				{
X					ent->client->ps.gunframe = 15;
X					ent->client->grenade_blew_up = false;
X				}
X				else
X				{
X					return;
X				}
X			}
X		}
X
X		if (ent->client->ps.gunframe == 12)
X		{
X			ent->client->weapon_sound = 0;
X			weapon_grenade_fire (ent, false);
X		}
X
X		if ((ent->client->ps.gunframe == 15) && (level.time < ent->client->grenade_time))
X			return;
X
X		ent->client->ps.gunframe++;
X
X		if (ent->client->ps.gunframe == 16)
X		{
X			ent->client->grenade_time = 0;
X			ent->client->weaponstate = WEAPON_READY;
X		}
X	}
}
*/
X
#define FRAME_IDLE_FIRST		(FRAME_FIRE_LAST + 1)
X
//void Weapon_Generic (edict_t *ent, int FRAME_ACTIVATE_LAST, int FRAME_FIRE_LAST, int FRAME_IDLE_LAST, int FRAME_DEACTIVATE_LAST, int *pause_frames, int *fire_frames, void (*fire)(edict_t *ent))
//									15                      48						5						11					12				29,34,39,48
void Throw_Generic (edict_t *ent, int FRAME_FIRE_LAST, int FRAME_IDLE_LAST, int FRAME_THROW_SOUND,
X					int FRAME_THROW_HOLD, int FRAME_THROW_FIRE, int *pause_frames, int EXPLODE,
X					void (*fire)(edict_t *ent, qboolean held))
{
X	int n;
X
X	if ((ent->client->newweapon) && (ent->client->weaponstate == WEAPON_READY))
X	{
X		ChangeWeapon (ent);
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_ACTIVATING)
X	{
X		ent->client->weaponstate = WEAPON_READY;
X		ent->client->ps.gunframe = FRAME_IDLE_FIRST;
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_READY)
X	{
X		if ( ((ent->client->latched_buttons|ent->client->buttons) & BUTTON_ATTACK) )
X		{
X			ent->client->latched_buttons &= ~BUTTON_ATTACK;
X			if (ent->client->pers.inventory[ent->client->ammo_index])
X			{
X				ent->client->ps.gunframe = 1;
X				ent->client->weaponstate = WEAPON_FIRING;
X				ent->client->grenade_time = 0;
X			}
X			else
X			{
X				if (level.time >= ent->pain_debounce_time)
X				{
X					gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/noammo.wav"), 1, ATTN_NORM, 0);
X					ent->pain_debounce_time = level.time + 1;
X				}
X				NoAmmoWeaponChange (ent);
X			}
X			return;
X		}
X
X		if (ent->client->ps.gunframe == FRAME_IDLE_LAST)
X		{
X			ent->client->ps.gunframe = FRAME_IDLE_FIRST;
X			return;
X		}
X
X		if (pause_frames)
X		{
X			for (n = 0; pause_frames[n]; n++)
X			{
X				if (ent->client->ps.gunframe == pause_frames[n])
X				{
X					if (rand()&15)
X						return;
X				}
X			}
X		}
X
X		ent->client->ps.gunframe++;
X		return;
X	}
X
X	if (ent->client->weaponstate == WEAPON_FIRING)
X	{
X		if (ent->client->ps.gunframe == FRAME_THROW_SOUND)
X			gi.sound(ent, CHAN_WEAPON, gi.soundindex("weapons/hgrena1b.wav"), 1, ATTN_NORM, 0);
X
X		if (ent->client->ps.gunframe == FRAME_THROW_HOLD)
X		{
X			if (!ent->client->grenade_time)
X			{
X				ent->client->grenade_time = level.time + GRENADE_TIMER + 0.2;
X				switch(ent->client->pers.weapon->tag)
X				{
X					case AMMO_GRENADES:
X						ent->client->weapon_sound = gi.soundindex("weapons/hgrenc1b.wav");
X						break;
X				}
X			}
X
X			// they waited too long, detonate it in their hand
X			if (EXPLODE && !ent->client->grenade_blew_up && level.time >= ent->client->grenade_time)
X			{
X				ent->client->weapon_sound = 0;
X				fire (ent, true);
X				ent->client->grenade_blew_up = true;
X			}
X
X			if (ent->client->buttons & BUTTON_ATTACK)
X				return;
X
X			if (ent->client->grenade_blew_up)
X			{
X				if (level.time >= ent->client->grenade_time)
X				{
X					ent->client->ps.gunframe = FRAME_FIRE_LAST;
X					ent->client->grenade_blew_up = false;
X				}
X				else
X				{
X					return;
X				}
X			}
X		}
X
X		if (ent->client->ps.gunframe == FRAME_THROW_FIRE)
X		{
X			ent->client->weapon_sound = 0;
X			fire (ent, true);
X		}
X
X		if ((ent->client->ps.gunframe == FRAME_FIRE_LAST) && (level.time < ent->client->grenade_time))
X			return;
X
X		ent->client->ps.gunframe++;
X
X		if (ent->client->ps.gunframe == FRAME_IDLE_FIRST)
X		{
X			ent->client->grenade_time = 0;
X			ent->client->weaponstate = WEAPON_READY;
X		}
X	}
}
X
//void Throw_Generic (edict_t *ent, int FRAME_FIRE_LAST, int FRAME_IDLE_LAST, int FRAME_THROW_SOUND,
//						int FRAME_THROW_HOLD, int FRAME_THROW_FIRE, int *pause_frames, 
//						int EXPLOSION_TIME, void (*fire)(edict_t *ent))
X
void Weapon_Grenade (edict_t *ent)
{
X	static int	pause_frames[]	= {29,34,39,48,0};
X
X	Throw_Generic (ent, 15, 48, 5, 11, 12, pause_frames, GRENADE_TIMER, weapon_grenade_fire);
}
X
void Weapon_Prox (edict_t *ent)
{
X	static int	pause_frames[]	= {22, 29, 0};
X
X	Throw_Generic (ent, 7, 27, 99, 2, 4, pause_frames, 0, weapon_grenade_fire);
}
X
void Weapon_Tesla (edict_t *ent)
{
X	static int	pause_frames[]	= {21, 0};
X
X	if ((ent->client->ps.gunframe > 1) && (ent->client->ps.gunframe < 9))
X	{
X		ent->client->ps.gunindex = gi.modelindex  ("models/weapons/v_tesla2/tris.md2");
X	}
X	else
X	{
X		ent->client->ps.gunindex = gi.modelindex  ("models/weapons/v_tesla/tris.md2");
X	}
X
X	Throw_Generic (ent, 8, 32, 99, 1, 2, pause_frames, 0, weapon_grenade_fire);
}
X
X
X
/*
======================================================================
X
GRENADE LAUNCHER
X
======================================================================
*/
X
void weapon_grenadelauncher_fire (edict_t *ent)
{
X	vec3_t	offset;
X	vec3_t	forward, right;
X	vec3_t	start;
//	int		damage = 120;
X	int		damage;			// PGM
X	float	radius;
X
// =====
// PGM
X	switch(ent->client->pers.weapon->tag)
X	{
X		case AMMO_PROX:
X			damage = 90;
X			break;
X		default:
X			damage = 120;
X			break;
X	}
// PGM
// =====
X
X	radius = damage+40;
X	if (is_quad)
//		damage *= 4;
X		damage *= damage_multiplier;		//pgm
X
X	VectorSet(offset, 8, 8, ent->viewheight-8);
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X
X	VectorScale (forward, -2, ent->client->kick_origin);
X	ent->client->kick_angles[0] = -1;
X
//	fire_grenade (ent, start, forward, damage, 600, 2.5, radius);
// =====
// PGM
X	switch(ent->client->pers.weapon->tag)
X	{
X		case AMMO_PROX:
X			fire_prox (ent, start, forward, damage_multiplier, 600);
X			break;
X		default:
X			fire_grenade (ent, start, forward, damage, 600, 2.5, radius);
X			break;
X	}
// PGM
// =====
X
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_GRENADE | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	ent->client->ps.gunframe++;
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index]--;
}
X
void Weapon_GrenadeLauncher (edict_t *ent)
{
X	static int	pause_frames[]	= {34, 51, 59, 0};
X	static int	fire_frames[]	= {6, 0};
X
X	Weapon_Generic (ent, 5, 16, 59, 64, pause_frames, fire_frames, weapon_grenadelauncher_fire);
}
X
//==========
//PGM
void Weapon_ProxLauncher (edict_t *ent)
{
X	static int      pause_frames[]  = {34, 51, 59, 0};
X	static int      fire_frames[]   = {6, 0};
X
X	Weapon_Generic (ent, 5, 16, 59, 64, pause_frames, fire_frames, weapon_grenadelauncher_fire);
}
//PGM
//==========
X
/*
======================================================================
X
ROCKET
X
======================================================================
*/
X
void Weapon_RocketLauncher_Fire (edict_t *ent)
{
X	vec3_t	offset, start;
X	vec3_t	forward, right;
X	int		damage;
X	float	damage_radius;
X	int		radius_damage;
X
X	damage = 100 + (int)(random() * 20.0);
X	radius_damage = 120;
X	damage_radius = 120;
X	if (is_quad)
X	{
//PGM
//		damage *= 4;
X		damage *= damage_multiplier;
//		radius_damage *= 4;
X		radius_damage *= damage_multiplier;
//PGM
X	}
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X
X	VectorScale (forward, -2, ent->client->kick_origin);
X	ent->client->kick_angles[0] = -1;
X
X	VectorSet(offset, 8, 8, ent->viewheight-8);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X	fire_rocket (ent, start, forward, damage, 650, damage_radius, radius_damage);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_ROCKET | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	ent->client->ps.gunframe++;
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index]--;
}
X
void Weapon_RocketLauncher (edict_t *ent)
{
X	static int	pause_frames[]	= {25, 33, 42, 50, 0};
X	static int	fire_frames[]	= {5, 0};
X
X	Weapon_Generic (ent, 4, 12, 50, 54, pause_frames, fire_frames, Weapon_RocketLauncher_Fire);
}
X
X
/*
======================================================================
X
BLASTER / HYPERBLASTER
X
======================================================================
*/
X
void Blaster_Fire (edict_t *ent, vec3_t g_offset, int damage, qboolean hyper, int effect)
{
X	vec3_t	forward, right;
X	vec3_t	start;
X	vec3_t	offset;
X
X	if (is_quad)
//		damage *= 4;		
X		damage *= damage_multiplier;		//pgm
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X	VectorSet(offset, 24, 8, ent->viewheight-8);
X	VectorAdd (offset, g_offset, offset);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X
X	VectorScale (forward, -2, ent->client->kick_origin);
X	ent->client->kick_angles[0] = -1;
X
X	fire_blaster (ent, start, forward, damage, 1000, effect, hyper);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	if (hyper)
X		gi.WriteByte (MZ_HYPERBLASTER | is_silenced);
X	else
X		gi.WriteByte (MZ_BLASTER | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
}
X
X
void Weapon_Blaster_Fire (edict_t *ent)
{
X	int		damage;
X
X	if (deathmatch->value)
X		damage = 15;
X	else
X		damage = 10;
X	Blaster_Fire (ent, vec3_origin, damage, false, EF_BLASTER);
X	ent->client->ps.gunframe++;
}
X
void Weapon_Blaster (edict_t *ent)
{
X	static int	pause_frames[]	= {19, 32, 0};
X	static int	fire_frames[]	= {5, 0};
X
X	Weapon_Generic (ent, 4, 8, 52, 55, pause_frames, fire_frames, Weapon_Blaster_Fire);
}
X
X
void Weapon_HyperBlaster_Fire (edict_t *ent)
{
X	float	rotation;
X	vec3_t	offset;
X	int		effect;
X	int		damage;
X
X	ent->client->weapon_sound = gi.soundindex("weapons/hyprbl1a.wav");
X
X	if (!(ent->client->buttons & BUTTON_ATTACK))
X	{
X		ent->client->ps.gunframe++;
X	}
X	else
X	{
X		if (! ent->client->pers.inventory[ent->client->ammo_index] )
X		{
X			if (level.time >= ent->pain_debounce_time)
X			{
X				gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/noammo.wav"), 1, ATTN_NORM, 0);
X				ent->pain_debounce_time = level.time + 1;
X			}
X			NoAmmoWeaponChange (ent);
X		}
X		else
X		{
X			rotation = (ent->client->ps.gunframe - 5) * 2*M_PI/6;
X			offset[0] = -4 * sin(rotation);
X			offset[1] = 0;
X			offset[2] = 4 * cos(rotation);
X
X			if ((ent->client->ps.gunframe == 6) || (ent->client->ps.gunframe == 9))
X				effect = EF_HYPERBLASTER;
X			else
X				effect = 0;
X			if (deathmatch->value)
X				damage = 15;
X			else
X				damage = 20;
X			Blaster_Fire (ent, offset, damage, true, effect);
X			if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X				ent->client->pers.inventory[ent->client->ammo_index]--;
X
X			ent->client->anim_priority = ANIM_ATTACK;
X			if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X			{
X				ent->s.frame = FRAME_crattak1 - 1;
X				ent->client->anim_end = FRAME_crattak9;
X			}
X			else
X			{
X				ent->s.frame = FRAME_attack1 - 1;
X				ent->client->anim_end = FRAME_attack8;
X			}
X		}
X
X		ent->client->ps.gunframe++;
X		if (ent->client->ps.gunframe == 12 && ent->client->pers.inventory[ent->client->ammo_index])
X			ent->client->ps.gunframe = 6;
X	}
X
X	if (ent->client->ps.gunframe == 12)
X	{
X		gi.sound(ent, CHAN_AUTO, gi.soundindex("weapons/hyprbd1a.wav"), 1, ATTN_NORM, 0);
X		ent->client->weapon_sound = 0;
X	}
X
}
X
void Weapon_HyperBlaster (edict_t *ent)
{
X	static int	pause_frames[]	= {0};
X	static int	fire_frames[]	= {6, 7, 8, 9, 10, 11, 0};
X
X	Weapon_Generic (ent, 5, 20, 49, 53, pause_frames, fire_frames, Weapon_HyperBlaster_Fire);
}
X
/*
======================================================================
X
MACHINEGUN / CHAINGUN
X
======================================================================
*/
X
void Machinegun_Fire (edict_t *ent)
{
X	int	i;
X	vec3_t		start;
X	vec3_t		forward, right;
X	vec3_t		angles;
X	int			damage = 8;
X	int			kick = 2;
X	vec3_t		offset;
X
X	if (!(ent->client->buttons & BUTTON_ATTACK))
X	{
X		ent->client->machinegun_shots = 0;
X		ent->client->ps.gunframe++;
X		return;
X	}
X
X	if (ent->client->ps.gunframe == 5)
X		ent->client->ps.gunframe = 4;
X	else
X		ent->client->ps.gunframe = 5;
X
X	if (ent->client->pers.inventory[ent->client->ammo_index] < 1)
X	{
X		ent->client->ps.gunframe = 6;
X		if (level.time >= ent->pain_debounce_time)
X		{
X			gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/noammo.wav"), 1, ATTN_NORM, 0);
X			ent->pain_debounce_time = level.time + 1;
X		}
X		NoAmmoWeaponChange (ent);
X		return;
X	}
X
X	if (is_quad)
X	{
//PGM
//		damage *= 4;
X		damage *= damage_multiplier;
//		kick *= 4;
X		kick *= damage_multiplier;
//PGM
X	}
X
X	for (i=1 ; i<3 ; i++)
X	{
X		ent->client->kick_origin[i] = crandom() * 0.35;
X		ent->client->kick_angles[i] = crandom() * 0.7;
X	}
X	ent->client->kick_origin[0] = crandom() * 0.35;
X	ent->client->kick_angles[0] = ent->client->machinegun_shots * -1.5;
X
X	// raise the gun as it is firing
X	if (!deathmatch->value)
X	{
X		ent->client->machinegun_shots++;
X		if (ent->client->machinegun_shots > 9)
X			ent->client->machinegun_shots = 9;
X	}
X
X	// get start / end positions
X	VectorAdd (ent->client->v_angle, ent->client->kick_angles, angles);
X	AngleVectors (angles, forward, right, NULL);
X	VectorSet(offset, 0, 8, ent->viewheight-8);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X	fire_bullet (ent, start, forward, damage, kick, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MOD_MACHINEGUN);
X
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_MACHINEGUN | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index]--;
X
X	ent->client->anim_priority = ANIM_ATTACK;
X	if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X	{
X		ent->s.frame = FRAME_crattak1 - (int) (random()+0.25);
X		ent->client->anim_end = FRAME_crattak9;
X	}
X	else
X	{
X		ent->s.frame = FRAME_attack1 - (int) (random()+0.25);
X		ent->client->anim_end = FRAME_attack8;
X	}
}
X
void Weapon_Machinegun (edict_t *ent)
{
X	static int	pause_frames[]	= {23, 45, 0};
X	static int	fire_frames[]	= {4, 5, 0};
X
X	Weapon_Generic (ent, 3, 5, 45, 49, pause_frames, fire_frames, Machinegun_Fire);
}
X
void Chaingun_Fire (edict_t *ent)
{
X	int			i;
X	int			shots;
X	vec3_t		start;
X	vec3_t		forward, right, up;
X	float		r, u;
X	vec3_t		offset;
X	int			damage;
X	int			kick = 2;
X
X	if (deathmatch->value)
X		damage = 6;
X	else
X		damage = 8;
X
X	if (ent->client->ps.gunframe == 5)
X		gi.sound(ent, CHAN_AUTO, gi.soundindex("weapons/chngnu1a.wav"), 1, ATTN_IDLE, 0);
X
X	if ((ent->client->ps.gunframe == 14) && !(ent->client->buttons & BUTTON_ATTACK))
X	{
X		ent->client->ps.gunframe = 32;
X		ent->client->weapon_sound = 0;
X		return;
X	}
X	else if ((ent->client->ps.gunframe == 21) && (ent->client->buttons & BUTTON_ATTACK)
X		&& ent->client->pers.inventory[ent->client->ammo_index])
X	{
X		ent->client->ps.gunframe = 15;
X	}
X	else
X	{
X		ent->client->ps.gunframe++;
X	}
X
X	if (ent->client->ps.gunframe == 22)
X	{
X		ent->client->weapon_sound = 0;
X		gi.sound(ent, CHAN_AUTO, gi.soundindex("weapons/chngnd1a.wav"), 1, ATTN_IDLE, 0);
X	}
X	else
X	{
X		ent->client->weapon_sound = gi.soundindex("weapons/chngnl1a.wav");
X	}
X
X	ent->client->anim_priority = ANIM_ATTACK;
X	if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X	{
X		ent->s.frame = FRAME_crattak1 - (ent->client->ps.gunframe & 1);
X		ent->client->anim_end = FRAME_crattak9;
X	}
X	else
X	{
X		ent->s.frame = FRAME_attack1 - (ent->client->ps.gunframe & 1);
X		ent->client->anim_end = FRAME_attack8;
X	}
X
X	if (ent->client->ps.gunframe <= 9)
X		shots = 1;
X	else if (ent->client->ps.gunframe <= 14)
X	{
X		if (ent->client->buttons & BUTTON_ATTACK)
X			shots = 2;
X		else
X			shots = 1;
X	}
X	else
X		shots = 3;
X
X	if (ent->client->pers.inventory[ent->client->ammo_index] < shots)
X		shots = ent->client->pers.inventory[ent->client->ammo_index];
X
X	if (!shots)
X	{
X		if (level.time >= ent->pain_debounce_time)
X		{
X			gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/noammo.wav"), 1, ATTN_NORM, 0);
X			ent->pain_debounce_time = level.time + 1;
X		}
X		NoAmmoWeaponChange (ent);
X		return;
X	}
X
X	if (is_quad)
X	{
//PGM
//		damage *= 4;
X		damage *= damage_multiplier;
//		kick *= 4;
X		kick *= damage_multiplier;
//PGM
X	}
X
X	for (i=0 ; i<3 ; i++)
X	{
X		ent->client->kick_origin[i] = crandom() * 0.35;
X		ent->client->kick_angles[i] = crandom() * 0.7;
X	}
X
X	for (i=0 ; i<shots ; i++)
X	{
X		// get start / end positions
X		AngleVectors (ent->client->v_angle, forward, right, up);
X		r = 7 + crandom()*4;
X		u = crandom()*4;
X		VectorSet(offset, 0, r, u + ent->viewheight-8);
X		P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X
X		fire_bullet (ent, start, forward, damage, kick, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MOD_CHAINGUN);
X	}
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte ((MZ_CHAINGUN1 + shots - 1) | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index] -= shots;
}
X
X
void Weapon_Chaingun (edict_t *ent)
{
X	static int	pause_frames[]	= {38, 43, 51, 61, 0};
X	static int	fire_frames[]	= {5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 0};
X
X	Weapon_Generic (ent, 4, 31, 61, 64, pause_frames, fire_frames, Chaingun_Fire);
}
X
X
/*
======================================================================
X
SHOTGUN / SUPERSHOTGUN
X
======================================================================
*/
X
void weapon_shotgun_fire (edict_t *ent)
{
X	vec3_t		start;
X	vec3_t		forward, right;
X	vec3_t		offset;
X	int			damage = 4;
X	int			kick = 8;
X
X	if (ent->client->ps.gunframe == 9)
X	{
X		ent->client->ps.gunframe++;
X		return;
X	}
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X
X	VectorScale (forward, -2, ent->client->kick_origin);
X	ent->client->kick_angles[0] = -2;
X
X	VectorSet(offset, 0, 8,  ent->viewheight-8);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X
X	if (is_quad)
X	{
//PGM
//		damage *= 4;
X		damage *= damage_multiplier;
//		kick *= 4;
X		kick *= damage_multiplier;
//PGM
X	}
X
X	if (deathmatch->value)
X		fire_shotgun (ent, start, forward, damage, kick, 500, 500, DEFAULT_DEATHMATCH_SHOTGUN_COUNT, MOD_SHOTGUN);
X	else
X		fire_shotgun (ent, start, forward, damage, kick, 500, 500, DEFAULT_SHOTGUN_COUNT, MOD_SHOTGUN);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_SHOTGUN | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	ent->client->ps.gunframe++;
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index]--;
}
X
void Weapon_Shotgun (edict_t *ent)
{
X	static int	pause_frames[]	= {22, 28, 34, 0};
X	static int	fire_frames[]	= {8, 9, 0};
X
X	Weapon_Generic (ent, 7, 18, 36, 39, pause_frames, fire_frames, weapon_shotgun_fire);
}
X
X
void weapon_supershotgun_fire (edict_t *ent)
{
X	vec3_t		start;
X	vec3_t		forward, right;
X	vec3_t		offset;
X	vec3_t		v;
X	int			damage = 6;
X	int			kick = 12;
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X
X	VectorScale (forward, -2, ent->client->kick_origin);
X	ent->client->kick_angles[0] = -2;
X
X	VectorSet(offset, 0, 8,  ent->viewheight-8);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X
X	if (is_quad)
X	{
//PGM
//		damage *= 4;
X		damage *= damage_multiplier;
//		kick *= 4;
X		kick *= damage_multiplier;
//PGM
X	}
X
X	v[PITCH] = ent->client->v_angle[PITCH];
X	v[YAW]   = ent->client->v_angle[YAW] - 5;
X	v[ROLL]  = ent->client->v_angle[ROLL];
X	AngleVectors (v, forward, NULL, NULL);
X	fire_shotgun (ent, start, forward, damage, kick, DEFAULT_SHOTGUN_HSPREAD, DEFAULT_SHOTGUN_VSPREAD, DEFAULT_SSHOTGUN_COUNT/2, MOD_SSHOTGUN);
X	v[YAW]   = ent->client->v_angle[YAW] + 5;
X	AngleVectors (v, forward, NULL, NULL);
X	fire_shotgun (ent, start, forward, damage, kick, DEFAULT_SHOTGUN_HSPREAD, DEFAULT_SHOTGUN_VSPREAD, DEFAULT_SSHOTGUN_COUNT/2, MOD_SSHOTGUN);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_SSHOTGUN | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	ent->client->ps.gunframe++;
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index] -= 2;
}
X
void Weapon_SuperShotgun (edict_t *ent)
{
X	static int	pause_frames[]	= {29, 42, 57, 0};
X	static int	fire_frames[]	= {7, 0};
X
X	Weapon_Generic (ent, 6, 17, 57, 61, pause_frames, fire_frames, weapon_supershotgun_fire);
}
X
X
X
/*
======================================================================
X
RAILGUN
X
======================================================================
*/
X
void weapon_railgun_fire (edict_t *ent)
{
X	vec3_t		start;
X	vec3_t		forward, right;
X	vec3_t		offset;
X	int			damage;
X	int			kick;
X
X	if (deathmatch->value)
X	{	// normal damage is too extreme in dm
X		damage = 100;
X		kick = 200;
X	}
X	else
X	{
X		damage = 150;
X		kick = 250;
X	}
X
X	if (is_quad)
X	{
//PGM
//		damage *= 4;
X		damage *= damage_multiplier;
//		kick *= 4;
X		kick *= damage_multiplier;
//PGM
X	}
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X
X	VectorScale (forward, -3, ent->client->kick_origin);
X	ent->client->kick_angles[0] = -3;
X
X	VectorSet(offset, 0, 7,  ent->viewheight-8);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X	fire_rail (ent, start, forward, damage, kick);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_RAILGUN | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	ent->client->ps.gunframe++;
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index]--;
}
X
X
void Weapon_Railgun (edict_t *ent)
{
X	static int	pause_frames[]	= {56, 0};
X	static int	fire_frames[]	= {4, 0};
X
X	Weapon_Generic (ent, 3, 18, 56, 61, pause_frames, fire_frames, weapon_railgun_fire);
}
X
X
/*
======================================================================
X
BFG10K
X
======================================================================
*/
X
void weapon_bfg_fire (edict_t *ent)
{
X	vec3_t	offset, start;
X	vec3_t	forward, right;
X	int		damage;
X	float	damage_radius = 1000;
X
X	if (deathmatch->value)
X		damage = 200;
X	else
X		damage = 500;
X
X	if (ent->client->ps.gunframe == 9)
X	{
X		// send muzzle flash
X		gi.WriteByte (svc_muzzleflash);
X		gi.WriteShort (ent-g_edicts);
X		gi.WriteByte (MZ_BFG | is_silenced);
X		gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X		ent->client->ps.gunframe++;
X
X		PlayerNoise(ent, start, PNOISE_WEAPON);
X		return;
X	}
X
X	// cells can go down during windup (from power armor hits), so
X	// check again and abort firing if we don't have enough now
X	if (ent->client->pers.inventory[ent->client->ammo_index] < 50)
X	{
X		ent->client->ps.gunframe++;
X		return;
X	}
X
X	if (is_quad)
//PGM
//		damage *= 4;
X		damage *= damage_multiplier;
//PGM
X
X	AngleVectors (ent->client->v_angle, forward, right, NULL);
X
X	VectorScale (forward, -2, ent->client->kick_origin);
X
X	// make a big pitch kick with an inverse fall
X	ent->client->v_dmg_pitch = -40;
X	ent->client->v_dmg_roll = crandom()*8;
X	ent->client->v_dmg_time = level.time + DAMAGE_TIME;
X
X	VectorSet(offset, 8, 8, ent->viewheight-8);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X	fire_bfg (ent, start, forward, damage, 400, damage_radius);
X
X	ent->client->ps.gunframe++;
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index] -= 50;
}
X
void Weapon_BFG (edict_t *ent)
{
X	static int	pause_frames[]	= {39, 45, 50, 55, 0};
X	static int	fire_frames[]	= {9, 17, 0};
X
X	Weapon_Generic (ent, 8, 32, 55, 58, pause_frames, fire_frames, weapon_bfg_fire);
}
X
X
//======================================================================
// ROGUE MODS BELOW
//======================================================================
X
X
//
// CHAINFIST
//
#define CHAINFIST_REACH 64
X
void weapon_chainfist_fire (edict_t *ent)
{
X	vec3_t	offset;
X	vec3_t	forward, right, up;
X	vec3_t	start;
X	int		damage;
X
X	damage = 15;
X	if(deathmatch->value)
X		damage = 30;
X
X	if (is_quad)
X		damage *= damage_multiplier;
X
X	AngleVectors (ent->client->v_angle, forward, right, up);
X
X	// kick back
X	VectorScale (forward, -2, ent->client->kick_origin);
X	ent->client->kick_angles[0] = -1;
X
X	// set start point
X	VectorSet(offset, 0, 8, ent->viewheight-4);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X
X	fire_player_melee (ent, start, forward, CHAINFIST_REACH, damage, 100, 1, MOD_CHAINFIST);
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	ent->client->ps.gunframe++;
X	ent->client->pers.inventory[ent->client->ammo_index] -= ent->client->pers.weapon->quantity;
}
X
// this spits out some smoke from the motor. it's a two-stroke, you know.
void chainfist_smoke (edict_t *ent)
{
X	vec3_t	tempVec, forward, right, up;
X	vec3_t	offset;
X
X	AngleVectors(ent->client->v_angle, forward, right, up);
X	VectorSet(offset, 8, 8, ent->viewheight -4);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, tempVec);
X
X	gi.WriteByte (svc_temp_entity);
X	gi.WriteByte (TE_CHAINFIST_SMOKE);
X	gi.WritePosition (tempVec);
X	gi.unicast (ent, 0);
//	gi.multicast (tempVec, MULTICAST_PVS);
}
X
#define HOLD_FRAMES			0
X
void Weapon_ChainFist (edict_t *ent)
{
X	static int	pause_frames[]	= {0};
X	static int	fire_frames[]	= {8, 9, 16, 17, 18, 30, 31, 0};
X
X	// these are caches for the sound index. there's probably a better way to do this.
//	static int	idle_index;
//	static int	attack_index;
X	float		chance;
X	int			last_sequence;
X	
X	last_sequence = 0;
X
X	// load chainsaw sounds and store the indexes for later use.
//	if(!idle_index && !attack_index)
//	{
//		idle_index = gi.soundindex("weapons/sawidle.wav");
//		attack_index = gi.soundindex("weapons/sawhit.wav");
//	}
X
X	if(ent->client->ps.gunframe == 13 ||
X		ent->client->ps.gunframe == 23)			// end of attack, go idle
X		ent->client->ps.gunframe = 32;
X
#if HOLD_FRAMES
X	else if(ent->client->ps.gunframe == 9 && ((ent->client->buttons) & BUTTON_ATTACK))
X		ent->client->ps.gunframe = 7;
X	else if(ent->client->ps.gunframe == 18 && ((ent->client->buttons) & BUTTON_ATTACK))
X		ent->client->ps.gunframe = 16;
#endif
X
X	// holds for idle sequence
X	else if(ent->client->ps.gunframe == 42 && (rand()&7))
X	{
X		if((ent->client->pers.hand != CENTER_HANDED) && random() < 0.4)
X			chainfist_smoke(ent);
//		ent->client->ps.gunframe = 40;
X	}
X	else if(ent->client->ps.gunframe == 51 && (rand()&7))
X	{
X		if((ent->client->pers.hand != CENTER_HANDED) && random() < 0.4)
X			chainfist_smoke(ent);
//		ent->client->ps.gunframe = 49;
X	}	
X
X	// set the appropriate weapon sound.
X	if(ent->client->weaponstate == WEAPON_FIRING)
//		ent->client->weapon_sound = attack_index;
X		ent->client->weapon_sound = gi.soundindex("weapons/sawhit.wav");
X	else if(ent->client->weaponstate == WEAPON_DROPPING)
X		ent->client->weapon_sound = 0;
X	else
//		ent->client->weapon_sound = idle_index;
X		ent->client->weapon_sound = gi.soundindex("weapons/sawidle.wav");
X
X	Weapon_Generic (ent, 4, 32, 57, 60, pause_frames, fire_frames, weapon_chainfist_fire);
X
//	gi.dprintf("chainfist %d\n", ent->client->ps.gunframe);
X	if((ent->client->buttons) & BUTTON_ATTACK)
X	{
X		if(ent->client->ps.gunframe == 13 ||
X			ent->client->ps.gunframe == 23 ||
X			ent->client->ps.gunframe == 32)
X		{
X			last_sequence = ent->client->ps.gunframe;
X			ent->client->ps.gunframe = 6;
X		}
X	}
X
X	if (ent->client->ps.gunframe == 6)
X	{
X		chance = random();
X		if(last_sequence == 13)			// if we just did sequence 1, do 2 or 3.
X			chance -= 0.34;
X		else if(last_sequence == 23)	// if we just did sequence 2, do 1 or 3
X			chance += 0.33;
X		else if(last_sequence == 32)	// if we just did sequence 3, do 1 or 2
X		{
X			if(chance >= 0.33)
X				chance += 0.34;
X		}
X
X		if(chance < 0.33)
X			ent->client->ps.gunframe = 14;
X		else if(chance < 0.66)
X			ent->client->ps.gunframe = 24;
X	}
X
}
X
//
// Disintegrator
//
X
void weapon_tracker_fire (edict_t *self)
{
X	vec3_t		forward, right;
X	vec3_t		start;
X	vec3_t		end;
X	vec3_t		offset;
X	edict_t		*enemy;
X	trace_t		tr;
X	int			damage;
X	vec3_t		mins, maxs;
X
X	// PMM - felt a little high at 25
X	if(deathmatch->value)
X		damage = 30;
X	else
X		damage = 45;
X
X	if (is_quad)
X		damage *= damage_multiplier;		//pgm
X
X	VectorSet(mins, -16, -16, -16);
X	VectorSet(maxs, 16, 16, 16);
X	AngleVectors (self->client->v_angle, forward, right, NULL);
X	VectorSet(offset, 24, 8, self->viewheight-8);
X	P_ProjectSource (self->client, self->s.origin, offset, forward, right, start);
X
X	// FIXME - can we shorten this? do we need to?
X	VectorMA (start, 8192, forward, end);
X	enemy = NULL;
X	//PMM - doing two traces .. one point and one box.  
X	tr = gi.trace (start, vec3_origin, vec3_origin, end, self, MASK_SHOT);
X	if(tr.ent != world)
X	{
X		if(tr.ent->svflags & SVF_MONSTER || tr.ent->client || tr.ent->svflags & SVF_DAMAGEABLE)
X		{
X			if(tr.ent->health > 0)
X				enemy = tr.ent;
X		}
X	}
X	else
X	{
X		tr = gi.trace (start, mins, maxs, end, self, MASK_SHOT);
X		if(tr.ent != world)
X		{
X			if(tr.ent->svflags & SVF_MONSTER || tr.ent->client || tr.ent->svflags & SVF_DAMAGEABLE)
X			{
X				if(tr.ent->health > 0)
X					enemy = tr.ent;
X			}
X		}
X	}
X
X	VectorScale (forward, -2, self->client->kick_origin);
X	self->client->kick_angles[0] = -1;
X
X	fire_tracker (self, start, forward, damage, 1000, enemy);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (self-g_edicts);
X	gi.WriteByte (MZ_TRACKER);
X	gi.multicast (self->s.origin, MULTICAST_PVS);
X
X	PlayerNoise(self, start, PNOISE_WEAPON);
X
X	self->client->ps.gunframe++;
X	self->client->pers.inventory[self->client->ammo_index] -= self->client->pers.weapon->quantity;
}
X
void Weapon_Disintegrator (edict_t *ent)
{
X	static int	pause_frames[]	= {14, 19, 23, 0};
//	static int	fire_frames[]	= {7, 0};
X	static int	fire_frames[]	= {5, 0};
X
X	Weapon_Generic (ent, 4, 9, 29, 34, pause_frames, fire_frames, weapon_tracker_fire);
}
X
/*
======================================================================
X
ETF RIFLE
X
======================================================================
*/
void weapon_etf_rifle_fire (edict_t *ent)
{
X	vec3_t	forward, right, up;
X	vec3_t	start, tempPt;
X	int		damage;
X	int		kick = 3;
X	int		i;
X	vec3_t	angles;
X	vec3_t	offset;
X
X	if(deathmatch->value)
X		damage = 10;
X	else
X		damage = 10;
X
X	// PGM - adjusted to use the quantity entry in the weapon structure.
X	if(ent->client->pers.inventory[ent->client->ammo_index] < ent->client->pers.weapon->quantity)
X	{
X		VectorClear (ent->client->kick_origin);
X		VectorClear (ent->client->kick_angles);
X		ent->client->ps.gunframe = 8;
X
X		if (level.time >= ent->pain_debounce_time)
X		{
X			gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/noammo.wav"), 1, ATTN_NORM, 0);
X			ent->pain_debounce_time = level.time + 1;
X		}
X		NoAmmoWeaponChange (ent);
X		return;
X	}
X
X	if (is_quad)
X	{
X		damage *= damage_multiplier;
X		kick *= damage_multiplier;
X	}
X
X	for(i=0;i<3;i++)
X	{
X		ent->client->kick_origin[i] = crandom() * 0.85;
X		ent->client->kick_angles[i] = crandom() * 0.85;
X	}
X
X	// get start / end positions
X	VectorAdd (ent->client->v_angle, ent->client->kick_angles, angles);
//	AngleVectors (angles, forward, right, NULL);
//	gi.dprintf("v_angle: %s\n", vtos(ent->client->v_angle));
X	AngleVectors (ent->client->v_angle, forward, right, up);
X
X	// FIXME - set correct frames for different offsets.
X
X	if(ent->client->ps.gunframe == 6)					// right barrel
X	{
//		gi.dprintf("right\n");
X		VectorSet(offset, 15, 8, -8);
X	}
X	else										// left barrel
X	{
//		gi.dprintf("left\n");
X		VectorSet(offset, 15, 6, -8);
X	}
X	
X	VectorCopy (ent->s.origin, tempPt);
X	tempPt[2] += ent->viewheight;
X	P_ProjectSource2 (ent->client, tempPt, offset, forward, right, up, start);
//	gi.dprintf("start: %s\n", vtos(start));
X	fire_flechette (ent, start, forward, damage, 750, kick);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_ETF_RIFLE);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	ent->client->ps.gunframe++;
X	ent->client->pers.inventory[ent->client->ammo_index] -= ent->client->pers.weapon->quantity;
X
X	ent->client->anim_priority = ANIM_ATTACK;
X	if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X	{
X		ent->s.frame = FRAME_crattak1 - 1;
X		ent->client->anim_end = FRAME_crattak9;
X	}
X	else
X	{
X		ent->s.frame = FRAME_attack1 - 1;
X		ent->client->anim_end = FRAME_attack8;
X	}
X
}
X
void Weapon_ETF_Rifle (edict_t *ent)
{
X	static int	pause_frames[]	= {18, 28, 0};
X	static int	fire_frames[]	= {6, 7, 0};
//	static int	idle_seq;
X
X	// note - if you change the fire frame number, fix the offset in weapon_etf_rifle_fire.
X
//	if (!(ent->client->buttons & BUTTON_ATTACK))
//		ent->client->machinegun_shots = 0;
X
X	if (ent->client->weaponstate == WEAPON_FIRING)
X	{
X		if (ent->client->pers.inventory[ent->client->ammo_index] <= 0)
X			ent->client->ps.gunframe = 8;
X	}
X
X	Weapon_Generic (ent, 4, 7, 37, 41, pause_frames, fire_frames, weapon_etf_rifle_fire);
X
X	if(ent->client->ps.gunframe == 8 && (ent->client->buttons & BUTTON_ATTACK))
X		ent->client->ps.gunframe = 6;
X
//	gi.dprintf("etf rifle %d\n", ent->client->ps.gunframe);
}
X
// pgm - this now uses ent->client->pers.weapon->quantity like all the other weapons
//#define HEATBEAM_AMMO_USE		2		
#define	HEATBEAM_DM_DMG			15
#define HEATBEAM_SP_DMG			15
X
void Heatbeam_Fire (edict_t *ent)
{
X	vec3_t		start;
X	vec3_t		forward, right, up;
X	vec3_t		offset;
X	int			damage;
X	int			kick;
X
X	// for comparison, the hyperblaster is 15/20
X	// jim requested more damage, so try 15/15 --- PGM 07/23/98
X	if (deathmatch->value)
X		damage = HEATBEAM_DM_DMG;
X	else
X		damage = HEATBEAM_SP_DMG;
X
X	if (deathmatch->value)  // really knock 'em around in deathmatch
X		kick = 75;
X	else
X		kick = 30;
X
//	if(ent->client->pers.inventory[ent->client->ammo_index] < HEATBEAM_AMMO_USE)
//	{
//		NoAmmoWeaponChange (ent);
//		return;
//	}
X
X	ent->client->ps.gunframe++;
X	ent->client->ps.gunindex = gi.modelindex ("models/weapons/v_beamer2/tris.md2");
X
X	if (is_quad)
X	{
X		damage *= damage_multiplier;
X		kick *= damage_multiplier;
X	}
X
X	VectorClear (ent->client->kick_origin);
X	VectorClear (ent->client->kick_angles);
X
X	// get start / end positions
X	AngleVectors (ent->client->v_angle, forward, right, up);
X
// This offset is the "view" offset for the beam start (used by trace)
X	
X	VectorSet(offset, 7, 2, ent->viewheight-3);
X	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
X
X	// This offset is the entity offset
X	VectorSet(offset, 2, 7, -3);
X
X	fire_heat (ent, start, forward, offset, damage, kick, false);
X
X	// send muzzle flash
X	gi.WriteByte (svc_muzzleflash);
X	gi.WriteShort (ent-g_edicts);
X	gi.WriteByte (MZ_HEATBEAM | is_silenced);
X	gi.multicast (ent->s.origin, MULTICAST_PVS);
X
X	PlayerNoise(ent, start, PNOISE_WEAPON);
X
X	if (! ( (int)dmflags->value & DF_INFINITE_AMMO ) )
X		ent->client->pers.inventory[ent->client->ammo_index] -= ent->client->pers.weapon->quantity;
X
X	ent->client->anim_priority = ANIM_ATTACK;
X	if (ent->client->ps.pmove.pm_flags & PMF_DUCKED)
X	{
X		ent->s.frame = FRAME_crattak1 - 1;
X		ent->client->anim_end = FRAME_crattak9;
X	}
X	else
X	{
X		ent->s.frame = FRAME_attack1 - 1;
X		ent->client->anim_end = FRAME_attack8;
X	}
X
}
X
void Weapon_Heatbeam (edict_t *ent)
{
//	static int	pause_frames[]	= {38, 43, 51, 61, 0};
//	static int	fire_frames[]	= {5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 0};
X	static int	pause_frames[]	= {35, 0};
//	static int	fire_frames[]	= {9, 0};
X	static int	fire_frames[]	= {9, 10, 11, 12, 0};
//	static int	attack_index;
//	static int  off_model, on_model;
X
//	if ((g_showlogic) && (g_showlogic->value)) {
//		gi.dprintf ("Frame %d, skin %d\n", ent->client->ps.gunframe, ent->client->ps.gunskin);
//	}
X	
//	if (!attack_index)
//	{
//		attack_index = gi.soundindex ("weapons/bfg__l1a.wav");
//		off_model = gi.modelindex ("models/weapons/v_beamer/tris.md2");
//		on_model = gi.modelindex ("models/weapons/v_beamer2/tris.md2");
X		//ent->client->ps.gunindex = gi.modelindex(ent->client->pers.weapon->view_model);
//	}
X
X	if (ent->client->weaponstate == WEAPON_FIRING)
X	{
//		ent->client->weapon_sound = attack_index;
X		ent->client->weapon_sound = gi.soundindex ("weapons/bfg__l1a.wav");
X		if ((ent->client->pers.inventory[ent->client->ammo_index] >= 2) && ((ent->client->buttons) & BUTTON_ATTACK))
X		{
//			if(ent->client->ps.gunframe >= 9 && ((ent->client->buttons) & BUTTON_ATTACK))
//			if(ent->client->ps.gunframe >= 12 && ((ent->client->buttons) & BUTTON_ATTACK))
X			if(ent->client->ps.gunframe >= 13)
X			{
X				ent->client->ps.gunframe = 9;
//				ent->client->ps.gunframe = 8;
//				ent->client->ps.gunskin = 0;
//				ent->client->ps.gunindex = on_model;
X				ent->client->ps.gunindex = gi.modelindex ("models/weapons/v_beamer2/tris.md2");
X			}
X			else
X			{
//				ent->client->ps.gunskin = 1;
//				ent->client->ps.gunindex = on_model;
X				ent->client->ps.gunindex = gi.modelindex ("models/weapons/v_beamer2/tris.md2");
X			}
X		}
X		else
X		{
//			ent->client->ps.gunframe = 10;
X			ent->client->ps.gunframe = 13;
//			ent->client->ps.gunskin = 1;
//			ent->client->ps.gunindex = off_model;
X			ent->client->ps.gunindex = gi.modelindex ("models/weapons/v_beamer/tris.md2");
X		}
X	}
X	else
X	{
//		ent->client->ps.gunskin = 1;
//		ent->client->ps.gunindex = off_model;
X		ent->client->ps.gunindex = gi.modelindex ("models/weapons/v_beamer/tris.md2");
X		ent->client->weapon_sound = 0;
X	}
X
//	Weapon_Generic (ent, 8, 9, 39, 44, pause_frames, fire_frames, Heatbeam_Fire);
X	Weapon_Generic (ent, 8, 12, 39, 44, pause_frames, fire_frames, Heatbeam_Fire);
}
SHAR_EOF
  $shar_touch -am 1130175398 'p_weapon.c' &&
  chmod 0664 'p_weapon.c' ||
  $echo 'restore of' 'p_weapon.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'p_weapon.c:' 'MD5 check failed'
c8bcf4cff0b6ca261d11dcc4b5e29443  p_weapon.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'p_weapon.c'`"
    test 55810 -eq "$shar_count" ||
    $echo 'p_weapon.c:' 'original size' '55810,' 'current size' "$shar_count!"
  fi
fi
# ============= q_shared.c ==============
if test -f 'q_shared.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'q_shared.c' '(file already exists)'
else
  $echo 'x -' extracting 'q_shared.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'q_shared.c' &&
#include "q_shared.h"
X
#define DEG2RAD( a ) ( a * M_PI ) / 180.0F
X
vec3_t vec3_origin = {0,0,0};
// ROGUE VERSIONING
//int rogueid = ROGUE_VERSION_ID;
// ROGUE
X
//============================================================================
X
#ifdef _WIN32
#pragma optimize( "", off )
#endif
X
void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, float degrees )
{
X	float	m[3][3];
X	float	im[3][3];
X	float	zrot[3][3];
X	float	tmpmat[3][3];
X	float	rot[3][3];
X	int	i;
X	vec3_t vr, vup, vf;
X
X	vf[0] = dir[0];
X	vf[1] = dir[1];
X	vf[2] = dir[2];
X
X	PerpendicularVector( vr, dir );
X	CrossProduct( vr, vf, vup );
X
X	m[0][0] = vr[0];
X	m[1][0] = vr[1];
X	m[2][0] = vr[2];
X
X	m[0][1] = vup[0];
X	m[1][1] = vup[1];
X	m[2][1] = vup[2];
X
X	m[0][2] = vf[0];
X	m[1][2] = vf[1];
X	m[2][2] = vf[2];
X
X	memcpy( im, m, sizeof( im ) );
X
X	im[0][1] = m[1][0];
X	im[0][2] = m[2][0];
X	im[1][0] = m[0][1];
X	im[1][2] = m[2][1];
X	im[2][0] = m[0][2];
X	im[2][1] = m[1][2];
X
X	memset( zrot, 0, sizeof( zrot ) );
X	zrot[0][0] = zrot[1][1] = zrot[2][2] = 1.0F;
X
X	zrot[0][0] = cos( DEG2RAD( degrees ) );
X	zrot[0][1] = sin( DEG2RAD( degrees ) );
X	zrot[1][0] = -sin( DEG2RAD( degrees ) );
X	zrot[1][1] = cos( DEG2RAD( degrees ) );
X
X	R_ConcatRotations( m, zrot, tmpmat );
X	R_ConcatRotations( tmpmat, im, rot );
X
X	for ( i = 0; i < 3; i++ )
X	{
X		dst[i] = rot[i][0] * point[0] + rot[i][1] * point[1] + rot[i][2] * point[2];
X	}
}
X
#ifdef _WIN32
#pragma optimize( "", on )
#endif
X
X
X
void AngleVectors (vec3_t angles, vec3_t forward, vec3_t right, vec3_t up)
{
X	float		angle;
X	static float		sr, sp, sy, cr, cp, cy;
X	// static to help MS compiler fp bugs
X
X	angle = angles[YAW] * (M_PI*2 / 360);
X	sy = sin(angle);
X	cy = cos(angle);
X	angle = angles[PITCH] * (M_PI*2 / 360);
X	sp = sin(angle);
X	cp = cos(angle);
X	angle = angles[ROLL] * (M_PI*2 / 360);
X	sr = sin(angle);
X	cr = cos(angle);
X
X	if (forward)
X	{
X		forward[0] = cp*cy;
X		forward[1] = cp*sy;
X		forward[2] = -sp;
X	}
X	if (right)
X	{
X		right[0] = (-1*sr*sp*cy+-1*cr*-sy);
X		right[1] = (-1*sr*sp*sy+-1*cr*cy);
X		right[2] = -1*sr*cp;
X	}
X	if (up)
X	{
X		up[0] = (cr*sp*cy+-sr*-sy);
X		up[1] = (cr*sp*sy+-sr*cy);
X		up[2] = cr*cp;
X	}
}
X
X
void ProjectPointOnPlane( vec3_t dst, const vec3_t p, const vec3_t normal )
{
X	float d;
X	vec3_t n;
X	float inv_denom;
X
X	inv_denom = 1.0F / DotProduct( normal, normal );
X
X	d = DotProduct( normal, p ) * inv_denom;
X
X	n[0] = normal[0] * inv_denom;
X	n[1] = normal[1] * inv_denom;
X	n[2] = normal[2] * inv_denom;
X
X	dst[0] = p[0] - d * n[0];
X	dst[1] = p[1] - d * n[1];
X	dst[2] = p[2] - d * n[2];
}
X
/*
** assumes "src" is normalized
*/
void PerpendicularVector( vec3_t dst, const vec3_t src )
{
X	int	pos;
X	int i;
X	float minelem = 1.0F;
X	vec3_t tempvec;
X
X	/*
X	** find the smallest magnitude axially aligned vector
X	*/
X	for ( pos = 0, i = 0; i < 3; i++ )
X	{
X		if ( fabs( src[i] ) < minelem )
X		{
X			pos = i;
X			minelem = fabs( src[i] );
X		}
X	}
X	tempvec[0] = tempvec[1] = tempvec[2] = 0.0F;
X	tempvec[pos] = 1.0F;
X
X	/*
X	** project the point onto the plane defined by src
X	*/
X	ProjectPointOnPlane( dst, tempvec, src );
X
X	/*
X	** normalize the result
X	*/
X	VectorNormalize( dst );
}
X
X
X
/*
================
R_ConcatRotations
================
*/
void R_ConcatRotations (float in1[3][3], float in2[3][3], float out[3][3])
{
X	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
X				in1[0][2] * in2[2][0];
X	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
X				in1[0][2] * in2[2][1];
X	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
X				in1[0][2] * in2[2][2];
X	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
X				in1[1][2] * in2[2][0];
X	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
X				in1[1][2] * in2[2][1];
X	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
X				in1[1][2] * in2[2][2];
X	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
X				in1[2][2] * in2[2][0];
X	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
X				in1[2][2] * in2[2][1];
X	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
X				in1[2][2] * in2[2][2];
}
X
X
/*
================
R_ConcatTransforms
================
*/
void R_ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4])
{
X	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
X				in1[0][2] * in2[2][0];
X	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
X				in1[0][2] * in2[2][1];
X	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
X				in1[0][2] * in2[2][2];
X	out[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +
X				in1[0][2] * in2[2][3] + in1[0][3];
X	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
X				in1[1][2] * in2[2][0];
X	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
X				in1[1][2] * in2[2][1];
X	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
X				in1[1][2] * in2[2][2];
X	out[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +
X				in1[1][2] * in2[2][3] + in1[1][3];
X	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
X				in1[2][2] * in2[2][0];
X	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
X				in1[2][2] * in2[2][1];
X	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
X				in1[2][2] * in2[2][2];
X	out[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +
X				in1[2][2] * in2[2][3] + in1[2][3];
}
X
X
//============================================================================
X
X
float Q_fabs (float f)
{
#if 0
X	if (f >= 0)
X		return f;
X	return -f;
#else
X	int tmp = * ( int * ) &f;
X	tmp &= 0x7FFFFFFF;
X	return * ( float * ) &tmp;
#endif
}
X
#if defined _M_IX86 && !defined C_ONLY
#pragma warning (disable:4035)
__declspec( naked ) long Q_ftol( float f )
{
X	static int tmp;
X	__asm fld dword ptr [esp+4]
X	__asm fistp tmp
X	__asm mov eax, tmp
X	__asm ret
}
#pragma warning (default:4035)
#endif
X
/*
===============
LerpAngle
X
===============
*/
float LerpAngle (float a2, float a1, float frac)
{
X	if (a1 - a2 > 180)
X		a1 -= 360;
X	if (a1 - a2 < -180)
X		a1 += 360;
X	return a2 + frac * (a1 - a2);
}
X
X
float	anglemod(float a)
{
#if 0
X	if (a >= 0)
X		a -= 360*(int)(a/360);
X	else
X		a += 360*( 1 + (int)(-a/360) );
#endif
X	a = (360.0/65536) * ((int)(a*(65536/360.0)) & 65535);
X	return a;
}
X
X	int		i;
X	vec3_t	corners[2];
X
X
// this is the slow, general version
int BoxOnPlaneSide2 (vec3_t emins, vec3_t emaxs, struct cplane_s *p)
{
X	int		i;
X	float	dist1, dist2;
X	int		sides;
X	vec3_t	corners[2];
X
X	for (i=0 ; i<3 ; i++)
X	{
X		if (p->normal[i] < 0)
X		{
X			corners[0][i] = emins[i];
X			corners[1][i] = emaxs[i];
X		}
X		else
X		{
X			corners[1][i] = emins[i];
X			corners[0][i] = emaxs[i];
X		}
X	}
X	dist1 = DotProduct (p->normal, corners[0]) - p->dist;
X	dist2 = DotProduct (p->normal, corners[1]) - p->dist;
X	sides = 0;
X	if (dist1 >= 0)
X		sides = 1;
X	if (dist2 < 0)
X		sides |= 2;
X
X	return sides;
}
X
/*
==================
BoxOnPlaneSide
X
Returns 1, 2, or 1 + 2
==================
*/
#if !id386 || defined __linux__ 
int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct cplane_s *p)
{
X	float	dist1, dist2;
X	int		sides;
X
// fast axial cases
X	if (p->type < 3)
X	{
X		if (p->dist <= emins[p->type])
X			return 1;
X		if (p->dist >= emaxs[p->type])
X			return 2;
X		return 3;
X	}
X	
// general case
X	switch (p->signbits)
X	{
X	case 0:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
X		break;
X	case 1:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
X		break;
X	case 2:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
X		break;
X	case 3:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
X		break;
X	case 4:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
X		break;
X	case 5:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
X		break;
X	case 6:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
X		break;
X	case 7:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
X		break;
X	default:
X		dist1 = dist2 = 0;		// shut up compiler
X		assert( 0 );
X		break;
X	}
X
X	sides = 0;
X	if (dist1 >= p->dist)
X		sides = 1;
X	if (dist2 < p->dist)
X		sides |= 2;
X
X	assert( sides != 0 );
X
X	return sides;
}
#else
#pragma warning( disable: 4035 )
X
__declspec( naked ) int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct cplane_s *p)
{
X	static int bops_initialized;
X	static int Ljmptab[8];
X
X	__asm {
X
X		push ebx
X			
X		cmp bops_initialized, 1
X		je  initialized
X		mov bops_initialized, 1
X		
X		mov Ljmptab[0*4], offset Lcase0
X		mov Ljmptab[1*4], offset Lcase1
X		mov Ljmptab[2*4], offset Lcase2
X		mov Ljmptab[3*4], offset Lcase3
X		mov Ljmptab[4*4], offset Lcase4
X		mov Ljmptab[5*4], offset Lcase5
X		mov Ljmptab[6*4], offset Lcase6
X		mov Ljmptab[7*4], offset Lcase7
X			
initialized:
X
X		mov edx,ds:dword ptr[4+12+esp]
X		mov ecx,ds:dword ptr[4+4+esp]
X		xor eax,eax
X		mov ebx,ds:dword ptr[4+8+esp]
X		mov al,ds:byte ptr[17+edx]
X		cmp al,8
X		jge Lerror
X		fld ds:dword ptr[0+edx]
X		fld st(0)
X		jmp dword ptr[Ljmptab+eax*4]
Lcase0:
X		fmul ds:dword ptr[ebx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ebx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
X		jmp LSetSides
Lcase1:
X		fmul ds:dword ptr[ecx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ebx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
X		jmp LSetSides
Lcase2:
X		fmul ds:dword ptr[ebx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ecx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
X		jmp LSetSides
Lcase3:
X		fmul ds:dword ptr[ecx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ecx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
X		jmp LSetSides
Lcase4:
X		fmul ds:dword ptr[ebx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ebx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
X		jmp LSetSides
Lcase5:
X		fmul ds:dword ptr[ecx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ebx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
X		jmp LSetSides
Lcase6:
X		fmul ds:dword ptr[ebx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ecx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ecx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
X		jmp LSetSides
Lcase7:
X		fmul ds:dword ptr[ecx]
X		fld ds:dword ptr[0+4+edx]
X		fxch st(2)
X		fmul ds:dword ptr[ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[4+ecx]
X		fld ds:dword ptr[0+8+edx]
X		fxch st(2)
X		fmul ds:dword ptr[4+ebx]
X		fxch st(2)
X		fld st(0)
X		fmul ds:dword ptr[8+ecx]
X		fxch st(5)
X		faddp st(3),st(0)
X		fmul ds:dword ptr[8+ebx]
X		fxch st(1)
X		faddp st(3),st(0)
X		fxch st(3)
X		faddp st(2),st(0)
LSetSides:
X		faddp st(2),st(0)
X		fcomp ds:dword ptr[12+edx]
X		xor ecx,ecx
X		fnstsw ax
X		fcomp ds:dword ptr[12+edx]
X		and ah,1
X		xor ah,1
X		add cl,ah
X		fnstsw ax
X		and ah,1
X		add ah,ah
X		add cl,ah
X		pop ebx
X		mov eax,ecx
X		ret
Lerror:
X		int 3
X	}
}
#pragma warning( default: 4035 )
#endif
X
void ClearBounds (vec3_t mins, vec3_t maxs)
{
X	mins[0] = mins[1] = mins[2] = 99999;
X	maxs[0] = maxs[1] = maxs[2] = -99999;
}
X
void AddPointToBounds (vec3_t v, vec3_t mins, vec3_t maxs)
{
X	int		i;
X	vec_t	val;
X
X	for (i=0 ; i<3 ; i++)
X	{
X		val = v[i];
X		if (val < mins[i])
X			mins[i] = val;
X		if (val > maxs[i])
X			maxs[i] = val;
X	}
}
X
X
int VectorCompare (vec3_t v1, vec3_t v2)
{
X	if (v1[0] != v2[0] || v1[1] != v2[1] || v1[2] != v2[2])
X			return 0;
X			
X	return 1;
}
X
X
vec_t VectorNormalize (vec3_t v)
{
X	float	length, ilength;
X
X	length = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
X	length = sqrt (length);		// FIXME
X
X	if (length)
X	{
X		ilength = 1/length;
X		v[0] *= ilength;
X		v[1] *= ilength;
X		v[2] *= ilength;
X	}
X		
X	return length;
X
}
X
vec_t VectorNormalize2 (vec3_t v, vec3_t out)
{
X	float	length, ilength;
X
X	length = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
X	length = sqrt (length);		// FIXME
X
X	if (length)
X	{
X		ilength = 1/length;
X		out[0] = v[0]*ilength;
X		out[1] = v[1]*ilength;
X		out[2] = v[2]*ilength;
X	}
X		
X	return length;
X
}
X
void VectorMA (vec3_t veca, float scale, vec3_t vecb, vec3_t vecc)
{
X	vecc[0] = veca[0] + scale*vecb[0];
X	vecc[1] = veca[1] + scale*vecb[1];
X	vecc[2] = veca[2] + scale*vecb[2];
}
X
X
vec_t _DotProduct (vec3_t v1, vec3_t v2)
{
X	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}
X
void _VectorSubtract (vec3_t veca, vec3_t vecb, vec3_t out)
{
X	out[0] = veca[0]-vecb[0];
X	out[1] = veca[1]-vecb[1];
X	out[2] = veca[2]-vecb[2];
}
X
void _VectorAdd (vec3_t veca, vec3_t vecb, vec3_t out)
{
X	out[0] = veca[0]+vecb[0];
X	out[1] = veca[1]+vecb[1];
X	out[2] = veca[2]+vecb[2];
}
X
void _VectorCopy (vec3_t in, vec3_t out)
{
X	out[0] = in[0];
X	out[1] = in[1];
X	out[2] = in[2];
}
X
void CrossProduct (vec3_t v1, vec3_t v2, vec3_t cross)
{
X	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
X	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
X	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
}
X
double sqrt(double x);
X
vec_t VectorLength(vec3_t v)
{
X	int		i;
X	float	length;
X	
X	length = 0;
X	for (i=0 ; i< 3 ; i++)
X		length += v[i]*v[i];
X	length = sqrt (length);		// FIXME
X
X	return length;
}
X
void VectorInverse (vec3_t v)
{
X	v[0] = -v[0];
X	v[1] = -v[1];
X	v[2] = -v[2];
}
X
void VectorScale (vec3_t in, vec_t scale, vec3_t out)
{
X	out[0] = in[0]*scale;
X	out[1] = in[1]*scale;
X	out[2] = in[2]*scale;
}
X
X
int Q_log2(int val)
{
X	int answer=0;
X	while (val>>=1)
X		answer++;
X	return answer;
}
X
X
X
//====================================================================================
X
/*
============
COM_SkipPath
============
*/
char *COM_SkipPath (char *pathname)
{
X	char	*last;
X	
X	last = pathname;
X	while (*pathname)
X	{
X		if (*pathname=='/')
X			last = pathname+1;
X		pathname++;
X	}
X	return last;
}
X
/*
============
COM_StripExtension
============
*/
void COM_StripExtension (char *in, char *out)
{
X	while (*in && *in != '.')
X		*out++ = *in++;
X	*out = 0;
}
X
/*
============
COM_FileExtension
============
*/
char *COM_FileExtension (char *in)
{
X	static char exten[8];
X	int		i;
X
X	while (*in && *in != '.')
X		in++;
X	if (!*in)
X		return "";
X	in++;
X	for (i=0 ; i<7 && *in ; i++,in++)
X		exten[i] = *in;
X	exten[i] = 0;
X	return exten;
}
X
/*
============
COM_FileBase
============
*/
void COM_FileBase (char *in, char *out)
{
X	char *s, *s2;
X	
X	s = in + strlen(in) - 1;
X	
X	while (s != in && *s != '.')
X		s--;
X	
X	for (s2 = s ; s2 != in && *s2 != '/' ; s2--)
X	;
X	
X	if (s-s2 < 2)
X		out[0] = 0;
X	else
X	{
X		s--;
X		strncpy (out,s2+1, s-s2);
X		out[s-s2] = 0;
X	}
}
X
/*
============
COM_FilePath
X
Returns the path up to, but not including the last /
============
*/
void COM_FilePath (char *in, char *out)
{
X	char *s;
X	
X	s = in + strlen(in) - 1;
X	
X	while (s != in && *s != '/')
X		s--;
X
X	strncpy (out,in, s-in);
X	out[s-in] = 0;
}
X
X
/*
==================
COM_DefaultExtension
==================
*/
void COM_DefaultExtension (char *path, char *extension)
{
X	char    *src;
//
// if path doesn't have a .EXT, append extension
// (extension should include the .)
//
X	src = path + strlen(path) - 1;
X
X	while (*src != '/' && src != path)
X	{
X		if (*src == '.')
X			return;                 // it has an extension
X		src--;
X	}
X
X	strcat (path, extension);
}
X
/*
============================================================================
X
X					BYTE ORDER FUNCTIONS
X
============================================================================
*/
X
qboolean	bigendien;
X
// can't just use function pointers, or dll linkage can
// mess up when qcommon is included in multiple places
short	(*_BigShort) (short l);
short	(*_LittleShort) (short l);
int		(*_BigLong) (int l);
int		(*_LittleLong) (int l);
float	(*_BigFloat) (float l);
float	(*_LittleFloat) (float l);
X
short	BigShort(short l){return _BigShort(l);}
short	LittleShort(short l) {return _LittleShort(l);}
int		BigLong (int l) {return _BigLong(l);}
int		LittleLong (int l) {return _LittleLong(l);}
float	BigFloat (float l) {return _BigFloat(l);}
float	LittleFloat (float l) {return _LittleFloat(l);}
X
short   ShortSwap (short l)
{
X	byte    b1,b2;
X
X	b1 = l&255;
X	b2 = (l>>8)&255;
X
X	return (b1<<8) + b2;
}
X
short	ShortNoSwap (short l)
{
X	return l;
}
X
int    LongSwap (int l)
{
X	byte    b1,b2,b3,b4;
X
X	b1 = l&255;
X	b2 = (l>>8)&255;
X	b3 = (l>>16)&255;
X	b4 = (l>>24)&255;
X
X	return ((int)b1<<24) + ((int)b2<<16) + ((int)b3<<8) + b4;
}
X
int	LongNoSwap (int l)
{
X	return l;
}
X
float FloatSwap (float f)
{
X	union
X	{
X		float	f;
X		byte	b[4];
X	} dat1, dat2;
X	
X	
X	dat1.f = f;
X	dat2.b[0] = dat1.b[3];
X	dat2.b[1] = dat1.b[2];
X	dat2.b[2] = dat1.b[1];
X	dat2.b[3] = dat1.b[0];
X	return dat2.f;
}
X
float FloatNoSwap (float f)
{
X	return f;
}
X
/*
================
Swap_Init
================
*/
void Swap_Init (void)
{
X	byte	swaptest[2] = {1,0};
X
// set the byte swapping variables in a portable manner	
X	if ( *(short *)swaptest == 1)
X	{
X		bigendien = false;
X		_BigShort = ShortSwap;
X		_LittleShort = ShortNoSwap;
X		_BigLong = LongSwap;
X		_LittleLong = LongNoSwap;
X		_BigFloat = FloatSwap;
X		_LittleFloat = FloatNoSwap;
X	}
X	else
X	{
X		bigendien = true;
X		_BigShort = ShortNoSwap;
X		_LittleShort = ShortSwap;
X		_BigLong = LongNoSwap;
X		_LittleLong = LongSwap;
X		_BigFloat = FloatNoSwap;
X		_LittleFloat = FloatSwap;
X	}
X
}
X
X
X
/*
============
va
X
does a varargs printf into a temp buffer, so I don't need to have
varargs versions of all text functions.
FIXME: make this buffer size safe someday
============
*/
char	*va(char *format, ...)
{
X	va_list		argptr;
X	static char		string[1024];
X	
X	va_start (argptr, format);
X	vsprintf (string, format,argptr);
X	va_end (argptr);
X
X	return string;	
}
X
X
char	com_token[MAX_TOKEN_CHARS];
X
/*
==============
COM_Parse
X
Parse a token out of a string
==============
*/
char *COM_Parse (char **data_p)
{
X	int		c;
X	int		len;
X	char	*data;
X
X	data = *data_p;
X	len = 0;
X	com_token[0] = 0;
X	
X	if (!data)
X	{
X		*data_p = NULL;
X		return "";
X	}
X		
// skip whitespace
skipwhite:
X	while ( (c = *data) <= ' ')
X	{
X		if (c == 0)
X		{
X			*data_p = NULL;
X			return "";
X		}
X		data++;
X	}
X	
// skip // comments
X	if (c=='/' && data[1] == '/')
X	{
X		while (*data && *data != '\n')
X			data++;
X		goto skipwhite;
X	}
X	
// handle quoted strings specially
X	if (c == '\"')
X	{
X		data++;
X		while (1)
X		{
X			c = *data++;
X			if (c=='\"' || !c)
X			{
X				com_token[len] = 0;
X				*data_p = data;
X				return com_token;
X			}
X			if (len < MAX_TOKEN_CHARS)
X			{
X				com_token[len] = c;
X				len++;
X			}
X		}
X	}
X
// parse a regular word
X	do
X	{
X		if (len < MAX_TOKEN_CHARS)
X		{
X			com_token[len] = c;
X			len++;
X		}
X		data++;
X		c = *data;
X	} while (c>32);
X
X	if (len == MAX_TOKEN_CHARS)
X	{
//		Com_Printf ("Token exceeded %i chars, discarded.\n", MAX_TOKEN_CHARS);
X		len = 0;
X	}
X	com_token[len] = 0;
X
X	*data_p = data;
X	return com_token;
}
X
X
/*
===============
Com_PageInMemory
X
===============
*/
int	paged_total;
X
void Com_PageInMemory (byte *buffer, int size)
{
X	int		i;
X
X	for (i=size-1 ; i>0 ; i-=4096)
X		paged_total += buffer[i];
}
X
X
X
/*
============================================================================
X
X					LIBRARY REPLACEMENT FUNCTIONS
X
============================================================================
*/
X
// FIXME: replace all Q_stricmp with Q_strcasecmp
int Q_stricmp (char *s1, char *s2)
{
#if defined(WIN32)
X	return _stricmp (s1, s2);
#else
X	return strcasecmp (s1, s2);
#endif
}
X
X
int Q_strncasecmp (char *s1, char *s2, int n)
{
X	int		c1, c2;
X	
X	do
X	{
X		c1 = *s1++;
X		c2 = *s2++;
X
X		if (!n--)
X			return 0;		// strings are equal until end point
X		
X		if (c1 != c2)
X		{
X			if (c1 >= 'a' && c1 <= 'z')
X				c1 -= ('a' - 'A');
X			if (c2 >= 'a' && c2 <= 'z')
X				c2 -= ('a' - 'A');
X			if (c1 != c2)
X				return -1;		// strings not equal
X		}
X	} while (c1);
X	
X	return 0;		// strings are equal
}
X
int Q_strcasecmp (char *s1, char *s2)
{
X	return Q_strncasecmp (s1, s2, 99999);
}
X
X
X
void Com_sprintf (char *dest, int size, char *fmt, ...)
{
X	int		len;
X	va_list		argptr;
X	char	bigbuffer[0x10000];
X
X	va_start (argptr,fmt);
X	len = vsprintf (bigbuffer,fmt,argptr);
X	va_end (argptr);
X	if (len >= size)
X		Com_Printf ("Com_sprintf: overflow of %i in %i\n", len, size);
X	strncpy (dest, bigbuffer, size-1);
}
X
/*
=====================================================================
X
X  INFO STRINGS
X
=====================================================================
*/
X
/*
===============
Info_ValueForKey
X
Searches the string for the given
key and returns the associated value, or an empty string.
===============
*/
char *Info_ValueForKey (char *s, char *key)
{
X	char	pkey[512];
X	static	char value[2][512];	// use two buffers so compares
X								// work without stomping on each other
X	static	int	valueindex;
X	char	*o;
X	
X	valueindex ^= 1;
X	if (*s == '\\')
X		s++;
X	while (1)
X	{
X		o = pkey;
X		while (*s != '\\')
X		{
X			if (!*s)
X				return "";
X			*o++ = *s++;
X		}
X		*o = 0;
X		s++;
X
X		o = value[valueindex];
X
X		while (*s != '\\' && *s)
X		{
X			if (!*s)
X				return "";
X			*o++ = *s++;
X		}
X		*o = 0;
X
X		if (!strcmp (key, pkey) )
X			return value[valueindex];
X
X		if (!*s)
X			return "";
X		s++;
X	}
}
X
void Info_RemoveKey (char *s, char *key)
{
X	char	*start;
X	char	pkey[512];
X	char	value[512];
X	char	*o;
X
X	if (strstr (key, "\\"))
X	{
//		Com_Printf ("Can't use a key with a \\\n");
X		return;
X	}
X
X	while (1)
X	{
X		start = s;
X		if (*s == '\\')
X			s++;
X		o = pkey;
X		while (*s != '\\')
X		{
X			if (!*s)
X				return;
X			*o++ = *s++;
X		}
X		*o = 0;
X		s++;
X
X		o = value;
X		while (*s != '\\' && *s)
X		{
X			if (!*s)
X				return;
X			*o++ = *s++;
X		}
X		*o = 0;
X
X		if (!strcmp (key, pkey) )
X		{
X			strcpy (start, s);	// remove this part
X			return;
X		}
X
X		if (!*s)
X			return;
X	}
X
}
X
X
/*
==================
Info_Validate
X
Some characters are illegal in info strings because they
can mess up the server's parsing
==================
*/
qboolean Info_Validate (char *s)
{
X	if (strstr (s, "\""))
X		return false;
X	if (strstr (s, ";"))
X		return false;
X	return true;
}
X
void Info_SetValueForKey (char *s, char *key, char *value)
{
X	char	newi[MAX_INFO_STRING], *v;
X	int		c;
X	int		maxsize = MAX_INFO_STRING;
X
X	if (strstr (key, "\\") || strstr (value, "\\") )
X	{
X		Com_Printf ("Can't use keys or values with a \\\n");
X		return;
X	}
X
X	if (strstr (key, ";") )
X	{
X		Com_Printf ("Can't use keys or values with a semicolon\n");
X		return;
X	}
X
X	if (strstr (key, "\"") || strstr (value, "\"") )
X	{
X		Com_Printf ("Can't use keys or values with a \"\n");
X		return;
X	}
X
X	if (strlen(key) > MAX_INFO_KEY-1 || strlen(value) > MAX_INFO_KEY-1)
X	{
X		Com_Printf ("Keys and values must be < 64 characters.\n");
X		return;
X	}
X	Info_RemoveKey (s, key);
X	if (!value || !strlen(value))
X		return;
X
X	Com_sprintf (newi, sizeof(newi), "\\%s\\%s", key, value);
X
X	if (strlen(newi) + strlen(s) > maxsize)
X	{
X		Com_Printf ("Info string length exceeded\n");
X		return;
X	}
X
X	// only copy ascii values
X	s += strlen(s);
X	v = newi;
X	while (*v)
X	{
X		c = *v++;
X		c &= 127;		// strip high bits
X		if (c >= 32 && c < 127)
X			*s++ = c;
X	}
X	*s = 0;
}
X
//====================================================================
X
X
SHAR_EOF
  $shar_touch -am 1130175398 'q_shared.c' &&
  chmod 0664 'q_shared.c' ||
  $echo 'restore of' 'q_shared.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'q_shared.c:' 'MD5 check failed'
dccb81f978e52a9ca08db1bed94dc973  q_shared.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'q_shared.c'`"
    test 24947 -eq "$shar_count" ||
    $echo 'q_shared.c:' 'original size' '24947,' 'current size' "$shar_count!"
  fi
fi
# ============= q_shared.h ==============
if test -f 'q_shared.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'q_shared.h' '(file already exists)'
else
  $echo 'x -' extracting 'q_shared.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'q_shared.h' &&
X	
// q_shared.h -- included first by ALL program modules
X
#ifdef _WIN32
// unknown pragmas are SUPPOSED to be ignored, but....
#pragma warning(disable : 4244)     // MIPS
#pragma warning(disable : 4136)     // X86
#pragma warning(disable : 4051)     // ALPHA
X
#pragma warning(disable : 4018)     // signed/unsigned mismatch
#pragma warning(disable : 4305)		// truncation from const double to float
X
#endif
X
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
X
#if (defined _M_IX86 || defined __i386__) && !defined C_ONLY && !defined __sun__
#define id386	1
#else
#define id386	0
#endif
X
#if defined _M_ALPHA && !defined C_ONLY
#define idaxp	1
#else
#define idaxp	0
#endif
X
typedef unsigned char 		byte;
typedef enum {false, true}	qboolean;
X
X
#ifndef NULL
#define NULL ((void *)0)
#endif
X
X
// angle indexes
#define	PITCH				0		// up / down
#define	YAW					1		// left / right
#define	ROLL				2		// fall over
X
#define	MAX_STRING_CHARS	1024	// max length of a string passed to Cmd_TokenizeString
#define	MAX_STRING_TOKENS	80		// max tokens resulting from Cmd_TokenizeString
#define	MAX_TOKEN_CHARS		128		// max length of an individual token
X
#define	MAX_QPATH			64		// max length of a quake game pathname
#define	MAX_OSPATH			128		// max length of a filesystem pathname
X
//
// per-level limits
//
#define	MAX_CLIENTS			256		// absolute limit
#define	MAX_EDICTS			1024	// must change protocol to increase more
#define	MAX_LIGHTSTYLES		256
#define	MAX_MODELS			256		// these are sent over the net as bytes
#define	MAX_SOUNDS			256		// so they cannot be blindly increased
#define	MAX_IMAGES			256
#define	MAX_ITEMS			256
#define MAX_GENERAL			(MAX_CLIENTS*2)	// general config strings
X
X
// game print flags
#define	PRINT_LOW			0		// pickup messages
#define	PRINT_MEDIUM		1		// death messages
#define	PRINT_HIGH			2		// critical messages
#define	PRINT_CHAT			3		// chat messages
X
X
X
#define	ERR_FATAL			0		// exit the entire game with a popup window
#define	ERR_DROP			1		// print to console and disconnect from game
#define	ERR_DISCONNECT		2		// don't kill server
X
#define	PRINT_ALL			0
#define PRINT_DEVELOPER		1		// only print when "developer 1"
#define PRINT_ALERT			2		
X
X
// destination class for gi.multicast()
typedef enum
{
MULTICAST_ALL,
MULTICAST_PHS,
MULTICAST_PVS,
MULTICAST_ALL_R,
MULTICAST_PHS_R,
MULTICAST_PVS_R
} multicast_t;
X
X
/*
==============================================================
X
MATHLIB
X
==============================================================
*/
X
typedef float vec_t;
typedef vec_t vec3_t[3];
typedef vec_t vec5_t[5];
X
typedef	int	fixed4_t;
typedef	int	fixed8_t;
typedef	int	fixed16_t;
X
#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif
X
struct cplane_s;
X
extern vec3_t vec3_origin;
X
#define	nanmask (255<<23)
X
#define	IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)
X
// microsoft's fabs seems to be ungodly slow...
//float Q_fabs (float f);
//#define	fabs(f) Q_fabs(f)
#if !defined C_ONLY && !defined __linux__ && !defined __sgi
extern long Q_ftol( float f );
#else
#define Q_ftol( f ) ( long ) (f)
#endif
X
#define DotProduct(x,y)			(x[0]*y[0]+x[1]*y[1]+x[2]*y[2])
#define VectorSubtract(a,b,c)	(c[0]=a[0]-b[0],c[1]=a[1]-b[1],c[2]=a[2]-b[2])
#define VectorAdd(a,b,c)		(c[0]=a[0]+b[0],c[1]=a[1]+b[1],c[2]=a[2]+b[2])
#define VectorCopy(a,b)			(b[0]=a[0],b[1]=a[1],b[2]=a[2])
#define VectorClear(a)			(a[0]=a[1]=a[2]=0)
#define VectorNegate(a,b)		(b[0]=-a[0],b[1]=-a[1],b[2]=-a[2])
#define VectorSet(v, x, y, z)	(v[0]=(x), v[1]=(y), v[2]=(z))
X
void VectorMA (vec3_t veca, float scale, vec3_t vecb, vec3_t vecc);
X
// just in case you do't want to use the macros
vec_t _DotProduct (vec3_t v1, vec3_t v2);
void _VectorSubtract (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorAdd (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorCopy (vec3_t in, vec3_t out);
X
void ClearBounds (vec3_t mins, vec3_t maxs);
void AddPointToBounds (vec3_t v, vec3_t mins, vec3_t maxs);
int VectorCompare (vec3_t v1, vec3_t v2);
vec_t VectorLength (vec3_t v);
void CrossProduct (vec3_t v1, vec3_t v2, vec3_t cross);
vec_t VectorNormalize (vec3_t v);		// returns vector length
vec_t VectorNormalize2 (vec3_t v, vec3_t out);
void VectorInverse (vec3_t v);
void VectorScale (vec3_t in, vec_t scale, vec3_t out);
int Q_log2(int val);
X
void R_ConcatRotations (float in1[3][3], float in2[3][3], float out[3][3]);
void R_ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4]);
X
void AngleVectors (vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct cplane_s *plane);
float	anglemod(float a);
float LerpAngle (float a1, float a2, float frac);
X
#define BOX_ON_PLANE_SIDE(emins, emaxs, p)	\
X	(((p)->type < 3)?						\
X	(										\
X		((p)->dist <= (emins)[(p)->type])?	\
X			1								\
X		:									\
X		(									\
X			((p)->dist >= (emaxs)[(p)->type])?\
X				2							\
X			:								\
X				3							\
X		)									\
X	)										\
X	:										\
X		BoxOnPlaneSide( (emins), (emaxs), (p)))
X
void ProjectPointOnPlane( vec3_t dst, const vec3_t p, const vec3_t normal );
void PerpendicularVector( vec3_t dst, const vec3_t src );
void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, float degrees );
X
X
//=============================================
X
char *COM_SkipPath (char *pathname);
void COM_StripExtension (char *in, char *out);
void COM_FileBase (char *in, char *out);
void COM_FilePath (char *in, char *out);
void COM_DefaultExtension (char *path, char *extension);
X
char *COM_Parse (char **data_p);
// data is an in/out parm, returns a parsed out token
X
void Com_sprintf (char *dest, int size, char *fmt, ...);
X
void Com_PageInMemory (byte *buffer, int size);
X
//=============================================
X
// portable case insensitive compare
int Q_stricmp (char *s1, char *s2);
int Q_strcasecmp (char *s1, char *s2);
int Q_strncasecmp (char *s1, char *s2, int n);
X
//=============================================
X
short	BigShort(short l);
short	LittleShort(short l);
int		BigLong (int l);
int		LittleLong (int l);
float	BigFloat (float l);
float	LittleFloat (float l);
X
void	Swap_Init (void);
char	*va(char *format, ...);
X
//=============================================
X
//
// key / value info strings
//
#define	MAX_INFO_KEY		64
#define	MAX_INFO_VALUE		64
#define	MAX_INFO_STRING		512
X
char *Info_ValueForKey (char *s, char *key);
void Info_RemoveKey (char *s, char *key);
void Info_SetValueForKey (char *s, char *key, char *value);
qboolean Info_Validate (char *s);
X
/*
==============================================================
X
SYSTEM SPECIFIC
X
==============================================================
*/
X
extern	int	curtime;		// time returned by last Sys_Milliseconds
X
int		Sys_Milliseconds (void);
void	Sys_Mkdir (char *path);
X
// large block stack allocation routines
void	*Hunk_Begin (int maxsize);
void	*Hunk_Alloc (int size);
void	Hunk_Free (void *buf);
int		Hunk_End (void);
X
// directory searching
#define SFF_ARCH    0x01
#define SFF_HIDDEN  0x02
#define SFF_RDONLY  0x04
#define SFF_SUBDIR  0x08
#define SFF_SYSTEM  0x10
X
/*
** pass in an attribute mask of things you wish to REJECT
*/
char	*Sys_FindFirst (char *path, unsigned musthave, unsigned canthave );
char	*Sys_FindNext ( unsigned musthave, unsigned canthave );
void	Sys_FindClose (void);
X
X
// this is only here so the functions in q_shared.c and q_shwin.c can link
void Sys_Error (char *error, ...);
void Com_Printf (char *msg, ...);
X
X
/*
==========================================================
X
CVARS (console variables)
X
==========================================================
*/
X
#ifndef CVAR
#define	CVAR
X
#define	CVAR_ARCHIVE	1	// set to cause it to be saved to vars.rc
#define	CVAR_USERINFO	2	// added to userinfo  when changed
#define	CVAR_SERVERINFO	4	// added to serverinfo when changed
#define	CVAR_NOSET		8	// don't allow change from console at all,
X							// but can be set from the command line
#define	CVAR_LATCH		16	// save changes until server restart
X
// nothing outside the Cvar_*() functions should modify these fields!
typedef struct cvar_s
{
X	char		*name;
X	char		*string;
X	char		*latched_string;	// for CVAR_LATCH vars
X	int			flags;
X	qboolean	modified;	// set each time the cvar is changed
X	float		value;
X	struct cvar_s *next;
} cvar_t;
X
#endif		// CVAR
X
/*
==============================================================
X
COLLISION DETECTION
X
==============================================================
*/
X
// lower bits are stronger, and will eat weaker brushes completely
#define	CONTENTS_SOLID			1		// an eye is never valid in a solid
#define	CONTENTS_WINDOW			2		// translucent, but not watery
#define	CONTENTS_AUX			4
#define	CONTENTS_LAVA			8
#define	CONTENTS_SLIME			16
#define	CONTENTS_WATER			32
#define	CONTENTS_MIST			64
#define	LAST_VISIBLE_CONTENTS	64
X
// remaining contents are non-visible, and don't eat brushes
X
#define	CONTENTS_AREAPORTAL		0x8000
X
#define	CONTENTS_PLAYERCLIP		0x10000
#define	CONTENTS_MONSTERCLIP	0x20000
X
// currents can be added to any other contents, and may be mixed
#define	CONTENTS_CURRENT_0		0x40000
#define	CONTENTS_CURRENT_90		0x80000
#define	CONTENTS_CURRENT_180	0x100000
#define	CONTENTS_CURRENT_270	0x200000
#define	CONTENTS_CURRENT_UP		0x400000
#define	CONTENTS_CURRENT_DOWN	0x800000
X
#define	CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity
X
#define	CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define	CONTENTS_DEADMONSTER	0x4000000
#define	CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define	CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define	CONTENTS_LADDER			0x20000000
X
X
X
#define	SURF_LIGHT		0x1		// value will hold the light strength
X
#define	SURF_SLICK		0x2		// effects game physics
X
#define	SURF_SKY		0x4		// don't draw, but add to skybox
#define	SURF_WARP		0x8		// turbulent water warp
#define	SURF_TRANS33	0x10
#define	SURF_TRANS66	0x20
#define	SURF_FLOWING	0x40	// scroll towards angle
#define	SURF_NODRAW		0x80	// don't bother referencing the texture
X
X
X
// content masks
#define	MASK_ALL				(-1)
#define	MASK_SOLID				(CONTENTS_SOLID|CONTENTS_WINDOW)
#define	MASK_PLAYERSOLID		(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define	MASK_DEADSOLID			(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW)
#define	MASK_MONSTERSOLID		(CONTENTS_SOLID|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define	MASK_WATER				(CONTENTS_WATER|CONTENTS_LAVA|CONTENTS_SLIME)
#define	MASK_OPAQUE				(CONTENTS_SOLID|CONTENTS_SLIME|CONTENTS_LAVA)
#define	MASK_SHOT				(CONTENTS_SOLID|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEADMONSTER)
#define MASK_CURRENT			(CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)
X
X
// gi.BoxEdicts() can return a list of either solid or trigger entities
// FIXME: eliminate AREA_ distinction?
#define	AREA_SOLID		1
#define	AREA_TRIGGERS	2
X
X
// plane_t structure
// !!! if this is changed, it must be changed in asm code too !!!
typedef struct cplane_s
{
X	vec3_t	normal;
X	float	dist;
X	byte	type;			// for fast side tests
X	byte	signbits;		// signx + (signy<<1) + (signz<<1)
X	byte	pad[2];
} cplane_t;
X
// structure offset for asm code
#define CPLANE_NORMAL_X			0
#define CPLANE_NORMAL_Y			4
#define CPLANE_NORMAL_Z			8
#define CPLANE_DIST				12
#define CPLANE_TYPE				16
#define CPLANE_SIGNBITS			17
#define CPLANE_PAD0				18
#define CPLANE_PAD1				19
X
typedef struct cmodel_s
{
X	vec3_t		mins, maxs;
X	vec3_t		origin;		// for sounds or lights
X	int			headnode;
} cmodel_t;
X
typedef struct csurface_s
{
X	char		name[16];
X	int			flags;
X	int			value;
} csurface_t;
X
typedef struct mapsurface_s  // used internally due to name len probs //ZOID
{
X	csurface_t	c;
X	char		rname[32];
} mapsurface_t;
X
// a trace is returned when a box is swept through the world
typedef struct
{
X	qboolean	allsolid;	// if true, plane is not valid
X	qboolean	startsolid;	// if true, the initial point was in a solid area
X	float		fraction;	// time completed, 1.0 = didn't hit anything
X	vec3_t		endpos;		// final position
X	cplane_t	plane;		// surface normal at impact
X	csurface_t	*surface;	// surface hit
X	int			contents;	// contents on other side of surface hit
X	struct edict_s	*ent;		// not set by CM_*() functions
} trace_t;
X
X
X
// pmove_state_t is the information necessary for client side movement
// prediction
typedef enum 
{
X	// can accelerate and turn
X	PM_NORMAL,
X	PM_SPECTATOR,
X	// no acceleration or turning
X	PM_DEAD,
X	PM_GIB,		// different bounding box
X	PM_FREEZE
} pmtype_t;
X
// pmove->pm_flags
#define	PMF_DUCKED			1
#define	PMF_JUMP_HELD		2
#define	PMF_ON_GROUND		4
#define	PMF_TIME_WATERJUMP	8	// pm_time is waterjump
#define	PMF_TIME_LAND		16	// pm_time is time before rejump
#define	PMF_TIME_TELEPORT	32	// pm_time is non-moving time
#define PMF_NO_PREDICTION	64	// temporarily disables prediction (used for grappling hook)
X
// this structure needs to be communicated bit-accurate
// from the server to the client to guarantee that
// prediction stays in sync, so no floats are used.
// if any part of the game code modifies this struct, it
// will result in a prediction error of some degree.
typedef struct
{
X	pmtype_t	pm_type;
X
X	short		origin[3];		// 12.3
X	short		velocity[3];	// 12.3
X	byte		pm_flags;		// ducked, jump_held, etc
X	byte		pm_time;		// each unit = 8 ms
X	short		gravity;
X	short		delta_angles[3];	// add to command angles to get view direction
X									// changed by spawns, rotating objects, and teleporters
} pmove_state_t;
X
X
//
// button bits
//
#define	BUTTON_ATTACK		1
#define	BUTTON_USE			2
#define	BUTTON_ANY			128			// any key whatsoever
X
X
// usercmd_t is sent to the server each client frame
typedef struct usercmd_s
{
X	byte	msec;
X	byte	buttons;
X	short	angles[3];
X	short	forwardmove, sidemove, upmove;
X	byte	impulse;		// remove?
X	byte	lightlevel;		// light level the player is standing on
} usercmd_t;
X
X
#define	MAXTOUCH	32
typedef struct
{
X	// state (in / out)
X	pmove_state_t	s;
X
X	// command (in)
X	usercmd_t		cmd;
X	qboolean		snapinitial;	// if s has been changed outside pmove
X
X	// results (out)
X	int			numtouch;
X	struct edict_s	*touchents[MAXTOUCH];
X
X	vec3_t		viewangles;			// clamped
X	float		viewheight;
X
X	vec3_t		mins, maxs;			// bounding box size
X
X	struct edict_s	*groundentity;
X	int			watertype;
X	int			waterlevel;
X
X	// callbacks to test the world
X	trace_t		(*trace) (vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end);
X	int			(*pointcontents) (vec3_t point);
} pmove_t;
X
X
// entity_state_t->effects
// Effects are things handled on the client side (lights, particles, frame animations)
// that happen constantly on the given entity.
// An entity that has effects will be sent to the client
// even if it has a zero index model.
#define	EF_ROTATE			0x00000001		// rotate (bonus items)
#define	EF_GIB				0x00000002		// leave a trail
#define	EF_BLASTER			0x00000008		// redlight + trail
#define	EF_ROCKET			0x00000010		// redlight + trail
#define	EF_GRENADE			0x00000020
#define	EF_HYPERBLASTER		0x00000040
#define	EF_BFG				0x00000080
#define EF_COLOR_SHELL		0x00000100
#define EF_POWERSCREEN		0x00000200
#define	EF_ANIM01			0x00000400		// automatically cycle between frames 0 and 1 at 2 hz
#define	EF_ANIM23			0x00000800		// automatically cycle between frames 2 and 3 at 2 hz
#define EF_ANIM_ALL			0x00001000		// automatically cycle through all frames at 2hz
#define EF_ANIM_ALLFAST		0x00002000		// automatically cycle through all frames at 10hz
#define	EF_FLIES			0x00004000
#define	EF_QUAD				0x00008000
#define	EF_PENT				0x00010000
#define	EF_TELEPORTER		0x00020000		// particle fountain
#define EF_FLAG1			0x00040000
#define EF_FLAG2			0x00080000
// RAFAEL
#define EF_IONRIPPER		0x00100000
#define EF_GREENGIB			0x00200000
#define	EF_BLUEHYPERBLASTER 0x00400000
#define EF_SPINNINGLIGHTS	0x00800000
#define EF_PLASMA			0x01000000
#define EF_TRAP				0x02000000
X
//ROGUE
#define EF_TRACKER			0x04000000
#define	EF_DOUBLE			0x08000000
#define	EF_SPHERETRANS		0x10000000
#define EF_TAGTRAIL			0x20000000
#define EF_HALF_DAMAGE		0x40000000
#define EF_TRACKERTRAIL		0x80000000
//ROGUE
X
// entity_state_t->renderfx flags
#define	RF_MINLIGHT			1		// allways have some light (viewmodel)
#define	RF_VIEWERMODEL		2		// don't draw through eyes, only mirrors
#define	RF_WEAPONMODEL		4		// only draw through eyes
#define	RF_FULLBRIGHT		8		// allways draw full intensity
#define	RF_DEPTHHACK		16		// for view weapon Z crunching
#define	RF_TRANSLUCENT		32
#define	RF_FRAMELERP		64
#define RF_BEAM				128
#define	RF_CUSTOMSKIN		256		// skin is an index in image_precache
#define	RF_GLOW				512		// pulse lighting for bonus items
#define RF_SHELL_RED		1024
#define	RF_SHELL_GREEN		2048
#define RF_SHELL_BLUE		4096
X
//ROGUE
#define RF_IR_VISIBLE		0x00008000		// 32768
#define	RF_SHELL_DOUBLE		0x00010000		// 65536
#define	RF_SHELL_HALF_DAM	0x00020000
#define RF_USE_DISGUISE		0x00040000
//ROGUE
X
// player_state_t->refdef flags
#define	RDF_UNDERWATER		1		// warp the screen as apropriate
#define RDF_NOWORLDMODEL	2		// used for player configuration screen
X
//ROGUE
#define	RDF_IRGOGGLES		4
#define RDF_UVGOGGLES		8
//ROGUE
X
//
// muzzle flashes / player effects
//
#define	MZ_BLASTER			0
#define MZ_MACHINEGUN		1
#define	MZ_SHOTGUN			2
#define	MZ_CHAINGUN1		3
#define	MZ_CHAINGUN2		4
#define	MZ_CHAINGUN3		5
#define	MZ_RAILGUN			6
#define	MZ_ROCKET			7
#define	MZ_GRENADE			8
#define	MZ_LOGIN			9
#define	MZ_LOGOUT			10
#define	MZ_RESPAWN			11
#define	MZ_BFG				12
#define	MZ_SSHOTGUN			13
#define	MZ_HYPERBLASTER		14
#define	MZ_ITEMRESPAWN		15
// RAFAEL
#define MZ_IONRIPPER		16
#define MZ_BLUEHYPERBLASTER 17
#define MZ_PHALANX			18
#define MZ_SILENCED			128		// bit flag ORed with one of the above numbers
X
//ROGUE
#define MZ_ETF_RIFLE		30
#define MZ_UNUSED			31
#define MZ_SHOTGUN2			32
#define MZ_HEATBEAM			33
#define MZ_BLASTER2			34
#define	MZ_TRACKER			35
#define	MZ_NUKE1			36
#define	MZ_NUKE2			37
#define	MZ_NUKE4			38
#define	MZ_NUKE8			39
//ROGUE
X
//
// monster muzzle flashes
//
#define MZ2_TANK_BLASTER_1				1
#define MZ2_TANK_BLASTER_2				2
#define MZ2_TANK_BLASTER_3				3
#define MZ2_TANK_MACHINEGUN_1			4
#define MZ2_TANK_MACHINEGUN_2			5
#define MZ2_TANK_MACHINEGUN_3			6
#define MZ2_TANK_MACHINEGUN_4			7
#define MZ2_TANK_MACHINEGUN_5			8
#define MZ2_TANK_MACHINEGUN_6			9
#define MZ2_TANK_MACHINEGUN_7			10
#define MZ2_TANK_MACHINEGUN_8			11
#define MZ2_TANK_MACHINEGUN_9			12
#define MZ2_TANK_MACHINEGUN_10			13
#define MZ2_TANK_MACHINEGUN_11			14
#define MZ2_TANK_MACHINEGUN_12			15
#define MZ2_TANK_MACHINEGUN_13			16
#define MZ2_TANK_MACHINEGUN_14			17
#define MZ2_TANK_MACHINEGUN_15			18
#define MZ2_TANK_MACHINEGUN_16			19
#define MZ2_TANK_MACHINEGUN_17			20
#define MZ2_TANK_MACHINEGUN_18			21
#define MZ2_TANK_MACHINEGUN_19			22
#define MZ2_TANK_ROCKET_1				23
#define MZ2_TANK_ROCKET_2				24
#define MZ2_TANK_ROCKET_3				25
X
#define MZ2_INFANTRY_MACHINEGUN_1		26
#define MZ2_INFANTRY_MACHINEGUN_2		27
#define MZ2_INFANTRY_MACHINEGUN_3		28
#define MZ2_INFANTRY_MACHINEGUN_4		29
#define MZ2_INFANTRY_MACHINEGUN_5		30
#define MZ2_INFANTRY_MACHINEGUN_6		31
#define MZ2_INFANTRY_MACHINEGUN_7		32
#define MZ2_INFANTRY_MACHINEGUN_8		33
#define MZ2_INFANTRY_MACHINEGUN_9		34
#define MZ2_INFANTRY_MACHINEGUN_10		35
#define MZ2_INFANTRY_MACHINEGUN_11		36
#define MZ2_INFANTRY_MACHINEGUN_12		37
#define MZ2_INFANTRY_MACHINEGUN_13		38
X
#define MZ2_SOLDIER_BLASTER_1			39
#define MZ2_SOLDIER_BLASTER_2			40
#define MZ2_SOLDIER_SHOTGUN_1			41
#define MZ2_SOLDIER_SHOTGUN_2			42
#define MZ2_SOLDIER_MACHINEGUN_1		43
#define MZ2_SOLDIER_MACHINEGUN_2		44
X
#define MZ2_GUNNER_MACHINEGUN_1			45
#define MZ2_GUNNER_MACHINEGUN_2			46
#define MZ2_GUNNER_MACHINEGUN_3			47
#define MZ2_GUNNER_MACHINEGUN_4			48
#define MZ2_GUNNER_MACHINEGUN_5			49
#define MZ2_GUNNER_MACHINEGUN_6			50
#define MZ2_GUNNER_MACHINEGUN_7			51
#define MZ2_GUNNER_MACHINEGUN_8			52
#define MZ2_GUNNER_GRENADE_1			53
#define MZ2_GUNNER_GRENADE_2			54
#define MZ2_GUNNER_GRENADE_3			55
#define MZ2_GUNNER_GRENADE_4			56
X
#define MZ2_CHICK_ROCKET_1				57
X
#define MZ2_FLYER_BLASTER_1				58
#define MZ2_FLYER_BLASTER_2				59
X
#define MZ2_MEDIC_BLASTER_1				60
X
#define MZ2_GLADIATOR_RAILGUN_1			61
X
#define MZ2_HOVER_BLASTER_1				62
X
#define MZ2_ACTOR_MACHINEGUN_1			63
X
#define MZ2_SUPERTANK_MACHINEGUN_1		64
#define MZ2_SUPERTANK_MACHINEGUN_2		65
#define MZ2_SUPERTANK_MACHINEGUN_3		66
#define MZ2_SUPERTANK_MACHINEGUN_4		67
#define MZ2_SUPERTANK_MACHINEGUN_5		68
#define MZ2_SUPERTANK_MACHINEGUN_6		69
#define MZ2_SUPERTANK_ROCKET_1			70
#define MZ2_SUPERTANK_ROCKET_2			71
#define MZ2_SUPERTANK_ROCKET_3			72
X
#define MZ2_BOSS2_MACHINEGUN_L1			73
#define MZ2_BOSS2_MACHINEGUN_L2			74
#define MZ2_BOSS2_MACHINEGUN_L3			75
#define MZ2_BOSS2_MACHINEGUN_L4			76
#define MZ2_BOSS2_MACHINEGUN_L5			77
#define MZ2_BOSS2_ROCKET_1				78
#define MZ2_BOSS2_ROCKET_2				79
#define MZ2_BOSS2_ROCKET_3				80
#define MZ2_BOSS2_ROCKET_4				81
X
#define MZ2_FLOAT_BLASTER_1				82
X
#define MZ2_SOLDIER_BLASTER_3			83
#define MZ2_SOLDIER_SHOTGUN_3			84
#define MZ2_SOLDIER_MACHINEGUN_3		85
#define MZ2_SOLDIER_BLASTER_4			86
#define MZ2_SOLDIER_SHOTGUN_4			87
#define MZ2_SOLDIER_MACHINEGUN_4		88
#define MZ2_SOLDIER_BLASTER_5			89
#define MZ2_SOLDIER_SHOTGUN_5			90
#define MZ2_SOLDIER_MACHINEGUN_5		91
#define MZ2_SOLDIER_BLASTER_6			92
#define MZ2_SOLDIER_SHOTGUN_6			93
#define MZ2_SOLDIER_MACHINEGUN_6		94
#define MZ2_SOLDIER_BLASTER_7			95
#define MZ2_SOLDIER_SHOTGUN_7			96
#define MZ2_SOLDIER_MACHINEGUN_7		97
#define MZ2_SOLDIER_BLASTER_8			98
#define MZ2_SOLDIER_SHOTGUN_8			99
#define MZ2_SOLDIER_MACHINEGUN_8		100
X
// --- Xian shit below ---
#define	MZ2_MAKRON_BFG					101
#define MZ2_MAKRON_BLASTER_1			102
#define MZ2_MAKRON_BLASTER_2			103
#define MZ2_MAKRON_BLASTER_3			104
#define MZ2_MAKRON_BLASTER_4			105
#define MZ2_MAKRON_BLASTER_5			106
#define MZ2_MAKRON_BLASTER_6			107
#define MZ2_MAKRON_BLASTER_7			108
#define MZ2_MAKRON_BLASTER_8			109
#define MZ2_MAKRON_BLASTER_9			110
#define MZ2_MAKRON_BLASTER_10			111
#define MZ2_MAKRON_BLASTER_11			112
#define MZ2_MAKRON_BLASTER_12			113
#define MZ2_MAKRON_BLASTER_13			114
#define MZ2_MAKRON_BLASTER_14			115
#define MZ2_MAKRON_BLASTER_15			116
#define MZ2_MAKRON_BLASTER_16			117
#define MZ2_MAKRON_BLASTER_17			118
#define MZ2_MAKRON_RAILGUN_1			119
#define	MZ2_JORG_MACHINEGUN_L1			120
#define	MZ2_JORG_MACHINEGUN_L2			121
#define	MZ2_JORG_MACHINEGUN_L3			122
#define	MZ2_JORG_MACHINEGUN_L4			123
#define	MZ2_JORG_MACHINEGUN_L5			124
#define	MZ2_JORG_MACHINEGUN_L6			125
#define	MZ2_JORG_MACHINEGUN_R1			126
#define	MZ2_JORG_MACHINEGUN_R2			127
#define	MZ2_JORG_MACHINEGUN_R3			128
#define	MZ2_JORG_MACHINEGUN_R4			129
#define MZ2_JORG_MACHINEGUN_R5			130
#define	MZ2_JORG_MACHINEGUN_R6			131
#define MZ2_JORG_BFG_1					132
#define MZ2_BOSS2_MACHINEGUN_R1			133
#define MZ2_BOSS2_MACHINEGUN_R2			134
#define MZ2_BOSS2_MACHINEGUN_R3			135
#define MZ2_BOSS2_MACHINEGUN_R4			136
#define MZ2_BOSS2_MACHINEGUN_R5			137
X
//ROGUE
#define	MZ2_CARRIER_MACHINEGUN_L1		138
#define	MZ2_CARRIER_MACHINEGUN_R1		139
#define	MZ2_CARRIER_GRENADE				140
#define MZ2_TURRET_MACHINEGUN			141
#define MZ2_TURRET_ROCKET				142
#define MZ2_TURRET_BLASTER				143
#define MZ2_STALKER_BLASTER				144
#define MZ2_DAEDALUS_BLASTER			145
#define MZ2_MEDIC_BLASTER_2				146
#define	MZ2_CARRIER_RAILGUN				147
#define	MZ2_WIDOW_DISRUPTOR				148
#define	MZ2_WIDOW_BLASTER				149
#define	MZ2_WIDOW_RAIL					150
#define	MZ2_WIDOW_PLASMABEAM			151		// PMM - not used
#define	MZ2_CARRIER_MACHINEGUN_L2		152
#define	MZ2_CARRIER_MACHINEGUN_R2		153
#define	MZ2_WIDOW_RAIL_LEFT				154
#define	MZ2_WIDOW_RAIL_RIGHT			155
#define	MZ2_WIDOW_BLASTER_SWEEP1		156
#define	MZ2_WIDOW_BLASTER_SWEEP2		157
#define	MZ2_WIDOW_BLASTER_SWEEP3		158
#define	MZ2_WIDOW_BLASTER_SWEEP4		159
#define	MZ2_WIDOW_BLASTER_SWEEP5		160
#define	MZ2_WIDOW_BLASTER_SWEEP6		161
#define	MZ2_WIDOW_BLASTER_SWEEP7		162
#define	MZ2_WIDOW_BLASTER_SWEEP8		163
#define	MZ2_WIDOW_BLASTER_SWEEP9		164
#define	MZ2_WIDOW_BLASTER_100			165
#define	MZ2_WIDOW_BLASTER_90			166
#define	MZ2_WIDOW_BLASTER_80			167
#define	MZ2_WIDOW_BLASTER_70			168
#define	MZ2_WIDOW_BLASTER_60			169
#define	MZ2_WIDOW_BLASTER_50			170
#define	MZ2_WIDOW_BLASTER_40			171
#define	MZ2_WIDOW_BLASTER_30			172
#define	MZ2_WIDOW_BLASTER_20			173
#define	MZ2_WIDOW_BLASTER_10			174
#define	MZ2_WIDOW_BLASTER_0				175
#define	MZ2_WIDOW_BLASTER_10L			176
#define	MZ2_WIDOW_BLASTER_20L			177
#define	MZ2_WIDOW_BLASTER_30L			178
#define	MZ2_WIDOW_BLASTER_40L			179
#define	MZ2_WIDOW_BLASTER_50L			180
#define	MZ2_WIDOW_BLASTER_60L			181
#define	MZ2_WIDOW_BLASTER_70L			182
#define	MZ2_WIDOW_RUN_1					183
#define	MZ2_WIDOW_RUN_2					184
#define	MZ2_WIDOW_RUN_3					185
#define	MZ2_WIDOW_RUN_4					186
#define	MZ2_WIDOW_RUN_5					187
#define	MZ2_WIDOW_RUN_6					188
#define	MZ2_WIDOW_RUN_7					189
#define	MZ2_WIDOW_RUN_8					190
#define	MZ2_CARRIER_ROCKET_1			191
#define	MZ2_CARRIER_ROCKET_2			192
#define	MZ2_CARRIER_ROCKET_3			193
#define	MZ2_CARRIER_ROCKET_4			194
#define	MZ2_WIDOW2_BEAMER_1				195
#define	MZ2_WIDOW2_BEAMER_2				196
#define	MZ2_WIDOW2_BEAMER_3				197
#define	MZ2_WIDOW2_BEAMER_4				198
#define	MZ2_WIDOW2_BEAMER_5				199
#define	MZ2_WIDOW2_BEAM_SWEEP_1			200
#define	MZ2_WIDOW2_BEAM_SWEEP_2			201
#define	MZ2_WIDOW2_BEAM_SWEEP_3			202
#define	MZ2_WIDOW2_BEAM_SWEEP_4			203
#define	MZ2_WIDOW2_BEAM_SWEEP_5			204
#define	MZ2_WIDOW2_BEAM_SWEEP_6			205
#define	MZ2_WIDOW2_BEAM_SWEEP_7			206
#define	MZ2_WIDOW2_BEAM_SWEEP_8			207
#define	MZ2_WIDOW2_BEAM_SWEEP_9			208
#define	MZ2_WIDOW2_BEAM_SWEEP_10		209
#define	MZ2_WIDOW2_BEAM_SWEEP_11		210
X
// ROGUE
X
extern	vec3_t monster_flash_offset [];
X
X
// temp entity events
//
// Temp entity events are for things that happen
// at a location seperate from any existing entity.
// Temporary entity messages are explicitly constructed
// and broadcast.
typedef enum
{
X	TE_GUNSHOT,
X	TE_BLOOD,
X	TE_BLASTER,
X	TE_RAILTRAIL,
X	TE_SHOTGUN,
X	TE_EXPLOSION1,
X	TE_EXPLOSION2,
X	TE_ROCKET_EXPLOSION,
X	TE_GRENADE_EXPLOSION,
X	TE_SPARKS,
X	TE_SPLASH,
X	TE_BUBBLETRAIL,
X	TE_SCREEN_SPARKS,
X	TE_SHIELD_SPARKS,
X	TE_BULLET_SPARKS,
X	TE_LASER_SPARKS,
X	TE_PARASITE_ATTACK,
X	TE_ROCKET_EXPLOSION_WATER,
X	TE_GRENADE_EXPLOSION_WATER,
X	TE_MEDIC_CABLE_ATTACK,
X	TE_BFG_EXPLOSION,
X	TE_BFG_BIGEXPLOSION,
X	TE_BOSSTPORT,			// used as '22' in a map, so DON'T RENUMBER!!!
X	TE_BFG_LASER,
X	TE_GRAPPLE_CABLE,
X	TE_WELDING_SPARKS,
X	TE_GREENBLOOD,
X	TE_BLUEHYPERBLASTER,
X	TE_PLASMA_EXPLOSION,
X	TE_TUNNEL_SPARKS,
//ROGUE
X	TE_BLASTER2,
X	TE_RAILTRAIL2,
X	TE_FLAME,
X	TE_LIGHTNING,
X	TE_DEBUGTRAIL,
X	TE_PLAIN_EXPLOSION,
X	TE_FLASHLIGHT,
X	TE_FORCEWALL,
X	TE_HEATBEAM,
X	TE_MONSTER_HEATBEAM,
X	TE_STEAM,
X	TE_BUBBLETRAIL2,
X	TE_MOREBLOOD,
X	TE_HEATBEAM_SPARKS,
X	TE_HEATBEAM_STEAM,
X	TE_CHAINFIST_SMOKE,
X	TE_ELECTRIC_SPARKS,
X	TE_TRACKER_EXPLOSION,
X	TE_TELEPORT_EFFECT,
X	TE_DBALL_GOAL,
X	TE_WIDOWBEAMOUT,
X	TE_NUKEBLAST,
X	TE_WIDOWSPLASH,
X	TE_EXPLOSION1_BIG,
X	TE_EXPLOSION1_NP,
X	TE_FLECHETTE
//ROGUE
} temp_event_t;
X
#define SPLASH_UNKNOWN		0
#define SPLASH_SPARKS		1
#define SPLASH_BLUE_WATER	2
#define SPLASH_BROWN_WATER	3
#define SPLASH_SLIME		4
#define	SPLASH_LAVA			5
#define SPLASH_BLOOD		6
X
X
// sound channels
// channel 0 never willingly overrides
// other channels (1-7) allways override a playing sound on that channel
#define	CHAN_AUTO               0
#define	CHAN_WEAPON             1
#define	CHAN_VOICE              2
#define	CHAN_ITEM               3
#define	CHAN_BODY               4
// modifier flags
#define	CHAN_NO_PHS_ADD			8	// send to all clients, not just ones in PHS (ATTN 0 will also do this)
#define	CHAN_RELIABLE			16	// send by reliable message, not datagram
X
X
// sound attenuation values
#define	ATTN_NONE               0	// full volume the entire level
#define	ATTN_NORM               1
#define	ATTN_IDLE               2
#define	ATTN_STATIC             3	// diminish very rapidly with distance
X
X
// player_state->stats[] indexes
#define STAT_HEALTH_ICON		0
#define	STAT_HEALTH				1
#define	STAT_AMMO_ICON			2
#define	STAT_AMMO				3
#define	STAT_ARMOR_ICON			4
#define	STAT_ARMOR				5
#define	STAT_SELECTED_ICON		6
#define	STAT_PICKUP_ICON		7
#define	STAT_PICKUP_STRING		8
#define	STAT_TIMER_ICON			9
#define	STAT_TIMER				10
#define	STAT_HELPICON			11
#define	STAT_SELECTED_ITEM		12
#define	STAT_LAYOUTS			13
#define	STAT_FRAGS				14
#define	STAT_FLASHES			15		// cleared each frame, 1 = health, 2 = armor
#define STAT_CHASE				16
#define STAT_SPECTATOR			17
X
#define	MAX_STATS				32
X
X
// dmflags->value flags
#define	DF_NO_HEALTH		0x00000001	// 1
#define	DF_NO_ITEMS			0x00000002	// 2
#define	DF_WEAPONS_STAY		0x00000004	// 4
#define	DF_NO_FALLING		0x00000008	// 8
#define	DF_INSTANT_ITEMS	0x00000010	// 16
#define	DF_SAME_LEVEL		0x00000020	// 32
#define DF_SKINTEAMS		0x00000040	// 64
#define DF_MODELTEAMS		0x00000080	// 128
#define DF_NO_FRIENDLY_FIRE	0x00000100	// 256
#define	DF_SPAWN_FARTHEST	0x00000200	// 512
#define DF_FORCE_RESPAWN	0x00000400	// 1024
#define DF_NO_ARMOR			0x00000800	// 2048
#define DF_ALLOW_EXIT		0x00001000	// 4096
#define DF_INFINITE_AMMO	0x00002000	// 8192
#define DF_QUAD_DROP		0x00004000	// 16384
#define DF_FIXED_FOV		0x00008000	// 32768
X
// RAFAEL
#define	DF_QUADFIRE_DROP	0x00010000	// 65536
X
//ROGUE
#define DF_NO_MINES			0x00020000
#define DF_NO_STACK_DOUBLE	0x00040000
#define DF_NO_NUKES			0x00080000
#define DF_NO_SPHERES		0x00100000
//ROGUE
X
/*
ROGUE - VERSIONS
1234	08/13/1998		Activision
1235	08/14/1998		Id Software
1236	08/15/1998		Steve Tietze
1237	08/15/1998		Phil Dobranski
1238	08/15/1998		John Sheley
1239	08/17/1998		Barrett Alexander
1230	08/17/1998		Brandon Fish
1245	08/17/1998		Don MacAskill
1246	08/17/1998		David "Zoid" Kirsch
1247	08/17/1998		Manu Smith
1248	08/17/1998		Geoff Scully
1249	08/17/1998		Andy Van Fossen
1240	08/20/1998		Activision Build 2
1256	08/20/1998		Ranger Clan
1257	08/20/1998		Ensemble Studios
1258	08/21/1998		Robert Duffy
1259	08/21/1998		Stephen Seachord
1250	08/21/1998		Stephen Heaslip
1267	08/21/1998		Samir Sandesara
1268	08/21/1998		Oliver Wyman
1269	08/21/1998		Steven Marchegiano
1260	08/21/1998		Build #2 for Nihilistic
1278	08/21/1998		Build #2 for Ensemble
1279	08/26/1998		Build for Ron Solo - DEFUNCT
1270	08/26/1998		Build #3 for Activision
1289	08/26/1998		Build for Don MacAskill
1280	08/26/1998		Build for Robert Duffy
1290	08/26/1998		Build #2 for Rangers
1345	08/28/1998		Build #4 for Activision
2345	08/26/1998		Build for Zoid
X
9999	08/20/1998		Internal Use
*/
//#define ROGUE_VERSION_ID		1345
X
//#define ROGUE_VERSION_STRING	"08/29/1998 Beta 4 for Activision"
X
// ROGUE
/*
==========================================================
X
X  ELEMENTS COMMUNICATED ACROSS THE NET
X
==========================================================
*/
X
#define	ANGLE2SHORT(x)	((int)((x)*65536/360) & 65535)
#define	SHORT2ANGLE(x)	((x)*(360.0/65536))
X
X
//
// config strings are a general means of communication from
// the server to all connected clients.
// Each config string can be at most MAX_QPATH characters.
//
#define	CS_NAME				0
#define	CS_CDTRACK			1
#define	CS_SKY				2
#define	CS_SKYAXIS			3		// %f %f %f format
#define	CS_SKYROTATE		4
#define	CS_STATUSBAR		5		// display program string
X
#define CS_AIRACCEL			29		// air acceleration control
#define	CS_MAXCLIENTS		30
#define	CS_MAPCHECKSUM		31		// for catching cheater maps
X
#define	CS_MODELS			32
#define	CS_SOUNDS			(CS_MODELS+MAX_MODELS)
#define	CS_IMAGES			(CS_SOUNDS+MAX_SOUNDS)
#define	CS_LIGHTS			(CS_IMAGES+MAX_IMAGES)
#define	CS_ITEMS			(CS_LIGHTS+MAX_LIGHTSTYLES)
#define	CS_PLAYERSKINS		(CS_ITEMS+MAX_ITEMS)
#define CS_GENERAL			(CS_PLAYERSKINS+MAX_CLIENTS)
#define	MAX_CONFIGSTRINGS	(CS_GENERAL+MAX_GENERAL)
X
X
//==============================================
X
X
// entity_state_t->event values
// ertity events are for effects that take place reletive
// to an existing entities origin.  Very network efficient.
// All muzzle flashes really should be converted to events...
typedef enum
{
X	EV_NONE,
X	EV_ITEM_RESPAWN,
X	EV_FOOTSTEP,
X	EV_FALLSHORT,
X	EV_FALL,
X	EV_FALLFAR,
X	EV_PLAYER_TELEPORT,
X	EV_OTHER_TELEPORT
} entity_event_t;
X
X
// entity_state_t is the information conveyed from the server
// in an update message about entities that the client will
// need to render in some way
typedef struct entity_state_s
{
X	int		number;			// edict index
X
X	vec3_t	origin;
X	vec3_t	angles;
X	vec3_t	old_origin;		// for lerping
X	int		modelindex;
X	int		modelindex2, modelindex3, modelindex4;	// weapons, CTF flags, etc
X	int		frame;
X	int		skinnum;
X	unsigned int		effects;		// PGM - we're filling it, so it needs to be unsigned
X	int		renderfx;
X	int		solid;			// for client side prediction, 8*(bits 0-4) is x/y radius
X							// 8*(bits 5-9) is z down distance, 8(bits10-15) is z up
X							// gi.linkentity sets this properly
X	int		sound;			// for looping sounds, to guarantee shutoff
X	int		event;			// impulse events -- muzzle flashes, footsteps, etc
X							// events only go out for a single frame, they
X							// are automatically cleared each frame
} entity_state_t;
X
//==============================================
X
X
// player_state_t is the information needed in addition to pmove_state_t
// to rendered a view.  There will only be 10 player_state_t sent each second,
// but the number of pmove_state_t changes will be reletive to client
// frame rates
typedef struct
{
X	pmove_state_t	pmove;		// for prediction
X
X	// these fields do not need to be communicated bit-precise
X
X	vec3_t		viewangles;		// for fixed views
X	vec3_t		viewoffset;		// add to pmovestate->origin
X	vec3_t		kick_angles;	// add to view direction to get render angles
X								// set by weapon kicks, pain effects, etc
X
X	vec3_t		gunangles;
X	vec3_t		gunoffset;
X	int			gunindex;
X	int			gunframe;
X
X	float		blend[4];		// rgba full screen effect
X	
X	float		fov;			// horizontal field of view
X
X	int			rdflags;		// refdef flags
X
X	short		stats[MAX_STATS];		// fast status bar updates
} player_state_t;
X
X
// ==================
// PGM 
#define VIDREF_GL		1
#define VIDREF_SOFT		2
#define VIDREF_OTHER	3
X
extern int vidref_val;
// PGM
// ==================
SHAR_EOF
  $shar_touch -am 1130175398 'q_shared.h' &&
  chmod 0664 'q_shared.h' ||
  $echo 'restore of' 'q_shared.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'q_shared.h:' 'MD5 check failed'
104f4722a00408b61faf04d13019b72f  q_shared.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'q_shared.h'`"
    test 34104 -eq "$shar_count" ||
    $echo 'q_shared.h:' 'original size' '34104,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh09367
exit 0
